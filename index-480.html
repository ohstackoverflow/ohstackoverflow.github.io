<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 480) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-480.html">
<link rel="prev" href="index-481.html" type="text/html">
<link rel="next" href="index-479.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/class-self-idiom-in-ruby/" class="u-url">class &lt;&lt; self idiom in Ruby</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/class-self-idiom-in-ruby/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:55:49+08:00" itemprop="datePublished" title="2023-02-17 07:55">2023-02-17 07:55</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What does <code>class &lt;&lt; self</code> do in <strong>Ruby</strong>?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>First, the <code>class &lt;&lt; foo</code> syntax opens up <code>foo</code>'s singleton class
(eigenclass). This allows you to specialise the behaviour of methods called on
that specific object.</p>
<div class="code"><pre class="code literal-block"><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'foo'</span>
<span class="nv">class</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nv">a</span>
<span class="w">  </span><span class="nv">def</span><span class="w"> </span><span class="nv">inspect</span>
<span class="w">    </span><span class="s1">'"bar"'</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>
<span class="nv">a</span>.<span class="nv">inspect</span><span class="w">   </span>#<span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"bar"</span>

<span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'foo'</span><span class="w">   </span>#<span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">object</span>,<span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">singleton</span><span class="w"> </span><span class="nv">class</span>
<span class="nv">a</span>.<span class="nv">inspect</span><span class="w">   </span>#<span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"foo"</span>
</pre></div>

<hr>
<p>Now, to answer the question: <code>class &lt;&lt; self</code> opens up <code>self</code>'s singleton
class, so that methods can be redefined for the current <code>self</code> object (which
inside a class or module body is the class or module <em>itself</em> ). Usually, this
is used to define class/module ("static") methods:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">String</span>
  <span class="k">class</span> <span class="s">&lt;&lt; self</span>
<span class="s">    def value_of obj</span>
<span class="s">      obj.to_s</span>
<span class="s">    end</span>
<span class="s">  end</span>
<span class="s">end</span>

<span class="s">String.value_of 42   # =&gt;</span> <span class="s">"42"</span>
</pre></div>

<p>This can also be written as a shorthand:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">String</span>
  <span class="n">def</span> <span class="nb">self</span>.<span class="n">value_of</span> <span class="n">obj</span>
    <span class="n">obj</span>.<span class="n">to_s</span>
  <span class="nb">end</span>
<span class="nb">end</span>
</pre></div>

<p>Or even shorter:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">String</span>.<span class="nv">value_of</span><span class="w"> </span><span class="nv">obj</span>
<span class="w">  </span><span class="nv">obj</span>.<span class="nv">to_s</span>
<span class="k">end</span>
</pre></div>

<hr>
<p>When inside a function definition, <code>self</code> refers to the object the function is
being called with. In this case, <code>class &lt;&lt; self</code> opens the singleton class for
that object; one use of that is to implement a poor man's state machine:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">StateMachineExample</span>
  <span class="n">def</span> <span class="n">process</span> <span class="n">obj</span>
    <span class="n">process_hook</span> <span class="n">obj</span>
  <span class="nb">end</span>

<span class="nb">private</span>
  <span class="n">def</span> <span class="n">process_state_1</span> <span class="n">obj</span>
    <span class="c1"># ...</span>
    <span class="k">class</span> &lt;&lt; <span class="nb">self</span>
      <span class="n">alias</span> <span class="n">process_hook</span> <span class="n">process_state_2</span>
    <span class="nb">end</span>
  <span class="nb">end</span>

  <span class="n">def</span> <span class="n">process_state_2</span> <span class="n">obj</span>
    <span class="c1"># ...</span>
    <span class="k">class</span> &lt;&lt; <span class="nb">self</span>
      <span class="n">alias</span> <span class="n">process_hook</span> <span class="n">process_state_1</span>
    <span class="nb">end</span>
  <span class="nb">end</span>

  <span class="c1"># Set up initial state</span>
  <span class="n">alias</span> <span class="n">process_hook</span> <span class="n">process_state_1</span>
<span class="nb">end</span>
</pre></div>

<p>So, in the example above, each instance of <code>StateMachineExample</code> has
<code>process_hook</code> aliased to <code>process_state_1</code>, but note how in the latter, it
can redefine <code>process_hook</code> (for <code>self</code> only, not affecting other
<code>StateMachineExample</code> instances) to <code>process_state_2</code>. So, each time a caller
calls the <code>process</code> method (which calls the redefinable <code>process_hook</code>), the
behaviour changes depending on what state it's in.</p>
<p><br></p>
<h3>Suggest</h3>
<p>I found a super simple explanation about <code>class &lt;&lt; self</code> , <code>Eigenclass</code> and
different type of methods.</p>
<p>In Ruby, there are three types of methods that can be applied to a class:</p>
<ol>
<li>Instance methods</li>
<li>Singleton methods</li>
<li>Class methods</li>
</ol>
<p>Instance methods and class methods are almost similar to their homonymous in
other programming languages.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>  
  <span class="n">def</span> <span class="n">an_instance_method</span>  
    <span class="n">puts</span> <span class="s">"I am an instance method"</span>  
  <span class="nb">end</span>  
  <span class="n">def</span> <span class="nb">self</span>.<span class="n">a_class_method</span>  
    <span class="n">puts</span> <span class="s">"I am a class method"</span>  
  <span class="nb">end</span>  
<span class="nb">end</span>

<span class="n">foo</span> = <span class="n">Foo</span>.<span class="nb">new</span>

<span class="n">def</span> <span class="n">foo</span>.<span class="n">a_singleton_method</span>
  <span class="n">puts</span> <span class="s">"I am a singletone method"</span>
<span class="nb">end</span>
</pre></div>

<p>Another way of accessing an <code>Eigenclass</code>(which includes singleton methods) is
with the following syntax (<code>class &lt;&lt;</code>):</p>
<div class="code"><pre class="code literal-block"><span class="nv">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Foo</span>.<span class="nv">new</span>

<span class="nv">class</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nv">foo</span>
<span class="w">  </span><span class="nv">def</span><span class="w"> </span><span class="nv">a_singleton_method</span>
<span class="w">    </span><span class="nv">puts</span><span class="w"> </span><span class="s2">"I am a singleton method"</span>
<span class="w">  </span><span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>now you can define a singleton method for <code>self</code> which is the class <code>Foo</code>
itself in this context:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>
  <span class="k">class</span> &lt;&lt; <span class="nb">self</span>
    <span class="n">def</span> <span class="n">a_singleton_and_class_method</span>
      <span class="n">puts</span> <span class="s">"I am a singleton method for self and a class method for Foo"</span>
    <span class="nb">end</span>
  <span class="nb">end</span>
<span class="nb">end</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/which-status-code-should-i-use-for-failed-validations-or-invalid-duplicates/" class="u-url">Which status code should I use for failed validations or invalid duplicates?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/which-status-code-should-i-use-for-failed-validations-or-invalid-duplicates/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:55:24+08:00" itemprop="datePublished" title="2023-02-17 07:55">2023-02-17 07:55</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am building an application with a REST-based API and have come to the point
where I am specifying status codes for each requests.</p>
<p>What status code should i send for requests failing validation or where a
request is trying to add a duplicate in my database?</p>
<p>I've looked through http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html but
none of them seems right.</p>
<p>Is there a common practice when sending status codes?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>For input validation failure: 400 Bad Request + your optional description.
This is suggested in the book "RESTful Web Services". For double submit: 409
Conflict</p>
<hr>
<p><strong>Update June 2014</strong></p>
<p>The relevant specification used to be RFC2616, which gave the use of 400 (Bad
Request) rather narrowly as</p>
<blockquote>
<p>The request could not be understood by the server due to malformed syntax</p>
</blockquote>
<p>So it <em>might</em> have been argued that it was inappropriate for semantic errors.
But not any more; since June 2014 the relevant standard RFC 7231, which
supersedes the previous RFC2616, gives the use of 400 (Bad Request) more
broadly as</p>
<blockquote>
<p>the server cannot or will not process the request due to something that is
perceived to be a client error</p>
</blockquote>
<p><br></p>
<h3>Suggest</h3>
<ul>
<li>Failed validation: 403 Forbidden ("The server understood the request, but is refusing to fulfill it"). Contrary to popular opinion, RFC2616 doesn't say "403 is only intended for failed authentication", but "403: I know what you want, but I won't do that". That condition may or may not be due to authentication.</li>
<li>Trying to add a duplicate: 409 Conflict ("The request could not be completed due to a conflict with the current state of the resource.")</li>
</ul>
<p>You should definitely give a more detailed explanation in the response headers
and/or body (e.g. with a custom header - <code>X-Status-Reason: Validation
failed</code>).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/understanding-unique-keys-for-array-children-in-react-js/" class="u-url">Understanding unique keys for array children in React.js</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/understanding-unique-keys-for-array-children-in-react-js/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:54:55+08:00" itemprop="datePublished" title="2023-02-17 07:54">2023-02-17 07:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm building a React component that accepts a JSON data source and creates a
sortable table.<br>
Each of the dynamic data rows has a unique key assigned to it but I'm still
getting an error of:</p>
<blockquote>
<p>Each child in an array should have a unique "key" prop.<br>
 Check the render method of TableComponent.</p>
</blockquote>
<p>My <code>TableComponent</code> render method returns:</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;table&gt;</span>
<span class="w">  </span><span class="nt">&lt;thead</span><span class="w"> </span><span class="na">key=</span><span class="s">"thead"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;TableHeader</span><span class="w"> </span><span class="na">columns=</span><span class="s">{columnNames}/</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;/thead&gt;</span>
<span class="w">  </span><span class="nt">&lt;tbody</span><span class="w"> </span><span class="na">key=</span><span class="s">"tbody"</span><span class="nt">&gt;</span>
<span class="w">    </span>{<span class="w"> </span>rows<span class="w"> </span>}
<span class="w">  </span><span class="nt">&lt;/tbody&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</pre></div>

<p>The <code>TableHeader</code> component is a single row and also has a unique key assigned
to it.</p>
<p>Each <code>row</code> in <code>rows</code> is built from a component with a unique key:</p>
<div class="code"><pre class="code literal-block">&lt;TableRowItem key={item.id} data={item} columns={columnNames}/&gt;
</pre></div>

<p>And the <code>TableRowItem</code> looks like this:</p>
<div class="code"><pre class="code literal-block"><span class="nf">var</span><span class="w"> </span><span class="n">TableRowItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">React</span><span class="p">.</span><span class="n">createClass</span><span class="p">(</span><span class="err">{</span>
<span class="w">  </span><span class="nl">render</span><span class="p">:</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>

<span class="w">    </span><span class="nf">var</span><span class="w"> </span><span class="n">td</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">props</span><span class="p">.</span><span class="n">columns</span><span class="p">.</span><span class="k">map</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="n">td</span><span class="w"> </span><span class="k">key</span><span class="o">=</span><span class="err">{</span><span class="n">this</span><span class="p">.</span><span class="n">props</span><span class="p">.</span><span class="k">data</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="err">}</span><span class="o">&gt;</span><span class="err">{</span><span class="n">this</span><span class="p">.</span><span class="n">props</span><span class="p">.</span><span class="k">data</span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="err">}</span><span class="o">&lt;/</span><span class="n">td</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="p">);</span>
<span class="w">      </span><span class="err">}</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="o">&lt;</span><span class="n">tr</span><span class="o">&gt;</span><span class="err">{</span><span class="w"> </span><span class="n">td</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">props</span><span class="p">.</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="o">&lt;/</span><span class="n">tr</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span><span class="p">);</span>
</pre></div>

<p>What is causing the unique key prop error?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You should add a key to each child <strong>as well as each element inside
children</strong>.</p>
<p>This way React can handle the minimal DOM change.</p>
<p>In your code, each <code>&lt;TableRowItem key={item.id} data={item}
columns={columnNames}/&gt;</code> is trying to render some children inside them without
a key.</p>
<p>Check this example.</p>
<p>Try removing the <code>key={i}</code> from the <code>&lt;b&gt;&lt;/b&gt;</code> element inside the div's (and
check the console).</p>
<p>In the sample, if we don't give a key to the <code>&lt;b&gt;</code> element and we want to
update <strong>only</strong> the <code>object.city</code>, React needs to re-render the whole row vs
just the element.</p>
<p>Here is the code:</p>
<div class="code"><pre class="code literal-block">const<span class="w"> </span>data<span class="w"> </span>=<span class="w"> </span>[
<span class="w">  </span>{<span class="w"> </span>name:<span class="w"> </span>"Nuri",<span class="w"> </span>age:<span class="w"> </span>28,<span class="w"> </span>city:<span class="w"> </span>"HO"<span class="w"> </span>},
<span class="w">  </span>{<span class="w"> </span>name:<span class="w"> </span>"Talib",<span class="w"> </span>age:<span class="w"> </span>82,<span class="w"> </span>city:<span class="w"> </span>"HN"<span class="w"> </span>},
<span class="w">  </span>{<span class="w"> </span>name:<span class="w"> </span>"Jenny",<span class="w"> </span>age:<span class="w"> </span>41,<span class="w"> </span>city:<span class="w"> </span>"IT"<span class="w"> </span>},
];

const<span class="w"> </span>ExampleComponent<span class="w"> </span>=<span class="w"> </span>React.createClass({
<span class="w">  </span>render:<span class="w"> </span>function<span class="w"> </span>()<span class="w"> </span>{
<span class="w">    </span>const<span class="w"> </span>infoData<span class="w"> </span>=<span class="w"> </span>this.props.info;
<span class="w">    </span>return<span class="w"> </span>(
<span class="w">      </span><span class="nt">&lt;div&gt;</span>
<span class="w">        </span>{infoData.map((object,<span class="w"> </span>i)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">          </span>return<span class="w"> </span>(
<span class="w">            </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">className=</span><span class="s">{"row"}</span><span class="w"> </span><span class="na">key=</span><span class="s">{i}</span><span class="nt">&gt;</span>
<span class="w">              </span>{[
<span class="w">                </span>object.name,
<span class="w">                </span>//<span class="w"> </span>remove<span class="w"> </span>the<span class="w"> </span>key
<span class="w">                </span><span class="nt">&lt;b</span><span class="w"> </span><span class="na">className=</span><span class="s">"fosfo"</span><span class="w"> </span><span class="na">key=</span><span class="s">{i}</span><span class="nt">&gt;</span>
<span class="w">                  </span>{"<span class="w"> </span>"}
<span class="w">                  </span>{object.city}{"<span class="w"> </span>"}
<span class="w">                </span><span class="nt">&lt;/b&gt;</span>,
<span class="w">                </span>object.age,
<span class="w">              </span>]}
<span class="w">            </span><span class="nt">&lt;/div&gt;</span>
<span class="w">          </span>);
<span class="w">        </span>})}
<span class="w">      </span><span class="nt">&lt;/div&gt;</span>
<span class="w">    </span>);
<span class="w">  </span>},
});

React.render(<span class="nt">&lt;ExampleComponent</span><span class="w"> </span><span class="na">info=</span><span class="s">{data}</span><span class="w"> </span><span class="nt">/&gt;</span>,<span class="w"> </span>document.body);
</pre></div>

<hr>
<h3>**The answer posted by @Chris at the bottom goes into much more detail than</h3>
<p>this answer.**</p>
<p>React documentation on the importance of keys in reconciliation: Keys</p>
<p><br></p>
<h3>Suggest</h3>
<p><strong>Be careful when iterating over arrays!!</strong></p>
<p>It is a common misconception that using the index of the element in the array
is an acceptable way of suppressing the error you are probably familiar with:</p>
<div class="code"><pre class="code literal-block">Each child in an array should have a unique "key" prop.
</pre></div>

<p>However, in many cases it is not! This is <strong>anti-pattern</strong> that can in <em>some</em>
situations lead to <strong>unwanted behavior</strong>.</p>
<h2>Understanding the <code>key</code> prop</h2>
<p>React uses the <code>key</code> prop to understand the component-to-DOM Element relation,
which is then used for the reconciliation process. It is therefore very
important that the key <em>always</em> remains <em>unique</em> , otherwise there is a good
chance React will mix up the elements and mutate the incorrect one. It is also
important that these keys <em>remain static</em> throughout all re-renders in order
to maintain best performance.</p>
<p>That being said, one does not <em>always</em> need to apply the above, provided it is
<em>known</em> that the array is completely static. However, applying best practices
is encouraged whenever possible.</p>
<p>A React developer said in this GitHub issue:</p>
<blockquote>
<ul>
<li>key is not really about performance, it's more about identity (which in
turn leads to better performance). randomly assigned and changing values are
not identity</li>
<li>We can't realistically provide keys [automatically] without knowing how
your data is modeled. I would suggest maybe using some sort of hashing
function if you don't have ids</li>
<li>We already have internal keys when we use arrays, but they are the index
in the array. When you insert a new element, those keys are wrong.
</li>
</ul>
</blockquote>
<p>In short, a <code>key</code> should be:</p>
<ul>
<li>
<strong>Unique</strong> - A key cannot be identical to that of a sibling component.</li>
<li>
<strong>Static</strong> - A key should not ever change between renders.</li>
</ul>
<h2>Using the <code>key</code> prop</h2>
<p>As per the explanation above, carefully study the following samples and try to
implement, when possible, the recommended approach.</p>
<hr>
<h4>Bad (Potentially)</h4>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;tbody&gt;</span>
<span class="w">    </span>{rows.map((row,<span class="w"> </span>i)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">        </span>return<span class="w"> </span><span class="nt">&lt;ObjectRow</span><span class="w"> </span><span class="na">key=</span><span class="s">{i}</span><span class="w"> </span><span class="nt">/&gt;</span>;
<span class="w">    </span>})}
<span class="nt">&lt;/tbody&gt;</span>
</pre></div>

<p>This is arguably the most common mistake seen when iterating over an array in
React. This approach isn't technically <em>"wrong"</em> , it's just... <em>"dangerous"</em>
if you don't know what you are doing. If you are iterating through a static
array then this is a perfectly valid approach (e.g. an array of links in your
navigation menu). However, if you are adding, removing, reordering or
filtering items, then you need to be careful. Take a look at this detailed
explanation in the official documentation.</p>
<p>Show code snippet</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">MyApp</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">React</span><span class="o">.</span><span class="n">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">constructor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">super</span><span class="p">();</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">arr</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Item 1"</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">click</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">setState</span><span class="p">({</span>
<span class="w">      </span><span class="n">arr</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s1">'Item '</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">arr</span><span class="p">),</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">render</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">(</span>
<span class="w">      </span><span class="o">&lt;</span><span class="n">div</span><span class="o">&gt;</span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">onClick</span><span class="o">=</span><span class="p">{</span><span class="n">this</span><span class="o">.</span><span class="n">click</span><span class="p">}</span><span class="o">&gt;</span><span class="n">Add</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
<span class="w">        </span><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="w">          </span><span class="p">{</span><span class="n">this</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
<span class="w">            </span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="n">key</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="w"> </span><span class="n">text</span><span class="o">=</span><span class="p">{</span><span class="s2">"Item "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="n">item</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" "</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">Item</span><span class="o">&gt;</span>
<span class="w">          </span><span class="p">)}</span>
<span class="w">        </span><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="n">label</span><span class="o">&gt;</span><span class="p">{</span><span class="n">props</span><span class="o">.</span><span class="n">children</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">label</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="n">input</span><span class="w"> </span><span class="n">value</span><span class="o">=</span><span class="p">{</span><span class="n">props</span><span class="o">.</span><span class="n">text</span><span class="p">}</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="w">    </span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ReactDOM</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="o">&lt;</span><span class="n">MyApp</span><span class="w"> </span><span class="o">/&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">document</span><span class="o">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"app"</span><span class="p">));</span>


<span class="o">&lt;</span><span class="n">script</span><span class="w"> </span><span class="n">src</span><span class="o">=</span><span class="s2">"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js"</span><span class="o">&gt;&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">script</span><span class="w"> </span><span class="n">src</span><span class="o">=</span><span class="s2">"https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js"</span><span class="o">&gt;&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">div</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"app"</span><span class="o">&gt;&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
</pre></div>

<p>In this snippet we are using a non-static array and we are not restricting
ourselves to using it as a stack. This is an unsafe approach (you'll see why).
Note how as we add items to the beginning of the array (basically unshift),
the value for each <code>&lt;input&gt;</code> remains in place. Why? Because the <code>key</code> doesn't
uniquely identify each item.</p>
<p>In other words, at first <code>Item 1</code> has <code>key={0}</code>. When we add the second item,
the top item becomes <code>Item 2</code>, followed by <code>Item 1</code> as the second item.
However, now <code>Item 1</code> has <code>key={1}</code> and not <code>key={0}</code> anymore. Instead, <code>Item
2</code> now has <code>key={0}</code>!!</p>
<p>As such, React thinks the <code>&lt;input&gt;</code> elements have not changed, because the
<code>Item</code> with key <code>0</code> is always at the top!</p>
<p><strong>So why is this approach only <em>sometimes</em> bad?</strong></p>
<p>This approach is only risky if the array is somehow filtered, rearranged, or
items are added/removed. If it is always static, then it's perfectly safe to
use. For example, a navigation menu like <code>["Home", "Products", "Contact us"]</code>
can safely be iterated through with this method because you'll probably never
add new links or rearrange them.</p>
<p>In short, here's when you can <strong>safely</strong> use the index as <code>key</code>:</p>
<ul>
<li>The array is static and will never change.</li>
<li>The array is never filtered (display a subset of the array).</li>
<li>The array is never reordered.</li>
<li>The array is used as a stack or LIFO (last in, first out). In other words, adding can only be done at the end of the array (i.e push), and only the last item can ever be removed (i.e pop).</li>
</ul>
<p>Had we instead, in the snippet above, <strong>pushed</strong> the added item to the end of
the array, the order for each existing item would always be correct.</p>
<hr>
<h4>Very bad</h4>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;tbody&gt;</span>
<span class="w">    </span>{rows.map((row)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">        </span>return<span class="w"> </span><span class="nt">&lt;ObjectRow</span><span class="w"> </span><span class="na">key=</span><span class="s">{Math.random()}</span><span class="w"> </span><span class="nt">/&gt;</span>;
<span class="w">    </span>})}
<span class="nt">&lt;/tbody&gt;</span>
</pre></div>

<p>While this approach will probably guarantee uniqueness of the keys, it will
<em>always</em> force react to re-render each item in the list, even when this is not
required. This a very bad solution as it greatly impacts performance. Not to
mention that one cannot exclude the possibility of a key collision in the
event that <code>Math.random()</code> produces the same number twice.</p>
<blockquote>
<p>Unstable keys (like those produced by <code>Math.random()</code>) will cause many
component instances and DOM nodes to be unnecessarily recreated, which can
cause performance degradation and lost state in child components.</p>
</blockquote>
<hr>
<h4>Very good</h4>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;tbody&gt;</span>
<span class="w">    </span>{rows.map((row)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">        </span>return<span class="w"> </span><span class="nt">&lt;ObjectRow</span><span class="w"> </span><span class="na">key=</span><span class="s">{row.uniqueId}</span><span class="w"> </span><span class="nt">/&gt;</span>;
<span class="w">    </span>})}
<span class="nt">&lt;/tbody&gt;</span>
</pre></div>

<p>This is arguably the best approach because it uses a property that is unique
for each item in the dataset. For example, if <code>rows</code> contains data fetched
from a database, one could use the table's Primary Key ( <em>which typically is
an auto-incrementing number</em> ).</p>
<blockquote>
<p>The best way to pick a key is to use a string that uniquely identifies a
list item among its siblings. Most often you would use IDs from your data as
keys</p>
</blockquote>
<hr>
<h4>Good</h4>
<div class="code"><pre class="code literal-block">componentWillMount()<span class="w"> </span>{
<span class="w">  </span>let<span class="w"> </span>rows<span class="w"> </span>=<span class="w"> </span>this.props.rows.map(item<span class="w"> </span>=&gt;<span class="w"> </span>{<span class="w"> </span>
<span class="w">    </span>return<span class="w"> </span>{uid:<span class="w"> </span>SomeLibrary.generateUniqueID(),<span class="w"> </span>value:<span class="w"> </span>item};
<span class="w">  </span>});
}

...

<span class="nt">&lt;tbody&gt;</span>
<span class="w">    </span>{rows.map((row)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">        </span>return<span class="w"> </span><span class="nt">&lt;ObjectRow</span><span class="w"> </span><span class="na">key=</span><span class="s">{row.uid}</span><span class="w"> </span><span class="nt">/&gt;</span>;
<span class="w">    </span>})}
<span class="nt">&lt;/tbody&gt;</span>
</pre></div>

<p>This is also a good approach. If your dataset does not contain any data that
guarantees uniqueness ( <em>e.g. an array of arbitrary numbers</em> ), there is a
chance of a key collision. In such cases, it is best to manually generate a
unique identifier for each item in the dataset before iterating over it.
Preferably when mounting the component or when the dataset is received ( <em>e.g.
from<code>props</code> or from an async API call</em>), in order to do this only <em>once</em> , and
not each time the component re-renders. There are already a handful of
libraries out there that can provide you such keys. Here is one example:
react-key-index.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-481.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-479.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
