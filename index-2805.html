<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2805) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2805.html">
<link rel="prev" href="index-2806.html" type="text/html">
<link rel="next" href="index-2804.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/when-to-use-queryparam-vs-pathparam/" class="u-url">When to use @QueryParam vs @PathParam</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/when-to-use-queryparam-vs-pathparam/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T19:16:01+08:00" itemprop="datePublished" title="2023-03-05 19:16">2023-03-05 19:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am not asking the question that is already asked here: What is the
difference between @PathParam and @QueryParam</p>
<p>This is a "best practices" or convention question.</p>
<p>When would you use <code>@PathParam</code> vs <code>@QueryParam</code>.</p>
<p>What I can think of that the decision might be using the two to differentiate
the information pattern. Let me illustrate below my LTPO - less than perfect
observation.</p>
<p>PathParam use could be reserved for information category, which would fall
nicely into a branch of an information tree. PathParam could be used to drill
down to entity class hierarchy.</p>
<p>Whereas, QueryParam could be reserved for specifying attributes to locate the
instance of a class.</p>
<p>For example,</p>
<ul>
<li><code>/Vehicle/Car?registration=123</code></li>
<li><code>/House/Colonial?region=newengland</code></li>
</ul>
<p><code>/category?instance</code></p>
<div class="code"><pre class="code literal-block"><span class="nv">@GET</span>
<span class="nv">@Path</span><span class="p">(</span><span class="ss">"/employee/{dept}"</span><span class="p">)</span>
<span class="n">Patient</span><span class="w"> </span><span class="n">getEmployee</span><span class="p">(</span><span class="nv">@PathParam</span><span class="p">(</span><span class="ss">"dept"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">dept</span><span class="p">,</span><span class="w"> </span><span class="nv">@QueryParam</span><span class="p">(</span><span class="ss">"id"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">;</span>
</pre></div>

<p>vs <code>/category/instance</code></p>
<div class="code"><pre class="code literal-block"><span class="nv">@GET</span>
<span class="nv">@Path</span><span class="p">(</span><span class="ss">"/employee/{dept}/{id}"</span><span class="p">)</span>
<span class="n">Patient</span><span class="w"> </span><span class="n">getEmployee</span><span class="p">(</span><span class="nv">@PathParam</span><span class="p">(</span><span class="ss">"dept"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">dept</span><span class="p">,</span><span class="w"> </span><span class="nv">@PathParam</span><span class="p">(</span><span class="ss">"id"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">;</span>
</pre></div>

<p>vs <code>?category+instance</code></p>
<div class="code"><pre class="code literal-block"><span class="nv">@GET</span>
<span class="nv">@Path</span><span class="p">(</span><span class="ss">"/employee"</span><span class="p">)</span>
<span class="n">Patient</span><span class="w"> </span><span class="n">getEmployee</span><span class="p">(</span><span class="nv">@QueryParam</span><span class="p">(</span><span class="ss">"dept"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">dept</span><span class="p">,</span><span class="w"> </span><span class="nv">@QueryParam</span><span class="p">(</span><span class="ss">"id"</span><span class="p">)</span><span class="n">Long</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">;</span>
</pre></div>

<p>I don't think there is a standard convention of doing it. Is there? However, I
would like to hear of how people use PathParam vs QueryParam to differentiate
their information like I exemplified above. I would also love to hear the
reason behind the practice.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>REST may not be a standard as such, but reading up on general REST
documentation and blog posts should give you some guidelines for a good way to
structure API URLs. Most rest APIs tend to only have resource names and
resource IDs in the path. Such as:</p>
<div class="code"><pre class="code literal-block">/departments/{dept}/employees/{id}
</pre></div>

<p>Some REST APIs use query strings for filtering, pagination and sorting, but
Since REST isn't a strict standard I'd recommend checking some REST APIs out
there such as github and stackoverflow and see what could work well for your
use case.</p>
<p>I'd recommend putting any required parameters in the path, and any optional
parameters should certainly be query string parameters. Putting optional
parameters in the path will end up getting really messy when trying to write
URL handlers that match different combinations.</p>
<p><br></p>
<h3>Suggest</h3>
<p>This is what I do.</p>
<p>If there is a scenario to retrieve a record based on id, for example you need
to get the details of the employee whose id is 15, then you can have resource
with @PathParam.</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /employee/{id}</span>
</pre></div>

<p>If there is a scenario where you need to get the details of all employees but
only 10 at a time, you may use query param</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /employee?start=1&amp;size=10</span>
</pre></div>

<p>This says that starting employee id 1 get ten records.</p>
<p>To summarize, use @PathParam for retrieval based on id. User @QueryParam for
filter or if you have any fixed list of options that user can pass.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-add-a-default-include-path-for-gcc-in-linux/" class="u-url">How can I add a default include path for GCC in Linux?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-add-a-default-include-path-for-gcc-in-linux/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T19:15:16+08:00" itemprop="datePublished" title="2023-03-05 19:15">2023-03-05 19:15</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'd like GCC to include files from <code>$HOME/include</code> in addition to the usual
include directories, but there doesn't seem to be an analogue to
<code>$LD_LIBRARY_PATH</code>.</p>
<p>I know I can just add the include directory at command line when compiling (or
in the makefile), but I'd really like a universal approach here, as in the
library case.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Try setting <code>C_INCLUDE_PATH</code> (for C header files) or <code>CPLUS_INCLUDE_PATH</code> (for
C++ header files) environment variables.</p>
<p>As Ciro mentioned, <code>CPATH</code> will set the path for both C and C++ (and any other
language).</p>
<p>On Windows these may be set to semicolon-separated lists. On most other
platforms they may be set to colon-separated lists.</p>
<p>More details in GCC's documentation.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Create an alias for gcc with your favorite includes.</p>
<div class="code"><pre class="code literal-block">alias mygcc='gcc -I /whatever/'
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/are-variables-declared-with-let-or-const-hoisted/" class="u-url">Are variables declared with let or const hoisted?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/are-variables-declared-with-let-or-const-hoisted/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T19:14:03+08:00" itemprop="datePublished" title="2023-03-05 19:14">2023-03-05 19:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have been playing with ES6 for a while and I noticed that while variables
declared with <code>var</code> are hoisted as expected...</p>
<div class="code"><pre class="code literal-block"><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">typeof</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">undefined</span>
<span class="k">var</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"John"</span><span class="p">;</span>
</pre></div>

<p>...variables declared with <code>let</code> or <code>const</code> seem to have some problems with
hoisting:</p>
<div class="code"><pre class="code literal-block">console.log(typeof name); // ReferenceError
let name = "John";
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block"><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">typeof</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ReferenceError</span>
<span class="k">const</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"John"</span><span class="p">;</span>
</pre></div>

<p>Does this mean that variables declared with <code>let</code> or <code>const</code> are not hoisted?
What is really going on here? Is there any difference between <code>let</code> and
<code>const</code> in this matter?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>@thefourtheye is correct in saying that these variables <strong>cannot be accessed</strong>
before they are declared. However, it's a bit more complicated than that.</p>
<blockquote>
<p>Are variables declared with <code>let</code> or <code>const</code> not hoisted? What is really
going on here?</p>
</blockquote>
<p><strong>All declarations</strong> (<code>var</code>, <code>let</code>, <code>const</code>, <code>function</code>, <code>function*</code>, <code>class</code>)
<strong>are "hoisted"</strong> in JavaScript. This means that if a name is declared in a
scope, in that scope the identifier will always reference that particular
variable:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"global"</span><span class="p">;</span>
<span class="o">//</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">scope</span><span class="o">:</span>
<span class="p">(</span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="s2">"global"</span>

<span class="w">    </span><span class="n">var</span><span class="o">/</span><span class="n">let</span><span class="o">/</span><span class="n">…</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="err">}</span><span class="p">());</span>
<span class="o">//</span><span class="w"> </span><span class="k">block</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="p">(</span><span class="k">not</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n n-Quoted">`var`</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="s2">"global"</span>

<span class="w">    </span><span class="n">let</span><span class="o">/</span><span class="n">const</span><span class="o">/</span><span class="n">…</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>This is true both for function and block scopes1.</p>
<p>The difference between <code>var</code>/<code>function</code>/<code>function*</code> declarations and
<code>let</code>/<code>const</code>/<code>class</code> declara­tions is the <strong>initialisation</strong>.<br>
The former are initialised with <code>undefined</code> or the (generator) function right
when the binding is created at the top of the scope. The lexically declared
variables however stay <strong>uninitialised</strong>. This means that a <code>ReferenceError</code>
exception is thrown when you try to access it. It will only get initialised
when the <code>let</code>/<code>const</code>/<code>class</code> statement is evaluated, everything before
(above) that is called the <em>temporal dead zone</em>.</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"global"</span><span class="p">;</span>
<span class="p">(</span><span class="n">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">undefined</span>
<span class="w">    </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Reference</span><span class="w"> </span><span class="n">error</span><span class="p">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">defined</span>

<span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"local"</span><span class="p">;</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"local"</span><span class="p">;</span>
<span class="p">}());</span>
</pre></div>

<p>Notice that a <code>let y;</code> statement initialises the variable with <code>undefined</code>
like <code>let y = undefined;</code> would have.</p>
<p>The <em>temporal</em> dead zone is not a syntactic location, but rather the <em>time</em>
between the variable (scope) creation and the initialisation. It's not an
error to reference the variable in code above the declaration as long as that
code is not executed (e.g. a function body or simply dead code), and it will
throw an exception if you access the variable before the initialisation even
if the accessing code is below the declaration (e.g. in a hoisted function
declaration that is called too early).</p>
<blockquote>
<p>Is there any difference between <code>let</code> and <code>const</code> in this matter?</p>
</blockquote>
<p>No, they work the same as far as hoisting is regarded. The only difference
between them is that a <code>const</code>ant must be and can only be assigned in the
initialiser part of the declaration (<code>const one = 1;</code>, both <code>const one;</code> and
later reassignments like <code>one = 2</code> are invalid).</p>
<p>1: <code>var</code> declarations are still working only on the function level, of course</p>
<p><br></p>
<h3>Suggest</h3>
<p>Quoting ECMAScript 6 (ECMAScript 2015) specification's, <code>let</code> and <code>const</code>
declarations section,</p>
<blockquote>
<p>The variables are created when their containing Lexical Environment is
instantiated but <strong>may not be accessed in any way until the variable’s
LexicalBinding is evaluated</strong>.</p>
</blockquote>
<p>So, to answer your question, yes, <code>let</code> and <code>const</code> hoist but you cannot
access them before the actual declaration is evaluated at runtime.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2806.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2804.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
