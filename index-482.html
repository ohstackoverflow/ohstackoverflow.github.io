<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 482) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-482.html">
<link rel="prev" href="index-483.html" type="text/html">
<link rel="next" href="index-481.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-an-entity-body-allowed-for-an-http-delete-request/" class="u-url">Is an entity body allowed for an HTTP DELETE request?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-an-entity-body-allowed-for-an-http-delete-request/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:58:39+08:00" itemprop="datePublished" title="2023-02-17 07:58">2023-02-17 07:58</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>When issuing an HTTP DELETE request, the request URI should completely
identify the resource to delete. However, is it allowable to add extra meta-
data as part of the entity body of the request?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The spec does not explicitly forbid or discourage it, so I would tend to say
it is allowed.</p>
<p>Microsoft sees it the same way (I can hear murmuring in the audience), they
state in the MSDN article about the DELETE Method of ADO.NET Data Services
Framework:</p>
<blockquote>
<p>If a DELETE request includes an entity body, the body is ignored [...]</p>
</blockquote>
<p>Additionally here is what RFC2616 (HTTP 1.1) has to say in regard to requests:</p>
<ul>
<li>an <em>entity-body</em> is only present when a <em>message-body</em> is present (section 7.2)</li>
<li>the presence of a <em>message-body</em> is signaled by the inclusion of a <code>Content-Length</code> or <code>Transfer-Encoding</code> header (section 4.3)</li>
<li>a <em>message-body</em> must not be included when the specification of the request method does not allow sending an <em>entity-body</em> (section 4.3)</li>
<li>an <em>entity-body</em> is explicitly forbidden in TRACE requests only, all other request types are unrestricted (section 9, and 9.8 specifically)</li>
</ul>
<p>For responses, this has been defined:</p>
<ul>
<li>whether a <em>message-body</em> is included depends on both request method <em>and</em> response status (section 4.3)</li>
<li>a <em>message-body</em> is explicitly forbidden in responses to HEAD requests (section 9, and 9.4 specifically)</li>
<li>a <em>message-body</em> is explicitly forbidden in 1xx (informational), 204 (no content), and 304 (not modified) responses (section 4.3)</li>
<li>all other responses include a message-body, though it may be of zero length (section 4.3)</li>
</ul>
<h3>Update</h3>
<p>And in RFC 9110 (June 2022), The fact that request bodies on GET, HEAD, and
DELETE are not interoperable has been clarified.</p>
<p>section 9.3.5 Delete</p>
<blockquote>
<p>Although request message framing is independent of the method used, content
received in a DELETE request has no generally defined semantics, cannot
alter the meaning or target of the request, and might lead some
implementations to reject the request and close the connection because of
its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A
client SHOULD NOT generate content in a DELETE request unless it is made
directly to an origin server that has previously indicated, in or out of
band, that such a request has a purpose and will be adequately supported. An
origin server SHOULD NOT rely on private agreements to receive content,
since participants in HTTP communication are often unaware of intermediaries
along the request chain.</p>
</blockquote>
<p><br></p>
<h3>Suggest</h3>
<p>The 2014 update to the HTTP 1.1 specification (RFC 7231) explicitly permits an
entity-body in a DELETE request:</p>
<blockquote>
<p>A payload within a DELETE request message has no defined semantics; sending
a payload body on a DELETE request might cause some existing implementations
to reject the request.</p>
</blockquote>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/count-the-number-of-set-bits-in-a-32-bit-integer/" class="u-url">Count the number of set bits in a 32-bit integer</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/count-the-number-of-set-bits-in-a-32-bit-integer/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:58:09+08:00" itemprop="datePublished" title="2023-02-17 07:58">2023-02-17 07:58</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>8 bits representing the number 7 look like this:</p>
<div class="code"><pre class="code literal-block"><span class="mf">00000111</span>
</pre></div>

<p>Three bits are set.</p>
<p>What are the algorithms to determine the number of set bits in a 32-bit
integer?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>This is known as the 'Hamming Weight', 'popcount' or 'sideways addition'.</p>
<p>Some CPUs have a single built-in instruction to do it and others have parallel
instructions which act on bit vectors. Instructions like x86's <code>popcnt</code> (on
CPUs where it's supported) will almost certainly be fastest for a single
integer. Some other architectures may have a slow instruction implemented with
a microcoded loop that tests a bit per cycle ( <em>citation needed</em> - hardware
popcount is normally fast if it exists at all.).</p>
<p>The 'best' algorithm really depends on which CPU you are on and what your
usage pattern is.</p>
<p>Your compiler may know how to do something that's good for the specific CPU
you're compiling for, e.g. C++20 <code>std::popcount()</code>, or C++
<code>std::bitset&lt;32&gt;::count()</code>, as a portable way to access builtin / intrinsic
functions (see another answer on this question). But your compiler's choice of
fallback for target CPUs that don't have hardware popcnt might not be optimal
for your use-case. Or your language (e.g. C) might not expose any portable
function that could use a CPU-specific popcount when there is one.</p>
<hr>
<h4>Portable algorithms that don't need (or benefit from) any HW support</h4>
<p>A pre-populated table lookup method can be very fast if your CPU has a large
cache and you are doing lots of these operations in a tight loop. However it
can suffer because of the expense of a 'cache miss', where the CPU has to
fetch some of the table from main memory. (Look up each byte separately to
keep the table small.) If you want popcount for a contiguous range of numbers,
only the low byte is changing for groups of 256 numbers, making this very
good.</p>
<p>If you know that your bytes will be mostly 0's or mostly 1's then there are
efficient algorithms for these scenarios, e.g. clearing the lowest set with a
bithack in a loop until it becomes zero.</p>
<p>I believe a very good general purpose algorithm is the following, known as
'parallel' or 'variable-precision SWAR algorithm'. I have expressed this in a
C-like pseudo language, you may need to adjust it to work for a particular
language (e.g. using uint32_t for C++ and &gt;&gt;&gt; in Java):</p>
<p>GCC10 and clang 10.0 can recognize this pattern / idiom and compile it to a
hardware popcnt or equivalent instruction when available, giving you the best
of both worlds. (https://godbolt.org/z/qGdh1dvKK)</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">numberOfSetBits</span><span class="o">(</span><span class="nt">uint32_t</span><span class="w"> </span><span class="nt">i</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="n">Java</span><span class="p">:</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">int</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">instead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="o">&gt;&gt;.</span><span class="w"> </span><span class="n">Or</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">Integer</span><span class="o">.</span><span class="nf">bitCount</span><span class="p">()</span>
<span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">C</span><span class="o">++:</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">uint32_t</span>
<span class="w">     </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">0</span><span class="n">x55555555</span><span class="p">);</span><span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">add</span><span class="w"> </span><span class="err">pairs</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">bits</span>
<span class="w">     </span><span class="err">i</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">(i</span><span class="w"> </span><span class="err">&amp;</span><span class="w"> </span><span class="err">0x33333333)</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">((i</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">2)</span><span class="w"> </span><span class="err">&amp;</span><span class="w"> </span><span class="err">0x33333333)</span><span class="p">;</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="err">quads</span>
<span class="w">     </span><span class="err">i</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">(i</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">(i</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">4))</span><span class="w"> </span><span class="err">&amp;</span><span class="w"> </span><span class="err">0x0F0F0F0F</span><span class="p">;</span><span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">groups</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">8</span>
<span class="w">     </span><span class="err">return</span><span class="w"> </span><span class="err">(i</span><span class="w"> </span><span class="err">*</span><span class="w"> </span><span class="err">0x01010101)</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">24</span><span class="p">;</span><span class="w">          </span><span class="err">//</span><span class="w"> </span><span class="err">horizontal</span><span class="w"> </span><span class="err">sum</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">bytes</span>
<span class="p">}</span>
</pre></div>

<p>For JavaScript: coerce to integer with <code>|0</code> for performance: change the first
line to <code>i = (i|0) - ((i &gt;&gt; 1) &amp; 0x55555555);</code></p>
<p>This has the best worst-case behaviour of any of the algorithms discussed, so
will efficiently deal with any usage pattern or values you throw at it. (Its
performance is not data-dependent on normal CPUs where all integer operations
including multiply are constant-time. It doesn't get any faster with "simple"
inputs, but it's still pretty decent.)</p>
<p>References:</p>
<ul>
<li>https://graphics.stanford.edu/~seander/bithacks.html</li>
<li>https://catonmat.net/low-level-bit-hacks for bithack basics, like how subtracting 1 flips contiguous zeros.</li>
<li>https://en.wikipedia.org/wiki/Hamming_weight</li>
<li>http://gurmeet.net/puzzles/fast-bit-counting-routines/</li>
<li>http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)</li>
</ul>
<hr>
<h4>How this SWAR bithack works:</h4>
<div class="code"><pre class="code literal-block">i = i - ((i &gt;&gt; 1) &amp; 0x55555555);
</pre></div>

<p>The first step is an optimized version of masking to isolate the odd / even
bits, shifting to line them up, and adding. This effectively does 16 separate
additions in 2-bit accumulators (SWAR = SIMD Within A Register). Like <code>(i &amp;
0x55555555) + ((i&gt;&gt;1) &amp; 0x55555555)</code>.</p>
<p>The next step takes the odd/even eight of those 16x 2-bit accumulators and
adds again, producing 8x 4-bit sums. The <code>i - ...</code> optimization isn't possible
this time so it does just mask before / after shifting. Using the same
<code>0x33...</code> constant both times instead of <code>0xccc...</code> before shifting is a good
thing when compiling for ISAs that need to construct 32-bit constants in
registers separately.</p>
<p>The final shift-and-add step of <code>(i + (i &gt;&gt; 4)) &amp; 0x0F0F0F0F</code> widens to 4x
8-bit accumulators. It masks <em>after</em> adding instead of before, because the
maximum value in any 4-bit accumulator is <code>4</code>, if all 4 bits of the
corresponding input bits were set. 4+4 = 8 which still fits in 4 bits, so
carry between nibble elements is impossible in <code>i + (i &gt;&gt; 4)</code>.</p>
<p>So far this is just fairly normal SIMD using SWAR techniques with a few clever
optimizations. Continuing on with the same pattern for 2 more steps can widen
to 2x 16-bit then 1x 32-bit counts. But there is a more efficient way on
machines with fast hardware multiply:</p>
<p>Once we have few enough "elements", <strong>a multiply with a magic constant can sum
all the elements into the top element</strong>. In this case byte elements. Multiply
is done by left-shifting and adding, so <strong>a multiply of<code>x * 0x01010101</code>
results in <code>x + (x&lt;&lt;8) + (x&lt;&lt;16) + (x&lt;&lt;24)</code>.</strong> Our 8-bit elements are wide
enough (and holding small enough counts) that this doesn't produce carry
<em>into</em> that top 8 bits.</p>
<p><strong>A 64-bit version of this</strong> can do 8x 8-bit elements in a 64-bit integer with
a 0x0101010101010101 multiplier, and extract the high byte with <code>&gt;&gt;56</code>. So it
doesn't take any extra steps, just wider constants. This is what GCC uses for
<code>__builtin_popcountll</code> on x86 systems when the hardware <code>popcnt</code> instruction
isn't enabled. If you can use builtins or intrinsics for this, do so to give
the compiler a chance to do target-specific optimizations.</p>
<hr>
<h4>With full SIMD for wider vectors (e.g. counting a whole array)</h4>
<p>This bitwise-SWAR algorithm could parallelize to be done in multiple vector
elements at once, instead of in a single integer register, for a speedup on
CPUs with SIMD but no usable popcount instruction. (e.g. x86-64 code that has
to run on any CPU, not just Nehalem or later.)</p>
<p>However, the best way to use vector instructions for popcount is usually by
using a variable-shuffle to do a table-lookup for 4 bits at a time of each
byte in parallel. (The 4 bits index a 16 entry table held in a vector
register).</p>
<p>On Intel CPUs, the hardware 64bit popcnt instruction can outperform an SSSE3
<code>PSHUFB</code> bit-parallel implementation by about a factor of 2, but only if your
compiler gets it just right. Otherwise SSE can come out significantly ahead.
Newer compiler versions are aware of the popcnt false dependency problem on
Intel.</p>
<ul>
<li>https://github.com/WojciechMula/sse-popcount state-of-the-art x86 SIMD popcount for SSSE3, AVX2, AVX512BW, AVX512VBMI, or AVX512 VPOPCNT. Using Harley-Seal across vectors to defer popcount within an element. (Also ARM NEON)</li>
<li>Counting 1 bits (population count) on large data using AVX-512 or AVX-2</li>
<li>related: https://github.com/mklarqvist/positional-popcount - separate counts for each bit-position of multiple 8, 16, 32, or 64-bit integers. (Again, x86 SIMD including AVX-512 which is really good at this, with <code>vpternlogd</code> making Harley-Seal <em>very</em> good.)</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>Some languages portably expose the operation in a way that <em>can</em> use efficient
hardware support if available, otherwise some library fallback that's
hopefully decent.</p>
<p>For example (from a table by language):</p>
<ul>
<li>C++ has <code>std::bitset&lt;&gt;::count()</code>, or C++20 <code>std::popcount(T x)</code>
</li>
<li>Java has <code>java.lang.Integer.bitCount()</code> (also for Long or BigInteger)</li>
<li>C# has <code>System.Numerics.BitOperations.PopCount()</code>
</li>
<li>Python has <code>int.bit_count()</code> (since 3.10)</li>
</ul>
<p>Not all compilers / libraries actually manage to use HW support when it's
available, though. (Notably MSVC, even with options that make std::popcount
inline as x86 popcnt, its std::bitset::count still always uses a lookup table.
This will hopefully change in future versions.)</p>
<p>Also consider the built-in functions of your compiler when the portable
language doesn't have this basic bit operation. In GNU C for example:</p>
<div class="code"><pre class="code literal-block">int __builtin_popcount (unsigned int x);
int __builtin_popcountll (unsigned long long x);
</pre></div>

<p>In the worst case (no single-instruction HW support) the compiler will
generate a call to a function (which in current GCC uses a shift/and bit-hack
like this answer, at least for x86). In the best case the compiler will emit a
cpu instruction to do the job. (Just like a <code>*</code> or <code>/</code> operator - GCC will use
a hardware multiply or divide instruction if available, otherwise will call a
libgcc helper function.) Or even better, if the operand is a compile-time
constant after inlining, it can do constant-propagation to get a compile-time-
constant popcount result.</p>
<p>The GCC builtins even work across multiple platforms. Popcount has almost
become mainstream in the x86 architecture, so it makes sense to start using
the builtin now so you can recompile to let it inline a hardware instruction
when you compile with <code>-mpopcnt</code> or something that includes that (e.g.
https://godbolt.org/z/Ma5e5a). Other architectures have had popcount for
years, but in the x86 world there are still some ancient Core 2 and similar
vintage AMD CPUs in use.</p>
<hr>
<p>On x86, you can tell the compiler that it can assume support for <code>popcnt</code>
instruction with <code>-mpopcnt</code> (also implied by <code>-msse4.2</code>). See GCC x86 options.
<code>-march=nehalem -mtune=skylake</code> (or <code>-march=</code> whatever CPU you want your code
to assume and to tune for) could be a good choice. Running the resulting
binary on an older CPU will result in an illegal-instruction fault.</p>
<p>To make binaries optimized for the machine you build them on,
<strong>use<code>-march=native</code></strong> (with gcc, clang, or ICC).</p>
<p>MSVC provides an intrinsic for the x86 <code>popcnt</code> instruction, but unlike gcc
it's really an intrinsic for the hardware instruction and requires hardware
support.</p>
<hr>
<h3>Using <code>std::bitset&lt;&gt;::count()</code> instead of a built-in</h3>
<p>In theory, any compiler that knows how to popcount efficiently for the target
CPU should expose that functionality through ISO C++ <code>std::bitset&lt;&gt;</code>. In
practice, you might be better off with the bit-hack AND/shift/ADD in some
cases for some target CPUs.</p>
<p>For target architectures where hardware popcount is an optional extension
(like x86), not all compilers have a <code>std::bitset</code> that takes advantage of it
when available. For example, MSVC has no way to enable <code>popcnt</code> support at
compile time, and it's <code>std::bitset&lt;&gt;::count</code> always uses a table lookup, even
with <code>/Ox /arch:AVX</code> (which implies SSE4.2, which in turn implies the popcnt
feature.) (Update: see below; that <em>does</em> get MSVC's C++20 <code>std::popcount</code> to
use x86 <code>popcnt</code>, but still not its bitset&lt;&gt;::count. MSVC could fix that by
updating their standard library headers to use std::popcount when available.)</p>
<p>But at least you get something portable that works everywhere, and with
gcc/clang with the right target options, you get hardware popcount for
architectures that support it.</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bitset&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="c1">//static inline  // static if you want to compile with -mpopcnt in one compilation unit but not others</span>
<span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w">  </span><span class="kr">unsigned</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span>
<span class="n">popcount</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">radix</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"non-binary type"</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// sizeof(x)*CHAR_BIT</span>
<span class="w">    </span><span class="n">constexpr</span><span class="w"> </span><span class="kr">int</span><span class="w"> </span><span class="n">bitwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">is_signed</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// std::bitset constructor was only unsigned long before C++11.  Beware if porting to C++03</span>
<span class="w">    </span><span class="n">static_assert</span><span class="p">(</span><span class="n">bitwidth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kr">unsigned</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">,</span><span class="w"> </span><span class="s">"arg too wide for std::bitset() constructor"</span><span class="p">);</span>

<span class="w">    </span><span class="kr">typedef</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">make_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">UT</span><span class="p">;</span><span class="w">        </span><span class="c1">// probably not needed, bitset width chops after sign-extension</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="n">bitwidth</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bs</span><span class="p">(</span><span class="w"> </span><span class="kr">static_cast</span><span class="o">&lt;</span><span class="n">UT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bs</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>See asm from gcc, clang, icc, and MSVC on the Godbolt compiler explorer.</p>
<p>x86-64 <code>gcc -O3 -std=gnu++11 -mpopcnt</code> emits this:</p>
<div class="code"><pre class="code literal-block"><span class="nv">unsigned</span><span class="w"> </span><span class="nv">test_short</span><span class="ss">(</span><span class="nv">short</span><span class="w"> </span><span class="nv">a</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">popcount</span><span class="ss">(</span><span class="nv">a</span><span class="ss">)</span><span class="c1">; }</span>
<span class="w">    </span><span class="nv">movzx</span><span class="w">   </span><span class="nv">eax</span>,<span class="w"> </span><span class="nv">di</span><span class="w">      </span>#<span class="w"> </span><span class="nv">note</span><span class="w"> </span><span class="nv">zero</span><span class="o">-</span><span class="nv">extension</span>,<span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">sign</span><span class="o">-</span><span class="nv">extension</span>
<span class="w">    </span><span class="nv">popcnt</span><span class="w">  </span><span class="nv">rax</span>,<span class="w"> </span><span class="nv">rax</span>
<span class="w">    </span><span class="nv">ret</span>

<span class="nv">unsigned</span><span class="w"> </span><span class="nv">test_int</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">a</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">popcount</span><span class="ss">(</span><span class="nv">a</span><span class="ss">)</span><span class="c1">; }</span>
<span class="w">    </span><span class="nv">mov</span><span class="w">     </span><span class="nv">eax</span>,<span class="w"> </span><span class="nv">edi</span>
<span class="w">    </span><span class="nv">popcnt</span><span class="w">  </span><span class="nv">rax</span>,<span class="w"> </span><span class="nv">rax</span><span class="w">        </span>#<span class="w"> </span><span class="nv">unnecessary</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nv">bit</span><span class="w"> </span><span class="nv">operand</span><span class="w"> </span><span class="nv">size</span>
<span class="w">    </span><span class="nv">ret</span>

<span class="nv">unsigned</span><span class="w"> </span><span class="nv">test_u64</span><span class="ss">(</span><span class="nv">unsigned</span><span class="w"> </span><span class="nv">long</span><span class="w"> </span><span class="nv">long</span><span class="w"> </span><span class="nv">a</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">popcount</span><span class="ss">(</span><span class="nv">a</span><span class="ss">)</span><span class="c1">; }</span>
<span class="w">    </span><span class="nv">xor</span><span class="w">     </span><span class="nv">eax</span>,<span class="w"> </span><span class="nv">eax</span><span class="w">     </span>#<span class="w"> </span><span class="nv">gcc</span><span class="w"> </span><span class="nv">avoids</span><span class="w"> </span><span class="nv">false</span><span class="w"> </span><span class="nv">dependencies</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">Intel</span><span class="w"> </span><span class="nv">CPUs</span>
<span class="w">    </span><span class="nv">popcnt</span><span class="w">  </span><span class="nv">rax</span>,<span class="w"> </span><span class="nv">rdi</span>
<span class="w">    </span><span class="nv">ret</span>
</pre></div>

<p>PowerPC64 <code>gcc -O3 -std=gnu++11</code> emits (for the <code>int</code> arg version):</p>
<div class="code"><pre class="code literal-block">    rldicl 3,3,0,32     # zero-extend from 32 to 64-bit
    popcntd 3,3         # popcount
    blr
</pre></div>

<p>This source isn't x86-specific or GNU-specific at all, but only compiles well
with gcc/clang/icc, at least when targeting x86 (including x86-64).</p>
<p>Also note that gcc's fallback for architectures without single-instruction
popcount is a byte-at-a-time table lookup. This isn't wonderful for ARM, for
example.</p>
<h3>C++20 has <code>std::popcount(T)</code>
</h3>
<p>Current libstdc++ headers unfortunately define it with a special case
<code>if(x==0) return 0;</code> at the start, which clang doesn't optimize away when
compiling for x86:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bit&gt;</span>
<span class="kr">int</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kr">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">popcount</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>clang 11.0.1 <code>-O3 -std=gnu++20 -march=nehalem</code> (https://godbolt.org/z/arMe5a)</p>
<div class="code"><pre class="code literal-block"><span class="err">#</span><span class="w"> </span><span class="n">clang</span><span class="w"> </span><span class="mi">11</span>
<span class="w">    </span><span class="n">bar</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span><span class="err">:</span><span class="w">                                </span><span class="err">#</span><span class="w"> </span><span class="nv">@bar</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span>
<span class="w">        </span><span class="n">popcnt</span><span class="w">  </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span>
<span class="w">        </span><span class="n">cmove</span><span class="w">   </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="w">         </span><span class="err">#</span><span class="w"> </span><span class="nl">redundant</span><span class="p">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">popcnt</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">instead</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">popcnt</span><span class="o">-</span><span class="n">generated</span><span class="w"> </span><span class="mf">0.</span><span class="p">..</span>
<span class="w">        </span><span class="n">ret</span>
</pre></div>

<p>But GCC compiles nicely:</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">gcc</span><span class="w"> </span><span class="mi">10</span>
<span class="w">        </span><span class="nv">xor</span><span class="w">     </span><span class="nv">eax</span>,<span class="w"> </span><span class="nv">eax</span><span class="w">         </span>#<span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nv">false</span><span class="w"> </span><span class="nv">dependency</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">Intel</span><span class="w"> </span><span class="nv">SnB</span><span class="o">-</span><span class="nv">family</span><span class="w"> </span><span class="nv">before</span><span class="w"> </span><span class="nv">Ice</span><span class="w"> </span><span class="nv">Lake</span>.
<span class="w">        </span><span class="nv">popcnt</span><span class="w">  </span><span class="nv">eax</span>,<span class="w"> </span><span class="nv">edi</span>
<span class="w">        </span><span class="nv">ret</span>
</pre></div>

<p>Even MSVC does well with it, as long as you use <code>-arch:AVX</code> or later (and
enable C++20 with <code>-std:c++latest</code>). https://godbolt.org/z/7K4Gef</p>
<div class="code"><pre class="code literal-block"><span class="n">int</span> <span class="n">bar</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">)</span> <span class="n">PROC</span>                                 <span class="p">;</span> <span class="n">bar</span><span class="p">,</span> <span class="n">COMDAT</span>
        <span class="n">popcnt</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="n">ret</span>     <span class="mi">0</span>
<span class="n">int</span> <span class="n">bar</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">)</span> <span class="n">ENDP</span>                                 <span class="p">;</span> <span class="n">bar</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-pass-a-parameter-to-a-settimeout-callback/" class="u-url">How can I pass a parameter to a setTimeout() callback?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-pass-a-parameter-to-a-settimeout-callback/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:57:40+08:00" itemprop="datePublished" title="2023-02-17 07:57">2023-02-17 07:57</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have some JavaScript code that looks like:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="nf">statechangedPostQuestion</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="n">alert</span><span class="p">(</span><span class="s">"statechangedPostQuestion"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xmlhttp</span><span class="p">.</span><span class="n">readyState</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nb">var</span><span class="w"> </span><span class="n">topicId</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">xmlhttp</span><span class="p">.</span><span class="n">responseText</span><span class="p">;</span>
<span class="w">    </span><span class="n">setTimeout</span><span class="p">(</span><span class="s">"postinsql(topicId)"</span><span class="p">,</span><span class="mi">4000</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">function</span><span class="w"> </span><span class="nf">postinsql</span><span class="p">(</span>topicId<span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="n">alert</span><span class="p">(</span><span class="n">topicId</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>I get an error that <code>topicId</code> is not defined Everything was working before I
used the <code>setTimeout()</code> function.</p>
<p>I want my <code>postinsql(topicId)</code> function to be called after some time. What
should I do?</p>
<p><br><br></p>
<h2>Answer</h2>
<div class="code"><pre class="code literal-block">setTimeout(function() {
    postinsql(topicId);
}, 4000)
</pre></div>

<p>You need to feed an anonymous function as a parameter instead of a string, the
latter method shouldn't even work per the ECMAScript specification but
browsers are just lenient. This is the proper solution, don't ever rely on
passing a string as a 'function' when using <code>setTimeout()</code> or <code>setInterval()</code>,
it's slower because it has to be evaluated and it just isn't right.</p>
<h3>UPDATE:</h3>
<p>As Hobblin said in his comments to the question, now you can pass arguments to
the function inside setTimeout using <code>Function.prototype.bind()</code>.</p>
<p><strong>Example:</strong></p>
<div class="code"><pre class="code literal-block">setTimeout(postinsql.bind(null, topicId), 4000);
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>In modern browsers (ie IE11 and beyond), the "setTimeout" receives a third
parameter that is sent as parameter to the internal function at the end of the
timer.</p>
<p>Example:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Hello World"</span><span class="p">;</span>
<span class="n">setTimeout</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="n">hello</span><span class="p">);</span>
</pre></div>

<p>More details:</p>
<ul>
<li>https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout</li>
<li>http://arguments.callee.info/2008/11/10/passing-arguments-to-settimeout-and-setinterval/</li>
</ul>
</div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-483.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-481.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
