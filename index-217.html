<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 217) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-217.html">
<link rel="prev" href="index-218.html" type="text/html">
<link rel="next" href="index-216.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-uitableview-zhong-shi-yong-zi-dong-bu-ju-shi-xian-dong-tai-dan-yuan-ge-bu-ju-he-ke-bian-xing-gao/" class="u-url">在 UITableView 中使用自动布局实现动态单元格布局和可变行高</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-uitableview-zhong-shi-yong-zi-dong-bu-ju-shi-xian-dong-tai-dan-yuan-ge-bu-ju-he-ke-bian-xing-gao/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T01:14:57+08:00" itemprop="datePublished" title="2023-02-17 01:14">2023-02-17 01:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何<code>UITableViewCell</code>在表视图中使用 s 内的自动布局让每个单元格的内容和子视图确定行高（本身/自动），同时保持平滑的滚动性能？</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>TL;DR：</strong> 不喜欢阅读？直接跳转到 GitHub 上的示例项目：</p>
<ul>
<li>iOS 8 示例项目- 需要 iOS 8</li>
<li>iOS 7 示例项目- 适用于 iOS 7+</li>
</ul>
<h2>概念描述</h2>
<p>无论您开发的是哪个 iOS 版本，下面的前 2 个步骤都适用。</p>
<h3>1. 设置和添加约束</h3>
<p>在您的<code>UITableViewCell</code>子类中，添加约束，以便单元格的子视图的边缘固定到单元格的 <strong>contentView</strong>
的边缘（最重要的是顶部和底部边缘）。 <strong>注意：不要将子视图固定到单元格本身；
只到细胞的<code>contentView</code>！</strong>让这些子视图的固有内容大小驱动表格视图单元格内容视图的高度，方法是确保每个子视图的垂直维度中的 <em>内容压缩阻力</em>
和 <em>内容拥抱</em> 约束不会被您添加的更高优先级约束覆盖。（嗯？点击这里。）</p>
<p>请记住，这个想法是让单元格的子视图垂直连接到单元格的内容视图，以便它们可以“施加压力”并使内容视图扩展以适合它们。使用带有几个子视图的示例单元格，这里是
<strong>一些</strong> <em>（不是全部！）</em> 约束的可视化图示：</p>
<p><img alt="表视图单元格约束的示例说明。" src="images/CTUPi.png"></p>
<p>您可以想象，随着更多文本被添加到上面示例单元格中的多行正文标签，它需要垂直增长以适应文本，这将有效地迫使单元格增加高度。（当然，您需要正确设置约束才能使其正常工作！）</p>
<p>正确设置约束绝对是使用自动布局获得动态单元格高度 <strong>最困难和最重要的部分。</strong>
如果你在这里犯了一个错误，它可能会阻止其他一切工作——所以慢慢来！我建议在代码中设置约束，因为您确切地知道在何处添加了哪些约束，并且在出现问题时更容易调试。在代码中添加约束与使用布局锚点或
GitHub 上提供的出色开源 API 之一的 Interface Builder 一样简单，而且功能强大得多。</p>
<ul>
<li>
<code>updateConstraints</code>如果您在代码中添加约束，您应该在UITableViewCell 子类的方法中执行一次。请注意，<code>updateConstraints</code>可能会多次调用，因此为避免多次添加相同的约束，请确保将添加约束的代码包装在检查<code>updateConstraints</code>布尔属性中，例如<code>didSetupConstraints</code>（在运行约束后将其设置为 YES - 添加代码一次）。另一方面，如果您有更新现有约束的代码（例如调整<code>constant</code>某些约束的属性），请将它放在<code>updateConstraints</code>检查之外但在检查之外<code>didSetupConstraints</code>，这样它就可以在每次调用该方法时运行。</li>
</ul>
<h3>2. 确定唯一的表视图单元格重用标识符</h3>
<p>对于单元格中的每组唯一约束，使用唯一的单元格重用标识符。换句话说，如果您的单元格有多个独特的布局，每个独特的布局都应该有自己的重用标识符。（当您的单元格变体具有不同数量的子视图，或者子视图以不同的方式排列时，您需要使用新的重用标识符的一个很好的提示。）</p>
<p>例如，如果您在每个单元格中显示一封电子邮件，您可能有 4
种独特的布局：只有一个主题的邮件、有一个主题和正文的邮件、有一个主题和一个照片附件的邮件，以及有一个主题的邮件，身体和照片附件。每个布局都有实现它所需的完全不同的约束，因此一旦初始化单元格并为这些单元格类型之一添加约束，单元格应该获得特定于该单元格类型的唯一重用标识符。这意味着当您将一个单元格出队以供重用时，约束已经添加并准备好用于该单元格类型。</p>
<p>请注意，由于内在内容大小的差异，具有相同约束（类型）的单元格可能仍具有不同的高度！由于内容大小不同，不要将根本不同的布局（不同的约束）与不同的计算视图框架（从相同的约束解决）混淆。</p>
<ul>
<li>不要将具有完全不同约束集的单元格添加到同一个重用池（即使用相同的重用标识符），然后在每次出列后尝试删除旧约束并从头开始设置新约束。内部的自动布局引擎不是为处理大规模的约束变化而设计的，你会看到大量的性能问题。</li>
</ul>
<h3>对于 iOS 8 - 自调整单元格</h3>
<h4>3.启用行高估计</h4>
<blockquote>
<p>要启用自适应表格视图单元格，您必须将表格视图的 rowHeight 属性设置为 UITableViewAutomaticDimension。您还必须为
estimatedRowHeight 属性分配一个值。一旦设置了这两个属性，系统就会使用自动布局来计算行的实际高度</p>
<p>Apple：使用自动调整大小的表格视图单元格</p>
</blockquote>
<p>在 iOS 8 中，Apple 已经内化了很多以前必须由你在 iOS 8
之前实现的工作。为了让自调整单元格机制起作用，你必须首先将表视图上的属性设置为<code>rowHeight</code>常量<code>UITableView.automaticDimension</code>.
然后，您只需要通过将表视图的<code>estimatedRowHeight</code>属性设置为非零值来启用行高估计，例如：</p>
<div class="code"><pre class="code literal-block">self.tableView.rowHeight = UITableView.automaticDimension;
self.tableView.estimatedRowHeight = 44.0; // set to whatever your "average" cell height is
</pre></div>

<p>这样做是为表格视图提供一个临时估计/占位符，用于尚未显示在屏幕上的单元格的行高。然后，当这些单元格即将在屏幕上滚动时，将计算实际的行高。为了确定每一行的实际高度，表格视图会<code>contentView</code>根据内容视图的已知固定宽度自动询问每个单元格需要的高度（基于表格视图的宽度，减去任何其他内容，如部分索引或附件视图）以及您添加到单元格的内容视图和子视图的自动布局约束。一旦确定了这个实际的单元格高度，该行的旧估计高度就会更新为新的实际高度（并且根据需要对表格视图的
contentSize/contentOffset 进行任何调整）。</p>
<p>一般来说，您提供的估计不必非常准确——它仅用于正确调整表视图中滚动指示器的大小，并且表视图可以很好地调整滚动指示器以防止您估计不正确在屏幕上滚动单元格。您应该将<code>estimatedRowHeight</code>表视图（in<code>viewDidLoad</code>或类似）上的属性设置为一个常量值，即“平均”行高。
<em>只有当您的行高具有极大的可变性（例如相差一个数量级）并且您注意到滚动指示器在滚动时“跳跃”时，您才应该费心实施以执行为每行返回更准确的估计所需的最小计算<code>tableView:estimatedHeightForRowAtIndexPath:</code>。</em></p>
<h3>对于 iOS 7 支持（自己实现自动调整单元格大小）</h3>
<h4>3. 做一次 Layout Pass &amp; 获取 Cell Height</h4>
<p>首先，实例化一个 table view cell 的屏幕外实例， <em>每个 reuse identifier 一个实例</em>
，严格用于高度计算。（离屏意味着单元格引用存储在视图控制器上的属性/ivar
中，并且永远不会返回<code>tableView:cellForRowAtIndexPath:</code>表视图以实际呈现在屏幕上。）接下来，必须使用确切的内容（例如文本、图像等）配置单元格如果它要显示在表视图中，它将保持不变。</p>
<p>然后，强制单元格立即布局其子视图，然后使用<code>systemLayoutSizeFittingSize:</code>上的方法<code>UITableViewCell</code>找出<code>contentView</code>单元格所需的高度是多少。用于<code>UILayoutFittingCompressedSize</code>获取适合单元格所有内容所需的最小尺寸。然后可以从委托方法返回高度<code>tableView:heightForRowAtIndexPath:</code>。</p>
<h4>4.使用估计的行高</h4>
<p>如果你的表视图中有超过几十行，你会发现在第一次加载表视图时执行自动布局约束求解会很快使主线程陷入困境，因为在第一次加载时对每一行调用<code>tableView:heightForRowAtIndexPath:</code>（以便计算滚动指示器的大小）。</p>
<p>从 iOS 7
开始，您可以（并且绝对应该）<code>estimatedRowHeight</code>在表格视图上使用该属性。这样做是为表格视图提供一个临时估计/占位符，用于尚未显示在屏幕上的单元格的行高。然后，当这些单元格即将在屏幕上滚动时，将计算实际行高（通过调用<code>tableView:heightForRowAtIndexPath:</code>），并将估计高度更新为实际高度。</p>
<p>一般来说，您提供的估计不必非常准确——它仅用于正确调整表视图中滚动指示器的大小，并且表视图可以很好地调整滚动指示器以防止您估计不正确在屏幕上滚动单元格。您应该将<code>estimatedRowHeight</code>表视图（in<code>viewDidLoad</code>或类似）上的属性设置为一个常量值，即“平均”行高。
<em>只有当您的行高具有极大的可变性（例如相差一个数量级）并且您注意到滚动指示器在滚动时“跳跃”时，您才应该费心实施以执行为每行返回更准确的估计所需的最小计算<code>tableView:estimatedHeightForRowAtIndexPath:</code>。</em></p>
<h4>5.（如果需要）添加行高缓存</h4>
<p>如果您已完成上述所有操作，但仍然发现在执行
中的约束求解时性能慢得令人无法接受<code>tableView:heightForRowAtIndexPath:</code>，那么很遗憾，您将需要为单元格高度实施一些缓存。（这是
Apple 工程师建议的方法。） 总体思路是让 Autolayout
引擎在第一时间解决约束，然后缓存该单元格的计算高度，并将缓存值用于该单元格高度的所有未来请求。当然，诀窍是确保在发生任何可能导致单元格高度改变的事情时清除单元格的缓存高度——主要是当单元格的内容改变或其他重要事件发生时（比如用户调整动态类型文本大小滑块）。</p>
<h4>iOS 7 通用示例代码（有很多有趣的评论）</h4>
<div class="code"><pre class="code literal-block"><span class="p">-</span> <span class="p">(</span><span class="bp">UITableViewCell</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span><span class="w"> </span><span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Determine which reuse identifier should be used for the cell at this </span>
<span class="w">    </span><span class="c1">// index path, depending on the particular layout required (you may have</span>
<span class="w">    </span><span class="c1">// just one, or may have many).</span>
<span class="w">    </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">reuseIdentifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="w">    </span><span class="c1">// Dequeue a cell for the reuse identifier.</span>
<span class="w">    </span><span class="c1">// Note that this method will init and return a new cell if there isn't</span>
<span class="w">    </span><span class="c1">// one available in the reuse pool, so either way after this line of </span>
<span class="w">    </span><span class="c1">// code you will have a cell with the correct constraints ready to go.</span>
<span class="w">    </span><span class="bp">UITableViewCell</span><span class="w"> </span><span class="o">*</span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">tableView</span><span class="w"> </span><span class="n">dequeueReusableCellWithIdentifier</span><span class="o">:</span><span class="n">reuseIdentifier</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Configure the cell with content for the given indexPath, for example:</span>
<span class="w">    </span><span class="c1">// cell.textLabel.text = someTextForThisCell;</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// Make sure the constraints have been set up for this cell, since it </span>
<span class="w">    </span><span class="c1">// may have just been created from scratch. Use the following lines, </span>
<span class="w">    </span><span class="c1">// assuming you are setting up constraints from within the cell's </span>
<span class="w">    </span><span class="c1">// updateConstraints method:</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">setNeedsUpdateConstraints</span><span class="p">];</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">updateConstraintsIfNeeded</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// If you are using multi-line UILabels, don't forget that the </span>
<span class="w">    </span><span class="c1">// preferredMaxLayoutWidth needs to be set correctly. Do it at this </span>
<span class="w">    </span><span class="c1">// point if you are NOT doing it within the UITableViewCell subclass </span>
<span class="w">    </span><span class="c1">// -[layoutSubviews] method. For example: </span>
<span class="w">    </span><span class="c1">// cell.multiLineLabel.preferredMaxLayoutWidth = CGRectGetWidth(tableView.bounds);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span><span class="w"> </span><span class="nf">heightForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Determine which reuse identifier should be used for the cell at this </span>
<span class="w">    </span><span class="c1">// index path.</span>
<span class="w">    </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">reuseIdentifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="w">    </span><span class="c1">// Use a dictionary of offscreen cells to get a cell for the reuse </span>
<span class="w">    </span><span class="c1">// identifier, creating a cell and storing it in the dictionary if one </span>
<span class="w">    </span><span class="c1">// hasn't already been added for the reuse identifier. WARNING: Don't </span>
<span class="w">    </span><span class="c1">// call the table view's dequeueReusableCellWithIdentifier: method here </span>
<span class="w">    </span><span class="c1">// because this will result in a memory leak as the cell is created but </span>
<span class="w">    </span><span class="c1">// never returned from the tableView:cellForRowAtIndexPath: method!</span>
<span class="w">    </span><span class="bp">UITableViewCell</span><span class="w"> </span><span class="o">*</span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">offscreenCells</span><span class="w"> </span><span class="n">objectForKey</span><span class="o">:</span><span class="n">reuseIdentifier</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="n">YourTableViewCellClass</span><span class="w"> </span><span class="n">alloc</span><span class="p">]</span><span class="w"> </span><span class="n">init</span><span class="p">];</span>
<span class="w">        </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">offscreenCells</span><span class="w"> </span><span class="n">setObject</span><span class="o">:</span><span class="n">cell</span><span class="w"> </span><span class="n">forKey</span><span class="o">:</span><span class="n">reuseIdentifier</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Configure the cell with content for the given indexPath, for example:</span>
<span class="w">    </span><span class="c1">// cell.textLabel.text = someTextForThisCell;</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// Make sure the constraints have been set up for this cell, since it </span>
<span class="w">    </span><span class="c1">// may have just been created from scratch. Use the following lines, </span>
<span class="w">    </span><span class="c1">// assuming you are setting up constraints from within the cell's </span>
<span class="w">    </span><span class="c1">// updateConstraints method:</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">setNeedsUpdateConstraints</span><span class="p">];</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">updateConstraintsIfNeeded</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Set the width of the cell to match the width of the table view. This</span>
<span class="w">    </span><span class="c1">// is important so that we'll get the correct cell height for different</span>
<span class="w">    </span><span class="c1">// table view widths if the cell's height depends on its width (due to </span>
<span class="w">    </span><span class="c1">// multi-line UILabels word wrapping, etc). We don't need to do this </span>
<span class="w">    </span><span class="c1">// above in -[tableView:cellForRowAtIndexPath] because it happens </span>
<span class="w">    </span><span class="c1">// automatically when the cell is used in the table view. Also note, </span>
<span class="w">    </span><span class="c1">// the final width of the cell may not be the width of the table view in</span>
<span class="w">    </span><span class="c1">// some cases, for example when a section index is displayed along </span>
<span class="w">    </span><span class="c1">// the right side of the table view. You must account for the reduced </span>
<span class="w">    </span><span class="c1">// cell width.</span>
<span class="w">    </span><span class="n">cell</span><span class="p">.</span><span class="n">bounds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">tableView</span><span class="p">.</span><span class="n">bounds</span><span class="p">),</span><span class="w"> </span><span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">cell</span><span class="p">.</span><span class="n">bounds</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Do the layout pass on the cell, which will calculate the frames for </span>
<span class="w">    </span><span class="c1">// all the views based on the constraints. (Note that you must set the </span>
<span class="w">    </span><span class="c1">// preferredMaxLayoutWidth on multiline UILabels inside the </span>
<span class="w">    </span><span class="c1">// -[layoutSubviews] method of the UITableViewCell subclass, or do it </span>
<span class="w">    </span><span class="c1">// manually at this point before the below 2 lines!)</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">setNeedsLayout</span><span class="p">];</span>
<span class="w">    </span><span class="p">[</span><span class="n">cell</span><span class="w"> </span><span class="n">layoutIfNeeded</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Get the actual height required for the cell's contentView</span>
<span class="w">    </span><span class="n">CGFloat</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">cell</span><span class="p">.</span><span class="n">contentView</span><span class="w"> </span><span class="n">systemLayoutSizeFittingSize</span><span class="o">:</span><span class="n">UILayoutFittingCompressedSize</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Add an extra point to the height to account for the cell separator, </span>
<span class="w">    </span><span class="c1">// which is added between the bottom of the cell's contentView and the </span>
<span class="w">    </span><span class="c1">// bottom of the table view cell.</span>
<span class="w">    </span><span class="n">height</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// NOTE: Set the table view's estimatedRowHeight property instead of </span>
<span class="c1">// implementing the below method, UNLESS you have extreme variability in </span>
<span class="c1">// your row heights and you notice the scroll indicator "jumping" </span>
<span class="c1">// as you scroll.</span>
<span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span><span class="w"> </span><span class="nf">estimatedHeightForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Do the minimal calculations required to be able to return an </span>
<span class="w">    </span><span class="c1">// estimated row height that's within an order of magnitude of the </span>
<span class="w">    </span><span class="c1">// actual height. For example:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">([</span><span class="nb">self</span><span class="w"> </span><span class="n">isTallCellAtIndexPath</span><span class="o">:</span><span class="n">indexPath</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mf">350.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mf">40.0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2>示例项目</h2>
<ul>
<li>iOS 8 示例项目- 需要 iOS 8</li>
<li>iOS 7 示例项目- 适用于 iOS 7+</li>
</ul>
<p>由于表视图单元格在 UILabel 中包含动态内容，这些项目是具有可变行高的表视图的完整工作示例。</p>
<h3>Xamarin (C#/.NET)</h3>
<p>如果您使用的是 Xamarin，请查看由@KentBoogaart整理的这个示例项目。</p>
<p><br></p>
<h3>更多建议</h3>
<p>对于上面的 iOS 8，它真的很简单：</p>
<div class="code"><pre class="code literal-block"><span class="n">override</span><span class="w"> </span><span class="k">func</span><span class="w"> </span><span class="n">viewDidLoad</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="n">super</span><span class="o">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

<span class="w">    </span><span class="bp">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">estimatedRowHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">80</span>
<span class="w">    </span><span class="bp">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="n">rowHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UITableView</span><span class="o">.</span><span class="n">automaticDimension</span>
<span class="p">}</span>
</pre></div>

<p>或者</p>
<div class="code"><pre class="code literal-block"><span class="k">func</span><span class="w"> </span><span class="n">tableView</span><span class="p">(</span><span class="n">tableView</span><span class="p">:</span><span class="w"> </span><span class="n">UITableView</span><span class="p">,</span><span class="w"> </span><span class="n">heightForRowAtIndexPath</span><span class="w"> </span><span class="n">indexPath</span><span class="p">:</span><span class="w"> </span><span class="n">NSIndexPath</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CGFloat</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">UITableView</span><span class="o">.</span><span class="n">automaticDimension</span>
<span class="p">}</span>
</pre></div>

<p>但对于 iOS 7，关键是计算自动布局后的高度：</p>
<div class="code"><pre class="code literal-block"><span class="k">func</span><span class="w"> </span><span class="n">calculateHeightForConfiguredSizingCell</span><span class="p">(</span><span class="n">cell</span><span class="p">:</span><span class="w"> </span><span class="n">GSTableViewCell</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CGFloat</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cell</span><span class="o">.</span><span class="n">setNeedsLayout</span><span class="p">()</span>
<span class="w">    </span><span class="n">cell</span><span class="o">.</span><span class="n">layoutIfNeeded</span><span class="p">()</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="o">.</span><span class="n">contentView</span><span class="o">.</span><span class="n">systemLayoutSizeFittingSize</span><span class="p">(</span><span class="n">UILayoutFittingExpandedSize</span><span class="p">)</span><span class="o">.</span><span class="n">height</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">height</span>
<span class="p">}</span>
</pre></div>

<p><strong>重要的</strong></p>
<ul>
<li>
<p>如果多行标签，不要忘记设置<code>numberOfLines</code>为<code>0</code>。</p>
</li>
<li>
<p>别忘了<code>label.preferredMaxLayoutWidth = CGRectGetWidth(tableView.bounds)</code></p>
</li>
</ul>
<p>完整的示例代码在这里。</p>
<p><br><br><a href="posts/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-variable-row-heights/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wei-shi-yao-wo-men-xu-yao-c-zhong-de-xu-han-shu/" class="u-url">为什么我们需要 C++ 中的虚函数？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wei-shi-yao-wo-men-xu-yao-c-zhong-de-xu-han-shu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T01:14:24+08:00" itemprop="datePublished" title="2023-02-17 01:14">2023-02-17 01:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在学习 C++，并且刚刚开始学习虚函数。</p>
<p>根据我所读的内容（在书中和网上），虚函数是基类中的函数，您可以在派生类中覆盖这些函数。</p>
<p>但在本书的前面，当学习基本继承时，我能够在不使用<code>virtual</code>.</p>
<p>那我在这里错过了什么？我知道虚函数还有更多内容，而且它似乎很重要，所以我想弄清楚它到底是什么。我只是在网上找不到直接的答案。</p>
<p><br><br></p>
<h2>解答</h2>
<p>没有“虚拟”，您将获得“早期绑定”。使用哪个方法的实现在编译时根据您调用的指针类型决定。</p>
<p>使用“虚拟”，您将获得“后期绑定”。使用哪个方法的实现是在运行时根据指向对象的类型决定的——它最初被构造成什么。根据指向该对象的指针类型，这不一定是您所想的。</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Base</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">            </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method1</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Base::Method1"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method2</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Base::Method2"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Base</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method1</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Derived::Method1"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="w">    </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method2</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Derived::Method2"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Note</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">constructed</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Derived</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Base</span><span class="o">*</span>

<span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">Method1</span><span class="w"> </span><span class="p">();</span><span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Prints</span><span class="w"> </span><span class="s2">"Base::Method1"</span>
<span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">Method2</span><span class="w"> </span><span class="p">();</span><span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Prints</span><span class="w"> </span><span class="s2">"Derived::Method2"</span>
</pre></div>

<p><strong>编辑</strong> -看到这个问题。</p>
<p>此外 -本教程涵盖了 C++ 中的早期和晚期绑定。</p>
<p><br></p>
<h3>更多建议</h3>
<p>没有“虚拟”，您将获得“早期绑定”。使用哪个方法的实现在编译时根据您调用的指针类型决定。</p>
<p>使用“虚拟”，您将获得“后期绑定”。使用哪个方法的实现是在运行时根据指向对象的类型决定的——它最初被构造成什么。根据指向该对象的指针类型，这不一定是您所想的。</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Base</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">            </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method1</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Base::Method1"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method2</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Base::Method2"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Base</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method1</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Derived::Method1"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="w">    </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Method2</span><span class="w"> </span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w">  </span><span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">"Derived::Method2"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Note</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">constructed</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Derived</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Base</span><span class="o">*</span>

<span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">Method1</span><span class="w"> </span><span class="p">();</span><span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Prints</span><span class="w"> </span><span class="s2">"Base::Method1"</span>
<span class="n">basePtr</span><span class="o">-&gt;</span><span class="n">Method2</span><span class="w"> </span><span class="p">();</span><span class="w">  </span><span class="o">//</span><span class="w">  </span><span class="n">Prints</span><span class="w"> </span><span class="s2">"Derived::Method2"</span>
</pre></div>

<p><strong>编辑</strong> -看到这个问题。</p>
<p>此外 -本教程涵盖了 C++ 中的早期和晚期绑定。</p>
<p><br><br><a href="posts/why-do-we-need-virtual-functions-in-c/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-python-zhong-fan-zhuan-zi-fu-chuan/" class="u-url">如何在 Python 中反转字符串？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-python-zhong-fan-zhuan-zi-fu-chuan/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T01:13:56+08:00" itemprop="datePublished" title="2023-02-17 01:13">2023-02-17 01:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>reverse</code>Python 的对象没有内置函数<code>str</code>。实施此方法的最佳方式是什么？</p>
<p>如果提供非常简洁的答案，请详细说明其效率。例如，<code>str</code>对象是否转换为不同的对象等。</p>
<p><br><br></p>
<h2>解答</h2>
<p>使用切片：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">'hello world'</span><span class="p">[</span><span class="o">::-</span><span class="mi">1</span><span class="p">]</span>
<span class="s s-Atom">'dlrow olleh'</span>
</pre></div>

<hr>
<p>切片符号采用<code>[start:stop:step]</code>. 在这种情况下，我们省略了<code>start</code>和<code>stop</code>位置，因为我们需要整个字符串。我们还使用<code>step
= -1</code>, 表示“从右到左重复步进 1 个字符”。</p>
<p><br></p>
<h3>更多建议</h3>
<p>@Paolo<code>s[::-1]</code>最快；一种较慢的方法（可能更具可读性，但值得商榷）是<code>''.join(reversed(s))</code>.</p>
<p><br><br><a href="posts/how-do-i-reverse-a-string-in-python/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-218.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-216.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
