<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 9) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-9.html">
<link rel="prev" href="index-10.html" type="text/html">
<link rel="next" href="index-8.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wei-shi-yao-jian-qu-zhe-liang-ci-1927-nian-hui-de-dao-yi-ge-qi-guai-de-jie-guo/" class="u-url">为什么减去这两次（1927 年）会得到一个奇怪的结果？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wei-shi-yao-jian-qu-zhe-liang-ci-1927-nian-hui-de-dao-yi-ge-qi-guai-de-jie-guo/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:26:33+08:00" itemprop="datePublished" title="2023-02-16 18:26">2023-02-16 18:26</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如果我运行以下程序，它解析两个引用时间间隔为 1 秒的日期字符串并进行比较：</p>
<div class="code"><pre class="code literal-block"><span class="nt">public</span><span class="w"> </span><span class="nt">static</span><span class="w"> </span><span class="nt">void</span><span class="w"> </span><span class="nt">main</span><span class="o">(</span><span class="nt">String</span><span class="cp">[]</span><span class="w"> </span><span class="nt">args</span><span class="o">)</span><span class="w"> </span><span class="nt">throws</span><span class="w"> </span><span class="nt">ParseException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">SimpleDateFormat</span><span class="w"> </span><span class="err">sf</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">SimpleDateFormat("yyyy-MM-dd</span><span class="w"> </span><span class="n">HH</span><span class="p">:</span><span class="n">mm</span><span class="o">:</span><span class="n">ss</span><span class="s2">");  </span>
<span class="s2">    String str3 = "</span><span class="mi">1927-12-31</span><span class="w"> </span><span class="mi">23</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">07</span><span class="s2">";  </span>
<span class="s2">    String str4 = "</span><span class="mi">1927-12-31</span><span class="w"> </span><span class="mi">23</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mi">08</span><span class="err">"</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="err">Date</span><span class="w"> </span><span class="err">sDt3</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">sf.parse(str3)</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="err">Date</span><span class="w"> </span><span class="err">sDt4</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">sf.parse(str4)</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="err">long</span><span class="w"> </span><span class="err">ld3</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">sDt3.getTime()</span><span class="w"> </span><span class="err">/1000</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="err">long</span><span class="w"> </span><span class="err">ld4</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">sDt4.getTime()</span><span class="w"> </span><span class="err">/1000</span><span class="p">;</span>
<span class="w">    </span><span class="err">System.out.println(ld4-ld3)</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p><strong>输出是：</strong></p>
<div class="code"><pre class="code literal-block"><span class="mf">353</span>
</pre></div>

<p>为什么是<code>ld4-ld3</code>，而不是<code>1</code>（正如我从时间上的一秒差异所期望的那样），而是<code>353</code>？</p>
<p>如果我将日期更改为 1 秒后的时间：</p>
<div class="code"><pre class="code literal-block"><span class="nt">String</span><span class="w"> </span><span class="nt">str3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"1927-12-31 23:54:08"</span><span class="o">;</span><span class="w">  </span>
<span class="nt">String</span><span class="w"> </span><span class="nt">str4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"1927-12-31 23:54:09"</span><span class="o">;</span>
</pre></div>

<p>然后<code>ld4-ld3</code>会<code>1</code>。</p>
<hr>
<p><strong>Java 版本：</strong></p>
<div class="code"><pre class="code literal-block">java version "1.6.0_22"
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Dynamic Code Evolution Client VM (build 0.2-b02-internal, 19.0-b04-internal, mixed mode)



Timezone(`TimeZone.getDefault()`):

sun.util.calendar.ZoneInfo[id="Asia/Shanghai",
offset=28800000,dstSavings=0,
useDaylight=false,
transitions=19,
lastRule=null]

Locale(Locale.getDefault()): zh_CN
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>12 月 31 日在上海时区发生变化。</p>
<p>有关 1927 年上海的详细信息，请参阅此页面。基本上在1927年底的午夜，时钟倒退了5分52秒。所以“1927-12-31
23:54:08”实际上发生了两次，看起来 Java 正在将其解析为该本地日期/时间的 <em>稍后</em> 可能时刻 - 因此存在差异。</p>
<p>时区世界中时常奇怪而奇妙的世界的又一集。</p>
<p><strong>编辑：</strong> 停止按下！历史改变...</p>
<p>如果使用TZDB的 2013a 版重建，原始问题将不再表现出完全相同的行为。在 2013a 中，结果为 358 秒，过渡时间为 23:54:03 而不是
23:54:08。</p>
<p>我只是注意到这一点，因为我在 Noda Time 中以单元测试的形式收集这样的问题......测试现在已经改变，但它只是表明 - 甚至历史数据也不安全。</p>
<p><strong>编辑：</strong> 历史再次改变......</p>
<p>在 TZDB 2014f 中，更改时间已移动到 1900-12-31，现在只有 343 秒的更改（所以 和 之间的时间<code>t</code>是<code>t+1</code>344
秒，如果你明白我的意思）。</p>
<p><strong>编辑：</strong> 要回答有关 1900 年过渡的问题......看起来 Java 时区实现将 <em>所有</em> 时区视为在 1900 UTC
开始之前的任何时刻都处于标准时间：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">java.util.TimeZone</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span> <span class="p">{</span>
        <span class="n">long</span> <span class="n">startOf1900Utc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2208988800000</span><span class="n">L</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">String</span> <span class="nb">id</span> <span class="p">:</span> <span class="n">TimeZone</span><span class="o">.</span><span class="n">getAvailableIDs</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">TimeZone</span> <span class="n">zone</span> <span class="o">=</span> <span class="n">TimeZone</span><span class="o">.</span><span class="n">getTimeZone</span><span class="p">(</span><span class="nb">id</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="o">.</span><span class="n">getRawOffset</span><span class="p">()</span> <span class="o">!=</span> <span class="n">zone</span><span class="o">.</span><span class="n">getOffset</span><span class="p">(</span><span class="n">startOf1900Utc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="nb">id</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>上面的代码在我的 Windows 机器上没有产生任何输出。因此，任何时区在 1900 年初的标准偏移量以外的任何偏移量都将被视为过渡。TZDB
本身有一些比这更早的数据，并且不依赖于任何“固定”标准时间的想法（这是一个<code>getRawOffset</code>有效的概念），因此其他库不需要引入这种人为的转换。</p>
<p><br></p>
<h3>更多建议</h3>
<p>您遇到了当地时间不连续性：</p>
<blockquote>
<p>当当地标准时间即将到达 1928 年 1 月 1 日星期日时，00:00:00 时钟向后拨动 0:05:52 时至 1927 年 12 月 31
日星期六，23:54:08 改为当地标准时间</p>
</blockquote>
<p>这并不是特别奇怪，并且随着时区因政治或行政行为而切换或更改，几乎在任何地方都曾发生过。</p>
<p><br><br><a href="posts/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-jiang-git-cun-chu-ku-hui-fu-wei-zhi-qian-de-ti-jiao/" class="u-url">如何将 Git 存储库恢复为之前的提交？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-jiang-git-cun-chu-ku-hui-fu-wei-zhi-qian-de-ti-jiao/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:24:53+08:00" itemprop="datePublished" title="2023-02-16 18:24">2023-02-16 18:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>如何从当前状态恢复到某个提交时创建的快照？</p>
<p>如果我这样做<code>git log</code>，那么我会得到以下输出：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>log
commit<span class="w"> </span>a867b4af366350be2e7c21b8de9cc6504678a61b<span class="sb">`</span>
Author:<span class="w"> </span>Me<span class="w"> </span>&lt;me@me.com&gt;
Date:<span class="w">   </span>Thu<span class="w"> </span>Nov<span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">18</span>:59:41<span class="w"> </span><span class="m">2010</span><span class="w"> </span>-0400

blah<span class="w"> </span>blah<span class="w"> </span>blah...

commit<span class="w"> </span>25eee4caef46ae64aa08e8ab3f988bc917ee1ce4
Author:<span class="w"> </span>Me<span class="w"> </span>&lt;me@me.com&gt;
Date:<span class="w">   </span>Thu<span class="w"> </span>Nov<span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">05</span>:13:39<span class="w"> </span><span class="m">2010</span><span class="w"> </span>-0400

more<span class="w"> </span>blah<span class="w"> </span>blah<span class="w"> </span>blah...

commit<span class="w"> </span>0766c053c0ea2035e90f504928f8df3c9363b8bd
Author:<span class="w"> </span>Me<span class="w"> </span>&lt;me@me.com&gt;
Date:<span class="w">   </span>Thu<span class="w"> </span>Nov<span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="m">00</span>:55:06<span class="w"> </span><span class="m">2010</span><span class="w"> </span>-0400

And<span class="w"> </span>yet<span class="w"> </span>more<span class="w"> </span>blah<span class="w"> </span>blah...

commit<span class="w"> </span>0d1d7fc32e5a947fbd92ee598033d85bfc445a50
Author:<span class="w"> </span>Me<span class="w"> </span>&lt;me@me.com&gt;
Date:<span class="w">   </span>Wed<span class="w"> </span>Nov<span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">23</span>:56:08<span class="w"> </span><span class="m">2010</span><span class="w"> </span>-0400

Yep,<span class="w"> </span>more<span class="w"> </span>blah<span class="w"> </span>blah.
</pre></div>

<p>如何恢复到 11 月 3 日的提交，即 commit <code>0d1d7fc</code>？</p>
<p><br><br></p>
<h2>解答</h2>
<p>这在很大程度上取决于您所说的“还原”是什么意思。</p>
<h3>暂时切换到不同的提交</h3>
<p>如果你想暂时回到它，四处游荡，然后回到你所在的地方，你所要做的就是检查所需的提交：</p>
<div class="code"><pre class="code literal-block"># This will detach your HEAD, that is, leave you with no branch checked out:
git checkout 0d1d7fc32
</pre></div>

<p>或者，如果您想在那里进行提交，请继续并在您进行时创建一个新分支：</p>
<div class="code"><pre class="code literal-block">git checkout -b old-state 0d1d7fc32
</pre></div>

<p>要回到原来的位置，只需再次检查您所在的分支即可。（如果您进行了更改，就像切换分支时一样，您必须适当地处理它们。您可以重置以丢弃它们；您可以
stash、checkout、stash pop 将它们带走；您可以提交如果你想要那里的分支机构，他们会去那里的分支机构。）</p>
<h3>硬删除未发布的提交</h3>
<p>另一方面，如果你真的想摆脱从那以后所做的一切，有两种可能性。第一，如果您还没有发布任何这些提交，只需重置：</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">This</span><span class="w"> </span><span class="nv">will</span><span class="w"> </span><span class="nv">destroy</span><span class="w"> </span><span class="nv">any</span><span class="w"> </span><span class="nv">local</span><span class="w"> </span><span class="nv">modifications</span>.
#<span class="w"> </span><span class="nv">Don</span><span class="err">'t do it if you have uncommitted work you want to keep.</span>
<span class="err">git reset --hard 0d1d7fc32</span>

#<span class="w"> </span><span class="nv">Alternatively</span>,<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">there</span><span class="err">'s work to keep:</span>
<span class="err">git stash</span>
<span class="err">git reset --hard 0d1d7fc32</span>
<span class="err">git stash pop</span>
<span class="err"># This saves the modifications, then reapplies that patch after resetting.</span>
#<span class="w"> </span><span class="nv">You</span><span class="w"> </span><span class="nv">could</span><span class="w"> </span><span class="nv">get</span><span class="w"> </span><span class="nv">merge</span><span class="w"> </span><span class="nv">conflicts</span>,<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">you</span><span class="err">'ve modified things which were</span>
<span class="err"># changed since the commit you reset to.</span>
</pre></div>

<p>如果你搞砸了，你已经放弃了你的本地更改，但你至少可以通过再次重置回到你之前的状态。</p>
<h3>使用新提交撤消已发布的提交</h3>
<p>另一方面，如果您已经发布了作品，您可能不想重置分支，因为这实际上是在重写历史。在那种情况下，您确实可以还原提交。对于
Git，还原有一个非常具体的含义：创建一个带有反向补丁的提交以将其取消。这样你就不会重写任何历史。</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">This</span><span class="w"> </span><span class="nv">will</span><span class="w"> </span><span class="nv">create</span><span class="w"> </span><span class="nv">three</span><span class="w"> </span><span class="nv">separate</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="nv">commits</span>:
<span class="nv">git</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="nv">a867b4af</span><span class="w"> </span><span class="mi">25</span><span class="nv">eee4ca</span><span class="w"> </span><span class="mi">0766</span><span class="nv">c053</span>

#<span class="w"> </span><span class="nv">It</span><span class="w"> </span><span class="nv">also</span><span class="w"> </span><span class="nv">takes</span><span class="w"> </span><span class="nv">ranges</span>.<span class="w"> </span><span class="nv">This</span><span class="w"> </span><span class="nv">will</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">last</span><span class="w"> </span><span class="nv">two</span><span class="w"> </span><span class="nv">commits</span>:
<span class="nv">git</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="nv">HEAD</span><span class="o">~</span><span class="mi">2</span>..<span class="nv">HEAD</span>

#<span class="nv">Similarly</span>,<span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">can</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">range</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">commits</span><span class="w"> </span><span class="nv">using</span><span class="w"> </span><span class="nv">commit</span><span class="w"> </span><span class="nv">hashes</span><span class="w"> </span><span class="ss">(</span><span class="nv">non</span><span class="w"> </span><span class="nv">inclusive</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">hash</span><span class="ss">)</span>:
<span class="nv">git</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="mi">0</span><span class="nv">d1d7fc</span>..<span class="nv">a867b4a</span>

#<span class="w"> </span><span class="nv">Reverting</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">merge</span><span class="w"> </span><span class="nv">commit</span>
<span class="nv">git</span><span class="w"> </span><span class="nv">revert</span><span class="w"> </span><span class="o">-</span><span class="nv">m</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">merge_commit_sha</span><span class="o">&gt;</span>

#<span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">get</span><span class="w"> </span><span class="nv">just</span><span class="w"> </span><span class="nv">one</span>,<span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">could</span><span class="w"> </span><span class="nv">use</span><span class="w"> </span>`<span class="nv">rebase</span><span class="w"> </span><span class="o">-</span><span class="nv">i</span>`<span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">squash</span><span class="w"> </span><span class="nv">them</span><span class="w"> </span><span class="nv">afterwards</span>
#<span class="w"> </span><span class="nv">Or</span>,<span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">could</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">manually</span><span class="w"> </span><span class="ss">(</span><span class="nv">be</span><span class="w"> </span><span class="nv">sure</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">top</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">repo</span><span class="ss">)</span>
#<span class="w"> </span><span class="nv">get</span><span class="w"> </span><span class="nv">your</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">work</span><span class="w"> </span><span class="nv">tree</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">desired</span><span class="w"> </span><span class="nv">state</span>,<span class="w"> </span><span class="nv">without</span><span class="w"> </span><span class="nv">changing</span><span class="w"> </span><span class="nv">HEAD</span>:
<span class="nv">git</span><span class="w"> </span><span class="nv">checkout</span><span class="w"> </span><span class="mi">0</span><span class="nv">d1d7fc32</span><span class="w"> </span>.

#<span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="nv">commit</span>.<span class="w"> </span><span class="nv">Be</span><span class="w"> </span><span class="nv">sure</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">write</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">good</span><span class="w"> </span><span class="nv">message</span><span class="w"> </span><span class="nv">describing</span><span class="w"> </span><span class="nv">what</span><span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">just</span><span class="w"> </span><span class="nv">did</span>
<span class="nv">git</span><span class="w"> </span><span class="nv">commit</span>
</pre></div>

<p>联机<code>git-revert</code>帮助页在其描述中实际上涵盖了很多内容。另一个有用的链接是讨论 git-revert 的 git-scm.com 部分。</p>
<p>如果您决定不想还原，您可以还原还原（如此处所述）或重置为还原之前的状态（请参阅上一节）。</p>
<p>您可能还会发现此答案在这种情况下很有用：<br>
How can I move HEAD back to a previous location? （分离头）和撤消提交</p>
<p><br></p>
<h3>更多建议</h3>
<p>这里有很多复杂和危险的答案，但实际上很简单：</p>
<div class="code"><pre class="code literal-block">git revert --no-commit 0766c053..HEAD
git commit
</pre></div>

<p>这会将 HEAD 中的所有内容还原为提交哈希，这意味着它将在工作树中重新创建该提交状态， <em>就好像</em>
每次提交都<code>0766c053</code>被退回一样。然后您可以提交当前树，它将创建一个全新的提交，本质上等同于您“恢复”到的提交。</p>
<p>（该<code>--no-commit</code>标志让 git 一次恢复所有提交 - 否则系统会提示您为范围内的每个提交输入一条消息，用不必要的新提交乱丢您的历史。）</p>
<p>这是 <strong>回滚到先前状态的一种安全且简单的方法</strong> 。没有历史被破坏，所以它可以用于已经公开的提交。</p>
<p><br><br><a href="posts/how-do-i-revert-a-git-repository-to-a-previous-commit/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/javascript-bi-bao-shi-ru-he-gong-zuo-de/" class="u-url">JavaScript 闭包是如何工作的？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/javascript-bi-bao-shi-ru-he-gong-zuo-de/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:24:18+08:00" itemprop="datePublished" title="2023-02-16 18:24">2023-02-16 18:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>您如何向了解闭包所包含的概念（例如函数、变量等）但不了解闭包本身的人解释 JavaScript 闭包？</p>
<p>我看过维基百科上给出的Scheme 示例，但不幸的是它没有帮助。</p>
<p><br><br></p>
<h2>解答</h2>
<p>闭包是一对：</p>
<ol>
<li>一个函数和</li>
<li>对该函数的外部范围（词法环境）的引用</li>
</ol>
<p>词法环境是每个执行上下文（堆栈框架）的一部分，并且是标识符（即局部变量名）和值之间的映射。</p>
<p>JavaScript
中的每个函数都维护对其外部词法环境的引用。此引用用于配置调用函数时创建的执行上下文。此引用使函数内部的代码能够“查看”在函数外部声明的变量，而不管函数何时何地被调用。</p>
<p>如果一个函数被一个函数调用，而这个函数又被另一个函数调用，那么就会创建一个指向外部词法环境的引用链。这个链称为作用域链。</p>
<p>在下面的代码中，用调用<code>inner</code>时创建的执行上下文的词法环境形成一个闭包， <em>关闭</em> 变量：<code>foo</code> __<code>secret</code></p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="n">const</span><span class="w"> </span><span class="n">secret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="k">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">inner</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n n-Quoted">`The secret number is ${secret}.`</span><span class="p">)</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
<span class="n">const</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`secret`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="k">accessible</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n n-Quoted">`foo`</span>
<span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">retrieve</span><span class="w"> </span><span class="n n-Quoted">`secret`</span><span class="p">,</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">invoke</span><span class="w"> </span><span class="n n-Quoted">`f`</span>
</pre></div>

<p>换句话说：在 JavaScript
中，函数带有对私有“状态框”的引用，只有它们（以及在同一词法环境中声明的任何其他函数）才能访问它。这个状态框对函数的调用者是不可见的，为数据隐藏和封装提供了一个很好的机制。</p>
<p>请记住：JavaScript 中的函数可以像变量一样传递（一等函数），这意味着这些功能和状态的配对可以在您的程序中传递：类似于您在 C++
中传递类实例的方式。</p>
<p>如果 JavaScript 没有闭包，则必须在函数之间显式传递更多状态 <em>，</em> 从而使参数列表更长且代码更嘈杂。</p>
<p>因此，如果您希望函数始终可以访问私有状态，则可以使用闭包。</p>
<p>...而且我们经常 <em>希望</em> 将状态与功能相关联。例如，在 Java 或 C++ 中，当您向类添加私有实例变量和方法时，您将状态与功能相关联。</p>
<p>在 C 和大多数其他常见语言中，函数返回后，所有局部变量都不再可访问，因为堆栈框架已被破坏。在 JavaScript
中，如果你在另一个函数中声明一个函数，那么外部函数的局部变量在从它返回后仍然可以访问。这样，在上面的代码中，函数对象在从返回
<em>后</em><code>secret</code>仍然可用。<code>inner</code> __<code>foo</code></p>
<h3>闭包的使用</h3>
<p>当您需要与函数关联的私有状态时，闭包很有用。这是一个非常常见的场景 - 请记住：JavaScript 直到 2015
年才具有类语法，并且它仍然没有私有字段语法。闭包满足了这种需求。</p>
<h4>私有实例变量</h4>
<p>在下面的代码中，该函数<code>toString</code>关闭了汽车的详细信息。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">Car</span><span class="p">(</span><span class="n">manufacturer</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="err">`</span><span class="o">$</span><span class="p">{</span><span class="n">manufacturer</span><span class="p">}</span><span class="w"> </span><span class="o">$</span><span class="p">{</span><span class="n">model</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="p">{</span><span class="n">year</span><span class="p">},</span><span class="w"> </span><span class="o">$</span><span class="p">{</span><span class="n">color</span><span class="p">})</span><span class="err">`</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Car</span><span class="p">(</span><span class="s1">'Aston Martin'</span><span class="p">,</span><span class="w"> </span><span class="s1">'V8 Vantage'</span><span class="p">,</span><span class="w"> </span><span class="s1">'2012'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Quantum Silver'</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">car</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>

<h4>函数式编程</h4>
<p>在下面的代码中，函数<code>inner</code>关闭了<code>fn</code>和<code>args</code>。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">curry</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">inner</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">fn</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="o">...</span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="n">args</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">inner</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">function</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">curriedAdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curry</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">curriedAdd</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)())</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<h4>面向事件的编程</h4>
<p>在下面的代码中，函数<code>onClick</code>关闭了变量<code>BACKGROUND_COLOR</code>。</p>
<div class="code"><pre class="code literal-block">const<span class="w"> </span>$<span class="w"> </span>=<span class="w"> </span>document.querySelector.bind(document)
const<span class="w"> </span>BACKGROUND_COLOR<span class="w"> </span>=<span class="w"> </span>'rgba(200,<span class="w"> </span>200,<span class="w"> </span>242,<span class="w"> </span>1)'

function<span class="w"> </span>onClick()<span class="w"> </span>{
<span class="w">  </span>$('body').style.background<span class="w"> </span>=<span class="w"> </span>BACKGROUND_COLOR
}

$('button').addEventListener('click',<span class="w"> </span>onClick)


<span class="nt">&lt;button&gt;</span>Set<span class="w"> </span>background<span class="w"> </span>color<span class="nt">&lt;/button&gt;</span>
</pre></div>

<h4>模块化</h4>
<p>在下面的例子中，所有的实现细节都隐藏在一个立即执行的函数表达式中。函数<code>tick</code>并<code>toString</code>关闭他们完成工作所需的私有状态和函数。闭包使我们能够模块化和封装我们的代码。</p>
<div class="code"><pre class="code literal-block"><span class="n">let</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">tick</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">numbers</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Math</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">n</span><span class="o">.</span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tick</span><span class="p">,</span>
<span class="w">    </span><span class="n">toString</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}(</span><span class="n">namespace</span><span class="p">))</span>

<span class="k">const</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">namespace</span><span class="o">.</span><span class="n">counter</span>
<span class="n">counter</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
<span class="n">counter</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>

<h3>例子</h3>
<h4>示例 1</h4>
<p>这个例子表明局部变量没有被复制到闭包中：闭包维护了对原始变量 <em>本身的</em> 引用。就好像即使在外部函数退出后，堆栈框架仍然存在于内存中。</p>
<div class="code"><pre class="code literal-block"><span class="nv">function</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="w">  </span><span class="nv">let</span><span class="w"> </span><span class="nv">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nv">console</span>.<span class="nv">log</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>
<span class="w">  </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">inner</span>
}

<span class="nv">foo</span><span class="ss">()()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nv">logs</span><span class="w"> </span><span class="mi">43</span>
</pre></div>

<h4>示例 2</h4>
<p>在下面的代码中，三个方法<code>log</code>, <code>increment</code>, 和<code>update</code>都关闭了相同的词法环境。</p>
<p>每次<code>createObject</code>调用时，都会创建一个新的执行上下文（堆栈框架）和一个全新的变量，并创建<code>x</code>一组新的函数（等），这些函数会关闭这个新变量。<code>log</code></p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">log</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="n">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">43</span>
<span class="n">o</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">o</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">5</span>
<span class="k">const</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">42</span>
</pre></div>

<h4>示例 3</h4>
<p>If you are using variables declared using <code>var</code>, be careful you understand
which variable you are closing over. Variables declared using <code>var</code> are
hoisted. This is much less of a problem in modern JavaScript due to the
introduction of <code>let</code> and <code>const</code>.</p>
<p>In the following code, each time around the loop, a new function <code>inner</code> is
created, which closes over <code>i</code>. But because <code>var i</code> is hoisted outside the
loop, all of these inner functions close over the same variable, meaning that
the final value of <code>i</code> (3) is printed, three times.</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="nf">var</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">result</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">function</span><span class="w"> </span><span class="k">inner</span><span class="p">()</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="err">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">result</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">print</span><span class="w"> </span><span class="err">`</span><span class="mi">3</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="n">times</span><span class="p">...</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="k">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">()</span><span class="w"> </span>
<span class="err">}</span>
</pre></div>

<h3>Final points:</h3>
<ul>
<li>Whenever a function is declared in JavaScript closure is created.</li>
<li>Returning a <code>function</code> from inside another function is the classic example of closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.</li>
<li>Whenever you use <code>eval()</code> inside a function, a closure is used. The text you <code>eval</code> can reference local variables of the function, and in the non-strict mode, you can even create new local variables by using <code>eval('var foo = …')</code>.</li>
<li>When you use <code>new Function(…)</code> (the Function constructor) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.</li>
<li>A closure in JavaScript is like keeping a reference ( <strong>NOT</strong> a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.</li>
<li>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</li>
<li>A new set of local variables is created every time a function is called.</li>
</ul>
<h3>Links</h3>
<ul>
<li>Douglas Crockford's simulated private attributes and private methods for an object, using closures.</li>
<li>A great explanation of how closures can cause memory leaks in IE if you are not careful.</li>
<li>MDN documentation on JavaScript Closures.</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>JavaScript 中的每个函数都维护到其外部词法环境的链接。词法环境是范围内所有名称（例如变量、参数）及其值的映射。</p>
<p>因此，只要您看到<code>function</code>关键字，该函数内的代码就可以访问在函数外声明的变量。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">tmp</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="nb">log</span><span class="w"> </span><span class="mi">16</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>

<p>这将记录下来<code>16</code>，因为函数<code>bar</code>关闭了参数<code>x</code>和变量<code>tmp</code>，这两者都存在于外部函数的词法环境中<code>foo</code>。</p>
<p>Function<code>bar</code>连同它与 function 的词法环境的链接<code>foo</code>是一个闭包。</p>
<p>函数不必为了创建闭包而 <em>返回。</em> 仅仅凭借其声明，每个函数都关闭其封闭的词法环境，形成一个闭包。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">tmp</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="nb">log</span><span class="w"> </span><span class="mi">16</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">16</span>
<span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">17</span>
</pre></div>

<p>上面的函数也会记录 16，因为里面的代码<code>bar</code>仍然可以引用 argument<code>x</code>和 variable <code>tmp</code>，即使它们不再直接在范围内。</p>
<p>但是，由于<code>tmp</code>is 仍然在 的闭包内徘徊<code>bar</code>，因此可以对其进行递增。每次调用时它都会递增<code>bar</code>。</p>
<p>闭包最简单的例子是这样的：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="n">function</span><span class="w"> </span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="mi">6</span>
<span class="p">}</span>
<span class="k">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="n">test</span><span class="p">();</span>
</pre></div>

<p>调用 JavaScript
函数时，<code>ec</code>会创建一个新的执行上下文。与函数参数和目标对象一起，此执行上下文还接收到调用执行上下文的词法环境的链接，这意味着在外部词法环境中声明的变量（在上面的示例中，
和 ）都<code>a</code>可以<code>b</code>从<code>ec</code>.</p>
<p>每个函数都会创建一个闭包，因为每个函数都有一个到其外部词法环境的链接。</p>
<p>请注意，变量 <em>本身</em> 在闭包中是可见的， <em>而不是</em> 副本。</p>
<p><br><br><a href="posts/how-do-javascript-closures-work/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-10.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-8.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
