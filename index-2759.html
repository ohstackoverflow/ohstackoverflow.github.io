<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2759) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2759.html">
<link rel="prev" href="index-2760.html" type="text/html">
<link rel="next" href="index-2758.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/using-powershell-to-write-a-file-in-utf-8-without-the-bom/" class="u-url">Using PowerShell to write a file in UTF-8 without the BOM</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/using-powershell-to-write-a-file-in-utf-8-without-the-bom/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T15:49:59+08:00" itemprop="datePublished" title="2023-03-05 15:49">2023-03-05 15:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>Out-File</code> seems to force the BOM when using UTF-8:</p>
<div class="code"><pre class="code literal-block">$MyFile = Get-Content $MyPath
$MyFile | Out-File -Encoding "UTF8" $MyPath
</pre></div>

<p>How can I write a file in UTF-8 with no BOM using PowerShell?</p>
<h4>Update 2021</h4>
<p>PowerShell has changed a bit since I wrote this question 10 years ago. Check
multiple answers below, they have a lot of good information!</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Using .NET's <code>UTF8Encoding</code> class and passing <code>$False</code> to the constructor
seems to work:</p>
<div class="code"><pre class="code literal-block">$MyRawString = Get-Content -Raw $MyPath
$Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding $False
[System.IO.File]::WriteAllLines($MyPath, $MyRawString, $Utf8NoBomEncoding)
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>The <strong>proper</strong> way as of now is to use a solution recommended by @Roman Kuzmin
in comments to @M. Dudley answer:</p>
<div class="code"><pre class="code literal-block">[IO.File]::WriteAllLines($filename, $content)
</pre></div>

<p><em>(I've also shortened it a bit by stripping unnecessary<code>System</code> namespace
clarification - it will be substituted automatically by default.)</em></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/http-headers-in-websockets-client-api/" class="u-url">HTTP headers in Websockets client API</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/http-headers-in-websockets-client-api/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T15:48:21+08:00" itemprop="datePublished" title="2023-03-05 15:48">2023-03-05 15:48</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Looks like it's easy to add custom HTTP headers to your websocket client with
any HTTP header client which supports this, but I can't find how to do it with
the web platform's <code>WebSocket</code> API.</p>
<p>Anyone has a clue on how to achieve it?</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">WebSocket</span><span class="p">(</span><span class="s2">"ws://example.com/service"</span><span class="p">);</span>
</pre></div>

<p>Specifically, I need to be able to send an HTTP Authorization header.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Updated 2x</strong></p>
<p>Short answer: <strong>No, only the path and protocol field can be specified.</strong></p>
<p>Longer answer:</p>
<p>There is no method in the JavaScript WebSockets API for specifying additional
headers for the client/browser to send. The HTTP path ("GET /xyz") and
protocol header ("Sec-WebSocket-Protocol") can be specified in the WebSocket
constructor.</p>
<p>The Sec-WebSocket-Protocol header (which is sometimes extended to be used in
websocket specific authentication) is generated from the optional second
argument to the WebSocket constructor:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">WebSocket</span><span class="p">(</span><span class="s2">"ws://example.com/path"</span><span class="p">,</span><span class="w"> </span><span class="s2">"protocol"</span><span class="p">);</span>
<span class="k">var</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">WebSocket</span><span class="p">(</span><span class="s2">"ws://example.com/path"</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">"protocol1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"protocol2"</span><span class="p">]);</span>
</pre></div>

<p>The above results in the following headers:</p>
<div class="code"><pre class="code literal-block">Sec-WebSocket-Protocol: protocol
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block">Sec-WebSocket-Protocol: protocol1, protocol2
</pre></div>

<p>A common pattern for achieving WebSocket authentication/authorization is to
implement a ticketing system where the page hosting the WebSocket client
requests a ticket from the server and then passes this ticket during WebSocket
connection setup either in the URL/query string, in the protocol field, or
required as the first message after the connection is established. The server
then only allows the connection to continue if the ticket is valid (exists,
has not been already used, client IP encoded in ticket matches, timestamp in
ticket is recent, etc). Here is a summary of WebSocket security information:
https://devcenter.heroku.com/articles/websocket-security</p>
<p>Basic authentication was formerly an option but this has been deprecated and
modern browsers don't send the header even if it is specified.</p>
<p><strong>Basic Auth Info (Deprecated - No longer functional)</strong> :</p>
<blockquote>
<p>NOTE: the following information is no longer accurate in any modern
browsers.</p>
</blockquote>
<p>The Authorization header is generated from the username and password (or just
username) field of the WebSocket URI:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">WebSocket</span><span class="p">(</span><span class="s2">"ws://username:password@example.com"</span><span class="p">)</span>
</pre></div>

<p>The above results in the following header with the string "username:password"
base64 encoded:</p>
<div class="code"><pre class="code literal-block"><span class="n">Authorization</span><span class="o">:</span><span class="w"> </span><span class="n">Basic</span><span class="w"> </span><span class="n">dXNlcm5hbWU6cGFzc3dvcmQ</span><span class="o">=</span>
</pre></div>

<p>I have tested basic auth in Chrome 55 and Firefox 50 and verified that the
basic auth info is indeed negotiated with the server (this may not work in
Safari).</p>
<p>Thanks to Dmitry Frank's for the basic auth answer</p>
<p><br></p>
<h3>Suggest</h3>
<p>More of an alternate solution, but all modern browsers send the domain cookies
along with the connection, so using:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">authToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'R3YKZFKBVi'</span><span class="p">;</span>

<span class="n">document</span><span class="o">.</span><span class="n">cookie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'X-Authorization='</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">authToken</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'; path=/'</span><span class="p">;</span>

<span class="k">var</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">WebSocket</span><span class="p">(</span>
<span class="w">    </span><span class="s1">'wss://localhost:9000/wss/'</span>
<span class="p">);</span>
</pre></div>

<p>End up with the request connection headers:</p>
<div class="code"><pre class="code literal-block"><span class="n">Cookie</span><span class="o">:</span><span class="w"> </span><span class="n">X</span><span class="o">-</span><span class="n">Authorization</span><span class="o">=</span><span class="n">R3YKZFKBVi</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/detect-the-internet-connection-is-offline/" class="u-url">Detect the Internet connection is offline?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/detect-the-internet-connection-is-offline/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T15:46:48+08:00" itemprop="datePublished" title="2023-03-05 15:46">2023-03-05 15:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How to detect the Internet connection is offline in JavaScript?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You can determine that the connection is lost by making <strong>failed XHR
requests</strong>.</p>
<p>The standard approach is to <strong>retry the request</strong> a few times. If it doesn't
go through, <strong>alert the user</strong> to check the connection, and <strong>fail
gracefully</strong>.</p>
<p><strong>Sidenote:</strong> To put the entire application in an "offline" state may lead to
a lot of error-prone work of handling state.. wireless connections may come
and go, etc. So your best bet may be to just fail gracefully, preserve the
data, and alert the user.. allowing them to eventually fix the connection
problem if there is one, and to continue using your app with a fair amount of
forgiveness.</p>
<p><strong>Sidenote:</strong> You could check a reliable site like google for connectivity,
but this may not be entirely useful as just trying to make your own request,
because while Google may be available, your own application may not be, and
you're still going to have to handle your own connection problem. Trying to
send a ping to google would be a good way to confirm that the internet
connection itself is down, so if that information is useful to you, then it
might be worth the trouble.</p>
<p><strong>Sidenote</strong> : <em>Sending a Ping</em> could be achieved in the same way that you
would make any kind of two-way ajax request, but sending a ping to google, in
this case, would pose some challenges. First, we'd have the same cross-domain
issues that are typically encountered in making Ajax communications. One
option is to set up a server-side proxy, wherein we actually <code>ping</code> google (or
whatever site), and return the results of the ping to the app. This is a
<strong>catch-22</strong> because if the internet connection is actually the problem, we
won't be able to get to the server, and if the connection problem is only on
our own domain, we won't be able to tell the difference. Other cross-domain
techniques could be tried, for example, embedding an iframe in your page which
points to google.com, and then polling the iframe for success/failure (examine
the contents, etc). Embedding an image may not really tell us anything,
because we need a useful response from the communication mechanism in order to
draw a good conclusion about what's going on. So again, determining the state
of the internet connection as a whole may be more trouble than it's worth.
You'll have to weight these options out for your specific app.</p>
<p><br></p>
<h3>Suggest</h3>
<p>You can determine that the connection is lost by making <strong>failed XHR
requests</strong>.</p>
<p>The standard approach is to <strong>retry the request</strong> a few times. If it doesn't
go through, <strong>alert the user</strong> to check the connection, and <strong>fail
gracefully</strong>.</p>
<p><strong>Sidenote:</strong> To put the entire application in an "offline" state may lead to
a lot of error-prone work of handling state.. wireless connections may come
and go, etc. So your best bet may be to just fail gracefully, preserve the
data, and alert the user.. allowing them to eventually fix the connection
problem if there is one, and to continue using your app with a fair amount of
forgiveness.</p>
<p><strong>Sidenote:</strong> You could check a reliable site like google for connectivity,
but this may not be entirely useful as just trying to make your own request,
because while Google may be available, your own application may not be, and
you're still going to have to handle your own connection problem. Trying to
send a ping to google would be a good way to confirm that the internet
connection itself is down, so if that information is useful to you, then it
might be worth the trouble.</p>
<p><strong>Sidenote</strong> : <em>Sending a Ping</em> could be achieved in the same way that you
would make any kind of two-way ajax request, but sending a ping to google, in
this case, would pose some challenges. First, we'd have the same cross-domain
issues that are typically encountered in making Ajax communications. One
option is to set up a server-side proxy, wherein we actually <code>ping</code> google (or
whatever site), and return the results of the ping to the app. This is a
<strong>catch-22</strong> because if the internet connection is actually the problem, we
won't be able to get to the server, and if the connection problem is only on
our own domain, we won't be able to tell the difference. Other cross-domain
techniques could be tried, for example, embedding an iframe in your page which
points to google.com, and then polling the iframe for success/failure (examine
the contents, etc). Embedding an image may not really tell us anything,
because we need a useful response from the communication mechanism in order to
draw a good conclusion about what's going on. So again, determining the state
of the internet connection as a whole may be more trouble than it's worth.
You'll have to weight these options out for your specific app.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2760.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2758.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
