<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 689) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-689.html">
<link rel="prev" href="index-690.html" type="text/html">
<link rel="next" href="index-688.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/restful-shen-fen-yan-zheng/" class="u-url">RESTful 身份验证</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/restful-shen-fen-yan-zheng/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T13:30:52+08:00" itemprop="datePublished" title="2023-02-17 13:30">2023-02-17 13:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>RESTful 身份验证是什么意思，它是如何工作的？我在 Google 上找不到很好的概述。我唯一的理解是您在 URL
中传递了会话密钥（remeberal），但这可能是非常错误的。</p>
<p><br><br></p>
<h2>解答</h2>
<p>如何在 RESTful 客户端-服务器架构中处理身份验证是一个有争议的问题。</p>
<p>通常，在 SOA over HTTP 世界中，它可以通过以下方式实现：</p>
<ul>
<li>基于 HTTPS 的 HTTP 基本身份验证；</li>
<li>Cookie 和会话管理；</li>
<li>HTTP 标头中的令牌（例如 <em>OAuth</em> 2.0 + JWT）；</li>
<li>使用附加签名参数查询身份验证。</li>
</ul>
<p>您必须适应，甚至更好地混合这些技术，以最好地匹配您的软件架构。</p>
<p>每种身份验证方案都有自己的优点和缺点，具体取决于您的安全策略和软件架构的目的。</p>
<p><strong>基于 HTTPS 的 HTTP 基本身份验证</strong></p>
<p>第一个解决方案基于标准的 HTTPS 协议，被大多数 Web 服务使用。</p>
<div class="code"><pre class="code literal-block"><span class="nf">GET</span> <span class="nn">/spec.html</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.example.org</span>
<span class="na">Authorization</span><span class="o">:</span> <span class="l">Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</span>
</pre></div>

<p>它很容易实现，默认情况下在所有浏览器上可用，但有一些已知的缺点，比如浏览器上显示的糟糕的身份验证窗口，它将持续存在（这里没有类似注销的功能），一些服务器端额外的
CPU 消耗，以及用户名和密码（通过 HTTPS）传输到服务器的事实（在键盘输入期间让密码仅保留在客户端并作为安全散列存储在服务器上应该更安全） .</p>
<p>我们可以使用Digest Authentication，但它也需要 HTTPS，因为它容易受到MiM或Replay攻击，并且特定于 HTTP。</p>
<p><strong>通过 Cookie 进行会话</strong></p>
<p>老实说，在服务器上管理的会话并不是真正的无状态。</p>
<p>一种可能性是在 cookie 内容中维护所有数据。而且，根据设计，cookie 在服务器端处理（实际上，客户端甚至不会尝试解释此 cookie
数据：它只是在每个连续请求时将其返回给服务器）。但是这个 cookie 数据是应用程序状态数据，所以在纯无状态的世界中，客户端应该管理它，而不是服务器。</p>
<div class="code"><pre class="code literal-block"><span class="nf">GET</span> <span class="nn">/spec.html</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.example.org</span>
<span class="na">Cookie</span><span class="o">:</span> <span class="l">theme=light; sessionToken=abc123</span>
</pre></div>

<p>cookie 技术本身是 HTTP 链接的，因此它不是真正的 RESTful，它应该是独立于协议的，恕我直言。它容易受到MiM或Replay攻击。</p>
<p><strong>通过令牌 (OAuth2) 授予</strong></p>
<p>另一种方法是在 HTTP 标头中放置一个令牌，以便对请求进行身份验证。例如，这就是 <em>OAuth 2.0 所做的。</em> 请参阅RFC 6749：</p>
<div class="code"><pre class="code literal-block"> GET /resource/1 HTTP/1.1
 Host: example.com
 Authorization: Bearer mF_9.B5f-4.1JqM
</pre></div>

<p>简而言之，这与 cookie 非常相似，并且存在相同的问题：不是无状态的，依赖于 HTTP 传输细节，并且存在许多安全漏洞- 包括 MiM 和
Replay - 因此只能通过 HTTPS 使用。通常，JWT用作令牌。</p>
<p><strong>查询认证</strong></p>
<p>查询身份验证包括通过 URI 上的一些附加参数对每个 RESTful 请求进行签名。请参阅这篇参考文章。</p>
<p>在这篇文章中是这样定义的：</p>
<blockquote>
<p>所有 REST 查询都必须通过使用私有凭证作为签名令牌对按小写字母顺序排序的查询参数进行签名来进行身份验证。签名应该发生在 URL 编码查询字符串之前。</p>
</blockquote>
<p>这种技术可能与无状态架构更兼容，也可以通过轻型会话管理（使用内存中会话而不是数据库持久性）来实现。</p>
<p>例如，这是来自上面链接的通用 URI 示例：</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /object?apiKey=Qwerty2010</span>
</pre></div>

<p>应该这样传送：</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /object?timestamp=1261496500&amp;apiKey=Qwerty2010&amp;signature=abcdef0123456789</span>
</pre></div>

<p>被签名的字符串是<code>/object?apikey=Qwerty2010&amp;timestamp=1261496500</code>并且签名是使用 API
密钥的私有组件的该字符串的 SHA256 哈希值。</p>
<p>服务器端数据缓存可以始终可用。例如，在我们的框架中，我们在 SQL 级别缓存响应，而不是在 URI 级别。所以添加这个额外的参数不会破坏缓存机制。</p>
<p>有关基于 JSON 和 REST 的客户端-服务器 ORM/SOA/MVC 框架中的 RESTful
身份验证的一些详细信息，请参阅本文。由于我们不仅允许通过 HTTP/1.1 进行通信，还允许通过命名管道或 GDI
消息（本地）进行通信，因此我们尝试实现真正的 RESTful 身份验证模式，而不依赖于 HTTP 特性（如标头或 cookie）。</p>
<p><em>稍后注意</em> ：在 URI 中添加签名可以被视为不好的做法（因为例如它会出现在 http 服务器日志中）因此必须减轻它，例如通过适当的 TTL
来避免重播。但是如果你的 http 日志被泄露，你肯定会有更大的安全问题。</p>
<p>实际上，即将推出的OAuth 2.0 MAC 令牌身份验证可能是相对于“通过令牌授予”当前方案的巨大改进。但这仍在进行中，并且与 HTTP 传输相关联。</p>
<p><strong>结论</strong></p>
<p>值得得出的结论是，REST 不仅是基于 HTTP 的，即使在实践中，它也主要通过 HTTP 实现。REST 可以使用其他通信层。因此，RESTful
身份验证不仅仅是 HTTP 身份验证的同义词，无论 Google 给出什么答案。它甚至应该完全不使用 HTTP 机制，而应该从通信层中抽象出来。如果您使用
HTTP 通信，由于Let's Encrypt 倡议，没有理由不使用适当的 HTTPS，这是除了任何身份验证方案之外所必需的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我怀疑那些热情地喊着“HTTP 身份验证”的人是否曾经尝试过使用 REST 制作基于浏览器的应用程序（而不是机器对机器的 Web 服务）（无意冒犯 -
我只是认为他们从未遇到过复杂情况） .</p>
<p>我在生成要在浏览器中查看的 HTML 页面的 RESTful 服务上使用 HTTP 身份验证时发现的问题是：</p>
<ul>
<li>用户通常会得到一个丑陋的浏览器制作的登录框，这对用户非常不友好。您不能添加密码检索、帮助框等。</li>
<li>注销或以不同的名称登录是一个问题 - 浏览器将继续向站点发送身份验证信息，直到您关闭窗口</li>
<li>超时很难</li>
</ul>
<p>此处有一篇非常有见地的文章逐点解决这些问题，但这会导致大量 <em>特定</em> 于浏览器的 javascript
hackery、变通方法的变通方法等等。因此，它也不向前兼容，因此在发布新浏览器时需要不断维护。我不考虑那种简洁明了的设计，而且我觉得这是很多额外的工作和头痛，只是为了让我可以热情地向我的朋友们展示我的
REST-badge。</p>
<p>我相信 cookie 是解决方案。但是等等，饼干是邪恶的，不是吗？不，它们不是，通常使用 cookie 的方式是邪恶的。cookie
本身只是一条客户端信息，就像浏览器在您浏览时会跟踪的 HTTP 身份验证信息一样。这条客户端信息会在每次请求时发送到服务器，就像 HTTP
身份验证信息一样。从概念上讲，唯一的区别是这段客户端状态的 <em>内容可以由</em> <em>服务器</em> 确定，作为其响应的一部分。</p>
<p>通过仅使用以下规则使会话成为 RESTful 资源：</p>
<ul>
<li>会话将密钥映射到用户 ID（可能 <em>还有</em> 超时的最后操作时间戳）</li>
<li>如果 <em>会话</em> 存在，则意味着密钥有效。</li>
<li>登录意味着 POST 到 /sessions，一个新的密钥被设置为一个 cookie</li>
<li>注销意味着删除 /sessions/{key} （使用过载的 POST，请记住，我们是浏览器，HTML 5 还有很长的路要走）</li>
<li>身份验证是通过在每次请求时将密钥作为 cookie 发送并检查会话是否存在且有效来完成的</li>
</ul>
<p>现在，与 HTTP 身份验证的唯一区别是，身份验证密钥由服务器生成并发送给不断发回它的客户端，而不是客户端根据输入的凭据计算它。</p>
<p>converter42 补充说，当使用 https（我们应该这样做）时，重要的是 cookie
将设置其安全标志，以便永远不会通过非安全连接发送身份验证信息。好点，我自己没见过。</p>
<p>我觉得这是一个足够好的解决方案，但我必须承认我还不够安全专家来识别这个方案中的潜在漏洞——我所知道的是数百个非 RESTful Web
应用程序使用基本相同的登录协议（PHP 中的 $_SESSION，Java EE 中的 HttpSession 等）。cookie
标头内容仅用于寻址服务器端资源，就像接受语言可能用于访问翻译资源等。我感觉是一样的，但也许别人不这么认为？你们觉得怎么样？</p>
<p><br><br><a href="posts/restful-authentication/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-cong-wo-de-android-she-bei-fang-wen-wo-de-ben-di-zhu-ji/" class="u-url">如何从我的 Android 设备访问我的本地主机？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-cong-wo-de-android-she-bei-fang-wen-wo-de-ben-di-zhu-ji/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T13:30:07+08:00" itemprop="datePublished" title="2023-02-17 13:30">2023-02-17 13:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我可以使用 Android 模拟器访问我的笔记本电脑网络服务器，我使用的<code>10.0.2.2:portno</code>很好。</p>
<p>但是当我连接我真正的 Android 手机时，手机浏览器无法连接到我笔记本电脑上的同一网络服务器。手机使用 USB 数据线连接到笔记本电脑。如果我运行
adb devices 命令，我可以看到我的手机。</p>
<p>我错过了什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>USB 不为移动设备提供网络。</p>
<p><strong>如果您的台式机和手机都连接到同一个 WiFi</strong> （或任何其他本地网络），则使用路由器分配给您的台式机 IP 地址（not<code>localhost</code>和
not <code>127.0.0.1</code>）。</p>
<p>要找出您桌面的 IP 地址：</p>
<ul>
<li>在命令行<code>ipconfig</code>(Windows) 或<code>ifconfig</code>(Unix) 中键入<ul>
<li>在 Linux 上，一行<code>ifconfig | grep "inet " | grep -v 127.0.0.1</code>只会产生重要的东西</li>
<li>有很多关于如何在 Windows 上获得类似输出的建议</li>
</ul>
</li>
<li>会有一堆IP</li>
<li>尝试所有这些（除了上述<code>localhost</code>和<code>127.0.0.1</code>）</li>
</ul>
<p><strong>如果您的手机已连接到移动网络</strong> ，那么事情就会变得更加困难。</p>
<p>要么去铁杆：</p>
<ul>
<li>首先找出你的路由器外部 IP 地址 ( https://www.google.de/search?q=myip )</li>
<li>然后，在路由器上，转发一些端口到<code>&lt;your desktop IP&gt;:&lt;server port number&gt;</code>
</li>
<li>最后使用外部 IP 地址和转发端口</li>
</ul>
<p>否则使用xip.io或ngrok之类的东西。</p>
<p><strong>注意</strong> ：<code>ifconfig</code>从 Debian stretch 开始，该命令已被弃用，因此默认情况下在 Debian Linux 上缺失。在
Debian Linux 上检查网络配置的新推荐替代方法是 ip 命令。例如，要使用 ip 命令显示网络配置，请运行以下命令：</p>
<div class="code"><pre class="code literal-block">ip address
</pre></div>

<p>上面的ip命令可以简写为：</p>
<div class="code"><pre class="code literal-block">ip a
</pre></div>

<p>如果您仍然喜欢将<code>ifconfig</code>其用作日常系统管理例程的一部分，则可以轻松地将其作为<code>net-tools</code>软件包的一部分进行安装。</p>
<div class="code"><pre class="code literal-block"><span class="n">apt</span><span class="o">-</span><span class="n">get</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">net</span><span class="o">-</span><span class="n">tools</span>
</pre></div>

<p>参考在这里</p>
<p><br></p>
<h3>更多建议</h3>
<p>其实很简单。</p>
<ul>
<li>打开 Android 手机/路由器的 WiFi 热点并将笔记本电脑连接到手机</li>
<li>启动您的服务器<code>localhost</code>（我正在使用适用于 Windows 的 WAMP 服务器）</li>
<li>
<p>现在打开命令提示符并输入</p>
<p>ipconfig</p>
</li>
</ul>
<p>完成后，您将看到如下内容：</p>
<div class="code"><pre class="code literal-block">无线局域网适配器无线网络连接：
  连接特定的 DNS 后缀。:
  链路本地 IPv6 地址。. . . . : fe80::80bc:e378:19ab:e448%11
  IPv4 地址。. . . . . . . . . . : 192.168.43.76
  子网掩码 。. . . . . . . . . . : 255.255.255.0
  默认网关 。. . . . . . . . : 192.168.43.1
</pre></div>

<ul>
<li>复制 IPv4 地址（在本例中为<code>192.168.43.76</code>）</li>
<li>在您的移动浏览器中，只需粘贴 IPv4 地址</li>
</ul>
<hr>
<p>注意： <strong>请将您的网络设置为“ <em>家庭网络</em> ”。</strong>将网络设置为家庭网络意味着您允许您的 PC 与同一网络上的其他设备共享内容。</p>
<p>如果您使用的是 Windows 10，则可以通过以下方式完成：</p>
<ul>
<li>打开 <em>设置</em>
</li>
<li>转到 <em>网络和互联网</em>
</li>
<li>在左侧菜单中选择 <em>WiFi</em>
</li>
<li>点击已连接 WiFi 的名称</li>
<li>
<strong>将网络的网络配置文件</strong> 设置为 <em>私有</em>
</li>
</ul>
<p>如果您遇到问题，很可能与 Windows 防火墙有关。</p>
<ul>
<li>打开 <em>控制面板</em>
</li>
<li>转到 <em>Windows Defender 防火墙</em>
</li>
<li>点击 <strong>允许应用程序或功能通过 Windows Defender 防火墙</strong>
</li>
<li>检查应用程序是否启用了 <strong>专用</strong> 网络（应该有勾号）</li>
<li>如果未 <em>启用</em> ，请点击 <strong>更改设置</strong> 并勾选应用程序 <strong>专用</strong> 下的复选框</li>
</ul>
<p><br><br><a href="posts/how-can-i-access-my-localhost-from-my-android-device/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-shi-ti-kuang-jia-zhong-cha-ru-de-zui-kuai-fang-fa/" class="u-url">在实体框架中插入的最快方法</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-shi-ti-kuang-jia-zhong-cha-ru-de-zui-kuai-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T13:29:34+08:00" itemprop="datePublished" title="2023-02-17 13:29">2023-02-17 13:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在寻找插入实体框架的最快方法。</p>
<p><code>TransactionScope</code>我问这个是因为你有一个活动并且插入很大（4000+）的场景。它可能会持续超过 10
分钟（交易的默认超时），这将导致交易不完整。</p>
<p><br><br></p>
<h2>解答</h2>
<p>对于您在问题评论中的评论：</p>
<blockquote>
<p>“...SavingChanges（ <strong>针对每条记录</strong> ）...”</p>
</blockquote>
<p>那是你能做的最糟糕的事情！调用<code>SaveChanges()</code>每条记录会大大降低批量插入的速度。我会做一些很可能会提高性能的简单测试：</p>
<ul>
<li>
<code>SaveChanges()</code>在所有记录后调用一次。</li>
<li>
<code>SaveChanges()</code>例如 100 条记录后调用。</li>
<li>例如在 100 条记录之后调用<code>SaveChanges()</code>并处理上下文并创建一个新记录。</li>
<li>禁用变化检测</li>
</ul>
<p>对于批量插入，我正在研究和试验这样的模式：</p>
<div class="code"><pre class="code literal-block"><span class="n">using</span><span class="w"> </span><span class="p">(</span><span class="n">TransactionScope</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">TransactionScope</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MyDbContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">null</span><span class="p">;</span>
<span class="w">    </span><span class="n">try</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyDbContext</span><span class="p">();</span>
<span class="w">        </span><span class="n">context</span><span class="o">.</span><span class="n">Configuration</span><span class="o">.</span><span class="n">AutoDetectChangesEnabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">false</span><span class="p">;</span>

<span class="w">        </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">            </span>
<span class="w">        </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">entityToInsert</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">someCollectionOfEntitiesToInsert</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">            </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddToContext</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">entityToInsert</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="bp">true</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">context</span><span class="o">.</span><span class="n">SaveChanges</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">finally</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">context</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb nb-Type">null</span><span class="p">)</span>
<span class="w">            </span><span class="n">context</span><span class="o">.</span><span class="n">Dispose</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">scope</span><span class="o">.</span><span class="n">Complete</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">private</span><span class="w"> </span><span class="n">MyDbContext</span><span class="w"> </span><span class="n">AddToContext</span><span class="p">(</span><span class="n">MyDbContext</span><span class="w"> </span><span class="n">context</span><span class="p">,</span>
<span class="w">    </span><span class="n">Entity</span><span class="w"> </span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">commitCount</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">recreateContext</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">context</span><span class="o">.</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">()</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">commitCount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">context</span><span class="o">.</span><span class="n">SaveChanges</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">recreateContext</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">context</span><span class="o">.</span><span class="n">Dispose</span><span class="p">();</span>
<span class="w">            </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyDbContext</span><span class="p">();</span>
<span class="w">            </span><span class="n">context</span><span class="o">.</span><span class="n">Configuration</span><span class="o">.</span><span class="n">AutoDetectChangesEnabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>我有一个测试程序，它将 560.000 个实体（9 个标量属性，无导航属性）插入到数据库中。使用此代码，它可以在不到 3 分钟的时间内运行。</p>
<p>对于性能，重要的是调用<code>SaveChanges()</code>“许多”记录（“许多”大约 100 或 1000）。它还提高了在 SaveChanges
之后处理上下文并创建新上下文的性能。这会清除所有实体的上下文，<code>SaveChanges</code>但不这样做，实体仍然附加到 state
中的上下文<code>Unchanged</code>。上下文中附加实体的大小不断增加会逐步减慢插入速度。因此，一段时间后清除它是有帮助的。</p>
<p>以下是我的 560000 个实体的一些测量值：</p>
<ul>
<li>commitCount = 1, recreateContext = false: <strong>许多小时</strong> （这是你当前的程序）</li>
<li>commitCount = 100, recreateContext = false: <strong>超过 20 分钟</strong>
</li>
<li>commitCount = 1000，recreateContext = false： <strong>242 秒</strong>
</li>
<li>commitCount = 10000，recreateContext = false： <strong>202 秒</strong>
</li>
<li>commitCount = 100000，recreateContext = false： <strong>199 秒</strong>
</li>
<li>commitCount = 1000000, recreateContext = false: <strong>内存不足异常</strong>
</li>
<li>commitCount = 1, recreateContext = true: <strong>超过 10 分钟</strong>
</li>
<li>commitCount = 10，recreateContext = true： <strong>241 秒</strong>
</li>
<li>commitCount = 100，recreateContext = true： <strong>164 秒</strong>
</li>
<li>commitCount = 1000，recreateContext = true： <strong>191 秒</strong>
</li>
</ul>
<p>上面第一个测试的行为是性能是非常非线性的，并且随着时间的推移极度下降。（“许多小时”是一个估计值，我从未完成此测试，20 分钟后我停在 50.000
个实体。）这种非线性行为在所有其他测试中并不那么重要。</p>
<p><br></p>
<h3>更多建议</h3>
<p>这种组合提高速度不够好。</p>
<div class="code"><pre class="code literal-block">context.Configuration.AutoDetectChangesEnabled = false;
context.Configuration.ValidateOnSaveEnabled = false;
</pre></div>

<p><br><br><a href="posts/fastest-way-of-inserting-in-entity-framework/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-690.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-688.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
