<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1425) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1425.html">
<link rel="prev" href="index-1426.html" type="text/html">
<link rel="next" href="index-1424.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-determine-subject-object-and-other-words/" class="u-url">How to determine subject, object and other words?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-determine-subject-object-and-other-words/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:36:19+08:00" itemprop="datePublished" title="2023-02-28 03:36">2023-02-28 03:36</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm trying to implement application that can determine meaning of sentence, by
dividing it to smaller pieces. So I need to know what words are subject,
object etc. so that my program can know how to handle this sentence.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>This is an open research problem. You can get an overview on Wikipedia,
http://en.wikipedia.org/wiki/Natural_language_processing. Consider phrases
like "Time flies like an arrow, fruit flies like a banana" - unambiguously
classifying words is not easy.</p>
<p><br></p>
<h3>Suggest</h3>
<p>You should look at the Natural Language Toolkit, which is for exactly this
sort of thing.</p>
<p>See this section of the manual: Categorizing and Tagging Words - here's an
extract:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">nltk</span>.<span class="nv">word_tokenize</span><span class="ss">(</span><span class="s2">"And now for something completely different"</span><span class="ss">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">nltk</span>.<span class="nv">pos_tag</span><span class="ss">(</span><span class="nv">text</span><span class="ss">)</span>
[<span class="ss">(</span><span class="s1">'And'</span>,<span class="w"> </span><span class="s1">'CC'</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="s1">'now'</span>,<span class="w"> </span><span class="s1">'RB'</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="s1">'for'</span>,<span class="w"> </span><span class="s1">'IN'</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="s1">'something'</span>,<span class="w"> </span><span class="s1">'NN'</span><span class="ss">)</span>,
<span class="ss">(</span><span class="s1">'completely'</span>,<span class="w"> </span><span class="s1">'RB'</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="s1">'different'</span>,<span class="w"> </span><span class="s1">'JJ'</span><span class="ss">)</span>]
</pre></div>

<p><em>"Here we see that <strong>and</strong> is CC, a coordinating conjunction; <strong>now</strong> and
<strong>completely</strong> are RB, or adverbs; <strong>for</strong> is IN, a preposition; <strong>something</strong>
is NN, a noun; and <strong>different</strong> is JJ, an adjective."</em></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/tictactoe-ai-making-incorrect-decisions/" class="u-url">TicTacToe AI Making Incorrect Decisions</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/tictactoe-ai-making-incorrect-decisions/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:35:58+08:00" itemprop="datePublished" title="2023-02-28 03:35">2023-02-28 03:35</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>A little background: as a way to learn multinode trees in C++, I decided to
generate all possible TicTacToe boards and store them in a tree such that the
branch beginning at a node are all boards that can follow from that node, and
the children of a node are boards that follow in one move. After that, I
thought it would be fun to write an AI to play TicTacToe using that tree as a
decision tree.</p>
<p>TTT is a solvable problem where a perfect player will never lose, so it seemed
an easy AI to code for my first time trying an AI.</p>
<p>Now when I first implemented the AI, I went back and added two fields to each
node upon generation: the # of times X will win &amp; the # of times O will win in
all children below that node. I figured the best solution was to simply have
my AI on each move choose and go down the subtree where it wins the most
times. Then I discovered that while it plays perfect most of the time, I found
ways where I could beat it. It wasn't a problem with my code, simply a problem
with the way I had the AI choose it's path.</p>
<p>Then I decided to have it choose the tree with either the maximum wins for the
computer or the maximum losses for the human, whichever was more. This made it
perform BETTER, but still not perfect. I could still beat it.</p>
<p>So I have two ideas and I'm hoping for input on which is better:</p>
<p>1) Instead of maximizing the wins or losses, instead I could assign values of
1 for a win, 0 for a draw, and -1 for a loss. Then choosing the tree with the
highest value will be the best move because that next node can't be a move
that results in a loss. It's an easy change in the board generation, but it
retains the same search space and memory usage. Or...</p>
<p>2) During board generation, if there is a board such that either X or O will
win in their next move, only the child that prevents that win will be
generated. No other child nodes will be considered, and then generation will
proceed as normal after that. It shrinks the size of the tree, but then I have
to implement an algorithm to determine if there is a one move win and I think
that can only be done in linear time (making board generation a lot slower I
think?)</p>
<p>Which is better, or is there an even better solution?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The (usually) correct way to implement AI based on a decision tree is to use
the " <strong>Minimax</strong> " algorithm:</p>
<ol>
<li>Assign each leaf node a score (+1=player wins, -1=player loses, 0=tie)</li>
<li>
<p>Work your way up the tree, applying the following rules to each node:</p>
<ul>
<li>For even depths (when the player would make a move), pick the child with the highest score, and copy that score to the node.</li>
<li>For odd depths (when the computer would make a move), pick the child with the lowest score, and copy that score to the node.</li>
</ul>
</li>
</ol>
<p>Of course, even and odd might need to be reversed, depending on who you decide
goes first.</p>
<p>You can read more at:</p>
<ul>
<li>http://ai-depot.com/articles/minimax-explained/</li>
<li>http://en.wikipedia.org/wiki/Minimax</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>Your existing algorithm is good, except you are forgetting one thing. Never
choose any path where a move by the other player results in you being unable
to at least tie.</p>
<p>So basically, discard any branch where the players next move could result in
an un-tieable situation and then run your existing algorithm. This results in
the highest chance of winning against a non-perfect opponent, while removing
the possibility of losing.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/implementation-of-the-bidirectional-graph-search/" class="u-url">Implementation of the bidirectional graph search</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/implementation-of-the-bidirectional-graph-search/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:35:34+08:00" itemprop="datePublished" title="2023-02-28 03:35">2023-02-28 03:35</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am trying to implement a bi-directional graph search. As I understand, I
should somehow merge two breadth-first searches, one which starts at the
starting (or root) node and one which starts at the goal (or end) node. The
bi-directional search terminates when both breadth-first searches "meet" at
the same vertex.</p>
<p>Could you provide me with a code example (in Java, if possible) or link with
code for the bidirectional graph search?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Assuming you have <code>Node</code>s like this (in the file <code>Node.java</code>):</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">T</span> <span class="n">data</span><span class="p">;</span> <span class="o">//</span> <span class="n">The</span> <span class="n">data</span> <span class="n">that</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">store</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">node</span><span class="o">.</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">adjacentNodes</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Constructor</span>
    <span class="n">public</span> <span class="n">Node</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Getters</span>

    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">Returns</span> <span class="n">the</span> <span class="n">data</span> <span class="n">stored</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">node</span><span class="o">.</span>
     <span class="o">*</span> <span class="o">*/</span>
    <span class="n">public</span> <span class="n">T</span> <span class="n">getData</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">Returns</span> <span class="n">a</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">the</span> <span class="n">adjacent</span> <span class="n">nodes</span> <span class="n">of</span> <span class="n">this</span> <span class="n">node</span><span class="o">.</span>
     <span class="o">*</span> <span class="o">*/</span>
    <span class="n">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">getAdjacentNodes</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">adjacentNodes</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Setters</span>

    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">Attempts</span> <span class="n">to</span> <span class="n">add</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">adjacent</span> <span class="n">nodes</span> <span class="n">of</span> <span class="n">this</span> <span class="n">node</span><span class="o">.</span> <span class="n">If</span> <span class="n">it</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">previously</span> <span class="n">added</span><span class="p">,</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">added</span><span class="p">,</span> <span class="ow">and</span>
     <span class="o">*</span> <span class="n">true</span> <span class="ow">is</span> <span class="n">returned</span><span class="o">.</span> <span class="n">If</span> <span class="n">it</span> <span class="n">was</span> <span class="n">previously</span> <span class="n">added</span><span class="p">,</span> <span class="n">it</span> <span class="n">returns</span> <span class="n">false</span><span class="o">.</span>
     <span class="o">*</span> <span class="o">*/</span>
    <span class="n">public</span> <span class="n">boolean</span> <span class="n">addAdjacent</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">adjacentNodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Then the bidirectional search algorithm (defined in the file
<code>BidirectionalSearch.java</code>) would look something like this:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="p">;</span>


<span class="n">public</span> <span class="k">class</span> <span class="nc">BidirectionalSearch</span> <span class="p">{</span>

    <span class="o">/*</span>
     <span class="o">*</span> <span class="n">Returns</span> <span class="n">true</span> <span class="k">if</span> <span class="n">a</span> <span class="n">path</span> <span class="n">exists</span> <span class="n">between</span> <span class="n">Node</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">,</span> <span class="n">false</span> <span class="n">otherwise</span><span class="o">.</span>
     <span class="o">*</span> <span class="o">*/</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">boolean</span> <span class="n">pathExists</span><span class="p">(</span><span class="n">Node</span> <span class="n">a</span><span class="p">,</span> <span class="n">Node</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">LinkedList</span> <span class="n">implements</span> <span class="n">the</span> <span class="n">Queue</span> <span class="n">interface</span><span class="p">,</span> <span class="n">FIFO</span> <span class="n">queue</span> <span class="n">operations</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="n">add</span> <span class="ow">and</span> <span class="n">poll</span><span class="p">)</span><span class="o">.</span>

        <span class="o">//</span> <span class="n">Queue</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">paths</span> <span class="kn">from</span> <span class="nn">Node</span> <span class="n">a</span><span class="o">.</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">queueA</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

        <span class="o">//</span> <span class="n">Queue</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">paths</span> <span class="kn">from</span> <span class="nn">Node</span> <span class="n">a</span><span class="o">.</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">queueB</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

        <span class="o">//</span> <span class="n">A</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">visited</span> <span class="n">nodes</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">Node</span> <span class="n">a</span><span class="o">.</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">visitedA</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>

        <span class="o">//</span> <span class="n">A</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">visited</span> <span class="n">nodes</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">Node</span> <span class="n">b</span><span class="o">.</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">visitedB</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">();</span>

        <span class="n">visitedA</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">visitedB</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

        <span class="n">queueA</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="n">queueB</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Both</span> <span class="n">queues</span> <span class="n">need</span> <span class="n">to</span> <span class="n">be</span> <span class="n">empty</span> <span class="n">to</span> <span class="n">exit</span> <span class="n">the</span> <span class="k">while</span> <span class="n">loop</span><span class="o">.</span>
        <span class="k">while</span> <span class="p">(</span><span class="err">!</span><span class="n">queueA</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="o">||</span> <span class="err">!</span><span class="n">queueB</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pathExistsHelper</span><span class="p">(</span><span class="n">queueA</span><span class="p">,</span> <span class="n">visitedA</span><span class="p">,</span> <span class="n">visitedB</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pathExistsHelper</span><span class="p">(</span><span class="n">queueB</span><span class="p">,</span> <span class="n">visitedB</span><span class="p">,</span> <span class="n">visitedA</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">static</span> <span class="n">boolean</span> <span class="n">pathExistsHelper</span><span class="p">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">,</span>
                                            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">visitedFromThisSide</span><span class="p">,</span>
                                            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">visitedFromThatSide</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">queue</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Node</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>

            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">adjacentNodes</span> <span class="o">=</span> <span class="nb">next</span><span class="o">.</span><span class="n">getAdjacentNodes</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">adjacent</span> <span class="p">:</span> <span class="n">adjacentNodes</span><span class="p">)</span> <span class="p">{</span>

                <span class="o">//</span> <span class="n">If</span> <span class="n">the</span> <span class="n">visited</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">starting</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">other</span> <span class="n">direction</span><span class="p">,</span>
                <span class="o">//</span> <span class="n">contain</span> <span class="n">the</span> <span class="s2">"adjacent"</span> <span class="n">node</span> <span class="n">of</span> <span class="s2">"next"</span><span class="p">,</span> <span class="n">then</span> <span class="n">we</span> <span class="n">can</span> <span class="n">terminate</span> <span class="n">the</span> <span class="n">search</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">visitedFromThatSide</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">adjacent</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">visitedFromThisSide</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">Test</span> <span class="n">here</span> <span class="n">the</span> <span class="n">implementation</span> <span class="n">above</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1426.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1424.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
