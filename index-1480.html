<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1480) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1480.html">
<link rel="prev" href="index-1481.html" type="text/html">
<link rel="next" href="index-1479.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/limit-of-number-of-nodes-in-hyperledger/" class="u-url">Limit of number of nodes in Hyperledger</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/limit-of-number-of-nodes-in-hyperledger/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T05:02:27+08:00" itemprop="datePublished" title="2023-02-28 05:02">2023-02-28 05:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In Hyperledger-fabric blockchain, is there a limit to the number of nodes
participating in a network? If yes, how many nodes can be in a network?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>To get the complete functionality of blockchain(consensus mechanism,
hyperledger fabric uses PBFT consensus which means it will accept any
transaction to be valid if more than 66% of the nodes are up and running.</p>
<p>In short more than 66% of nodes must be up and must validate the order to
requests in Hyperledger farbic.</p>
<p>Both the Starter Developer plan and the High Security Business Network plan
enable you to test the Practical Byzantine Fault Tolerance (PBFT) consensus
protocol on a four-node blockchain network</p>
<p>Consensus is a method for validating the order of requests, or transactions
(deploy and invoke), on a blockchain network. The correct ordering of
transactions is critical, because many transactions have a dependency on one
or more prior transactions (account debits often have a dependency on prior
credits, for example).</p>
<p>The network can tolerate no more than one Byzantine node. Each network
contains N=4 nodes, so applying the formula for the maximum number of
tolerated Byzantine nodes results in: f=(4-1)/3=1. If two or more Byzantine
nodes (f&gt;1) exist, a the 4-node PBFT network cannot guarantee consistency or
integrity of the ledger across all nodes. (For comparison, tolerating two
Byzantine nodes would require f=(7-1)/3=2, or a minimum 7-node PBFT blockchain
network.)</p>
<p><br></p>
<h3>Suggest</h3>
<p>In Hyperledger Fabric, nodes can be of type orderers, endrosing peers or
clients. Are you asking about a number of <strong>Byzantine</strong> nodes, or the number
of nodes <strong>in general</strong>?</p>
<ol>
<li>If you are asking about how many <strong>Byzantine</strong> nodes, then the precise answer is as follows: a) There is <strong><em>no limit</em></strong> on Byzantine peers and clients. If there are too many of them, a client just won't be able to get his transaction endorsed. However the integrity of the system is not endangered. b) Since the consensus algorithm is run between the <em>orderers</em> , then the limit depends on that specific algorithm used. Remember Hyperledger Fabric supports <em>pluggable</em> consensus, meaning that the consensus algorithm is not necessarily hardcoded. In its current implementation, Hypeledger Fabric runs "Kafka" which is NOT Byzantine-Fault tolerant. This means that <strong>even one</strong> Byzantine orderer can compromise the whole system! However, there are plans for BFT-Smart which is Byzantine-Fault tolerant and supports up to 33% faulty nodes, as the above answer says.</li>
<li>If you are asking about the total number of nodes, then the precise answer is as follows: a) There is (theoretically) <strong><em>no limit</em></strong> on the number of clients-peers. b) The <em>practical</em> limit of orderers again depends on the consensus. For BFT, this translates up to practically 10 (maybe 20) orderers. c) The <em>practical</em> limit of peers depends on the network latency. The Hyperledger paper by Androulaki et al. has an evaluation up to 100 peers showing its performance in a WAN and a LAN environment.</li>
</ol>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-does-the-minting-function-of-erc721-have-an-access-control/" class="u-url">Why does the minting function of ERC721 have an access control?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-does-the-minting-function-of-erc721-have-an-access-control/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T05:02:10+08:00" itemprop="datePublished" title="2023-02-28 05:02">2023-02-28 05:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Most of the ERC721 examples using Open Zeppelin I see require the mint
function to have an access control where only the owner of the contract is
allowed to call the function. For example,</p>
<div class="code"><pre class="code literal-block"><span class="nt">function</span><span class="w"> </span><span class="nt">mint</span><span class="o">(</span><span class="nt">address</span><span class="w"> </span><span class="nt">to</span><span class="o">)</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">virtual</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">require(hasRole(MINTER_ROLE,</span><span class="w"> </span><span class="err">_msgSender()),</span><span class="w"> </span><span class="err">"</span><span class="n">ERC721PresetMinterPauserAutoId</span><span class="p">:</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">minter</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="kc">to</span><span class="w"> </span><span class="n">mint</span><span class="err">"</span><span class="p">);</span>

<span class="w">    </span><span class="err">_mint(to,</span><span class="w"> </span><span class="err">_tokenIdTracker.current())</span><span class="p">;</span>
<span class="w">    </span><span class="err">_tokenIdTracker.increment()</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>or the following using the Ownable library.</p>
<div class="code"><pre class="code literal-block"><span class="nv">function</span><span class="w"> </span><span class="nv">mint</span><span class="ss">(</span><span class="nv">address</span><span class="w"> </span><span class="nv">receiver</span><span class="ss">)</span><span class="w"> </span><span class="nv">external</span><span class="w"> </span><span class="nv">onlyOwner</span><span class="w"> </span><span class="nv">returns</span><span class="w"> </span><span class="ss">(</span><span class="nv">uint256</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">_tokenIds</span>.<span class="nv">increment</span><span class="ss">()</span><span class="c1">;</span>

<span class="w">    </span><span class="nv">uint256</span><span class="w"> </span><span class="nv">newTokenId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">_tokenIds</span>.<span class="nv">current</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">_mint</span><span class="ss">(</span><span class="nv">receiver</span>,<span class="w"> </span><span class="nv">newTokenId</span><span class="ss">)</span><span class="c1">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">newTokenId</span><span class="c1">;</span>
}
</pre></div>

<p>Does this mean a new contract has to be deployed each time a new token is
minted? This seems not only excessive in terms of the gas fee, but also the
ERC721 contract has properties for mapping different owners and tokens:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Mapping from token ID to owner address</span>
<span class="n">mapping</span><span class="w"> </span><span class="p">(</span><span class="n">uint256</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">address</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">_owners</span><span class="p">;</span>

<span class="c1">// Mapping owner address to token count</span>
<span class="n">mapping</span><span class="w"> </span><span class="p">(</span><span class="n">address</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uint256</span><span class="p">)</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">_balances</span><span class="p">;</span>
</pre></div>

<p>which wouldn't make sense if minting is restricted to the contract owner.</p>
<p>It makes more sense to me that you deploy a single ERC721 contract (and its
dependencies) and have the users call the mint function. What is the best
practice for the mint function of ERC721?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The ERC-721 standard does not define a "best" or "correct" way to mint new
tokens (such as whether it should be open or restricted) and it's up to each
contract developer to implement or omit the minting feature in a way that
reflects their needs.</p>
<blockquote>
<p><em>Creating of NFTs ("minting") and destruction NFTs ("burning") is not
included in the specification. Your contract may implement these by other
means. Please see the event documentation for your responsibilities when
creating or destroying NFTs.</em></p>
</blockquote>
<p>But having a whitelist of addresses that are authorized to mint new tokens
(e.g. <code>MINTER_ROLE</code> or <code>onlyOwner</code>) seems to be more common than allowing
anyone to freely mint new tokens.</p>
<hr>
<p>Even though it's theoretically possible to deploy new contract each time a new
token is minted, it's not a standard approach (and I personally haven't seen
any contract that does it). In most cases the minting process "just" creates a
new ID, stores a new string/URL value associated with the ID, associates this
new token with an owner address (of the token, not a contract owner), plus
updates some metadata such as amount of tokens owned by an address (see
example below).</p>
<p>The token owner can then transfer their tokens, give anyone control over their
tokens, and do other stuff depending on the contract implementation.</p>
<p>The mappings that you point out in your question (<code>_owners</code> and <code>_balances</code>)
suggest that they store token owner (not contract owner) addresses as well as
amount of tokens held by each address.</p>
<p>Example:</p>
<ol>
<li>
<p>Contract owner mints token ID <code>1</code> to address <code>0x123</code>.</p>
<ul>
<li>
<p>Value of <code>_owners[1]</code> is <code>0x123</code> (was 0, the default value)</p>
</li>
<li>
<p>Value of <code>_balances[0x123]</code> becomes <code>1</code> (was 0, the default value)</p>
</li>
</ul>
</li>
<li>
<p>Contract owner mints token ID <code>2</code> to address <code>0x123</code>.</p>
<ul>
<li>
<p>Value of <code>_owners[1]</code> is still <code>0x123</code></p>
</li>
<li>
<p>Value of <code>_owners[2]</code> is now <code>0x123</code> (was 0, the default value)</p>
</li>
<li>
<p>Value of <code>_balances[0x123]</code> becomes <code>2</code> (because they now own 2 tokens)</p>
</li>
</ul>
</li>
</ol>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ipfs-and-editing-permissions/" class="u-url">IPFS and Editing Permissions</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ipfs-and-editing-permissions/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T05:01:53+08:00" itemprop="datePublished" title="2023-02-28 05:01">2023-02-28 05:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I just uploaded a folder of 5 images to IPFS (using the Mac Desktop IPFS
Client App, so it was a very simple drag and drop operation.)</p>
<p>So being that I’m the one that created and published this folder, does that
mean that I’m the only one that’s allowed to make further modifications to it
- like adding or deleting more images from it? Or can anyone out there on IPFS
do that as well?</p>
<p>If they can, is there a way to prevent that from happening?</p>
<p>=======================================</p>
<p>UPDATED QUESTION:</p>
<p>My specific use-case has to do with updating the metadata of ERC721 Tokens -
<em><strong>after</strong></em> they’ve already been minted.</p>
<p>Imagine for example a game where certain objects - like say a magical sword -
gains special powers after a certain amount of usage or after the completion
of certain missions by its owner. So we’d want to update this sword’s
attributes by editing it’s Metadata and re-committing this updated metadata
file to the Blockchain.</p>
<p>If our game has 100 swords for example, and we initially uploaded to IPFS a
folder containing all 100 json files (one for each sword), then I’m pretty
sure IPFS still let’s you access the specific files within the hashed-folder
by their specific human-readable names (and not only by their hash.) So if our
sword happens to be sword #76, and our naming convention for our JSON files
was of this format: <code>“sword000.json”</code> , then sword#76’s JSON metadata file
would have a path such as:
http://ipfs.infura.io/QmY2xxxxxxxxxxxxxxxxxxxxxx/sword076.json</p>
<p>If we then edited the “sword076.json“ file and drag-n-dropped it back into our
master JSON folder, it would obviously cause that folder’s Hash/CID value to
change. BUT, as long as we’re able update our Solidity Contract’s “tokenURI”
method to look for and serve our “.json” files from this newly updated
HASH/CID folder name, we could still refer to the individual files within it
by their regular English names. Which means we’d be good to go.</p>
<p>Whether or not this is a good scheme to employ is something we can definitely
discuss, but I FIRST want to go back to my original question/concern, which is
that I want to make sure that WE are the ONLY ones that can update the
contents of our folder - and that no one else has permission to do that.</p>
<p>Does that make sense?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>IPFS is immutable, meaning when you add your directory along with the files,
the directory gets a unique CID based on the contents of the directory. So in
a sense, nobody can modify it, not even you, because it's immutable. I believe
this confusion can be resolved with more background on how IPFS works.</p>
<p>When you add things to IPFS each file is hashed, and given a CID. The same is
true for directories, but their CID can more easily be understood as a sum of
the contents of the directory. So if any files in the directory are updated,
added, or deleted, the directory gets a new CID.</p>
<p>Understanding this, if someone else added the exact same content in the exact
same way, they'd end up with the exact same CID! With this, if two people
added the same CID, and a third person requested that file (or directory),
both nodes would be able to serve the data, as we know it's exactly the same.
The same is true if you simply shared your CID and another node pinned it,
both nodes would have the same data, so if anyone requested it, both nodes
would be able to serve it.</p>
<p>So your local copy, cannot be edited by anyone. In a sense, if you're relying
on the IPFS CID as the address of your data, not even by you! This is why IPFS
is typically referred to as "immutable", because any data you request via an
IPFS CID will always be the same. If you change any of the data, you'll get a
new CID.</p>
<p>More info can be found here: Content Addressing &amp; Immutability</p>
<p>If you read all this and thought "well what if I want mutable data?", I'd
recommend looking into IPNS and possibly ipfs-sync if you're looking for a
tool to automatically update IPNS for you.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1481.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1479.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
