<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 32) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-32.html">
<link rel="prev" href="index-33.html" type="text/html">
<link rel="next" href="index-31.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/iterating-over-dictionaries-using-for-loops/" class="u-url">Iterating over dictionaries using 'for' loops</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/iterating-over-dictionaries-using-for-loops/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:09:41+08:00" itemprop="datePublished" title="2023-02-16 19:09">2023-02-16 19:09</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div class="code"><pre class="code literal-block"><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="s1">'x'</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">'y'</span><span class="err">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">'z'</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="err">}</span>

<span class="k">for</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">d</span><span class="p">:</span>
<span class="w">    </span><span class="k">print</span><span class="p">(</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="s1">'corresponds to'</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">)</span>
</pre></div>

<p>How does Python recognize that it needs only to read the <code>key</code> from the
dictionary? Is <code>key</code> a special keyword, or is it simply a variable?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><code>key</code> is just a variable name.</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>:
</pre></div>

<p>will simply loop over the keys in the dictionary, rather than the keys and
values. To loop over both key and value you can use the following:</p>
<p>For Python 3.x:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">key</span>,<span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">items</span><span class="ss">()</span>:
</pre></div>

<p>For Python 2.x:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">key</span>,<span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">iteritems</span><span class="ss">()</span>:
</pre></div>

<p>To test for yourself, change the word <code>key</code> to <code>poop</code>.</p>
<p>In Python 3.x, <code>iteritems()</code> was replaced with simply <code>items()</code>, which returns
a set-like view backed by the dict, like <code>iteritems()</code> but even better. This
is also available in 2.7 as <code>viewitems()</code>.</p>
<p>The operation <code>items()</code> will work for both 2 and 3, but in 2 it will return a
list of the dictionary's <code>(key, value)</code> pairs, which will not reflect changes
to the dict that happen after the <code>items()</code> call. If you want the 2.x behavior
in 3.x, you can call <code>list(d.items())</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>It's not that key is a special word, but that dictionaries implement the
iterator protocol. You could do this in your class, e.g. see this question for
how to build class iterators.</p>
<p>In the case of dictionaries, it's implemented at the C level. The details are
available in PEP 234. In particular, the section titled "Dictionary
Iterators":</p>
<blockquote>
<ul>
<li>
<p>Dictionaries implement a tp_iter slot that returns an efficient iterator
that iterates over the keys of the dictionary. [...] This means that we can
write</p>
<blockquote>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">dict</span>:<span class="w"> </span>...
</pre></div>

</blockquote>
</li>
</ul>
<p>which is equivalent to, but much faster than</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">dict</span>.<span class="nv">keys</span><span class="ss">()</span>:<span class="w"> </span>...
</pre></div>

<p>as long as the restriction on modifications to the dictionary (either by the
loop or by another thread) are not violated.</p>
<ul>
<li>
<p>Add methods to dictionaries that return different kinds of iterators
explicitly:</p>
<blockquote>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">dict</span>.<span class="nv">iterkeys</span><span class="ss">()</span>:<span class="w"> </span>...
</pre></div>

</blockquote>
<p>for value in dict.itervalues(): ...</p>
<p>for key, value in dict.iteritems(): ...</p>
</li>
</ul>
<p>This means that <code>for x in dict</code> is shorthand for <code>for x in dict.iterkeys()</code>.</p>
</blockquote>
<p>In Python 3, <code>dict.iterkeys()</code>, <code>dict.itervalues()</code> and <code>dict.iteritems()</code> are
no longer supported. Use <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code>
instead.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-pair-socks-from-a-pile-efficiently/" class="u-url">How can I pair socks from a pile efficiently?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-pair-socks-from-a-pile-efficiently/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:09:13+08:00" itemprop="datePublished" title="2023-02-16 19:09">2023-02-16 19:09</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Yesterday I was pairing the socks from the clean laundry and figured out the
way I was doing it is not very efficient. I was doing a naive search — picking
one sock and "iterating" the pile in order to find its pair. This requires
iterating over n/2 * n/4 = n2/8 socks on average.</p>
<p>As a computer scientist I was thinking what I could do? Sorting (according to
size/color/...) of course came to mind to achieve an O(NlogN) solution.</p>
<p>Hashing or other not-in-place solutions are not an option, because I am not
able to duplicate my socks (though it could be nice if I could).</p>
<p><strong>So, the question is basically:</strong></p>
<p>Given a pile of <code>n</code> pairs of socks, containing <code>2n</code> elements (assume each sock
has exactly one matching pair), what is the best way to pair them up
efficiently with up to logarithmic extra space? (I believe I can remember that
amount of info if needed.)</p>
<p>I will appreciate an answer that addresses the following aspects:</p>
<ul>
<li>A general <em>theoretical</em> solution for a huge number of socks.</li>
<li>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</li>
<li>Is it equivalent to the element distinctness problem?</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p>Sorting solutions have been proposed, but <strong>sorting is a little too much</strong> :
We don't need order; <strong>we just need equality groups</strong>.</p>
<p>So <strong>hashing</strong> would be enough (and faster).</p>
<ol>
<li>For each color of socks, <strong>form a pile</strong>. Iterate over all socks in your input basket <strong>and distribute them onto the color piles</strong>.</li>
<li>Iterate over each pile and <strong>distribute it by some other metric</strong> (e.g. pattern) into the second set of piles</li>
<li>
<strong>Recursively apply this scheme</strong> until you have distributed all socks onto <strong>very small piles that you can visually process immediately</strong>
</li>
</ol>
<p>This kind of recursive hash partitioning is actually being done by SQL Server
when it needs to hash join or hash aggregate over huge data sets. It
distributes its build input stream into many partitions which are independent.
This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</p>
<p>You don't need recursive partitioning if you can find a distribution key (hash
key) that <strong>provides enough buckets</strong> that each bucket is small enough to be
processed very quickly. Unfortunately, I don't think socks have such a
property.</p>
<p>If each sock had an integer called "PairID" one could easily distribute them
into 10 buckets according to <code>PairID % 10</code> (the last digit).</p>
<p>The best real-world partitioning I can think of is creating a <strong>rectangle of
piles</strong> : one dimension is color, the other is the pattern. Why a rectangle?
Because we need O(1) random-access to piles. (A 3D cuboid would also work, but
that is not very practical.)</p>
<hr>
<p>Update:</p>
<p>What about <strong>parallelism</strong>? Can multiple humans match the socks faster?</p>
<ol>
<li>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. <strong>The synchronization costs</strong> (manifesting themselves as hand-collisions and human communication) <strong>destroy efficiency and speed-up</strong> (see the Universal Scalability Law!). Is this prone to <strong>deadlocks</strong>? No, because each worker only needs to access one pile at a time. With just one "lock" there cannot be a deadlock. <strong>Livelocks</strong> might be possible depending on how the humans coordinate access to piles. They might just use random backoff like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for NICs, it should work for humans as well.</li>
<li>It scales nearly indefinitely if <strong>each worker has its own set of piles</strong>. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an <strong>aggregation tree</strong>.</li>
</ol>
<p>What about the element distinctness problem? As the article states, the
element distinctness problem can be solved in <code>O(N)</code>. This is the same for the
socks problem (also <code>O(N)</code>, if you need only one distribution step (I proposed
multiple steps only because humans are bad at calculations - one step is
enough if you distribute on <code>md5(color, length, pattern, ...)</code>, i.e. a
<strong>perfect hash</strong> of all attributes)).</p>
<p>Clearly, one cannot go faster than <code>O(N)</code>, so we have reached the <strong>optimal
lower bound</strong>.</p>
<p>Although the outputs are not exactly the same (in one case, just a boolean. In
the other case, the pairs of socks), the asymptotic complexities are the same.</p>
<p><br></p>
<h3>Suggest</h3>
<p>As the architecture of the human brain is completely different than a modern
CPU, this question makes no practical sense.</p>
<p>Humans can win over CPU algorithms using the fact that "finding a matching
pair" can be one operation for a set that isn't too big.</p>
<p>My algorithm:</p>
<div class="code"><pre class="code literal-block"><span class="nv">spread_all_socks_on_flat_surface</span><span class="ss">()</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">socks_left_on_a_surface</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="nv">Thanks</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">human</span><span class="w"> </span><span class="nv">visual</span><span class="w"> </span><span class="nv">SIMD</span>,<span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span>,<span class="w"> </span><span class="nv">quick</span><span class="w"> </span><span class="nv">operation</span>.
<span class="w">     </span><span class="nv">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">notice_any_matching_pair</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">     </span><span class="nv">remove_socks_pair_from_surface</span><span class="ss">(</span><span class="nv">pair</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>At least this is what I am using in real life, and I find it very efficient.
The downside is it requires a flat surface, but it's usually abundant.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-restful-programming/" class="u-url">What is RESTful programming?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-restful-programming/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:08:40+08:00" itemprop="datePublished" title="2023-02-16 19:08">2023-02-16 19:08</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What exactly is RESTful programming?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>An <strong>architectural style</strong> called <strong>REST (Representational State Transfer)</strong>
advocates that web applications should use HTTP as it was <strong>originally
envisioned</strong>. Lookups should use <code>GET</code> requests. <code>PUT</code>, <code>POST</code>, and <code>DELETE</code>
requests should be used for <strong>mutation</strong> , <strong>creation</strong> , and <strong>deletion</strong>
respectively.</p>
<p>REST proponents tend to favor URLs, such as</p>
<div class="code"><pre class="code literal-block">http://myserver.com/catalog/item/1729
</pre></div>

<p>but the REST architecture does not require these "pretty URLs". A GET request
with a parameter</p>
<div class="code"><pre class="code literal-block">http://myserver.com/catalog?item=1729
</pre></div>

<p>is every bit as RESTful.</p>
<p>Keep in mind that GET requests should never be used for updating information.
For example, a GET request for adding an item to a cart</p>
<div class="code"><pre class="code literal-block">http://myserver.com/addToCart?cart=314159&amp;item=1729
</pre></div>

<p>would not be appropriate. GET requests should be idempotent. That is, issuing
a request twice should be no different from issuing it once. That's what makes
the requests cacheable. An "add to cart" request is not idempotent—issuing it
twice adds two copies of the item to the cart. A POST request is clearly
appropriate in this context. Thus, even a <strong>RESTful web application</strong> needs
its share of POST requests.</p>
<p>This is taken from the excellent book <em>Core JavaServer faces</em> book by David M.
Geary.</p>
<p><br></p>
<h3>Suggest</h3>
<p>An <strong>architectural style</strong> called <strong>REST (Representational State Transfer)</strong>
advocates that web applications should use HTTP as it was <strong>originally
envisioned</strong>. Lookups should use <code>GET</code> requests. <code>PUT</code>, <code>POST</code>, and <code>DELETE</code>
requests should be used for <strong>mutation</strong> , <strong>creation</strong> , and <strong>deletion</strong>
respectively.</p>
<p>REST proponents tend to favor URLs, such as</p>
<div class="code"><pre class="code literal-block">http://myserver.com/catalog/item/1729
</pre></div>

<p>but the REST architecture does not require these "pretty URLs". A GET request
with a parameter</p>
<div class="code"><pre class="code literal-block">http://myserver.com/catalog?item=1729
</pre></div>

<p>is every bit as RESTful.</p>
<p>Keep in mind that GET requests should never be used for updating information.
For example, a GET request for adding an item to a cart</p>
<div class="code"><pre class="code literal-block">http://myserver.com/addToCart?cart=314159&amp;item=1729
</pre></div>

<p>would not be appropriate. GET requests should be idempotent. That is, issuing
a request twice should be no different from issuing it once. That's what makes
the requests cacheable. An "add to cart" request is not idempotent—issuing it
twice adds two copies of the item to the cart. A POST request is clearly
appropriate in this context. Thus, even a <strong>RESTful web application</strong> needs
its share of POST requests.</p>
<p>This is taken from the excellent book <em>Core JavaServer faces</em> book by David M.
Geary.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-33.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-31.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
