<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 580) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-580.html">
<link rel="prev" href="index-581.html" type="text/html">
<link rel="next" href="index-579.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-cancel-a-local-git-commit/" class="u-url">How to cancel a local git commit?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-cancel-a-local-git-commit/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:30:35+08:00" itemprop="datePublished" title="2023-02-17 10:30">2023-02-17 10:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>My issue is I have changed a file e.g.: README, added a new line ' <em>this for
my testing line</em> ' and saved the file, then I issued the following commands:</p>
<div class="code"><pre class="code literal-block">git status

# On branch master
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
#
#   modified:   README
#
no changes added to commit (use "git add" and/or "git commit -a")


git add README

git commit -a -m 'To add new line to readme'
</pre></div>

<p>I didn't push the code to GitHub. Now I want to cancel this commit.</p>
<p>For this, I used</p>
<div class="code"><pre class="code literal-block">git reset --hard HEAD~1
</pre></div>

<p>But I lost the newly added line ' <em>this for my testing line</em> ' from the README
file. This should not happen. I need the content to be there. <strong>Is there a way
to retain the content and cancel my local commit?</strong></p>
<p><br><br></p>
<h2>Answer</h2>
<p>Just use <code>git reset</code> without the <code>--hard</code> flag:</p>
<div class="code"><pre class="code literal-block">git reset HEAD~1
</pre></div>

<p>PS: On Unix based systems you can use <code>HEAD^</code> which is equal to <code>HEAD~1</code>. On
Windows <code>HEAD^</code> will not work because <code>^</code> signals a line continuation. So your
command prompt will just ask you <code>More?</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Use <code>--soft</code> instead of <code>--hard</code> flag.</p>
<p>Unix:</p>
<div class="code"><pre class="code literal-block">git reset --soft HEAD^
</pre></div>

<p>Windows:</p>
<div class="code"><pre class="code literal-block">git reset --soft HEAD~
</pre></div>

<p>It will remove the last local (unpushed) commit, but will keep changes you
have done.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works/" class="u-url">What is __future__ in Python used for and how/when to use it, and how it works</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:30:08+08:00" itemprop="datePublished" title="2023-02-17 10:30">2023-02-17 10:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>__future__</code> frequently appears in Python modules. I do not understand what
<code>__future__</code> is for and how/when to use it even after reading the Python's
<code>__future__</code> doc.</p>
<p>Can anyone explain with examples?</p>
<p>A few answers regarding the basic usage of <code>__future__</code> I've received seemed
correct.</p>
<p>However, I need to understand one more thing regarding how <code>__future__</code> works:</p>
<p>The most confusing concept for me is how a current python release includes
features for future releases, and how a program using a feature from a future
release can be be compiled successfully in the current version of Python.</p>
<p>I am guessing that the current release is packaged with potential features for
the future. However, the features are available only by using <code>__future__</code>
because they are not the current standard. Let me know if I am right.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>With <code>__future__</code> module's inclusion, you can slowly be accustomed to
incompatible changes or to such ones introducing new keywords.</p>
<p>E.g., for using context managers, you had to do <code>from __future__ import
with_statement</code> in 2.5, as the <code>with</code> keyword was new and shouldn't be used as
variable names any longer. In order to use <code>with</code> as a Python keyword in
Python 2.5 or older, you will need to use the import from above.</p>
<p>Another example is</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="nb">print</span> <span class="mi">8</span><span class="o">/</span><span class="mi">7</span>  <span class="c1"># prints 1.1428571428571428</span>
<span class="nb">print</span> <span class="mi">8</span><span class="o">//</span><span class="mi">7</span> <span class="c1"># prints 1</span>
</pre></div>

<p>Without the <code>__future__</code> stuff, both <code>print</code> statements would print <code>1</code>.</p>
<p>The internal difference is that without that import, <code>/</code> is mapped to the
<code>__div__()</code> method, while with it, <code>__truediv__()</code> is used. (In any case, <code>//</code>
calls <code>__floordiv__()</code>.)</p>
<p>Apropos <code>print</code>: <code>print</code> becomes a function in 3.x, losing its special
property as a keyword. So it is the other way round.</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="nb">print</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>When you do</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">whatever</span>
</pre></div>

<p>You're not actually using an <code>import</code> statement, but a future statement.
You're reading the wrong docs, as you're not actually importing that module.</p>
<p>Future statements are special -- they change how your Python module is parsed,
which is why they <strong>must</strong> be at the top of the file. They give new -- or
different -- meaning to words or symbols in your file. From the docs:</p>
<blockquote>
<p>A future statement is a directive to the compiler that a particular module
should be compiled using syntax or semantics that will be available in a
specified future release of Python. The future statement is intended to ease
migration to future versions of Python that introduce incompatible changes
to the language. It allows use of the new features on a per-module basis
before the release in which the feature becomes standard.</p>
</blockquote>
<p>If you actually want to import the <code>__future__</code> module, just do</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">__future__</span>
</pre></div>

<p>and then access it as usual.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/data-table-vs-dplyr-can-one-do-something-well-the-other-can-t-or-does-poorly/" class="u-url">data.table vs dplyr: can one do something well the other can't or does poorly?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/data-table-vs-dplyr-can-one-do-something-well-the-other-can-t-or-does-poorly/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:29:24+08:00" itemprop="datePublished" title="2023-02-17 10:29">2023-02-17 10:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <h4>Overview</h4>
<p>I'm relatively familiar with <code>data.table</code>, not so much with <code>dplyr</code>. I've read
through some <code>dplyr</code> vignettes and examples that have popped up on SO, and so
far my conclusions are that:</p>
<ol>
<li>
<code>data.table</code> and <code>dplyr</code> are comparable in speed, except when there are many (i.e. &gt;10-100K) groups, and in some other circumstances (see benchmarks below)</li>
<li>
<code>dplyr</code> has more accessible syntax</li>
<li>
<code>dplyr</code> abstracts (or will) potential DB interactions</li>
<li>There are some minor functionality differences (see "Examples/Usage" below)</li>
</ol>
<p>In my mind 2. doesn't bear much weight because I am fairly familiar with it
<code>data.table</code>, though I understand that for users new to both it will be a big
factor. I would like to avoid an argument about which is more intuitive, as
that is irrelevant for my specific question asked from the perspective of
someone already familiar with <code>data.table</code>. I also would like to avoid a
discussion about how "more intuitive" leads to faster analysis (certainly
true, but again, not what I'm most interested about here).</p>
<h4>Question</h4>
<p>What I want to know is:</p>
<ol>
<li>Are there analytical tasks that are a lot easier to code with one or the other package for people familiar with the packages (i.e. some combination of keystrokes required vs. required level of esotericism, where less of each is a good thing).</li>
<li>Are there analytical tasks that are performed substantially (i.e. more than 2x) more efficiently in one package vs. another.</li>
</ol>
<p>One recent SO question got me thinking about this a bit more, because up until
that point I didn't think <code>dplyr</code> would offer much beyond what I can already
do in <code>data.table</code>. Here is the <code>dplyr</code> solution (data at end of Q):</p>
<div class="code"><pre class="code literal-block">dat %.%
  group_by(name, job) %.%
  filter(job != "Boss" | year == min(year)) %.%
  mutate(cumu_job2 = cumsum(job2))
</pre></div>

<p>Which was much better than my hack attempt at a <code>data.table</code> solution. That
said, good <code>data.table</code> solutions are also pretty good (thanks Jean-Robert,
Arun, and note here I favored single statement over the strictly most optimal
solution):</p>
<div class="code"><pre class="code literal-block"><span class="nf">setDT</span><span class="p">(</span><span class="nv">dat</span><span class="p">)[,</span>
<span class="w">  </span><span class="o">.</span><span class="nv">SD</span><span class="p">[</span><span class="nv">job</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">"Boss"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">year</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="nv">year</span><span class="p">)][,</span><span class="w"> </span><span class="nv">cumjob</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">cumsum</span><span class="p">(</span><span class="nv">job2</span><span class="p">)],</span><span class="w"> </span>
<span class="w">  </span><span class="nv">by</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="nv">id</span><span class="p">,</span><span class="w"> </span><span class="nv">job</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>

<p>The syntax for the latter may seem very esoteric, but it actually is pretty
straightforward if you're used to <code>data.table</code> (i.e. doesn't use some of the
more esoteric tricks).</p>
<p>Ideally what I'd like to see is some good examples were the <code>dplyr</code> or
<code>data.table</code> way is substantially more concise or performs substantially
better.</p>
<h4>Examples</h4>
<p>Usage</p>
<ul>
<li>
<code>dplyr</code> does not allow grouped operations that return arbitrary number of rows (from <strong>eddi's question</strong> , note: this looks like it will be implemented in <strong>dplyr 0.5</strong> , also, @beginneR shows a potential work-around using <code>do</code> in the answer to @eddi's question).</li>
<li>
<code>data.table</code> supports <strong>rolling joins</strong> (thanks @dholstius) as well as <strong>overlap joins</strong>
</li>
<li>
<code>data.table</code> internally optimises expressions of the form <code>DT[col == value]</code> or <code>DT[col %in% values]</code> for <em>speed</em> through <em>automatic indexing</em> which uses <em>binary search</em> while using the same base R syntax. See here for some more details and a tiny benchmark.</li>
<li>
<code>dplyr</code> offers standard evaluation versions of functions (e.g. <code>regroup</code>, <code>summarize_each_</code>) that can simplify the programmatic use of <code>dplyr</code> (note programmatic use of <code>data.table</code> is definitely possible, just requires some careful thought, substitution/quoting, etc, at least to my knowledge)</li>
</ul>
<p>Benchmarks</p>
<ul>
<li>I ran <strong>my own benchmarks</strong> and found both packages to be comparable in "split apply combine" style analysis, except when there are very large numbers of groups (&gt;100K) at which point <code>data.table</code> becomes substantially faster.</li>
<li>@Arun ran some <strong>benchmarks on joins</strong> , showing that <code>data.table</code> scales better than <code>dplyr</code> as the number of groups increase (updated with recent enhancements in both packages and recent version of R). Also, a benchmark when trying to get <strong>unique values</strong> has <code>data.table</code> ~6x faster.</li>
<li>(Unverified) has <code>data.table</code> 75% faster on larger versions of a group/apply/sort while <code>dplyr</code> was 40% faster on the smaller ones ( <strong>another SO question from comments</strong> , thanks danas).</li>
<li>Matt, the main author of <code>data.table</code>, has <strong>benchmarked grouping operations on<code>data.table</code>, <code>dplyr</code> and python <code>pandas</code> on up to 2 billion rows (~100GB in RAM)</strong>.</li>
<li>An <strong>older benchmark on 80K groups</strong> has <code>data.table</code> ~8x faster</li>
</ul>
<h4>Data</h4>
<p>This is for the first example I showed in the question section.</p>
<div class="code"><pre class="code literal-block"><span class="n">dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">structure</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span>
<span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">),</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">),</span><span class="w"> </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1980L</span><span class="p">,</span><span class="w"> </span><span class="m">1981L</span><span class="p">,</span><span class="w"> </span><span class="m">1982L</span><span class="p">,</span><span class="w"> </span><span class="m">1983L</span><span class="p">,</span><span class="w"> </span><span class="m">1984L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1985L</span><span class="p">,</span><span class="w"> </span><span class="m">1986L</span><span class="p">,</span><span class="w"> </span><span class="m">1987L</span><span class="p">,</span><span class="w"> </span><span class="m">1985L</span><span class="p">,</span><span class="w"> </span><span class="m">1986L</span><span class="p">,</span><span class="w"> </span><span class="m">1987L</span><span class="p">,</span><span class="w"> </span><span class="m">1988L</span><span class="p">,</span><span class="w"> </span><span class="m">1989L</span><span class="p">,</span><span class="w"> </span><span class="m">1990L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1991L</span><span class="p">,</span><span class="w"> </span><span class="m">1992L</span><span class="p">),</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">),</span><span class="w"> </span><span class="n">job2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">)),</span><span class="w"> </span><span class="n">.Names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"id"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"name"</span><span class="p">,</span><span class="w"> </span><span class="s">"year"</span><span class="p">,</span><span class="w"> </span><span class="s">"job"</span><span class="p">,</span><span class="w"> </span><span class="s">"job2"</span><span class="p">),</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"data.frame"</span><span class="p">,</span><span class="w"> </span><span class="n">row.names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span>
<span class="m">-16L</span><span class="p">))</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>We need to cover at least these aspects to provide a comprehensive
answer/comparison (in no particular order of importance): <code>Speed</code>, <code>Memory
usage</code>, <code>Syntax</code> and <code>Features</code>.</p>
<p>My intent is to cover each one of these as clearly as possible from data.table
perspective.</p>
<blockquote>
<p>Note: unless explicitly mentioned otherwise, by referring to dplyr, we refer
to dplyr's data.frame interface whose internals are in C++ using Rcpp.</p>
</blockquote>
<hr>
<p>The data.table syntax is consistent in its form - <code>DT[i, j, by]</code>. To keep <code>i</code>,
<code>j</code> and <code>by</code> together is by design. By keeping related operations together, it
allows to <em>easily optimise</em> operations for <em>speed</em> and more importantly
<em>memory usage</em> , and also provide some <em>powerful features</em> , all while
maintaining the consistency in syntax.</p>
<h4>1. Speed</h4>
<p>Quite a few benchmarks (though mostly on grouping operations) have been added
to the question already showing data.table gets <em>faster</em> than dplyr as the
number of groups and/or rows to group by increase, including benchmarks by
Matt on grouping from <em>10 million to 2 billion rows</em> (100GB in RAM) on <em>100 -
10 million groups</em> and varying grouping columns, which also compares <code>pandas</code>.
See also updated benchmarks, which include <code>Spark</code> and <code>pydatatable</code> as well.</p>
<p>On benchmarks, it would be great to cover these remaining aspects as well:</p>
<ul>
<li>
<p>Grouping operations involving a <em>subset of rows</em> - i.e., <code>DT[x &gt; val, sum(y), by = z]</code> type operations.</p>
</li>
<li>
<p>Benchmark other operations such as <em>update</em> and <em>joins</em>.</p>
</li>
<li>
<p>Also benchmark <em>memory footprint</em> for each operation in addition to runtime.</p>
</li>
</ul>
<h4>2. Memory usage</h4>
<ol>
<li>Operations involving <code>filter()</code> or <code>slice()</code> in dplyr can be memory inefficient (on both data.frames and data.tables). See this post.</li>
</ol>
<blockquote>
<p>Note that Hadley's comment talks about <em>speed</em> (that dplyr is plentiful fast
for him), whereas the major concern here is <em>memory</em>.</p>
</blockquote>
<ol>
<li>data.table interface at the moment allows one to modify/update columns <em>by reference</em> (note that we don't need to re-assign the result back to a variable).<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="n">sub</span><span class="o">-</span><span class="k">assign</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">updates</span><span class="w"> </span><span class="sc">'y'</span><span class="w"> </span><span class="n">in</span><span class="o">-</span><span class="n">place</span>
</pre></div>

<p>DT[x &gt;= 1L, y := NA]</p>
</li>
</ol>
<p>But dplyr <em>will never</em> update by reference. The dplyr equivalent would be
(note that the result needs to be re-assigned):</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1"># copies the entire 'y' column</span>
<span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nf">mutate</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="nf">which</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">1L</span><span class="p">),</span><span class="w"> </span><span class="kc">NA</span><span class="p">))</span>
</pre></div>

<p>A concern for this is <em>referential transparency</em>. Updating a data.table object
by reference, especially within a function may not be always desirable. But
this is an incredibly useful feature: see this and this posts for interesting
cases. And we want to keep it.</p>
<p>Therefore we are working towards exporting <code>shallow()</code> function in data.table
that will provide the user with <em>both possibilities</em>. For example, if it is
desirable to not modify the input data.table within a function, one can then
do:</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">foo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">DT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">shallow</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w">          </span><span class="c1">## shallow copy DT</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">1L</span><span class="p">]</span><span class="w">        </span><span class="c1">## does not affect the original DT </span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">2L</span><span class="p">]</span><span class="w">  </span><span class="c1">## no need to copy (internally), as this column exists only in shallow copied DT</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">3L</span><span class="p">]</span><span class="w">       </span><span class="c1">## have to copy (like base R / dplyr does always); otherwise original DT will </span>
<span class="w">                               </span><span class="c1">## also get modified.</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p>By not using <code>shallow()</code>, the old functionality is retained:</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">bar</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">1L</span><span class="p">]</span><span class="w">        </span><span class="c1">## old behaviour, original DT gets updated by reference</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">3L</span><span class="p">]</span><span class="w">       </span><span class="c1">## old behaviour, update column x in original DT.</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p>By creating a <em>shallow copy</em> using <code>shallow()</code>, we understand that you don't
want to modify the original object. We take care of everything internally to
ensure that while also ensuring to copy columns you modify <em>only when it is
absolutely necessary</em>. When implemented, this should settle the <em>referential
transparency</em> issue altogether while providing the user with both
possibilties.</p>
<blockquote>
<p>Also, once <code>shallow()</code> is exported dplyr's data.table interface should avoid
almost all copies. So those who prefer dplyr's syntax can use it with
data.tables.</p>
<p>But it will still lack many features that data.table provides, including
(sub)-assignment by reference.</p>
</blockquote>
<ol>
<li>Aggregate while joining:</li>
</ol>
<p>Suppose you have two data.tables as follows:</p>
<div class="code"><pre class="code literal-block">     DT1 = data.table(x=c(1,1,1,1,2,2,2,2), y=c("a", "a", "b", "b"), z=1:8, key=c("x", "y"))
 #    x y z
 # 1: 1 a 1
 # 2: 1 a 2
 # 3: 1 b 3
 # 4: 1 b 4
 # 5: 2 a 5
 # 6: 2 a 6
 # 7: 2 b 7
 # 8: 2 b 8
 DT2 = data.table(x=1:2, y=c("a", "b"), mul=4:3, key=c("x", "y"))
 #    x y mul
 # 1: 1 a   4
 # 2: 2 b   3
</pre></div>

<p>And you would like to get <code>sum(z) * mul</code> for each row in <code>DT2</code> while joining
by columns <code>x,y</code>. We can either:</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w">       </span><span class="mf">1.</span><span class="w"> </span><span class="k">aggregate</span><span class="w"> </span><span class="n n-Quoted">`DT1`</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">get</span><span class="w"> </span><span class="n n-Quoted">`sum(z)`</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="p">)</span>
</pre></div>

<h2>data.table way</h2>
<p>DT1[, .(z = sum(z)), keyby = .(x,y)][DT2][, z := z*mul][]</p>
<h2>dplyr equivalent</h2>
<p>DF1 %&gt;% group_by(x, y) %&gt;% summarise(z = sum(z)) %&gt;% right_join(DF2) %&gt;%
mutate(z = z * mul)</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w">       </span><span class="mf">2.</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="p">(</span><span class="k">using</span><span class="w"> </span><span class="err">`</span><span class="k">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">EACHI</span><span class="err">`</span><span class="w"> </span><span class="n">feature</span><span class="p">)</span><span class="err">:</span>
</pre></div>

<p>DT1[DT2, list(z=sum(z) * mul), by = .EACHI]</p>
<p>What is the advantage?</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w"> </span><span class="n">We</span><span class="w"> </span><span class="n">don</span><span class="s1">'t have to allocate memory for the intermediate result.</span>

<span class="s1">* We don'</span><span class="n">t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">group</span><span class="o">/</span><span class="k">hash</span><span class="w"> </span><span class="n">twice</span><span class="w"> </span><span class="p">(</span><span class="k">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">aggregation</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">joining</span><span class="p">).</span>

<span class="o">*</span><span class="w"> </span><span class="k">And</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">importantly</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">what</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">wanted</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">looking</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n n-Quoted">`j`</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">).</span>
</pre></div>

<p>Check this post for a detailed explanation of <code>by = .EACHI</code>. No intermediate
results are materialised, and the join+aggregate is performed all in one go.</p>
<p>Have a look at this, this and this posts for real usage scenarios.</p>
<p>In <code>dplyr</code> you would have to join and aggregate or aggregate first and then
join, neither of which are as efficient, in terms of memory (which in turn
translates to speed).</p>
<ol>
<li>Update and joins:</li>
</ol>
<p>Consider the data.table code shown below:</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="nv">DT1</span><span class="p">[</span><span class="nv">DT2</span><span class="p">,</span><span class="w"> </span><span class="nv">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">i</span><span class="o">.</span><span class="nv">mul</span><span class="p">]</span>
</pre></div>

<p>adds/updates <code>DT1</code>'s column <code>col</code> with <code>mul</code> from <code>DT2</code> on those rows where
<code>DT2</code>'s key column matches <code>DT1</code>. I don't think there is an exact equivalent
of this operation in <code>dplyr</code>, i.e., without avoiding a <code>*_join</code> operation,
which would have to copy the entire <code>DT1</code> just to add a new column to it,
which is unnecessary.</p>
<p>Check this post for a real usage scenario.</p>
<blockquote>
<p>To summarise, it is important to realise that every bit of optimisation
matters. As <strong>Grace Hopper</strong> would say, <strong>Mind your nanoseconds</strong>!</p>
</blockquote>
<h4>3. Syntax</h4>
<p>Let's now look at <em>syntax</em>. Hadley commented here:</p>
<blockquote>
<p>Data tables are extremely fast but I think their concision makes it <em>harder
to learn</em> and <em>code that uses it is harder to read after you have written
it</em> ...</p>
</blockquote>
<p>I find this remark pointless because it is very subjective. What we can
perhaps try is to contrast <em>consistency in syntax</em>. We will compare data.table
and dplyr syntax side-by-side.</p>
<p>We will work with the dummy data shown below:</p>
<div class="code"><pre class="code literal-block">DT = data.table(x=1:10, y=11:20, z=rep(1:2, each=5))
DF = as.data.frame(DT)
</pre></div>

<ol>
<li>
<p>Basic aggregation/update operations.</p>
<div class="code"><pre class="code literal-block"> # case (a)
</pre></div>

<p>DT[, sum(y), by = z]                       ## data.table syntax
 DF %&gt;% group_by(z) %&gt;% summarise(sum(y)) ## dplyr syntax
 DT[, y := cumsum(y), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate(y = cumsum(y))</p>
<p># case (b)
 DT[x &gt; 2, sum(y), by = z]
 DF %&gt;% filter(x&gt;2) %&gt;% group_by(z) %&gt;% summarise(sum(y))
 DT[x &gt; 2, y := cumsum(y), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate(y = replace(y, which(x &gt; 2), cumsum(y)))</p>
<p># case (c)
 DT[, if(any(x &gt; 5L)) y[1L]-y[2L] else y[2L], by = z]
 DF %&gt;% group_by(z) %&gt;% summarise(if (any(x &gt; 5L)) y[1L] - y[2L] else y[2L])
 DT[, if(any(x &gt; 5L)) y[1L] - y[2L], by = z]
 DF %&gt;% group_by(z) %&gt;% filter(any(x &gt; 5L)) %&gt;% summarise(y[1L] - y[2L])</p>
<ul>
<li>
<p>data.table syntax is compact and dplyr's quite verbose. Things are more or less equivalent in case (a).</p>
</li>
<li>
<p>In case (b), we had to use <code>filter()</code> in dplyr while <em>summarising</em>. But while <em>updating</em> , we had to move the logic inside <code>mutate()</code>. In data.table however, we express both operations with the same logic - operate on rows where <code>x &gt; 2</code>, but in first case, get <code>sum(y)</code>, whereas in the second case update those rows for <code>y</code> with its cumulative sum.</p>
</li>
</ul>
</li>
</ol>
<p>This is what we mean when we say the <code>DT[i, j, by]</code> form <em>is consistent</em>.</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w"> </span><span class="n">Similarly</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n n-Quoted">`if-else`</span><span class="w"> </span><span class="k">condition</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">able</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">express</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">logic</span><span class="w"> </span><span class="n">_</span><span class="s2">"as-is"</span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">both</span><span class="w"> </span><span class="k">data</span><span class="p">.</span><span class="k">table</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">dplyr</span><span class="p">.</span><span class="w"> </span><span class="n">However</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="n">those</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n n-Quoted">`if`</span><span class="w"> </span><span class="k">condition</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">skip</span><span class="w"> </span><span class="n">otherwise</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n n-Quoted">`summarise()`</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="p">(</span><span class="n">AFAICT</span><span class="p">).</span><span class="w"> </span><span class="n">We</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n n-Quoted">`filter()`</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">summarise</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`summarise()`</span><span class="w"> </span><span class="k">always</span><span class="w"> </span><span class="n">expects</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">_single</span><span class="w"> </span><span class="n">value_</span><span class="p">.</span>
</pre></div>

<p>While it returns the same result, using <code>filter()</code> here makes the actual
operation less obvious.</p>
<p>It might very well be possible to use <code>filter()</code> in the first case as well
(does not seem obvious to me), but my point is that we should not have to.</p>
<ol>
<li>
<p>Aggregation / update on multiple columns</p>
<div class="code"><pre class="code literal-block"> # case (a)
</pre></div>

<p>DT[, lapply(.SD, sum), by = z]                     ## data.table syntax
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(sum)) ## dplyr syntax
 DT[, (cols) := lapply(.SD, sum), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate_each(funs(sum))</p>
<p># case (b)
 DT[, c(lapply(.SD, sum), lapply(.SD, mean)), by = z]
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(sum, mean))</p>
<p># case (c)
 DT[, c(.N, lapply(.SD, sum)), by = z]   <br>
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(n(), mean))</p>
<ul>
<li>
<p>In case (a), the codes are more or less equivalent. data.table uses familiar base function <code>lapply()</code>, whereas <code>dplyr</code> introduces <code>*_each()</code> along with a bunch of functions to <code>funs()</code>.</p>
</li>
<li>
<p>data.table's <code>:=</code> requires column names to be provided, whereas dplyr generates it automatically.</p>
</li>
<li>
<p>In case (b), dplyr's syntax is relatively straightforward. Improving aggregations/updates on multiple functions is on data.table's list.</p>
</li>
<li>
<p>In case (c) though, dplyr would return <code>n()</code> as many times as many columns, instead of just once. In data.table, all we need to do is to return a list in <code>j</code>. Each element of the list will become a column in the result. So, we can use, once again, the familiar base function <code>c()</code> to concatenate <code>.N</code> to a <code>list</code> which returns a <code>list</code>.</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>Note: Once again, in data.table, all we need to do is return a list in <code>j</code>.
Each element of the list will become a column in result. You can use <code>c()</code>,
<code>as.list()</code>, <code>lapply()</code>, <code>list()</code> etc... base functions to accomplish this,
without having to learn any new functions.</p>
<p>You will need to learn just the special variables - <code>.N</code> and <code>.SD</code> at least.
The equivalent in dplyr are <code>n()</code> and <code>.</code></p>
</blockquote>
<ol>
<li>Joins</li>
</ol>
<p>dplyr provides separate functions for each type of join where as data.table
allows joins using the same syntax <code>DT[i, j, by]</code> (and with reason). It also
provides an equivalent <code>merge.data.table()</code> function as an alternative.</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">setkey</span><span class="p">(</span><span class="n">DT1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2</span><span class="o">]</span><span class="w">            </span><span class="err">##</span><span class="w"> </span><span class="k">data</span><span class="p">.</span><span class="nc">table</span><span class="w"> </span><span class="n">syntax</span>
<span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">DT2</span><span class="p">,</span><span class="w"> </span><span class="n">DT1</span><span class="p">)</span><span class="w"> </span><span class="err">##</span><span class="w"> </span><span class="n">dplyr</span><span class="w"> </span><span class="n">syntax</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span><span class="w">    </span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, .(z, i.mul)</span><span class="o">]</span>
<span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="k">select</span><span class="p">(</span><span class="n">DT2</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">),</span><span class="w"> </span><span class="k">select</span><span class="p">(</span><span class="n">DT1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="k">aggregate</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, .(sum(z) * i.mul), by = .EACHI</span><span class="o">]</span>
<span class="w"> </span><span class="n">DF1</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">group_by</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">summarise</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span>
<span class="w">     </span><span class="n">inner_join</span><span class="p">(</span><span class="n">DF2</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="o">*</span><span class="n">mul</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">select</span><span class="p">(</span><span class="o">-</span><span class="n">mul</span><span class="p">)</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, z := cumsum(z) * i.mul, by = .EACHI</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">5.</span><span class="w"> </span><span class="n">rolling</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, roll = -Inf</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">6.</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="k">output</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, mult = "first"</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>
</pre></div>

<ul>
<li>
<p>Some might find a separate function for each joins much nicer (left, right, inner, anti, semi etc), whereas as others might like data.table's <code>DT[i, j, by]</code>, or <code>merge()</code> which is similar to base R.</p>
</li>
<li>
<p>However dplyr joins do just that. Nothing more. Nothing less.</p>
</li>
<li>
<p>data.tables can select columns while joining (2), and in dplyr you will need to <code>select()</code> first on both data.frames before to join as shown above. Otherwise you would materialiase the join with unnecessary columns only to remove them later and that is inefficient.</p>
</li>
<li>
<p>data.tables can aggregate while joining (3) and also update while joining (4), using by = .EACHI feature. Why materialse the entire join result to add/update just a few columns?</p>
</li>
<li>
<p>data.table is capable of <em>rolling joins</em> (5) - roll forward, LOCF, roll backward, NOCB, nearest.</p>
</li>
<li>
<p>data.table also has <code>mult =</code> argument which selects <em>first</em> , <em>last</em> or <em>all</em> matches (6).</p>
</li>
<li>
<p>data.table has <code>allow.cartesian = TRUE</code> argument to protect from accidental invalid joins.</p>
</li>
</ul>
<blockquote>
<p>Once again, the syntax is consistent with <code>DT[i, j, by]</code> with additional
arguments allowing for controlling the output further.</p>
</blockquote>
<ol>
<li>
<code>do()</code>...</li>
</ol>
<p>dplyr's summarise is specially designed for functions that return a single
value. If your function returns multiple/unequal values, you will have to
resort to <code>do()</code>. You have to know beforehand about all your functions return
value.</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">list</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]<span class="w">                 </span>##<span class="w"> </span><span class="nv">data</span>.<span class="nv">table</span><span class="w"> </span><span class="nv">syntax</span>
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">summarise</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">dplyr</span><span class="w"> </span><span class="nv">syntax</span>
<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">list</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>:<span class="mi">2</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span>.$<span class="nv">x</span>[<span class="mi">1</span>:<span class="mi">2</span>],<span class="w"> </span>.$<span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">))</span>

<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">25</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">summarise</span><span class="ss">(</span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">25</span><span class="ss">))</span>
<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="mi">0</span>.<span class="mi">25</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">75</span><span class="ss">))</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span><span class="nv">quantile</span><span class="ss">(</span>.$<span class="nv">x</span>,<span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="mi">0</span>.<span class="mi">25</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">75</span><span class="ss">))))</span>

<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">as</span>.<span class="nv">list</span><span class="ss">(</span><span class="nv">summary</span><span class="ss">(</span><span class="nv">x</span><span class="ss">))</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span><span class="nv">as</span>.<span class="nv">list</span><span class="ss">(</span><span class="nv">summary</span><span class="ss">(</span>.$<span class="nv">x</span><span class="ss">))))</span>
</pre></div>

<ul>
<li>
<p><code>.SD</code>'s equivalent is <code>.</code></p>
</li>
<li>
<p>In data.table, you can throw pretty much anything in <code>j</code> - the only thing to remember is for it to return a list so that each element of the list gets converted to a column.</p>
</li>
<li>
<p>In dplyr, cannot do that. Have to resort to <code>do()</code> depending on how sure you are as to whether your function would always return a single value. And it is quite slow.</p>
</li>
</ul>
<blockquote>
<p>Once again, data.table's syntax is consistent with <code>DT[i, j, by]</code>. We can
just keep throwing expressions in <code>j</code> without having to worry about these
things.</p>
</blockquote>
<p>Have a look at this SO question and this one. I wonder if it would be possible
to express the answer as straightforward using dplyr's syntax...</p>
<blockquote>
<p>To summarise, I have particularly highlighted <em>several</em> instances where
dplyr's syntax is either inefficient, limited or fails to make operations
straightforward. This is particularly because data.table gets quite a bit of
backlash about "harder to read/learn" syntax (like the one pasted/linked
above). Most posts that cover dplyr talk about most straightforward
operations. And that is great. But it is important to realise its syntax and
feature limitations as well, and I am yet to see a post on it.</p>
<p>data.table has its quirks as well (some of which I have pointed out that we
are attempting to fix). We are also attempting to improve data.table's joins
as I have highlighted here.</p>
<p>But one should also consider the number of features that dplyr lacks in
comparison to data.table.</p>
</blockquote>
<h4>4. Features</h4>
<p>I have pointed out most of the features here and also in this post. In
addition:</p>
<ul>
<li>
<p><strong>fread</strong> - fast file reader has been available for a long time now.</p>
</li>
<li>
<p><strong>fwrite</strong> - a <em>parallelised</em> fast file writer is now available. See this post for a detailed explanation on the implementation and #1664 for keeping track of further developments.</p>
</li>
<li>
<p>Automatic indexing - another handy feature to optimise base R syntax as is, internally.</p>
</li>
<li>
<p><strong>Ad-hoc grouping</strong> : <code>dplyr</code> automatically sorts the results by grouping variables during <code>summarise()</code>, which may not be always desirable.</p>
</li>
<li>
<p>Numerous advantages in data.table joins (for speed / memory efficiency and syntax) mentioned above.</p>
</li>
<li>
<p><strong>Non-equi joins</strong> : Allows joins using other operators <code>&lt;=, &lt;, &gt;, &gt;=</code> along with all other advantages of data.table joins.</p>
</li>
<li>
<p>Overlapping range joins was implemented in data.table recently. Check this post for an overview with benchmarks.</p>
</li>
<li>
<p><code>setorder()</code> function in data.table that allows really fast reordering of data.tables by reference.</p>
</li>
<li>
<p>dplyr provides interface to databases using the same syntax, which data.table does not at the moment.</p>
</li>
<li>
<p><code>data.table</code> provides faster equivalents of <em>set operations</em> (written by Jan Gorecki) - <code>fsetdiff</code>, <code>fintersect</code>, <code>funion</code> and <code>fsetequal</code> with additional <code>all</code> argument (as in SQL).</p>
</li>
<li>
<p>data.table loads cleanly with no masking warnings and has a mechanism described here for <code>[.data.frame</code> compatibility when passed to any R package. dplyr changes base functions <code>filter</code>, <code>lag</code> and <code>[</code> which can cause problems; e.g. here and here.</p>
</li>
</ul>
<hr>
<p>Finally:</p>
<ul>
<li>
<p>On databases - there is no reason why data.table cannot provide similar interface, but this is not a priority now. It might get bumped up if users would very much like that feature.. not sure.</p>
</li>
<li>
<p>On parallelism - Everything is difficult, until someone goes ahead and does it. Of course it will take effort (being thread safe).</p>
<ul>
<li>Progress is being made currently (in v1.9.7 devel) towards parallelising known time consuming parts for incremental performance gains using <code>OpenMP</code>.</li>
</ul>
</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>Here's my attempt at a comprehensive answer from the dplyr perspective,
following the broad outline of Arun's answer (but somewhat rearranged based on
differing priorities).</p>
<h3>Syntax</h3>
<p>There is some subjectivity to syntax, but I stand by my statement that the
concision of data.table makes it harder to learn and harder to read. This is
partly because dplyr is solving a much easier problem!</p>
<p>One really important thing that dplyr does for you is that it <em>constrains</em>
your options. I claim that most single table problems can be solved with just
five key verbs filter, select, mutate, arrange and summarise, along with a "by
group" adverb. That constraint is a big help when you're learning data
manipulation, because it helps order your thinking about the problem. In
dplyr, each of these verbs is mapped to a single function. Each function does
one job, and is easy to understand in isolation.</p>
<p>You create complexity by piping these simple operations together with <code>%&gt;%</code>.
Here's an example from one of the posts Arun linked to:</p>
<div class="code"><pre class="code literal-block">diamonds %&gt;%
  filter(cut != "Fair") %&gt;%
  group_by(cut) %&gt;%
  summarize(
    AvgPrice = mean(price),
    MedianPrice = as.numeric(median(price)),
    Count = n()
  ) %&gt;%
  arrange(desc(Count))
</pre></div>

<p>Even if you've never seen dplyr before (or even R!), you can still get the
gist of what's happening because the functions are all English verbs. The
disadvantage of English verbs is that they require more typing than <code>[</code>, but I
think that can be largely mitigated by better autocomplete.</p>
<p>Here's the equivalent data.table code:</p>
<div class="code"><pre class="code literal-block"><span class="n">diamondsDT</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">data.table</span><span class="p">(</span><span class="n">diamonds</span><span class="p">)</span>
<span class="n">diamondsDT</span><span class="p">[</span>
<span class="w">  </span><span class="n">cut</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">"Fair"</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="nf">.</span><span class="p">(</span><span class="n">AvgPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="n">price</span><span class="p">),</span>
<span class="w">    </span><span class="n">MedianPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">as.numeric</span><span class="p">(</span><span class="nf">median</span><span class="p">(</span><span class="n">price</span><span class="p">)),</span>
<span class="w">    </span><span class="n">Count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">.N</span>
<span class="w">  </span><span class="p">),</span><span class="w"> </span>
<span class="w">  </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cut</span>
<span class="p">][</span><span class="w"> </span>
<span class="w">  </span><span class="nf">order</span><span class="p">(</span><span class="o">-</span><span class="n">Count</span><span class="p">)</span><span class="w"> </span>
<span class="p">]</span>
</pre></div>

<p>It's harder to follow this code unless you're already familiar with
data.table. (I also couldn't figure out how to indent the repeated <code>[</code> in a
way that looks good to my eye). Personally, when I look at code I wrote 6
months ago, it's like looking at a code written by a stranger, so I've come to
prefer straightforward, if verbose, code.</p>
<p>Two other minor factors that I think slightly decrease readability:</p>
<ul>
<li>
<p>Since almost every data table operation uses <code>[</code> you need additional context to figure out what's happening. For example, is <code>x[y]</code> joining two data tables or extracting columns from a data frame? This is only a small issue, because in well-written code the variable names should suggest what's happening.</p>
</li>
<li>
<p>I like that <code>group_by()</code> is a separate operation in dplyr. It fundamentally changes the computation so I think should be obvious when skimming the code, and it's easier to spot <code>group_by()</code> than the <code>by</code> argument to <code>[.data.table</code>.</p>
</li>
</ul>
<p>I also like that the the pipe isn't just limited to just one package. You can
start by tidying your data with tidyr, and finish up with a plot in ggvis. And
you're not limited to the packages that I write - anyone can write a function
that forms a seamless part of a data manipulation pipe. In fact, I rather
prefer the previous data.table code rewritten with <code>%&gt;%</code>:</p>
<div class="code"><pre class="code literal-block">diamonds %&gt;% 
  data.table() %&gt;% 
  .[cut != "Fair", 
    .(AvgPrice = mean(price),
      MedianPrice = as.numeric(median(price)),
      Count = .N
    ), 
    by = cut
  ] %&gt;% 
  .[order(-Count)]
</pre></div>

<p>And the idea of piping with <code>%&gt;%</code> is not limited to just data frames and is
easily generalised to other contexts: interactive web graphics, web scraping,
gists, run-time contracts, ...)</p>
<h3>Memory and performance</h3>
<p>I've lumped these together, because, to me, they're not that important. Most R
users work with well under 1 million rows of data, and dplyr is sufficiently
fast enough for that size of data that you're not aware of processing time. We
optimise dplyr for expressiveness on medium data; feel free to use data.table
for raw speed on bigger data.</p>
<p>The flexibility of dplyr also means that you can easily tweak performance
characteristics using the same syntax. If the performance of dplyr with the
data frame backend is not good enough for you, you can use the data.table
backend (albeit with a somewhat restricted set of functionality). If the data
you're working with doesn't fit in memory, then you can use a database
backend.</p>
<p>All that said, dplyr performance will get better in the long-term. We'll
definitely implement some of the great ideas of data.table like radix ordering
and using the same index for joins &amp; filters. We're also working on
parallelisation so we can take advantage of multiple cores.</p>
<h3>Features</h3>
<p>A few things that we're planning to work on in 2015:</p>
<ul>
<li>
<p>the <code>readr</code> package, to make it easy to get files off disk and in to memory, analogous to <code>fread()</code>.</p>
</li>
<li>
<p>More flexible joins, including support for non-equi-joins.</p>
</li>
<li>
<p>More flexible grouping like bootstrap samples, rollups and more</p>
</li>
</ul>
<p>I'm also investing time into improving R's database connectors, the ability to
talk to web apis, and making it easier to scrape html pages.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-581.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-579.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
