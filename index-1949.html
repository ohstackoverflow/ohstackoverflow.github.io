<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1949) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1949.html">
<link rel="prev" href="index-1950.html" type="text/html">
<link rel="next" href="index-1948.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/removing-empty-lines-in-notepad/" class="u-url">Removing empty lines in Notepad++</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/removing-empty-lines-in-notepad/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:13:56+08:00" itemprop="datePublished" title="2023-03-03 13:13">2023-03-03 13:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How can I replace empty lines in Notepad++? I tried a find and replace with
the empty lines in the find, and nothing in the replace, but it did not work;
it probably needs regex.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You need something like a regular expression.</p>
<p><strong>You have to be in<code>Extended</code> mode</strong></p>
<p>If you want all the lines to end up on a <strong>single line</strong> use <code>\r\n</code>. If you
want to simply remove <strong>empty</strong> lines, use <code>\n\r</code> as @Link originally
suggested.</p>
<p>Replace either expression with nothing.</p>
<p><br></p>
<h3>Suggest</h3>
<p>You need something like a regular expression.</p>
<p><strong>You have to be in<code>Extended</code> mode</strong></p>
<p>If you want all the lines to end up on a <strong>single line</strong> use <code>\r\n</code>. If you
want to simply remove <strong>empty</strong> lines, use <code>\n\r</code> as @Link originally
suggested.</p>
<p>Replace either expression with nothing.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-http-and-rest/" class="u-url">What is the difference between HTTP and REST?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-http-and-rest/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:13:32+08:00" itemprop="datePublished" title="2023-03-03 13:13">2023-03-03 13:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>After reading a lot about the differences between REST and SOAP, I got the
impression that REST is just another word for HTTP. Can someone explain what
functionality REST adds to HTTP?</p>
<p><strong>Note</strong> : I'm not looking for a comparison of REST versus SOAP.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>No, <strong>REST</strong> is the way <strong>HTTP</strong> should be <em>used</em>.</p>
<p>Today we only use a tiny bit of the HTTP protocol's methods – namely <code>GET</code> and
<code>POST</code>. The REST way to do it is to use all of the protocol's methods.</p>
<p>For example, REST dictates the usage of <code>DELETE</code> to erase a document (be it a
file, state, etc.) behind a URI, whereas, with HTTP, you would misuse a <code>GET</code>
or <code>POST</code> query like <code>...product/?delete_id=22</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>HTTP is a protocol used for communication, usually used to communicate with
internet resources or any application with a web browser client.</p>
<p>REST means that the main concept you are using while designing the application
is the Resource: for each action you want to perform you need to define a
resource on which you often do only CRUD operation, which is a simple task.
For that it's very convenient to use four verbs used in HTTP protocol against
the four CRUD operations (GET for Read, POST is for CREATE, PUT is for UPDATE
and DELETE is for DELETE).</p>
<p>That's unlike the older concept of RPC (Remote Procedure Call), in which you
have a set of actions you want to perform as a result of the user's call. if
you think for example on how to describe a Facebook like on a post, with RPC
you might create services called <code>AddLikeToPost</code> and <code>RemoveLikeFromPost</code>, and
manage it along with all your other services related to FB posts, thus you
won't need to create special object for Like.</p>
<p>With REST you will have a Like object which will be managed separately with
Delete and Create functions. It also means it will describe a separate entity
in your DB. That might look like a small difference, but working like that
would usually yield a much simpler code and a much simpler application. With
that design, most of the app's logic is obvious from the object's structure
(model), unlike RPC with which you would usually have to explicitly add a lot
more logic.</p>
<p>Designing a RESTful application is often a lot harder because it requires you
to describe complicated things in a simple manner. Describing all
functionalities using only CRUD functions is tricky, but after doing that your
life would be a lot simpler, and you will find that you write a lot shorter
methods.</p>
<p>One more restraint REST architecture presents is not to use a session context
when communicating with a client (stateless), meaning all the information
needed to understand who is the client and what he wants is passed with the
web message. Each call to a function is self-descriptive, there is no previous
conversation with the client which can be referenced in the message.
Therefore, a client could not tell you "give me the next page" since you don't
have a session to store what is the previous page and what kind of page you
want, the client would have to say "my name is Yuval, get me page 2 of a
specific post in a specific forum". This means a bit more data would have to
transfer in the communication, but think of the difference between finding a
bug reported from the "get me the next page" function in oppose to "get me
page 2 of question ID 2190836 in stack overflow".</p>
<p>Of course there is a lot more to it, but to my humble opinion these are the
main concepts in a teaspoon.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/one-dbcontext-per-web-request-why/" class="u-url">One DbContext per web request... why?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/one-dbcontext-per-web-request-why/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:13:07+08:00" itemprop="datePublished" title="2023-03-03 13:13">2023-03-03 13:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have been reading a lot of articles explaining how to set up Entity
Framework's <code>DbContext</code> so that only one is created and used per HTTP web
request using various DI frameworks.</p>
<p>Why is this a good idea in the first place? What advantages do you gain by
using this approach? Are there certain situations where this would be a good
idea? Are there things that you can do using this technique that you can't do
when instantiating <code>DbContext</code>s per repository method call?</p>
<p><br><br></p>
<h2>Answer</h2>
<blockquote>
<p><em><strong>NOTE: This answer talks about the Entity Framework's<code>DbContext</code>, but it
is applicable to any sort of Unit of Work implementation, such as LINQ to
SQL's <code>DataContext</code>, and NHibernate's <code>ISession</code>.</strong></em></p>
</blockquote>
<p>Let start by echoing Ian: Having a single <code>DbContext</code> for the whole
application is a Bad Idea. The only situation where this makes sense is when
you have a single-threaded application and a database that is solely used by
that single application instance. The <code>DbContext</code> is not thread-safe and since
the <code>DbContext</code> caches data, it gets stale pretty soon. This will get you in
all sorts of trouble when multiple users/applications work on that database
simultaneously (which is very common of course). But I expect you already know
that and just want to know why not to just inject a new instance (i.e. with a
transient lifestyle) of the <code>DbContext</code> into anyone who needs it. (for more
information about why a single <code>DbContext</code> -or even on context per thread- is
bad, read this answer).</p>
<p>Let me start by saying that registering a <code>DbContext</code> as transient could work,
but typically you want to have a single instance of such a unit of work within
a certain scope. In a web application, it can be practical to define such a
scope on the boundaries of a web request; thus a Per Web Request lifestyle.
This allows you to let a whole set of objects operate within the same context.
In other words, they operate within the same business transaction.</p>
<p>If you have no goal of having a set of operations operate inside the same
context, in that case the transient lifestyle is fine, but there are a few
things to watch:</p>
<ul>
<li>Since every object gets its own instance, every class that changes the state of the system, needs to call <code>_context.SaveChanges()</code> (otherwise changes would get lost). This can complicate your code, and adds a second responsibility to the code (the responsibility of controlling the context), and is a violation of the Single Responsibility Principle.</li>
<li>You need to make sure that entities [loaded and saved by a <code>DbContext</code>] never leave the scope of such a class, because they can't be used in the context instance of another class. This can complicate your code enormously, because when you need those entities, you need to load them again by id, which could also cause performance problems.</li>
<li>Since <code>DbContext</code> implements <code>IDisposable</code>, you probably still want to Dispose all created instances. If you want to do this, you basically have two options. You need to dispose them in the same method right after calling <code>context.SaveChanges()</code>, but in that case the business logic takes ownership of an object it gets passed on from the outside. The second option is to Dispose all created instances on the boundary of the Http Request, but in that case you still need some sort of scoping to let the container know when those instances need to be Disposed.</li>
</ul>
<p>Another option is to <em>not</em> inject a <code>DbContext</code> at all. Instead, you inject a
<code>DbContextFactory</code> that is able to create a new instance (I used to use this
approach in the past). This way the business logic controls the context
explicitly. If might look like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">SomeOperation</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">using</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">contextFactory</span><span class="o">.</span><span class="n">CreateNew</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">var</span><span class="w"> </span><span class="n">entities</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">otherDependency</span><span class="o">.</span><span class="n">Operate</span><span class="p">(</span>
<span class="w">            </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="s2">"some value"</span><span class="p">);</span>

<span class="w">        </span><span class="n">context</span><span class="o">.</span><span class="n">Entities</span><span class="o">.</span><span class="n">InsertOnSubmit</span><span class="p">(</span><span class="n">entities</span><span class="p">);</span>

<span class="w">        </span><span class="n">context</span><span class="o">.</span><span class="n">SaveChanges</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>The plus side of this is that you manage the life of the <code>DbContext</code>
explicitly and it is easy to set this up. It also allows you to use a single
context in a certain scope, which has clear advantages, such as running code
in a single business transaction, and being able to pass around entities,
since they originate from the same <code>DbContext</code>.</p>
<p>The downside is that you will have to pass around the <code>DbContext</code> from method
to method (which is termed Method Injection). Note that in a sense this
solution is the same as the 'scoped' approach, but now the scope is controlled
in the application code itself (and is possibly repeated many times). It is
the application that is responsible for creating and disposing the unit of
work. Since the <code>DbContext</code> is created after the dependency graph is
constructed, Constructor Injection is out of the picture and you need to defer
to Method Injection when you need to pass on the context from one class to the
other.</p>
<p>Method Injection isn't that bad, but when the business logic gets more
complex, and more classes get involved, you will have to pass it from method
to method and class to class, which can complicate the code a lot (I've seen
this in the past). For a simple application, this approach will do just fine
though.</p>
<p>Because of the downsides, this factory approach has for bigger systems,
another approach can be useful and that is the one where you let the container
or the infrastructure code / Composition Root manage the unit of work. This is
the style that your question is about.</p>
<p>By letting the container and/or the infrastructure handle this, your
application code is not polluted by having to create, (optionally) commit and
Dispose a UoW instance, which keeps the business logic simple and clean (just
a Single Responsibility). There are some difficulties with this approach. For
instance, where do you Commit and Dispose the instance?</p>
<p>Disposing a unit of work can be done at the end of the web request. Many
people however, <em>incorrectly</em> assume that this is also the place to Commit the
unit of work. However, at that point in the application, you simply can't
determine for sure that the unit of work should actually be committed. e.g. If
the business layer code threw an exception that was caught higher up the
callstack, you definitely <strong>don't</strong> want to Commit.</p>
<p>The real solution is again to explicitly manage some sort of scope, but this
time do it inside the Composition Root. Abstracting all business logic behind
the command / handler pattern, you will be able to write a decorator that can
be wrapped around each command handler that allows to do this. Example:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">TransactionalCommandHandlerDecorator</span><span class="s">&lt;TCommand&gt;</span>
    : <span class="n">ICommandHandler</span><span class="s">&lt;TCommand&gt;</span>
{
    <span class="nb">readonly</span> <span class="n">DbContext</span> <span class="n">context</span>;
    <span class="nb">readonly</span> <span class="n">ICommandHandler</span><span class="s">&lt;TCommand&gt;</span> <span class="n">decorated</span>;

    <span class="n">public</span> <span class="n">TransactionCommandHandlerDecorator</span>(
        <span class="n">DbContext</span> <span class="n">context</span>,
        <span class="n">ICommandHandler</span><span class="s">&lt;TCommand&gt;</span> <span class="n">decorated</span>)
    {
        <span class="n">this</span>.<span class="n">context</span> = <span class="n">context</span>;
        <span class="n">this</span>.<span class="n">decorated</span> = <span class="n">decorated</span>;
    }

    <span class="n">public</span> <span class="n">void</span> <span class="n">Handle</span>(<span class="n">TCommand</span> <span class="nb">command</span>)
    {
        <span class="n">this</span>.<span class="n">decorated</span>.<span class="n">Handle</span>(<span class="nb">command</span>);

        <span class="n">context</span>.<span class="n">SaveChanges</span>();
    } 
}
</pre></div>

<p>This ensures that you only need to write this infrastructure code once. Any
solid DI container allows you to configure such a decorator to be wrapped
around all <code>ICommandHandler&lt;T&gt;</code> implementations in a consistent manner.</p>
<p><br></p>
<h3>Suggest</h3>
<p>There are two <strong>contradicting</strong> recommendations by microsoft and many people
use DbContexts in a completely divergent manner.</p>
<ol>
<li>One recommendation is to <strong>"Dispose DbContexts as soon as posible"</strong> because having a DbContext Alive occupies valuable resources like db connections etc....</li>
<li>The other states that <strong>One DbContext per request is highly reccomended</strong>
</li>
</ol>
<p>Those contradict to each other because if your Request is doing a lot of
unrelated to the Db stuff , then your DbContext is kept for no reason. Thus it
is waste to keep your DbContext alive while your request is just waiting for
random stuff to get done...</p>
<p>So many people who follow <strong>rule 1</strong> have their DbContexts inside their
<strong>"Repository pattern"</strong> and create <strong>a new Instance per Database Query</strong> so
<strong>X*DbContext</strong> per Request</p>
<p>They just get their data and dispose the context ASAP. This is considered by
<strong>MANY</strong> people an acceptable practice. While this has the benefits of
occupying your db resources for the minimum time it clearly sacrifices all the
<strong>UnitOfWork</strong> and <strong>Caching</strong> candy EF has to offer.</p>
<p>Keeping alive a single <strong>multipurpose</strong> instance of DbContext maximizes the
benefits of <strong>Caching</strong> but since DbContext is <strong>not thread safe</strong> and each
Web request runs on it's own thread, a DbContext per Request is the
<strong>longest</strong> you can keep it.</p>
<p>So EF's team recommendation about using 1 Db Context per request it's clearly
based on the fact that in a Web Application a UnitOfWork most likely is going
to be within one request and that request has one thread. So one DbContext per
request is like the ideal benefit of UnitOfWork and Caching.</p>
<p><strong>But</strong> in many cases this is not true. I consider <strong>Logging</strong> a separate
UnitOfWork thus having a new DbContext for Post-Request Logging in <strong>async
threads</strong> is completely acceptable</p>
<p>So Finally it turns down that a DbContext's lifetime is restricted to these
two parameters. <strong>UnitOfWork</strong> and <strong>Thread</strong></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1950.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1948.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
