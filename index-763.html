<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 763) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-763.html">
<link rel="prev" href="index-764.html" type="text/html">
<link rel="next" href="index-762.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/she-zhi-gitla-qu-he-tui-song-suo-you-fen-zhi/" class="u-url">设置git拉取和推送所有分支</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/she-zhi-gitla-qu-he-tui-song-suo-you-fen-zhi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:29:27+08:00" itemprop="datePublished" title="2023-02-17 15:29">2023-02-17 15:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想默认推送和拉取所有分支，包括新创建的分支。</p>
<p>有没有我可以为它定义的设置？</p>
<p>否则，当我在本地添加一个新分支并想从服务器中拉出它时，最简单的方法是什么？</p>
<p>我创建了一个同名的新分支并尝试拉取但它不起作用。向我询问分支的所有远程配置。我该如何设置它。</p>
<p><br><br></p>
<h2>解答</h2>
<p>最简单的方法是：</p>
<div class="code"><pre class="code literal-block">git push --all origin
</pre></div>

<p>这将推送标签和分支。</p>
<p><br></p>
<h3>更多建议</h3>
<p>使用现代 git，你 <strong>总是获取所有分支</strong> （作为远程跟踪分支到<code>refs/remotes/origin/*</code>命名空间，可见<code>git branch
-r</code>or <code>git remote show origin</code>）。</p>
<p>默认情况下（请参阅<code>push.default</code>配置变量的文档）您推送 <strong> <em>匹配的分支</em></strong> ，这意味着首先您必须让<code>git push origin
branch</code>git 始终推送它<code>git push</code>。</p>
<p>如果你想 <strong>总是推送所有分支</strong> ，你可以设置推送 refspec。假设远程已命名，<code>origin</code>您可以使用git config：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>config<span class="w"> </span>--add<span class="w"> </span>remote.origin.push<span class="w"> </span><span class="s1">'+refs/heads/*:refs/heads/*'</span>
$<span class="w"> </span>git<span class="w"> </span>config<span class="w"> </span>--add<span class="w"> </span>remote.origin.push<span class="w"> </span><span class="s1">'+refs/tags/*:refs/tags/*'</span>
</pre></div>

<p>或直接编辑<code>.git/config</code>文件使其具有如下内容：</p>
<div class="code"><pre class="code literal-block"><span class="k">[远程“起源”]</span>
<span class="w">        </span><span class="na">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">user@example.com:/srv/git/repo.git</span>
<span class="w">        </span><span class="na">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">+refs/heads/*:refs/remotes/origin/*</span>
<span class="w">        </span><span class="na">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">+refs/tags/*:refs/标签/*</span>
<span class="w">        </span><span class="na">push</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">+refs/heads/*:refs/头/*</span>
<span class="w">        </span><span class="na">push</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">+refs/tags/*:refs/标签/*</span>
</pre></div>

<p><br><br><a href="posts/set-up-git-to-pull-and-push-all-branches/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-git-biao-qian-ru-he-chuang-jian-biao-qian-yi-ji-ru-he-jian-chu-git-yuan-cheng-biao-qian/" class="u-url">什么是 git 标签，如何创建标签以及如何检出 git 远程标签</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-git-biao-qian-ru-he-chuang-jian-biao-qian-yi-ji-ru-he-jian-chu-git-yuan-cheng-biao-qian/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:29:02+08:00" itemprop="datePublished" title="2023-02-17 15:29">2023-02-17 15:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>当我签出远程 git 标签时，使用这样的命令：</p>
<div class="code"><pre class="code literal-block">git checkout -b local_branch_name origin/remote_tag_name
</pre></div>

<p>我收到这样的错误：</p>
<blockquote>
<p>错误：pathspec<code>origin/remote_tag_name</code>与 git 已知的任何文件都不匹配。</p>
</blockquote>
<p>当我使用 git tag 命令时，我可以找到 remote_tag_name。</p>
<p><br><br></p>
<h2>解答</h2>
<h4>让我们先解释一下 git 中的标签是什么</h4>
<p><img alt="在此处输入图像描述" src="images/yRIIc.png"></p>
<blockquote>
<p>标签用于标记和标记历史记录中的特定 <strong>提交。</strong><br>
 它通常用于标记发布点（例如 v1.0 等）。</p>
<p>尽管标签可能看起来类似于分支， <strong>但是标签不会改变</strong> 。它 <strong>直接</strong> 指向历史中的 <strong>特定提交，除非明确更新，否则不会更改。</strong></p>
</blockquote>
<p><img alt="在此处输入图像描述" src="images/Xy20U.png"></p>
<hr>
<p>如果标签不在本地存储库中，您将无法签出标签，因此首先，您必须将<code>fetch</code>标签添加到本地存储库中。</p>
<p><strong>首先，通过执行以下操作确保标签在本地存在</strong></p>
<div class="code"><pre class="code literal-block"># --all will fetch all the remotes.
# --tags will fetch all tags as well
$ git fetch --all --tags --prune
</pre></div>

<p><strong>然后通过运行检查标签</strong></p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>tags/&lt;tag_name&gt;<span class="w"> </span>-b<span class="w"> </span>&lt;branch_name&gt;
</pre></div>

<p>而不是<code>origin</code>使用<code>tags/</code>前缀。</p>
<hr>
<p>在此示例中，您有 2 个标签版本 1.0 和版本 1.1，您可以使用以下任一方法检查它们：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>A<span class="w">  </span>...
$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>version<span class="w"> </span><span class="m">1</span>.0<span class="w">  </span>...
$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>tags/version<span class="w"> </span><span class="m">1</span>.0<span class="w">  </span>...
</pre></div>

<p>由于标签只是指向给定提交的指针，因此上述所有内容都将执行相同的操作。</p>
<p><img alt="在此处输入图像描述" src="images/X4lvg.png"><br>
来源：https ://backlog.com/git-tutorial/img/post/stepup/capture_stepup4_1_1.png</p>
<hr>
<h2>如何查看所有标签的列表？</h2>
<div class="code"><pre class="code literal-block"># list all tags
$ git tag

# list all tags with given pattern ex: v-
$ git tag --list 'v-*'
</pre></div>

<hr>
<h2>如何创建标签？</h2>
<p>创建标签有两种方式：</p>
<div class="code"><pre class="code literal-block"># lightweight tag 
$ git tag

# annotated tag
$ git tag -a
</pre></div>

<p>两者之间的区别在于，在创建带注释的标签时，您可以像在 git 提交中一样添加元数据：<br>
姓名、电子邮件、日期、评论和签名</p>
<p><img alt="在此处输入图像描述" src="images/EwBtF.jpg"></p>
<h2>如何删除标签？</h2>
<h4>删除本地标签</h4>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>tag<span class="w"> </span>-d<span class="w"> </span>&lt;tag_name&gt;
Deleted<span class="w"> </span>tag<span class="w"> </span>&lt;tag_name&gt;<span class="w"> </span><span class="o">(</span>was<span class="w"> </span><span class="m">000000</span><span class="o">)</span>
</pre></div>

<p><strong>注意：</strong> 如果您尝试删除一个不存在的 Git 标签，将会看到以下错误：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>tag<span class="w"> </span>-d<span class="w"> </span>&lt;tag_name&gt;
error:<span class="w"> </span>tag<span class="w"> </span><span class="s1">'&lt;tag_name&gt;'</span><span class="w"> </span>not<span class="w"> </span>found.
</pre></div>

<h4>删除远程标签</h4>
<div class="code"><pre class="code literal-block"># Delete a tag from the server with push tags
$ git push --delete origin &lt;tag name&gt;
</pre></div>

<h2>如何克隆特定标签？</h2>
<p>为了抓取给定标签的内容，您可以使用命令<code>checkout</code>。如上所述，标签就像任何其他提交一样，因此我们可以使用<code>checkout</code>and 而不是使用
SHA-1，只需将其替换为 <em>tag_name</em></p>
<p><strong>选项1：</strong></p>
<div class="code"><pre class="code literal-block"># Update the local git repo with the latest tags from all remotes
$ git fetch --all

# checkout the specific tag
$ git checkout tags/&lt;tag&gt; -b &lt;branch&gt;
</pre></div>

<p><strong>选项 2：</strong></p>
<h4>使用克隆命令</h4>
<p>Since git supports <em>shallow clone</em> by adding the <code>--branch</code> to the clone
command we can use the tag name instead of the branch name. Git knows how to
"translate" the given SHA-1 to the relevant commit</p>
<div class="code"><pre class="code literal-block"># Clone a specific tag name using git clone 
$ git clone &lt;url&gt; --branch=&lt;tag_name&gt;
</pre></div>

<blockquote>
<p><strong>git clone --branch=</strong></p>
<p><em><code>--branch</code> can also take tags and detaches the HEAD at that commit in the
resulting repository.</em></p>
</blockquote>
<hr>
<h2>How to push tags?</h2>
<h4><strong><code>git push --tags</code></strong></h4>
<p>To push all tags:</p>
<div class="code"><pre class="code literal-block"># Push all tags
$ git push --tags
</pre></div>

<h4>Using the <code>refs/tags</code> instead of just specifying the <code>&lt;tagname&gt;</code>.</h4>
<p>Why?</p>
<ul>
<li>It's recommended to use <code>refs/tags</code> since sometimes tags can have the same name as your branches and a simple git push will push the branch instead of the tag</li>
</ul>
<p>To push annotated tags and current history chain tags use:</p>
<h4><strong><code>git push --follow-tags</code></strong></h4>
<p>This flag <code>--follow-tags</code> pushes both <strong>commits</strong> and <strong>only tags</strong> that are
both:</p>
<ul>
<li>Annotated tags (so you can skip local/temp build tags)</li>
<li>Reachable tags (an ancestor) from the current branch (located on the history)</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/qLEtr.png"></p>
<p>From Git 2.4 you can set it using configuration</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>config<span class="w"> </span>--global<span class="w"> </span>push.followTags<span class="w"> </span><span class="nb">true</span>
</pre></div>

<hr>
<p>Cheatsheet: <img alt="在此处输入图像描述" src="images/xR2sf.png"></p>
<hr>
<p><br></p>
<h3>更多建议</h3>
<p>（这个答案写了一段时间，codeWizard 的答案在目标和本质上是正确的，但并不完全完整，所以我还是会发布这个。）</p>
<hr>
<p>没有“远程 Git 标签”这样的东西。只有“标签”。我指出所有这一切并不是学究气1，而是因为 Git 的临时用户对此有很多困惑，而且 Git
文档对初学者不是很有帮助2 。（目前尚不清楚混乱是因为文档不完善，还是文档不完善是因为这本身就有些混乱，或者是什么原因。）</p>
<p>有“远程分支”，更恰当地称为“远程跟踪分支”，但值得注意的是，这些实际上是本地实体 <em>。</em>
但是，没有远程标签（除非您（重新）发明它们）。只有本地标签，所以需要在本地获取标签才能使用。</p>
<p>特定提交名称的一般形式——Git 称之为 <em>引用</em> ——是任何以 .
开头的字符串<code>refs/</code>。<code>refs/heads/</code>以分支名称开头的字符串；<code>refs/remotes/</code>以远程跟踪分支名称开头的字符串；<code>refs/tags/</code>和一个以命名标签开头的字符串。名称<code>refs/stash</code>是存储引用（由<code>git
stash</code>; 使用，注意缺少尾部斜杠）。</p>
<p>有一些不以<code>refs/</code>: <code>HEAD</code>,
<code>ORIG_HEAD</code>,开头的不寻常的特殊情况名称<code>MERGE_HEAD</code>，特别<code>CHERRY_PICK_HEAD</code>是所有这些名称也可能引用特定的提交（尽管<code>HEAD</code>通常包含分支的名称，即
contains ）。但一般来说，引用以.<code>ref: refs/heads/ _branch_``refs/</code></p>
<p>Git 做的一件事就是让这个变得混乱，它允许你省略<code>refs/</code>，通常是在
之后的词<code>refs/</code>。例如，您可以在引用本地分支或标签时省略<code>refs/heads/</code>或<code>refs/tags/</code>- 事实上，在签出本地分支时 <em>必须</em>
省略！<code>refs/heads/</code>只要结果明确，或者——正如我们刚刚提到的——当你必须这样做时（for ），你就可以这样做。<code>git checkout
_branch_</code></p>
<p>确实，引用不仅存在于您自己的存储库中，而且还存在于远程存储库中。但是，Git
只允许您在非常特定的时间访问远程存储库的引用：即在<code>fetch</code>和<code>push</code>操作期间。您也可以使用<code>git ls-remote</code>或<code>git remote
show</code>查看它们，但<code>fetch</code>和<code>push</code>是更有趣的联系点。</p>
<h4>参考规格</h4>
<p>在<code>fetch</code>和期间<code>push</code>，Git 使用它调用 <em>refspecs 的</em> 字符串在本地和远程存储库之间传输引用。因此，正是在这些时候，通过
refspecs，两个 Git
存储库可以相互同步。一旦您的名字同步，您就可以使用与远程用户相同的名字。不过，这里有一些特殊的魔力<code>fetch</code>，它会影响分支名称和标签名称。</p>
<p>您应该将其视为<code>git fetch</code>指示您的 Git 调用（或者可能是文本消息）另一个
Git——“远程”——并与其进行对话。在此对话的早期，遥控器列出了它的所有引用： 中的所有内容<code>refs/heads/</code>以及
中的所有内容<code>refs/tags/</code>，以及它拥有的任何其他引用。您的 Git 扫描这些分支并（基于通常的 fetch refspec） <em>重命名</em>
它们的分支。</p>
<p>让我们看一下远程 named 的正常 refspec <code>origin</code>：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>config<span class="w"> </span>--get-all<span class="w"> </span>remote.origin.fetch
+refs/heads/*:refs/remotes/origin/*
$
</pre></div>

<p>此 refspec 指示您的 Git 获取每个名称匹配<code>refs/heads/*</code>- 即远程上的每个分支 -
并将其名称更改为<code>refs/remotes/origin/*</code>，即保持匹配部分相同，将分支名称 ( <code>refs/heads/</code>) 更改为远程跟踪分支名称 (
<code>refs/remotes/</code>，特别是, <code>refs/remotes/origin/</code>).</p>
<p>正是 <em>通过这个 refspec</em> ，<code>origin</code>'s 分支成为您的 remote
的远程跟踪分支<code>origin</code>。分支名称成为远程跟踪分支名称，其中包括远程名称，在本例中<code>origin</code>为 。<code>+</code>refspec
前面的加号设置“force”标志，即您的远程跟踪分支将更新以匹配远程的分支名称，无论需要什么才能使其匹配。（如果没有<code>+</code>，分支更新仅限于“快进”更改，并且自
Git 1.8.2 左右版本以来，标签更新将被简单地忽略——在此之前应用相同的快进规则。）</p>
<h4>标签</h4>
<p>但是标签呢？它们没有 refspec——至少，默认情况下没有。您可以设置一个，在这种情况下，refspec 的形式由您决定；或者你可以运行<code>git
fetch --tags</code>。使用<code>--tags</code>具有添加到 refspec 的效果<code>refs/tags/*:refs/tags/*</code>，即它会带来所有标签（但
<del>如果您已经有一个具有该名称的标签，</del> <del>则不会更新 <em>您的标签，</em> <em>无论远程标签说什么</em></del> 编辑，2017 年 1 月：从 Git 2.10
开始，测试表明<code>--tags</code>从远程标签强制更新你的标签，就像 refspec
读取一样<code>+refs/tags/*:refs/tags/*</code>；这可能与早期版本的 Git 在行为上有所不同）。</p>
<p>请注意，这里没有重命名：如果远程<code>origin</code>有 tag <code>xyzzy</code>，而你没有，而你<code>git fetch origin
"refs/tags/*:refs/tags/*"</code>，你将被<code>refs/tags/xyzzy</code>添加到你的存储库中（指向与远程相同的提交）。如果您使用<code>+refs/tags/*:refs/tags/*</code>，那么您的标签<code>xyzzy</code>（如果有的话）将被
<em>替换</em> 为来自 的标签<code>origin</code>。也就是说，<code>+</code>refspec 上的 force 标志意味着“用我的 Git 从他们的 Git
获得的值替换我的引用值”。</p>
<h4>提取期间的自动标记</h4>
<p>由于历史原因，3如果您既不使用<code>--tags</code>选项也不使用<code>--no-tags</code>选项，<code>git
fetch</code>则采取特殊操作。请记住，我们在上面说过，远程首先会向您的本地 Git 显示其 <em>所有</em> 引用，无论您的本地 Git 是否希望看到它们。4您的
Git 会记下它此时看到的所有标签。 <del>然后，当它开始下载它需要处理的任何提交对象时，如果其中一个提交与这些标签中的任何一个具有相同的 ID，则 git
将添加该标签——或者那些标签，如果多个标签具有该 ID——你的存储库。</del></p>
<p>编辑，2017 年 1 月：测试表明 Git 2.10 中的行为现在是：如果他们的 Git 提供了一个名为 <em>T</em> 的标签， <em>而</em> 你没有一个名为 <em>T</em>
的标签， <em>并且与</em> <em>T</em> 关联的提交 ID是他们分支之一的祖先你<code>git fetch</code>正在检查，你的 Git 将 <em>T</em>
添加到你的标签中，有或没有<code>--tags</code>。添加<code>--tags</code>会导致您的 Git 获取 <em>所有</em> 标签，并强制更新。</p>
<h4>底线</h4>
<p>您可能必须使用<code>git fetch --tags</code>来获取他们的标签。如果他们的标签名称与您现有的标签名称冲突，您 <em>可能</em> （取决于 Git
版本）甚至必须删除（或重命名）您的一些标签，然后运行<code>git fetch
--tags</code>​​，以获取他们的标签。由于标签（与远程分支不同）没有自动重命名，您的标签名称必须与其标签名称匹配，这就是您可能会遇到冲突问题的原因。</p>
<p>但是，在 <em>大多数</em><code>git fetch</code>正常情况下，一个简单的人就可以完成这项工作，带来他们的提交和他们的匹配标签，并且由于他们 - 无论他们是谁 -
都会在他们发布这些提交时标记提交，你将跟上他们的标签。如果您不制作自己的标签，也不混合他们的存储库和其他存储库（通过多个远程），您也不会有任何标签名称冲突，因此您不必为了删除或重命名标签而大惊小怪获取他们的标签。</p>
<h4>当您需要限定名称时</h4>
<p>我在上面提到过，你<code>refs/</code>几乎总是可以省略<code>refs/heads/</code>等等<code>refs/tags/</code>。但你什么时候 <em>不能</em> ？</p>
<p>完整（或接近完整）的答案在文档<code>gitrevisions</code>中。Git 将使用链接中给出的六步序列将名称解析为提交
ID。奇怪的是，标签覆盖了分支：如果有一个标签<code>xyzzy</code>和一个分支<code>xyzzy</code>，并且它们指向不同的提交，那么：</p>
<div class="code"><pre class="code literal-block">git rev-parse xyzzy
</pre></div>

<p>将为您提供标签指向的 ID。然而——这就是缺少的<code>gitrevisions</code>——<code>git checkout</code>更喜欢分支名称，所以<code>git checkout
xyzzy</code>会把你放在分支上，而不管标签。</p>
<p>如果出现歧义，您几乎总是可以使用其全名<code>refs/heads/xyzzy</code>或<code>refs/tags/xyzzy</code>. （请注意，这确实 <em>适用</em> 于<code>git
checkout</code>，但可能以一种意想不到的方式：<code>git checkout
refs/heads/xyzzy</code>导致分离头检出而不是分支检出。这就是为什么你只需要注意<code>git
checkout</code>首先使用短名称作为分支名称的原因：这就是你的方式签出分支<code>xyzzy</code>即使标签<code>xyzzy</code>存在。如果你想签出标签，你可以使用<code>refs/tags/xyzzy</code>。）</p>
<p>因为（如<code>gitrevisions</code>注释）Git
会尝试，您也可以简单地编写以识别标记的提交。（但是，如果有人设法编写了一个名为into的有效引用，这将解析为。但通常只有各种名称应该在 中。）<code>refs/
_name_``tags/xyzzy``xyzzy``xyzzy``$GIT_DIR``$GIT_DIR/xyzzy``*HEAD``$GIT_DIR</code></p>
<hr>
<p>1好吧，好吧，“不只是 <em>为了</em> 迂腐”。:-)</p>
<p>2有人会说“非常没有帮助”，实际上我倾向于同意。</p>
<p>3基本上，<code>git fetch</code>以及 remotes 和 refspecs 的整个概念，是 Git 的一个较晚添加的东西，发生在 Git 1.5
左右。在那之前只有一些特别的特殊情况，标签获取就是其中之一，所以它通过特殊代码得到了保护。</p>
<p>4如果有帮助，请将远程 Git 想象成俚语中的闪光灯。</p>
<p><br><br><a href="posts/what-is-git-tag-how-to-create-tags-how-to-checkout-git-remote-tag-s/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yong-pandas-groupby-huo-qu-mei-ge-zu-de-tong-ji-xin-xi-li-ru-ji-shu-ping-jun-zhi-deng/" class="u-url">使用 pandas GroupBy 获取每个组的统计信息（例如计数、平均值等）？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yong-pandas-groupby-huo-qu-mei-ge-zu-de-tong-ji-xin-xi-li-ru-ji-shu-ping-jun-zhi-deng/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:28:33+08:00" itemprop="datePublished" title="2023-02-17 15:28">2023-02-17 15:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我有一个数据框<code>df</code>，我使用其中的几列来<code>groupby</code>：</p>
<div class="code"><pre class="code literal-block">df['col1','col2','col3','col4'].groupby(['col1','col2']).mean()
</pre></div>

<p>通过上述方式，我几乎得到了我需要的表格（数据框）。缺少的是一个附加列，其中包含每个组中的行数。换句话说，我有意思，但我也想知道有多少数字被用来获得这些意思。例如，第一组有
8 个值，第二组有 10 个值，依此类推。</p>
<p>简而言之：如何获取数据框的 <strong>分组统计信息？</strong></p>
<p><br><br></p>
<h2>解答</h2>
<p>在<code>groupby</code>对象上，该<code>agg</code>函数可以使用一个列表来一次应用多个聚合方法。这应该会给你你需要的结果：</p>
<div class="code"><pre class="code literal-block">df[['col1', 'col2', 'col3', 'col4']].groupby(['col1', 'col2']).agg(['mean', 'count'])
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>在<code>groupby</code>对象上，该<code>agg</code>函数可以使用一个列表来一次应用多个聚合方法。这应该会给你你需要的结果：</p>
<div class="code"><pre class="code literal-block">df[['col1', 'col2', 'col3', 'col4']].groupby(['col1', 'col2']).agg(['mean', 'count'])
</pre></div>

<p><br><br><a href="posts/get-statistics-for-each-group-such-as-count-mean-etc-using-pandas-groupby/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-764.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-762.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
