<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 39) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-39.html">
<link rel="prev" href="index-40.html" type="text/html">
<link rel="next" href="index-38.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/jiang-xian-you-de-wei-ti-jiao-de-gong-zuo-yi-dong-dao-git-zhong-de-xin-fen-zhi/" class="u-url">将现有的、未提交的工作移动到 Git 中的新分支</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/jiang-xian-you-de-wei-ti-jiao-de-gong-zuo-yi-dong-dao-git-zhong-de-xin-fen-zhi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:22:31+08:00" itemprop="datePublished" title="2023-02-16 19:22">2023-02-16 19:22</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我开始了一些关于新特性的工作，在编码了一点之后，我决定这个特性应该在它自己的分支上。</p>
<p>如何将现有未提交的更改移动到新分支并重置当前分支？</p>
<p>我想重置我当前的分支，同时保留关于新功能的现有工作。</p>
<p><br><br></p>
<h2>解答</h2>
<h4>2020 年更新/Git 2.23</h4>
<p>Git 2.23 添加了新的<code>switch</code>子命令，试图消除因超载使用<code>checkout</code>（切换分支、恢复文件、分离 HEAD 等）而产生的一些混乱。</p>
<p>从这个版本的 Git 开始，将 checkout 命令替换为：</p>
<div class="code"><pre class="code literal-block">git switch -c &lt;new-branch&gt;
</pre></div>

<p>行为是相同的并且保持不变。</p>
<hr>
<h4>更新 2020 / Git 2.23 之前</h4>
<p>使用以下内容：</p>
<div class="code"><pre class="code literal-block">git checkout -b &lt;new-branch&gt;
</pre></div>

<p>这将使您当前的分支保持原样，创建并签出一个新分支并保留所有更改。然后，您可以暂存文件中的更改以提交：</p>
<div class="code"><pre class="code literal-block">git add &lt;files&gt;
</pre></div>

<p>并提交给你的 <em>新分支</em> ：</p>
<div class="code"><pre class="code literal-block">git commit -m "&lt;Brief description of this commit&gt;"
</pre></div>

<p>工作目录中的更改和索引中暂存的更改 <em>尚不属于任何分支</em> 。这会更改这些修改结束的分支。</p>
<p>您不 <em>重置</em> 原始分支，它保持原样。最后一次提交<code>&lt;old-branch&gt;</code>仍然是一样的。因此，您<code>checkout -b</code>然后提交。</p>
<p><br></p>
<h3>更多建议</h3>
<p>或者：</p>
<ol>
<li>将当前更改保存到临时存储：</li>
</ol>
<p><code>$ git stash</code></p>
<ol>
<li>基于这个 stash 创建一个新的分支，并切换到新的分支：</li>
</ol>
<p><code>$ git stash branch &lt;new-branch&gt; stash@{0}</code></p>
<p>提示：使用 tab 键可以减少输入存储名称。</p>
<p><br><br><a href="posts/move-existing-uncommitted-work-to-a-new-branch-in-git/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-bian-li-pandas-dataframe-zhong-de-xing/" class="u-url">如何遍历 Pandas DataFrame 中的行</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-bian-li-pandas-dataframe-zhong-de-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:22:03+08:00" itemprop="datePublished" title="2023-02-16 19:22">2023-02-16 19:22</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我有一个熊猫数据框，<code>df</code>：</p>
<div class="code"><pre class="code literal-block">   c1   c2
0  10  100
1  11  110
2  12  120
</pre></div>

<p>如何遍历此数据框的行？对于每一行，我希望能够通过列名访问其元素（单元格中的值）。例如：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">rows</span>:
<span class="w">    </span><span class="nv">print</span><span class="ss">(</span><span class="nv">row</span>[<span class="s1">'c1'</span>],<span class="w"> </span><span class="nv">row</span>[<span class="s1">'c2'</span>]<span class="ss">)</span>
</pre></div>

<hr>
<p>我发现了一个类似的问题，建议使用以下任一方法：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">date</span>,<span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">T</span>.<span class="nv">iteritems</span><span class="ss">()</span>:



<span class="k">for</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">iterrows</span><span class="ss">()</span>:
</pre></div>

<p>但是我不明白对象<code>row</code>是什么以及如何使用它。</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>DataFrame.iterrows</code>是一个产生索引和行的生成器（作为一个系列）：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'c1'</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="s1">'c2'</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">]})</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1"># make sure indexes pair with number of rows</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">'c1'</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">'c2'</span><span class="p">])</span>



<span class="mi">10</span> <span class="mi">100</span>
<span class="mi">11</span> <span class="mi">110</span>
<span class="mi">12</span> <span class="mi">120</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<blockquote>
<h3>如何遍历 Pandas DataFrame 中的行</h3>
</blockquote>
<h2>答：不要*！</h2>
<p>Pandas
中的迭代是一种反模式，只有在用尽所有其他选项时才应该这样做。你不应该<code>iter</code>在超过几千行的情况下使用任何名称中带有“”的函数，否则你将不得不习惯大量
<strong>的</strong> 等待。</p>
<p>你想打印一个 DataFrame 吗？使用 <strong><code>DataFrame.to_string()</code></strong> 。</p>
<p>你想计算一些东西吗？在这种情况下，按此顺序搜索方法（从此处修改的列表）：</p>
<ol>
<li>矢量化</li>
<li>Cython例程</li>
<li>列表理解（香草<code>for</code>循环）</li>
<li>
<strong><code>DataFrame.apply()</code></strong> : i) 可以在 Cython 中执行的归约，ii) Python 空间中的迭代</li>
<li>
<strong><code>DataFrame.itertuples()</code></strong> 和 <strong><code>iteritems()</code></strong>
</li>
<li><strong><code>DataFrame.iterrows()</code></strong></li>
</ol>
<p><code>iterrows</code>并且<code>itertuples</code>（在回答这个问题时都获得了很多选票）应该在非常罕见的情况下使用，例如为顺序处理生成行对象/名称元组，这实际上是这些函数唯一有用的地方。</p>
<p><strong>诉诸权威</strong></p>
<p>关于迭代的文档页面有一个巨大的红色警告框，上面写着：</p>
<blockquote>
<p>遍历 pandas 对象通常很慢。在许多情况下，不需要手动遍历行 [...]。</p>
</blockquote>
<ul>
<li>它实际上比“不要”要复杂一点。<code>df.iterrows()</code>是这个问题的正确答案，但“向量化你的操作”是更好的答案。我承认在某些情况下无法避免迭代（例如，某些操作的结果取决于为前一行计算的值）。但是，需要对库有一定的了解才能知道什么时候。如果您不确定是否需要迭代解决方案，您可能不需要。PS：要了解更多关于我写这个答案的理由，请跳到最底部。</li>
</ul>
<hr>
<h3>比循环更快：矢量化，Cython</h3>
<p>pandas（通过 NumPy 或通过 Cythonized
函数）“矢量化”了大量基本操作和计算。这包括算术、比较、（大多数）归约、重塑（例如旋转）、连接和分组操作。查看有关Essential Basic
Functionality的文档，找到适合您的问题的矢量化方法。</p>
<p>如果不存在，请随意使用自定义Cython 扩展编写您自己的。</p>
<hr>
<h3>下一个最好的事情：列出理解*</h3>
<p>如果 1) 没有可用的矢量化解决方案，2) 性能很重要，但还不够重要，无法解决代码的 cythonizing 问题，并且 3)
您正在尝试执行元素转换在你的代码上。有大量证据表明，列表理解对于许多常见的 Pandas 任务来说足够快（有时甚至更快）。</p>
<p>公式很简单，</p>
<div class="code"><pre class="code literal-block"><span class="c1"># Iterating over one column - `f` is some function that processes your data</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'col'</span><span class="err">]]</span>
<span class="c1"># Iterating over two columns, use `zip`</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zip</span><span class="p">(</span><span class="n">df</span><span class="err">[</span><span class="s1">'col1'</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'col2'</span><span class="err">]</span><span class="p">)</span><span class="err">]</span>
<span class="c1"># Iterating over multiple columns - same data type</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="k">row</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">row</span><span class="err">[</span><span class="n">n</span><span class="err">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">df</span><span class="err">[[</span><span class="s1">'col1'</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="s1">'coln'</span><span class="err">]]</span><span class="p">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="err">]</span>
<span class="c1"># Iterating over multiple columns - differing data type</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="k">row</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">row</span><span class="err">[</span><span class="n">n</span><span class="err">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zip</span><span class="p">(</span><span class="n">df</span><span class="err">[</span><span class="s1">'col1'</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'coln'</span><span class="err">]</span><span class="p">)</span><span class="err">]</span>
</pre></div>

<p>如果您可以将业务逻辑封装到一个函数中，则可以使用调用它的列表理解。您可以通过原始 Python 代码的简单性和速度来处理任意复杂的事情。</p>
<p><strong>注意事项</strong></p>
<p>列表理解假定您的数据易于使用——这意味着您的数据类型是一致的并且您没有 NaN，但这不能总是得到保证。</p>
<ol>
<li>第一个更明显，但是在处理 NaN 时，如果存在内置的 pandas 方法（因为它们具有更好的极端情况处理逻辑），则更喜欢它们，或者确保您的业务逻辑包含适当的 NaN 处理逻辑。</li>
<li>在处理混合数据类型时，您应该迭代而<code>zip(df['A'], df['B'], ...)</code>不是因为<code>df[['A', 'B']].to_numpy()</code>后者隐式地将数据向上转换为最常见的类型。例如，如果 A 是数字而 B 是字符串，<code>to_numpy()</code>会将整个数组转换为字符串，这可能不是您想要的。幸运的是，<code>zip</code>将您的列一起 ping 是最直接的解决方法。</li>
</ol>
<p><strong>*您的里程数可能会因上述注意事项</strong> 部分中概述的原因而有所不同。</p>
<hr>
<h3>一个明显的例子</h3>
<p>让我们通过添加两个 pandas 列的简单示例来演示差异<code>A + B</code>。这是一个可向量化的操作，因此很容易对比上面讨论的方法的性能。</p>
<p><img alt="" src="images/y44RJ.png"></p>
<p>基准代码，供大家参考。底部的一行测量了一个用 numpandas 编写的函数，numpandas 是一种与 NumPy 大量混合以发挥最大性能的
Pandas 风格。除非您知道自己在做什么，否则应避免编写 numpandas 代码。尽可能坚持使用 API（即，优先<code>vec</code>于<code>vec_numpy</code>）。</p>
<p>然而，我应该提一下，它并不总是如此干脆。有时“什么是最佳操作方法”的答案是“这取决于您的数据”。我的建议是在选择一种方法之前先针对您的数据测试不同的方法。</p>
<hr>
<h3>我的个人意见*</h3>
<p>对 iter 系列的各种替代方案进行的大多数分析都是通过性能的镜头进行的。然而，在大多数情况下，您通常会处理一个合理大小的数据集（不超过几千行或 10
万行），性能将仅次于解决方案的简单性/可读性。</p>
<p>在选择用于解决问题的方法时，这是我个人的偏好。</p>
<p>对于新手：</p>
<blockquote>
<p><em>矢量化</em> （如果可能） <em>；<code>apply()</code>; 列表理解；<code>itertuples()</code>/ <code>iteritems()</code>; <code>iterrows()</code>;
Cython</em></p>
</blockquote>
<p>对于更有经验的人：</p>
<blockquote>
<p><em>矢量化</em> （如果可能） <em>；<code>apply()</code>; 列表理解；赛通; <code>itertuples()</code>/
<code>iteritems()</code>;<code>iterrows()</code></em></p>
</blockquote>
<p>对于任何可以向量化的问题，向量化都是最惯用的方法。始终寻求矢量化！如有疑问，请查阅文档，或在 Stack Overflow
上查找有关您的特定任务的现有问题。</p>
<p>我确实倾向于继续谈论<code>apply</code>我的很多帖子有多糟糕，但我承认对于初学者来说更容易理解它在做什么。此外，在我的这篇文章<code>apply</code>中解释了很多用例。</p>
<p>Cython 在列表中排名靠后，因为它需要更多的时间和精力才能正确完成。您通常永远不需要使用 pandas
编写需要这种性能水平的代码，即使是列表理解也无法满足。</p>
<p>*与任何个人意见一样，请带上大量盐！</p>
<hr>
<h3>进一步阅读</h3>
<ul>
<li>
<p>10 Minutes to pandas和Essential Basic Functionality - 向您介绍 Pandas 及其向量化*/cythonized 函数库的有用链接。</p>
</li>
<li>
<p>增强性能- 增强标准 Pandas 操作文档中的入门读物</p>
</li>
<li>
<p><em>pandas 中的 for 循环真的很糟糕吗？ 我什么时候应该关心？</em>- 我详细写了一篇关于列表理解及其对各种操作（主要是涉及非数字数据的操作）的适用性的文章</p>
</li>
<li>
<p><em>我什么时候应该（不）想在我的代码中使用 pandas apply() ？</em> -<code>apply</code>很慢（但不像<code>iter*</code>家庭那么慢。但是，在某些情况下，人们可以（或应该）考虑将其<code>apply</code>作为一种严肃的选择，尤其是在某些<code>GroupBy</code>操作中）。</p>
</li>
<li>
<p>Pandas 字符串方法是“矢量化”的，因为它们在系列中指定但对每个元素进行操作。底层机制仍然是迭代的，因为字符串操作本质上很难向量化。</p>
</li>
</ul>
<hr>
<h3>为什么我写这个答案</h3>
<p>我从新用户那里注意到的一个常见趋势是提出“如何迭代我的 df 来执行
X？”形式的问题。<code>iterrows()</code>显示在循环内执行某些操作时调用的代码<code>for</code>。这就是为什么。没有被介绍过矢量化概念的图书馆新用户可能会将解决他们问题的代码想象为迭代他们的数据来做某事。不知道如何遍历
DataFrame，他们做的第一件事就是谷歌搜索并在这个问题上结束。然后他们看到接受的答案告诉他们如何去做，他们闭上眼睛并运行这段代码，而没有首先质疑迭代是否是正确的事情。</p>
<p>这个答案的目的是帮助新用户理解迭代不一定是所有问题的解决方案，可能存在更好、更快和更惯用的解决方案，值得花时间去探索它们。我并不是要开始一场迭代与矢量化的战争，但我希望新用户在使用这个库开发问题解决方案时得到通知。</p>
<p><br><br><a href="posts/how-to-iterate-over-rows-in-a-dataframe-in-pandas/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/fu-dian-shu-xue-pi-liao-ma/" class="u-url">浮点数学坏了吗？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/fu-dian-shu-xue-pi-liao-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:21:28+08:00" itemprop="datePublished" title="2023-02-16 19:21">2023-02-16 19:21</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>考虑以下代码：</p>
<div class="code"><pre class="code literal-block"><span class="mf">0.1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.3</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">false</span>



<span class="mf">0.1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.2</span><span class="w">         </span><span class="o">-&gt;</span><span class="w">  </span><span class="mf">0.30000000000000004</span>
</pre></div>

<p>为什么会出现这些错误？</p>
<p><br><br></p>
<h2>解答</h2>
<p>二进制浮点数学就是这样。在大多数编程语言中，它基于IEEE 754 标准。问题的症结在于，数字以这种格式表示为整数乘以 2 的幂；分母不是 2
的幂的有理数（例如<code>0.1</code>，它是）无法精确表示。<code>1/10</code></p>
<p>因为<code>0.1</code>在标准<code>binary64</code>格式中，表示可以完全写成</p>
<ul>
<li>
<code>0.1000000000000000055511151231257827021181583404541015625</code>十进制，或</li>
<li>
<code>0x1.999999999999ap-4</code>在C99 hexfloat 表示法中。</li>
</ul>
<p>相反，有理数<code>0.1</code>，即<code>1/10</code>，可以写成</p>
<ul>
<li>
<code>0.1</code>十进制，或</li>
<li>
<code>0x1.99999999999999...p-4</code>在 C99 hexfloat 表示法的模拟中，其中<code>...</code>代表 9 的无限序列。</li>
</ul>
<p>程序中的常量<code>0.2</code>和也将是它们真实值的近似值。<code>0.3</code>碰巧最接近<code>double</code>的<code>0.2</code>比有理数大<code>0.2</code>，但最接近<code>double</code>的<code>0.3</code>比有理数小<code>0.3</code>。<code>0.1</code>和的总和<code>0.2</code>最终大于有理数<code>0.3</code>，因此与代码中的常量不一致。</p>
<p>对浮点运算问题的相当全面的处理是 <em>What Every Computer Scientist Should Know About Floating-
Point Arithmetic</em> 。有关更易于理解的解释，请参阅floating-point-gui.de。</p>
<blockquote>
<p><strong>旁注：所有位置（以 N 为基数）数字系统都精确地共享此问题</strong></p>
</blockquote>
<p>普通的旧十进制（基数为 10）数字也有同样的问题，这就是为什么像 1/3 这样的数字最终会变成 0.333333333...</p>
<p>您刚刚偶然发现了一个数字 (3/10)，它恰好很容易用十进制表示，但不适合二进制系统。它也是双向的（在某种程度上）：1/16 是一个难看的十进制数字
(0.0625)，但在二进制中它看起来和十进制中的第 10,000 一样整洁 (0.0001)** - 如果我们在在我们的日常生活中习惯使用以 2
为底的数字系统，你甚至会看着那个数字并本能地理解你可以通过将某物减半，再减半，一次又一次地到达那里。</p>
<p>当然，这并不是浮点数在内存中的确切存储方式（它们使用一种科学记数法）。然而，它确实说明了二进制浮点精度错误往往会出现这一点，因为我们通常感兴趣的“现实世界”数字通常是十的幂——但这只是因为我们使用十进制数字系统日——今天。这也是为什么我们会说
71% 而不是“每 7 个中有 5 个”（71% 是一个近似值，因为 5/7 不能用任何小数精确表示）。</p>
<p>所以不：二进制浮点数没有被破坏，它们恰好与其他所有以 N 为基数的数字系统一样不完美 :)</p>
<blockquote>
<p><strong>旁注：在编程中使用浮点数</strong></p>
</blockquote>
<p>实际上，这个精度问题意味着您需要使用舍入函数将浮点数四舍五入到您感兴趣的小数位数，然后再显示它们。</p>
<p>您还需要用允许一定容差的比较替换相等性测试，这意味着：</p>
<p>不要做 <strong>_</strong><code>if (x == y) { ... }</code></p>
<p>而是做<code>if (abs(x - y) &lt; myToleranceValue) { ... }</code>。</p>
<p>哪里<code>abs</code>是绝对值。<code>myToleranceValue</code>需要为您的特定应用程序选择 -
这将与您准备允许的“摆动空间”有很大关系，以及您要比较的最大数字可能是多少（由于精度问题的损失） ). 当心您选择的语言中的“epsilon”样式常量。这些
<strong>可以</strong> 用作公差值，但它们的有效性取决于您正在使用的数字的大小（大小），因为大数字的计算可能会超过 epsilon 阈值。</p>
<p><br></p>
<h3>更多建议</h3>
<h2><strong>硬件设计师的观点</strong></h2>
<p>自从我设计和构建浮点硬件以来，我认为我应该对此添加硬件设计师的观点。了解错误的来源可能有助于理解软件中发生的事情，最终，我希望这有助于解释浮点错误发生的原因，并且似乎会随着时间的推移而累积。</p>
<h3>一、概述</h3>
<p>从工程的角度来看，大多数浮点运算都会有一些错误元素，因为进行浮点计算的硬件只需要在最后一个位置的误差小于一个单位的二分之一。
<em>因此，许多硬件将停止在一个精度上，该精度只需要在单个操作</em>
的最后位置产生小于一个单位的二分之一的误差，这在浮点除法中尤其成问题。什么构成单个操作取决于该单元需要多少个操作数。大多数情况下，它是两个，但有些单元需要
3 个或更多操作数。因此，无法保证重复操作会导致所需的错误，因为错误会随着时间的推移而累积。</p>
<h3>2.标准</h3>
<p>大多数处理器遵循IEEE-754标准，但有些处理器使用非规范化或不同的标准。例如，IEEE-754
中有一种非规范化模式，它允许以牺牲精度为代价来表示非常小的浮点数。然而，下文将介绍 IEEE-754 的规范化模式，这是典型的操作模式。</p>
<p>在 IEEE-754 标准中，硬件设计者可以使用任何误差/epsilon
值，只要它小于最后一个单位的二分之一，结果只需小于最后一个单位的二分之一一个操作的地方。这就解释了为什么当有重复的操作时，错误会累积起来。对于
IEEE-754 双精度，这是第 54 位，因为 53 位用于表示浮点数的数字部分（规范化），也称为尾数（例如 5.3e5 中的
5.3）。下一节将更详细地介绍各种浮点运算的硬件错误原因。</p>
<h3>三、除法舍入误差的原因</h3>
<p>浮点除法错误的主要原因是用于计算商的除法算法。大多数计算机系统使用逆乘法来计算除法，主要是<code>Z=X/Y</code>,<code>Z = X * (1/Y)</code>.
除法是迭代计算的，即每个循环计算商的一些位，直到达到所需的精度，对于 IEEE-754
来说，这是最后一位误差小于一个单位的任何东西。Y（1/Y）的倒数表在慢除法中称为商选择表（QST），商选择表的位数通常是基数的宽度，或者是位数的位数在每次迭代中计算的商，加上一些保护位。对于
IEEE-754 标准，双精度（64 位），它将是除法器基数的大小加上几个保护位 k，其中<code>k&gt;=2</code>. 因此，例如，一次计算 2 位商（基数
4）的除法器的典型商选择表将是<code>2+2= 4</code>位（加上一些可选位）。</p>
<p><strong>3.1除法舍入误差：倒数的近似</strong></p>
<p>商选择表中的倒数取决于除法方法：慢除法如SRT除法，或快除法如Goldschmidt除法；每个条目都根据除法算法进行修改，以试图产生尽可能低的错误。但无论如何，所有的倒数都是
<em>近似值</em>
的实际倒数并引入一些误差元素。慢除法和快除法都是迭代计算商，即每一步计算商的一些位数，然后将结果从被除数中减去，除法器重复这些步骤，直到误差小于二分之一单位在最后。慢速除法在每一步计算商的固定位数，通常构建成本较低，而快速除法每步计算可变位数，构建成本通常较高。除法最重要的部分是它们中的大多数依赖于重复乘以倒数的
<em>近似值，因此它们很容易出错。</em></p>
<h3>4.其他操作中的舍入误差：截断</h3>
<p>所有操作中舍入错误的另一个原因是 IEEE-754
允许的最终答案截断的不同模式。有截断、向零舍入、舍入到最近（默认）、向下舍入和向上舍入。对于单个操作，所有方法都在最后位置引入小于一个单位的误差元素。随着时间的推移和重复的操作，截断也会累积地增加所产生的错误。这种截断误差在求幂中尤其成问题，涉及某种形式的重复乘法。</p>
<h3>5.重复操作</h3>
<p>由于进行浮点计算的硬件只需要在单个操作的最后位置产生误差小于一个单位的二分之一的结果，如果不注意，误差会随着重复操作而增加。这就是为什么在需要有界误差的计算中，数学家使用诸如在
IEEE-754 的最后一位舍入到最接近的偶数等方法，因为随着时间的推移，误差更有可能相互抵消out 和Interval Arithmetic与IEEE
754 舍入模式的变体相结合预测舍入误差，并纠正它们。由于与其他舍入模式相比它的相对误差较低，舍入到最接近的偶数（在最后一位）是 IEEE-754
的默认舍入模式。</p>
<p>请注意，默认舍入模式，最后一位舍入到最接近的偶数位，保证一次操作的最后一位误差小于一个单位的二分之一。单独使用截断、上舍入和下舍入可能会导致最后一位大于一个单位的二分之一，但最后一位小于一个单位的误差，所以不推荐使用这些模式，除非它们是用于区间运算。</p>
<h3>6.总结</h3>
<p>简而言之，浮点运算错误的根本原因是硬件截断和除法时倒数截断的结合。由于 IEEE-754
标准仅要求单个操作在最后一位的误差小于一个单位的二分之一，因此除非更正，否则重复操作的浮点误差将累加起来。</p>
<p><br><br><a href="posts/is-floating-point-math-broken/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-40.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-38.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
