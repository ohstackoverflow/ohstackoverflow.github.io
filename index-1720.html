<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1720) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1720.html">
<link rel="prev" href="index-1721.html" type="text/html">
<link rel="next" href="index-1719.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/triggering-change-detection-manually-in-angular/" class="u-url">Triggering change detection manually in Angular</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/triggering-change-detection-manually-in-angular/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T07:45:14+08:00" itemprop="datePublished" title="2023-03-03 07:45">2023-03-03 07:45</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm writing an Angular component that has a property <code>Mode(): string</code>.</p>
<p>I would like to be able to set this property programmatically not in response
to any event.</p>
<p>The problem is that in the absence of a browser event, a template binding
<code>{{Mode}}</code> doesn't update.</p>
<p>Is there a way to trigger this change detection manually?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Try one of these:</p>
<ul>
<li>
<code>ApplicationRef.tick()</code> - similar to AngularJS's <code>$rootScope.$digest()</code> -- i.e., check the full component tree</li>
<li>
<code>NgZone.run(callback)</code> - similar to <code>$rootScope.$apply(callback)</code> -- i.e., evaluate the callback function inside the Angular zone. I think, but I'm not sure, that this ends up checking the full component tree after executing the callback function.</li>
<li>
<code>ChangeDetectorRef.detectChanges()</code> - similar to <code>$scope.$digest()</code> -- i.e., check only this component and its children</li>
</ul>
<p>You can inject <code>ApplicationRef</code>, <code>NgZone</code>, or <code>ChangeDetectorRef</code> into your
component.</p>
<p><br></p>
<h3>Suggest</h3>
<p>I used accepted answer reference and would like to put an example, since
Angular 2 documentation is very very hard to read, I hope this is easier:</p>
<ol>
<li>
<p>Import <code>NgZone</code>:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">Component</span><span class="p">,</span> <span class="n">NgZone</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">'@angular/core'</span><span class="p">;</span>
</pre></div>

</li>
<li>
<p>Add it to your class constructor</p>
<div class="code"><pre class="code literal-block"><span class="n">constructor</span><span class="p">(</span><span class="n">public</span><span class="w"> </span><span class="n">zone</span><span class="p">:</span><span class="w"> </span><span class="n">NgZone</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="n">args</span><span class="p">){}</span>
</pre></div>

</li>
<li>
<p>Run code with <code>zone.run</code>:</p>
<div class="code"><pre class="code literal-block">this.zone.run(() =&gt; this.donations = donations)
</pre></div>

</li>
</ol>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-i-pass-a-unique-ptr-argument-to-a-constructor-or-a-function/" class="u-url">How do I pass a unique_ptr argument to a constructor or a function?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-i-pass-a-unique-ptr-argument-to-a-constructor-or-a-function/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T07:44:49+08:00" itemprop="datePublished" title="2023-03-03 07:44">2023-03-03 07:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm new to move semantics in C++11 and I don't know very well how to handle
<code>unique_ptr</code> parameters in constructors or functions. Consider this class
referencing itself:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="kr">class</span><span class="w"> </span><span class="nc">Base</span>
<span class="p">{</span>
<span class="w">  </span><span class="kr">public</span><span class="o">:</span>

<span class="w">    </span><span class="kr">typedef</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="n">UPtr</span><span class="p">;</span>

<span class="w">    </span><span class="n">Base</span><span class="p">(){}</span>
<span class="w">    </span><span class="n">Base</span><span class="p">(</span><span class="n">Base</span><span class="o">::</span><span class="n">UPtr</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">next</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">move</span><span class="p">(</span><span class="n">n</span><span class="p">)){}</span>

<span class="w">    </span><span class="kr">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Base</span><span class="p">(){}</span>

<span class="w">    </span><span class="kr">void</span><span class="w"> </span><span class="n">setNext</span><span class="p">(</span><span class="n">Base</span><span class="o">::</span><span class="n">UPtr</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="nf">move</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="kr">protected</span><span class="w"> </span><span class="o">:</span>

<span class="w">    </span><span class="n">Base</span><span class="o">::</span><span class="n">UPtr</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>

<span class="p">};</span>
</pre></div>

<p>Is this how I should write functions taking <code>unique_ptr</code> arguments?</p>
<p>And do I need to use <code>std::move</code> in the calling code?</p>
<div class="code"><pre class="code literal-block"><span class="nt">Base</span><span class="p">::</span><span class="nd">UPtr</span><span class="w"> </span><span class="nt">b1</span><span class="o">;</span>
<span class="nt">Base</span><span class="p">::</span><span class="nd">UPtr</span><span class="w"> </span><span class="nt">b2</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Base</span><span class="o">());</span>

<span class="nt">b1-</span><span class="o">&gt;</span><span class="nt">setNext</span><span class="o">(</span><span class="nt">b2</span><span class="o">);</span><span class="w"> </span><span class="o">//</span><span class="nt">should</span><span class="w"> </span><span class="nt">I</span><span class="w"> </span><span class="nt">write</span><span class="w"> </span><span class="nt">b1-</span><span class="o">&gt;</span><span class="nt">setNext</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">b2</span><span class="o">));</span><span class="w"> </span><span class="nt">instead</span><span class="o">?</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Here are the possible ways to take a unique pointer as an argument, as well as
their associated meaning.</p>
<h4>(A) By Value</h4>
<div class="code"><pre class="code literal-block"><span class="nv">Base</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">n</span><span class="ss">)</span>
<span class="w">  </span>:<span class="w"> </span><span class="k">next</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">move</span><span class="ss">(</span><span class="nv">n</span><span class="ss">))</span><span class="w"> </span>{}
</pre></div>

<p>In order for the user to call this, they must do one of the following:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Base</span><span class="w"> </span><span class="nt">newBase</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">nextBase</span><span class="o">));</span>
<span class="nt">Base</span><span class="w"> </span><span class="nt">fromTemp</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Base</span><span class="o">(...));</span>
</pre></div>

<p>To take a unique pointer by value means that you are <em>transferring</em> ownership
of the pointer to the function/object/etc in question. After <code>newBase</code> is
constructed, <code>nextBase</code> is guaranteed to be <em>empty</em>. You don't own the object,
and you don't even have a pointer to it anymore. It's gone.</p>
<p>This is ensured because we take the parameter by value. <code>std::move</code> doesn't
actually <em>move</em> anything; it's just a fancy cast. <code>std::move(nextBase)</code>
returns a <code>Base&amp;&amp;</code> that is an r-value reference to <code>nextBase</code>. That's all it
does.</p>
<p>Because <code>Base::Base(std::unique_ptr&lt;Base&gt; n)</code> takes its argument by value
rather than by r-value reference, C++ will automatically construct a temporary
for us. It creates a <code>std::unique_ptr&lt;Base&gt;</code> from the <code>Base&amp;&amp;</code> that we gave
the function via <code>std::move(nextBase)</code>. It is the construction of this
temporary that actually <em>moves</em> the value from <code>nextBase</code> into the function
argument <code>n</code>.</p>
<h4>(B) By non-const l-value reference</h4>
<div class="code"><pre class="code literal-block"><span class="nv">Base</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="nv">n</span><span class="ss">)</span>
<span class="w">  </span>:<span class="w"> </span><span class="k">next</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">move</span><span class="ss">(</span><span class="nv">n</span><span class="ss">))</span><span class="w"> </span>{}
</pre></div>

<p>This has to be called on an actual l-value (a named variable). It cannot be
called with a temporary like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Base</span><span class="w"> </span><span class="nt">newBase</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Base</span><span class="o">));</span><span class="w"> </span><span class="o">//</span><span class="nt">Illegal</span><span class="w"> </span><span class="nt">in</span><span class="w"> </span><span class="nt">this</span><span class="w"> </span><span class="nt">case</span><span class="o">.</span>
</pre></div>

<p>The meaning of this is the same as the meaning of any other use of non-const
references: the function may <em>or may not</em> claim ownership of the pointer.
Given this code:</p>
<div class="code"><pre class="code literal-block">Base newBase(nextBase);
</pre></div>

<p>There is no guarantee that <code>nextBase</code> is empty. It <em>may</em> be empty; it may not.
It really depends on what <code>Base::Base(std::unique_ptr&lt;Base&gt; &amp;n)</code> wants to do.
Because of that, it's not very evident just from the function signature what's
going to happen; you have to read the implementation (or associated
documentation).</p>
<p>Because of that, I wouldn't suggest this as an interface.</p>
<h4>(C) By const l-value reference</h4>
<div class="code"><pre class="code literal-block"><span class="n">Base</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
</pre></div>

<p>I don't show an implementation, because you <em>cannot</em> move from a <code>const&amp;</code>. By
passing a <code>const&amp;</code>, you are saying that the function can access the <code>Base</code> via
the pointer, but it cannot <em>store</em> it anywhere. It cannot claim ownership of
it.</p>
<p>This can be useful. Not necessarily for your specific case, but it's always
good to be able to hand someone a pointer and know that they <em>cannot</em> (without
breaking rules of C++, like no casting away <code>const</code>) claim ownership of it.
They can't store it. They can pass it to others, but those others have to
abide by the same rules.</p>
<h4>(D) By r-value reference</h4>
<div class="code"><pre class="code literal-block"><span class="nv">Base</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="nv">n</span><span class="ss">)</span>
<span class="w">  </span>:<span class="w"> </span><span class="k">next</span><span class="ss">(</span><span class="nv">std</span>::<span class="nv">move</span><span class="ss">(</span><span class="nv">n</span><span class="ss">))</span><span class="w"> </span>{}
</pre></div>

<p>This is more or less identical to the "by non-const l-value reference" case.
The differences are two things.</p>
<ol>
<li>
<p>You <em>can</em> pass a temporary:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Base</span><span class="w"> </span><span class="nt">newBase</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Base</span><span class="o">));</span><span class="w"> </span><span class="o">//</span><span class="nt">legal</span><span class="w"> </span><span class="nt">now</span><span class="o">..</span>
</pre></div>

</li>
<li>
<p>You <em>must</em> use <code>std::move</code> when passing non-temporary arguments.</p>
</li>
</ol>
<p>The latter is really the problem. If you see this line:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Base</span><span class="w"> </span><span class="nt">newBase</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">nextBase</span><span class="o">));</span>
</pre></div>

<p>You have a reasonable expectation that, after this line completes, <code>nextBase</code>
should be empty. It should have been moved from. After all, you have that
<code>std::move</code> sitting there, telling you that movement has occurred.</p>
<p>The problem is that it hasn't. It is not <em>guaranteed</em> to have been moved from.
It <em>may</em> have been moved from, but you will only know by looking at the source
code. You cannot tell just from the function signature.</p>
<h4>Recommendations</h4>
<ul>
<li>
<strong>(A) By Value:</strong> If you mean for a function to claim <em>ownership</em> of a <code>unique_ptr</code>, take it by value.</li>
<li>
<strong>(C) By const l-value reference:</strong> If you mean for a function to simply use the <code>unique_ptr</code> for the duration of that function's execution, take it by <code>const&amp;</code>. Alternatively, pass a <code>&amp;</code> or <code>const&amp;</code> to the actual type pointed to, rather than using a <code>unique_ptr</code>.</li>
<li>
<strong>(D) By r-value reference:</strong> If a function may or may not claim ownership (depending on internal code paths), then take it by <code>&amp;&amp;</code>. But I strongly advise against doing this whenever possible.</li>
</ul>
<h4>How to manipulate unique_ptr</h4>
<p>You cannot copy a <code>unique_ptr</code>. You can only move it. The proper way to do
this is with the <code>std::move</code> standard library function.</p>
<p>If you take a <code>unique_ptr</code> by value, you can move from it freely. But movement
doesn't actually happen because of <code>std::move</code>. Take the following statement:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">newPtr</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">oldPtr</span><span class="o">));</span>
</pre></div>

<p>This is really two statements:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="nt">temporary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">oldPtr</span><span class="o">);</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">newPtr</span><span class="o">(</span><span class="nt">temporary</span><span class="o">);</span>
</pre></div>

<p>(note: The above code does not technically compile, since non-temporary
r-value references are not actually r-values. It is here for demo purposes
only).</p>
<p>The <code>temporary</code> is just an r-value reference to <code>oldPtr</code>. It is in the
<em>constructor</em> of <code>newPtr</code> where the movement happens. <code>unique_ptr</code>'s move
constructor (a constructor that takes a <code>&amp;&amp;</code> to itself) is what does the
actual movement.</p>
<p>If you have a <code>unique_ptr</code> value and you want to store it somewhere, you
<em>must</em> use <code>std::move</code> to do the storage.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Let me try to state the different viable modes of passing pointers around to
objects whose memory is managed by an instance of the <code>std::unique_ptr</code> class
template; it also applies to the the older <code>std::auto_ptr</code> class template
(which I believe allows all uses that unique pointer does, but for which in
addition modifiable lvalues will be accepted where rvalues are expected,
without having to invoke <code>std::move</code>), and to some extent also to
<code>std::shared_ptr</code>.</p>
<p>As a concrete example for the discussion I will consider the following simple
list type</p>
<div class="code"><pre class="code literal-block"><span class="nt">struct</span><span class="w"> </span><span class="nt">node</span><span class="o">;</span>
<span class="nt">typedef</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">node</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">list</span><span class="o">;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">entry</span><span class="p">;</span><span class="w"> </span><span class="err">list</span><span class="w"> </span><span class="err">next</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>

<p>Instances of such list (which cannot be allowed to share parts with other
instances or be circular) are entirely owned by whoever holds the initial
<code>list</code> pointer. If client code knows that the list it stores will never be
empty, it may also choose to store the first <code>node</code> directly rather than a
<code>list</code>. No destructor for <code>node</code> needs to be defined: since the destructors
for its fields are automatically called, the whole list will be recursively
deleted by the smart pointer destructor once the lifetime of initial pointer
or node ends.</p>
<p>This recursive type gives the occasion to discuss some cases that are less
visible in the case of a smart pointer to plain data. Also the functions
themselves occasionally provide (recursively) an example of client code as
well. The typedef for <code>list</code> is of course biased towards <code>unique_ptr</code>, but the
definition could be changed to use <code>auto_ptr</code> or <code>shared_ptr</code> instead without
much need to change to what is said below (notably concerning exception safety
being assured without the need to write destructors).</p>
<h2>Modes of passing smart pointers around</h2>
<h3>Mode 0: pass a pointer or reference argument instead of a smart pointer</h3>
<p>If your function is not concerned with ownership, this is the preferred
method: don't make it take a smart pointer at all. In this case your function
does not need to worry <em>who</em> owns the object pointed to, or by what means that
ownership is managed, so passing a raw pointer is both perfectly safe, and the
most flexible form, since regardless of ownership a client can always produce
a raw pointer (either by calling the <code>get</code> method or from the address-of
operator <code>&amp;</code>).</p>
<p>For instance the function to compute the length of such list, should not be
give a <code>list</code> argument, but a raw pointer:</p>
<div class="code"><pre class="code literal-block"><span class="n">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">node</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="o">!=</span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">.</span><span class="n">get</span><span class="p">())</span><span class="w"> </span><span class="o">++</span><span class="n">l</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>

<p>A client that holds a variable <code>list head</code> can call this function as
<code>length(head.get())</code>, while a client that has chosen instead to store a <code>node
n</code> representing a non-empty list can call <code>length(&amp;n)</code>.</p>
<p>If the pointer is guaranteed to be non null (which is not the case here since
lists may be empty) one might prefer to pass a reference rather than a
pointer. It might be a pointer/reference to non-<code>const</code> if the function needs
to update the contents of the node(s), without adding or removing any of them
(the latter would involve ownership).</p>
<p>An interesting case that falls in the mode 0 category is making a (deep) copy
of the list; while a function doing this must of course transfer ownership of
the copy it creates, it is not concerned with the ownership of the list it is
copying. So it could be defined as follows:</p>
<div class="code"><pre class="code literal-block"><span class="n">list</span><span class="w"> </span><span class="n">copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">node</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">list</span><span class="p">(</span><span class="w"> </span><span class="n">p</span><span class="o">==</span><span class="n">nullptr</span><span class="w"> </span><span class="err">?</span><span class="w"> </span><span class="n">nullptr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">node</span><span class="p">{</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span><span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">.</span><span class="n">get</span><span class="p">())}</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
</pre></div>

<p>This code merits a close look, both for the question as to why it compiles at
all (the result of the recursive call to <code>copy</code> in the initialiser list binds
to the rvalue reference argument in the move constructor of
<code>unique_ptr&lt;node&gt;</code>, a.k.a. <code>list</code>, when initialising the <code>next</code> field of the
generated <code>node</code>), and for the question as to why it is exception-safe (if
during the recursive allocation process memory runs out and some call of <code>new</code>
throws <code>std::bad_alloc</code>, then at that time a pointer to the partly constructed
list is held anonymously in a temporary of type <code>list</code> created for the
initialiser list, and its destructor will clean up that partial list). By the
way one should resist the temptation to replace (as I initially did) the
second <code>nullptr</code> by <code>p</code>, which after all is known to be null at that point:
one cannot construct a smart pointer from a (raw) pointer <em>to constant</em> , even
when it is known to be null.</p>
<h3>Mode 1: pass a smart pointer by value</h3>
<p>A function that takes a smart pointer value as argument takes possession of
the object pointed to right away: the smart pointer that the caller held
(whether in a named variable or an anonymous temporary) is copied into the
argument value at function entrance and the caller's pointer has become null
(in the case of a temporary the copy might have been elided, but in any case
the caller has lost access to the pointed to object). I would like to call
this mode <strong>call by cash</strong> : caller pays up front for the service called, and
can have no illusions about ownership after the call. To make this clear, the
language rules require the caller to wrap the argument in <code>std::move</code> if the
smart pointer is held in a variable (technically, if the argument is an
lvalue); in this case (but not for mode 3 below) this function does what its
name suggests, namely move the value from the variable to a temporary, leaving
the variable null.</p>
<p>For cases where the called function unconditionally takes ownership of
(pilfers) the pointed-to object, this mode used with <code>std::unique_ptr</code> or
<code>std::auto_ptr</code> is a good way of passing a pointer together with its
ownership, which avoids any risk of memory leaks. Nonetheless I think that
there are only very few situations where mode 3 below is not to be preferred
(ever so slightly) over mode 1. For this reason I shall provide no usage
examples of this mode. (But see the <code>reversed</code> example of mode 3 below, where
it is remarked that mode 1 would do at least as well.) If the function takes
more arguments than just this pointer, it may happen that there is in addition
a technical reason to avoid mode 1 (with <code>std::unique_ptr</code> or
<code>std::auto_ptr</code>): since an actual move operation takes place while passing a
pointer variable <code>p</code> by the expression <code>std::move(p)</code>, it cannot be assumed
that <code>p</code> holds a useful value while evaluating the other arguments (the order
of evaluation being unspecified), which could lead to subtle errors; by
contrast, using mode 3 assures that no move from <code>p</code> takes place before the
function call, so other arguments can safely access a value through <code>p</code>.</p>
<p>When used with <code>std::shared_ptr</code>, this mode is interesting in that with a
single function definition it allows the caller to <em>choose</em> whether to keep a
sharing copy of the pointer for itself while creating a new sharing copy to be
used by the function (this happens when an lvalue argument is provided; the
copy constructor for shared pointers used at the call increases the reference
count), or to just give the function a copy of the pointer without retaining
one or touching the reference count (this happens when a rvalue argument is
provided, possibly an lvalue wrapped in a call of <code>std::move</code>). For instance</p>
<div class="code"><pre class="code literal-block"><span class="nt">void</span><span class="w"> </span><span class="nt">f</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">shared_ptr</span><span class="o">&lt;</span><span class="nt">X</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">x</span><span class="o">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">call</span><span class="w"> </span><span class="nt">by</span><span class="w"> </span><span class="nt">shared</span><span class="w"> </span><span class="nt">cash</span>
<span class="p">{</span><span class="w"> </span><span class="err">container.insert(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">store</span><span class="w"> </span><span class="nt">shared</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">in</span><span class="w"> </span><span class="nt">container</span>

<span class="nt">void</span><span class="w"> </span><span class="nt">client</span><span class="o">()</span>
<span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="w">  </span><span class="err">f(p)</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">lvalue</span><span class="w"> </span><span class="err">argument</span><span class="p">;</span><span class="w"> </span><span class="err">store</span><span class="w"> </span><span class="err">pointer</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">container</span><span class="w"> </span><span class="err">but</span><span class="w"> </span><span class="err">keep</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">copy</span>
<span class="w">  </span><span class="err">f(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">));</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">prvalue</span><span class="w"> </span><span class="err">argument</span><span class="p">;</span><span class="w"> </span><span class="err">fresh</span><span class="w"> </span><span class="err">pointer</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">just</span><span class="w"> </span><span class="err">stored</span><span class="w"> </span><span class="err">away</span>
<span class="w">  </span><span class="err">f(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">p</span><span class="p">));</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">xvalue</span><span class="w"> </span><span class="err">argument</span><span class="p">;</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">transferred</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">container</span><span class="w"> </span><span class="err">and</span><span class="w"> </span><span class="err">left</span><span class="w"> </span><span class="err">null</span>
<span class="p">}</span>
</pre></div>

<p>The same could be achieved by separately defining <code>void f(const
std::shared_ptr&lt;X&gt;&amp; x)</code> (for the lvalue case) and <code>void f(std::shared_ptr&lt;X&gt;&amp;&amp;
x)</code> (for the rvalue case), with function bodies differing only in that the
first version invokes copy semantics (using copy construction/assignment when
using <code>x</code>) but the second version move semantics (writing <code>std::move(x)</code>
instead, as in the example code). So for shared pointers, mode 1 can be useful
to avoid some code duplication.</p>
<h3>Mode 2: pass a smart pointer by (modifiable) lvalue reference</h3>
<p>Here the function just requires having a modifiable reference to the smart
pointer, but gives no indication of what it will do with it. I would like to
call this method <strong>call by card</strong> : caller ensures payment by giving a credit
card number. The reference <em>can</em> be used to take ownership of the pointed-to
object, but it does not have to. This mode requires providing a modifiable
lvalue argument, corresponding to the fact that the desired effect of the
function may include leaving a useful value in the argument variable. A caller
with an rvalue expression that it wishes to pass to such a function would be
forced to store it in a named variable to be able to make the call, since the
language only provides implicit conversion to a <em>constant</em> lvalue reference
(referring to a temporary) from an rvalue. (Unlike the opposite situation
handled by <code>std::move</code>, a cast from <code>Y&amp;&amp;</code> to <code>Y&amp;</code>, with <code>Y</code> the smart pointer
type, is not possible; nonetheless this conversion could be obtained by a
simple template function if really desired; see
https://stackoverflow.com/a/24868376/1436796). For the case where the called
function intends to unconditionally take ownership of the object, stealing
from the argument, the obligation to provide an lvalue argument is giving the
wrong signal: the variable will have no useful value after the call. Therefore
mode 3, which gives identical possibilities inside our function but asks
callers to provide an rvalue, should be preferred for such usage.</p>
<p>However there is a valid use case for mode 2, namely functions that may
<em>modify</em> the pointer, or the object pointed to <em>in a way that involves
ownership</em>. For instance, a function that prefixes a node to a <code>list</code> provides
an example of such use:</p>
<div class="code"><pre class="code literal-block"><span class="nt">void</span><span class="w"> </span><span class="nt">prepend</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">,</span><span class="w"> </span><span class="nt">list</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">l</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">l</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">list(</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">node{</span><span class="w"> </span><span class="err">x,</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">l</span><span class="p">)}</span><span class="w"> </span><span class="o">);</span><span class="w"> </span><span class="err">}</span>
</pre></div>

<p>Clearly it would be undesirable here to force callers to use <code>std::move</code>,
since their smart pointer still owns a well defined and non-empty list after
the call, though a different one than before.</p>
<p>Again it is interesting to observe what happens if the <code>prepend</code> call fails
for lack of free memory. Then the <code>new</code> call will throw <code>std::bad_alloc</code>; at
this point in time, since no <code>node</code> could be allocated, it is certain that the
passed rvalue reference (mode 3) from <code>std::move(l)</code> cannot yet have been
pilfered, as that would be done to construct the <code>next</code> field of the <code>node</code>
that failed to be allocated. So the original smart pointer <code>l</code> still holds the
original list when the error is thrown; that list will either be properly
destroyed by the smart pointer destructor, or in case <code>l</code> should survive
thanks to a sufficiently early <code>catch</code> clause, it will still hold the original
list.</p>
<p>That was a constructive example; with a wink to this question one can also
give the more destructive example of removing the first node containing a
given value, if any:</p>
<div class="code"><pre class="code literal-block"><span class="nt">void</span><span class="w"> </span><span class="nt">remove_first</span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">,</span><span class="w"> </span><span class="nt">list</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">l</span><span class="o">)</span>
<span class="p">{</span><span class="w"> </span><span class="err">list*</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">&amp;l</span><span class="p">;</span>
<span class="w">  </span><span class="err">while</span><span class="w"> </span><span class="err">((*p).get()!=nullptr</span><span class="w"> </span><span class="err">and</span><span class="w"> </span><span class="err">(*p)-&gt;entry!=x)</span>
<span class="w">    </span><span class="err">p</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">&amp;(*p)-&gt;next</span><span class="p">;</span>
<span class="w">  </span><span class="err">if</span><span class="w"> </span><span class="err">((*p).get()!=nullptr)</span>
<span class="w">    </span><span class="err">(*p).reset((*p)-&gt;next.release())</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="n">equivalent</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="nf">move</span><span class="p">(</span><span class="err">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>Again the correctness is quite subtle here. Notably, in the final statement
the pointer <code>(*p)-&gt;next</code> held inside the node to be removed is unlinked (by
<code>release</code>, which returns the pointer but makes the original null) <em>before</em>
<code>reset</code> (implicitly) destroys that node (when it destroys the old value held
by <code>p</code>), ensuring that one and <em>only one</em> node is destroyed at that time. (In
the alternative form mentioned in the comment, this timing would be left to
the internals of the implementation of the move-assignment operator of the
<code>std::unique_ptr</code> instance <code>list</code>; the standard says 20.7.1.2.3;2 that this
operator should act "as if by calling <code>reset(u.release())</code>", whence the timing
should be safe here too.)</p>
<p>Note that <code>prepend</code> and <code>remove_first</code> cannot be called by clients who store a
local <code>node</code> variable for an always non-empty list, and rightly so since the
implementations given could not work for such cases.</p>
<h3>Mode 3: pass a smart pointer by (modifiable) rvalue reference</h3>
<p>This is the preferred mode to use when simply taking ownership of the pointer.
I would like to call this method <strong>call by check</strong> : caller must accept
relinquishing ownership, as if providing cash, by signing the check, but the
actual withdrawal is postponed until the called function actually pilfers the
pointer (exactly as it would when using mode 2). The "signing of the check"
concretely means callers have to wrap an argument in <code>std::move</code> (as in mode
1) if it is an lvalue (if it is an rvalue, the "giving up ownership" part is
obvious and requires no separate code).</p>
<p>Note that technically mode 3 behaves exactly as mode 2, so the called function
<em>does not have to</em> assume ownership; however I would insist that if there is
any uncertainty about ownership transfer (in normal usage), mode 2 should be
preferred to mode 3, so that using mode 3 is implicitly a signal to callers
that they <em>are</em> giving up ownership. One might retort that only mode 1
argument passing really signals forced loss of ownership to callers. But if a
client has any doubts about intentions of the called function, she is supposed
to know the specifications of the function being called, which should remove
any doubt.</p>
<p>It is surprisingly difficult to find a typical example involving our <code>list</code>
type that uses mode 3 argument passing. Moving a list <code>b</code> to the end of
another list <code>a</code> is a typical example; however <code>a</code> (which survives and holds
the result of the operation) is better passed using mode 2:</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">append</span><span class="w"> </span><span class="p">(</span><span class="n">list</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span><span class="n">list</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="o">=&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">!=</span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">p</span><span class="o">=&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">attach</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">relinquishes</span><span class="w"> </span><span class="n">ownership</span><span class="w"> </span><span class="n">here</span>
<span class="p">}</span>
</pre></div>

<p>A pure example of mode 3 argument passing is the following that takes a list
(and its ownership), and returns a list containing the identical nodes in
reverse order.</p>
<div class="code"><pre class="code literal-block"><span class="nt">list</span><span class="w"> </span><span class="nt">reversed</span><span class="w"> </span><span class="o">(</span><span class="nt">list</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">l</span><span class="o">)</span><span class="w"> </span><span class="nt">noexcept</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">pilfering</span><span class="w"> </span><span class="nt">reversal</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">list</span>
<span class="p">{</span><span class="w"> </span><span class="err">list</span><span class="w"> </span><span class="err">p(l.release())</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">move</span><span class="w"> </span><span class="err">list</span><span class="w"> </span><span class="err">into</span><span class="w"> </span><span class="err">temporary</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">traversal</span>
<span class="w">  </span><span class="err">list</span><span class="w"> </span><span class="err">result(nullptr)</span><span class="p">;</span>
<span class="w">  </span><span class="err">while</span><span class="w"> </span><span class="err">(p.get()!=nullptr)</span>
<span class="w">  </span><span class="err">{</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="n">permute</span><span class="p">:</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">p-</span><span class="o">&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">cycle</span><span class="w"> </span><span class="kc">to</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">    </span><span class="n">result</span><span class="o">.</span><span class="nf">swap</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="err">&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="w">    </span><span class="err">result.swap(p)</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nt">return</span><span class="w"> </span><span class="nt">result</span><span class="o">;</span>
<span class="err">}</span>
</pre></div>

<p>This function might be called as in <code>l = reversed(std::move(l));</code> to reverse
the list into itself, but the reversed list can also be used differently.</p>
<p>Here the argument is immediately moved to a local variable for efficiency (one
could have used the parameter <code>l</code> directly in the place of <code>p</code>, but then
accessing it each time would involve an extra level of indirection); hence the
difference with mode 1 argument passing is minimal. In fact using that mode,
the argument could have served directly as local variable, thus avoiding that
initial move; this is just an instance of the general principle that if an
argument passed by reference only serves to initialise a local variable, one
might just as well pass it by value instead and use the parameter as local
variable.</p>
<p>Using mode 3 appears to be advocated by the standard, as witnessed by the fact
that all provided library functions that transfer ownership of smart pointers
using mode 3. A particular convincing case in point is the constructor
<code>std::shared_ptr&lt;T&gt;(auto_ptr&lt;T&gt;&amp;&amp; p)</code>. That constructor used (in <code>std::tr1</code>)
to take a modifiable <em>lvalue</em> reference (just like the <code>auto_ptr&lt;T&gt;&amp;</code> copy
constructor), and could therefore be called with an <code>auto_ptr&lt;T&gt;</code> lvalue <code>p</code>
as in <code>std::shared_ptr&lt;T&gt; q(p)</code>, after which <code>p</code> has been reset to null. Due
to the change from mode 2 to 3 in argument passing, this old code must now be
rewritten to <code>std::shared_ptr&lt;T&gt; q(std::move(p))</code> and will then continue to
work. I understand that the committee did not like the mode 2 here, but they
had the option of changing to mode 1, by defining
<code>std::shared_ptr&lt;T&gt;(auto_ptr&lt;T&gt; p)</code> instead, they could have ensured that old
code works without modification, because (unlike unique-pointers) auto-
pointers can be silently dereferenced to a value (the pointer object itself
being reset to null in the process). Apparently the committee so much
preferred advocating mode 3 over mode 1, that they chose to <em>actively break
existing code</em> rather than to use mode 1 even for an already deprecated usage.</p>
<h2>When to prefer mode 3 over mode 1</h2>
<p>Mode 1 is perfectly usable in many cases, and might be preferred over mode 3
in cases where assuming ownership would otherwise takes the form of moving the
smart pointer to a local variable as in the <code>reversed</code> example above. However,
I can see two reasons to prefer mode 3 in the more general case:</p>
<ul>
<li>
<p>It is slightly more efficient to pass a reference than to create a temporary and nix the old pointer (handling cash is somewhat laborious); in some scenarios the pointer may be passed several times unchanged to another function before it is actually pilfered. Such passing will generally require writing <code>std::move</code> (unless mode 2 is used), but note that this is just a cast that does not actually do anything (in particular no dereferencing), so it has zero cost attached.</p>
</li>
<li>
<p>Should it be conceivable that anything throws an exception between the start of the function call and the point where it (or some contained call) actually moves the pointed-to object into another data structure (and this exception is not already caught inside the function itself), then when using mode 1, the object referred to by the smart pointer will be destroyed before a <code>catch</code> clause can handle the exception (because the function parameter was destructed during stack unwinding), but not so when using mode 3. The latter gives the caller has the option to recover the data of the object in such cases (by catching the exception). Note that mode 1 here <em>does not cause a memory leak</em> , but may lead to an unrecoverable loss of data for the program, which might be undesirable as well.</p>
</li>
</ul>
<h2>Returning a smart pointer: always by value</h2>
<p>To conclude a word about <em>returning</em> a smart pointer, presumably pointing to
an object created for use by the caller. This is not really a case comparable
with passing pointers into functions, but for completeness I would like to
insist that in such cases <strong>always return by value</strong> (and <em>don't use</em>
<code>std::move</code> in the <code>return</code> statement). Nobody wants to get a <em>reference</em> to a
pointer that probably has just been nixed.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/json-decode-to-array/" class="u-url">json_decode to array</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/json-decode-to-array/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T07:44:24+08:00" itemprop="datePublished" title="2023-03-03 07:44">2023-03-03 07:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am trying to decode a JSON string into an array but i get the following
error.</p>
<blockquote>
<p>Fatal error: Cannot use object of type stdClass as array in
C:\wamp\www\temp\asklaila.php on line 6</p>
</blockquote>
<p>Here is the code:</p>
<div class="code"><pre class="code literal-block"><span class="cp">&lt;?php</span>
<span class="nv">$json_string</span> <span class="o">=</span> <span class="s1">'http://www.domain.com/jsondata.json'</span><span class="p">;</span>

<span class="nv">$jsondata</span> <span class="o">=</span> <span class="nb">file_get_contents</span><span class="p">(</span><span class="nv">$json_string</span><span class="p">);</span>
<span class="nv">$obj</span> <span class="o">=</span> <span class="nb">json_decode</span><span class="p">(</span><span class="nv">$jsondata</span><span class="p">);</span>
<span class="nb">print_r</span><span class="p">(</span><span class="nv">$obj</span><span class="p">[</span><span class="s1">'Result'</span><span class="p">]);</span>
<span class="cp">?&gt;</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>As per the documentation, you need to specify <code>true</code> as the second argument if
you want an associative array instead of an object from <code>json_decode</code>. This
would be the code:</p>
<div class="code"><pre class="code literal-block">$result = json_decode($jsondata, true);
</pre></div>

<p>If you want <code>integer</code> keys instead of whatever the property names are:</p>
<div class="code"><pre class="code literal-block">$result = array_values(json_decode($jsondata, true));
</pre></div>

<p>However, with your current decode you just access it as an object:</p>
<div class="code"><pre class="code literal-block"><span class="n">print_r</span><span class="p">(</span><span class="err">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">Result</span><span class="p">);</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>try this</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="nt">json_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'http://www.domain.com/jsondata.json'</span><span class="o">;</span>
<span class="o">$</span><span class="nt">jsondata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">file_get_contents</span><span class="o">($</span><span class="nt">json_string</span><span class="o">);</span>
<span class="o">$</span><span class="nt">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">json_decode</span><span class="o">($</span><span class="nt">jsondata</span><span class="o">,</span><span class="nt">true</span><span class="o">);</span>
<span class="nt">echo</span><span class="w"> </span><span class="s2">"&lt;pre&gt;"</span><span class="o">;</span>
<span class="nt">print_r</span><span class="o">($</span><span class="nt">obj</span><span class="o">);</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1721.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1719.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
