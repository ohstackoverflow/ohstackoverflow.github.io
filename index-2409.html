<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2409) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2409.html">
<link rel="prev" href="index-2410.html" type="text/html">
<link rel="next" href="index-2408.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-group-an-array-of-objects-by-key/" class="u-url">How can I group an array of objects by key?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-group-an-array-of-objects-by-key/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T13:59:03+08:00" itemprop="datePublished" title="2023-03-04 13:59">2023-03-04 13:59</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Does anyone know of a way (lodash if possible too) to group an array of
objects by an object key then create a new array of objects based on the
grouping? For example, I have an array of car objects:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">cars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s1">'make'</span><span class="p">:</span><span class="w"> </span><span class="s1">'audi'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'r8'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">'make'</span><span class="p">:</span><span class="w"> </span><span class="s1">'audi'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'rs5'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2013'</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">'make'</span><span class="p">:</span><span class="w"> </span><span class="s1">'ford'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'mustang'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">'make'</span><span class="p">:</span><span class="w"> </span><span class="s1">'ford'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'fusion'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2015'</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s1">'make'</span><span class="p">:</span><span class="w"> </span><span class="s1">'kia'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'optima'</span><span class="p">,</span>
<span class="w">        </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">];</span>
</pre></div>

<p>I want to make a new array of car objects that's grouped by <code>make</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">cars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">'audi'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'r8'</span><span class="p">,</span>
<span class="w">            </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'rs5'</span><span class="p">,</span>
<span class="w">            </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2013'</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">    </span><span class="p">],</span>

<span class="w">    </span><span class="s1">'ford'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'mustang'</span><span class="p">,</span>
<span class="w">            </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'fusion'</span><span class="p">,</span>
<span class="w">            </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2015'</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">],</span>

<span class="w">    </span><span class="s1">'kia'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="s1">'model'</span><span class="p">:</span><span class="w"> </span><span class="s1">'optima'</span><span class="p">,</span>
<span class="w">            </span><span class="s1">'year'</span><span class="p">:</span><span class="w"> </span><span class="s1">'2012'</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Timo's answer is how I would do it. Simple <code>_.groupBy</code>, and allow some
duplications in the objects in the grouped structure.</p>
<p>However the OP also asked for the duplicate <code>make</code> keys to be removed. If you
wanted to go all the way:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">grouped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">cars</span><span class="p">,</span><span class="w"> </span><span class="s1">'make'</span><span class="p">),</span>
<span class="w">                          </span><span class="n">clist</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">clist</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">car</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="o">.</span><span class="n">omit</span><span class="p">(</span><span class="n">car</span><span class="p">,</span><span class="w"> </span><span class="s1">'make'</span><span class="p">)));</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">grouped</span><span class="p">);</span>
</pre></div>

<p>Yields:</p>
<div class="code"><pre class="code literal-block">{ audi:
   [ { model: 'r8', year: '2012' },
     { model: 'rs5', year: '2013' } ],
  ford:
   [ { model: 'mustang', year: '2012' },
     { model: 'fusion', year: '2015' } ],
  kia: 
   [ { model: 'optima', year: '2012' } ] 
}
</pre></div>

<p>If you wanted to do this using Underscore.js, note that its version of
<code>_.mapValues</code> is called <code>_.mapObject</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Timo's answer is how I would do it. Simple <code>_.groupBy</code>, and allow some
duplications in the objects in the grouped structure.</p>
<p>However the OP also asked for the duplicate <code>make</code> keys to be removed. If you
wanted to go all the way:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">grouped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">cars</span><span class="p">,</span><span class="w"> </span><span class="s1">'make'</span><span class="p">),</span>
<span class="w">                          </span><span class="n">clist</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">clist</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">car</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_</span><span class="o">.</span><span class="n">omit</span><span class="p">(</span><span class="n">car</span><span class="p">,</span><span class="w"> </span><span class="s1">'make'</span><span class="p">)));</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">grouped</span><span class="p">);</span>
</pre></div>

<p>Yields:</p>
<div class="code"><pre class="code literal-block">{ audi:
   [ { model: 'r8', year: '2012' },
     { model: 'rs5', year: '2013' } ],
  ford:
   [ { model: 'mustang', year: '2012' },
     { model: 'fusion', year: '2015' } ],
  kia: 
   [ { model: 'optima', year: '2012' } ] 
}
</pre></div>

<p>If you wanted to do this using Underscore.js, note that its version of
<code>_.mapValues</code> is called <code>_.mapObject</code>.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ignore-python-multiple-return-value/" class="u-url">Ignore python multiple return value</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ignore-python-multiple-return-value/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T13:57:26+08:00" itemprop="datePublished" title="2023-03-04 13:57">2023-03-04 13:57</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Say I have a Python function that returns multiple values in a tuple:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>:
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>
</pre></div>

<p>Is there a nice way to ignore one of the results rather than just assigning to
a temporary variable? Say if I was only interested in the first value, is
there a better way than this:</p>
<div class="code"><pre class="code literal-block">x, temp = func()
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>One common convention is to use a "_" as a variable name for the elements of
the tuple you wish to ignore. For instance:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">f</span><span class="ss">()</span>:
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>

<span class="nv">_</span>,<span class="w"> </span><span class="nv">_</span>,<span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">f</span><span class="ss">()</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>One common convention is to use a "_" as a variable name for the elements of
the tuple you wish to ignore. For instance:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">f</span><span class="ss">()</span>:
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>

<span class="nv">_</span>,<span class="w"> </span><span class="nv">_</span>,<span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">f</span><span class="ss">()</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-implement-the-factory-method-pattern-in-c-correctly/" class="u-url">How to implement the factory method pattern in C++ correctly</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-implement-the-factory-method-pattern-in-c-correctly/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T13:55:57+08:00" itemprop="datePublished" title="2023-03-04 13:55">2023-03-04 13:55</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>There's this one thing in C++ which has been making me feel uncomfortable for
quite a long time, because I honestly don't know how to do it, even though it
sounds simple:</p>
<h2><strong>How do I implement Factory Method in C++ correctly?</strong></h2>
<p>Goal: to make it possible to allow the client to instantiate some object using
factory methods instead of the object's constructors, without unacceptable
consequences and a performance hit.</p>
<p>By "Factory method pattern", I mean both static factory methods inside an
object or methods defined in another class, or global functions. Just
generally "the concept of redirecting the normal way of instantiation of class
X to anywhere else than the constructor".</p>
<p>Let me skim through some possible answers which I have thought of.</p>
<hr>
<h3>0) Don't make factories, make constructors.</h3>
<p>This sounds nice (and indeed often the best solution), but is not a general
remedy. First of all, there are cases when object construction is a task
complex enough to justify its extraction to another class. But even putting
that fact aside, even for simple objects using just constructors often won't
do.</p>
<p>The simplest example I know is a 2-D Vector class. So simple, yet tricky. I
want to be able to construct it both from both Cartesian and polar
coordinates. Obviously, I cannot do:</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">Vec2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Vec2</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">Vec2</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">magnitude</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="n">overload</span><span class="o">!</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="p">};</span>
</pre></div>

<p>My natural way of thinking is then:</p>
<div class="code"><pre class="code literal-block">struct Vec2 {
    static Vec2 fromLinear(float x, float y);
    static Vec2 fromPolar(float angle, float magnitude);
    // ...
};
</pre></div>

<p>Which, instead of constructors, leads me to usage of static factory methods...
which essentially means that I'm implementing the factory pattern, in some way
("the class becomes its own factory"). This looks nice (and would suit this
particular case), but fails in some cases, which I'm going to describe in
point 2. Do read on.</p>
<p><em>another case: trying to overload by two opaque typedefs of some API (such as
GUIDs of unrelated domains, or a GUID and a bitfield), types semantically
totally different (so - in theory - valid overloads) but which actually turn
out to be the same thing - like unsigned ints or void pointers.</em></p>
<hr>
<h3>1) The Java Way</h3>
<p>Java has it simple, as we only have dynamic-allocated objects. Making a
factory is as trivial as:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">FooFactory</span> {
    <span class="n">public</span> <span class="n">Foo</span> <span class="n">createFooInSomeWay</span>() {
        // <span class="nb">can</span> <span class="n">be</span> <span class="n">a</span> <span class="n">static</span> <span class="k">method</span> <span class="n">as</span> <span class="n">well</span>,
<span class="sr">        //</span>  <span class="k">if</span> <span class="n">we</span> <span class="n">don't</span> <span class="k">need</span> <span class="n">the</span> <span class="n">factory</span> <span class="nb">to</span> <span class="n">provide</span> <span class="n">its</span> <span class="n">own</span> <span class="n">object</span> <span class="n">semantics</span>
        //  <span class="o">and</span> <span class="n">just</span> <span class="n">serve</span> <span class="n">as</span> <span class="n">a</span> <span class="n">group</span> <span class="nb">of</span> <span class="nb">methods</span>
        <span class="k">return</span> <span class="nb">new</span> <span class="n">Foo</span>(<span class="n">some</span>, <span class="nb">args</span>);
    }
}
</pre></div>

<p>In C++, this translates to:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">FooFactory</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="nf">createFooInSomeWay</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Cool? Often, indeed. But then- this forces the user to only use dynamic
allocation. Static allocation is what makes C++ complex, but is also what
often makes it powerful. Also, I believe that there exist some targets
(keyword: embedded) which don't allow for dynamic allocation. And that doesn't
imply that the users of those platforms like to write clean OOP.</p>
<p>Anyway, philosophy aside: In the general case, I don't want to force the users
of the factory to be restrained to dynamic allocation.</p>
<hr>
<h3>2) Return-by-value</h3>
<p>OK, so we know that 1) is cool when we want dynamic allocation. Why won't we
add static allocation on top of that?</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">FooFactory</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="nf">createFooInSomeWay</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nt">Foo</span><span class="w"> </span><span class="nt">createFooInSomeWay</span><span class="o">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">Foo(some,</span><span class="w"> </span><span class="err">args)</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>What? We can't overload by the return type? Oh, of course we can't. So let's
change the method names to reflect that. And yes, I've written the invalid
code example above just to stress how much I dislike the need to change the
method name, for example because we cannot implement a language-agnostic
factory design properly now, since we have to change names - and every user of
this code will need to remember that difference of the implementation from the
specification.</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">FooFactory</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">*</span><span class="w"> </span><span class="nf">createDynamicFooInSomeWay</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nf">Foo</span><span class="p">(</span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nt">Foo</span><span class="w"> </span><span class="nt">createFooObjectInSomeWay</span><span class="o">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">Foo(some,</span><span class="w"> </span><span class="err">args)</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>OK... there we have it. It's ugly, as we need to change the method name. It's
imperfect, since we need to write the same code twice. But once done, it
works. Right?</p>
<p>Well, usually. But sometimes it does not. When creating Foo, we actually
depend on the compiler to do the return value optimisation for us, because the
C++ standard is benevolent enough for the compiler vendors not to specify when
will the object created in-place and when will it be copied when returning a
temporary object by value in C++. So if Foo is expensive to copy, this
approach is risky.</p>
<p>And what if Foo is not copiable at all? Well, doh. ( <em>Note that in C++17 with
guaranteed copy elision, not-being-copiable is no problem anymore for the code
above</em> )</p>
<p>Conclusion: Making a factory by returning an object is indeed a solution for
some cases (such as the 2-D vector previously mentioned), but still not a
general replacement for constructors.</p>
<hr>
<h3>3) Two-phase construction</h3>
<p>Another thing that someone would probably come up with is separating the issue
of object allocation and its initialisation. This usually results in code like
this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="nf">Foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">almost</span><span class="w"> </span><span class="n">empty</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>

<span class="nt">class</span><span class="w"> </span><span class="nt">FooFactory</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">void</span><span class="w"> </span><span class="nf">createFooInSomeWay</span><span class="p">(</span><span class="n">Foo</span><span class="err">&amp;</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">void</span><span class="w"> </span><span class="nt">clientCode</span><span class="o">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">Foo</span><span class="w"> </span><span class="err">staticFoo</span><span class="p">;</span>
<span class="w">    </span><span class="err">auto_ptr&lt;Foo&gt;</span><span class="w"> </span><span class="err">dynamicFoo</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">Foo()</span><span class="p">;</span>
<span class="w">    </span><span class="err">FooFactory</span><span class="w"> </span><span class="err">factory</span><span class="p">;</span>
<span class="w">    </span><span class="err">factory.createFooInSomeWay(&amp;staticFoo)</span><span class="p">;</span>
<span class="w">    </span><span class="err">factory.createFooInSomeWay(&amp;dynamicFoo.get())</span><span class="p">;</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="p">}</span>
</pre></div>

<p>One may think it works like a charm. The only price we pay for in our code...</p>
<p>Since I've written all of this and left this as the last, I must dislike it
too. :) Why?</p>
<p>First of all... I sincerely dislike the concept of two-phase construction and
I feel guilty when I use it. If I design my objects with the assertion that
"if it exists, it is in valid state", I feel that my code is safer and less
error-prone. I like it that way.</p>
<p>Having to drop that convention AND changing the design of my object just for
the purpose of making factory of it is.. well, unwieldy.</p>
<p>I know that the above won't convince many people, so let's me give some more
solid arguments. Using two-phase construction, you cannot:</p>
<ul>
<li>initialise <code>const</code> or reference member variables,</li>
<li>pass arguments to base class constructors and member object constructors.</li>
</ul>
<p>And probably there could be some more drawbacks which I can't think of right
now, and I don't even feel particularly obliged to since the above bullet
points convince me already.</p>
<p>So: not even close to a good general solution for implementing a factory.</p>
<hr>
<h3>Conclusions:</h3>
<p>We want to have a way of object instantiation which would:</p>
<ul>
<li>allow for uniform instantiation regardless of allocation,</li>
<li>give different, meaningful names to construction methods (thus not relying on by-argument overloading),</li>
<li>not introduce a significant performance hit and, preferably, a significant code bloat hit, especially at client side,</li>
<li>be general, as in: possible to be introduced for any class.</li>
</ul>
<p>I believe I have proven that the ways I have mentioned don't fulfil those
requirements.</p>
<p>Any hints? Please provide me with a solution, I don't want to think that this
language won't allow me to properly implement such a trivial concept.</p>
<p><br><br></p>
<h2>Answer</h2>
<blockquote>
<p>First of all, there are cases when object construction is a task complex
enough to justify its extraction to another class.</p>
</blockquote>
<p>I believe this point is incorrect. The complexity doesn't really matter. The
relevance is what does. If an object can be constructed in one step (not like
in the builder pattern), the constructor is the right place to do it. If you
really need another class to perform the job, then it should be a helper class
that is used from the constructor anyway.</p>
<div class="code"><pre class="code literal-block"><span class="n">Vec2</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="n">Vec2</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">magnitude</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="n">overload</span><span class="o">!</span>
</pre></div>

<p>There is an easy workaround for this:</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">Cartesian</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">inline</span><span class="w"> </span><span class="n">Cartesian</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">y</span><span class="p">):</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">struct</span><span class="w"> </span><span class="n">Polar</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">inline</span><span class="w"> </span><span class="n">Polar</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">magnitude</span><span class="p">):</span><span class="w"> </span><span class="n">angle</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="w"> </span><span class="n">magnitude</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="n">magnitude</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Vec2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Cartesian</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cartesian</span><span class="p">);</span>
<span class="n">Vec2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Polar</span><span class="w"> </span><span class="o">&amp;</span><span class="n">polar</span><span class="p">);</span>
</pre></div>

<p>The only disadvantage is that it looks a bit verbose:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Vec2</span><span class="w"> </span><span class="nt">v2</span><span class="o">(</span><span class="nt">Vec2</span><span class="p">::</span><span class="nd">Cartesian</span><span class="o">(</span><span class="nt">3</span><span class="p">.</span><span class="nc">0f</span><span class="o">,</span><span class="w"> </span><span class="nt">4</span><span class="p">.</span><span class="nc">0f</span><span class="o">));</span>
</pre></div>

<p>But the good thing is that you can immediately see what coordinate type you're
using, and at the same time you don't have to worry about copying. If you want
copying, and it's expensive (as proven by profiling, of course), you may wish
to use something like Qt's shared classes to avoid copying overhead.</p>
<p>As for the allocation type, the main reason to use the factory pattern is
usually polymorphism. Constructors can't be virtual, and even if they could,
it wouldn't make much sense. When using static or stack allocation, you can't
create objects in a polymorphic way because the compiler needs to know the
exact size. So it works only with pointers and references. And returning a
reference from a factory doesn't work too, because while an object technically
<em>can</em> be deleted by reference, it could be rather confusing and bug-prone, see
Is the practice of returning a C++ reference variable, evil? for example. So
pointers are the only thing that's left, and that includes smart pointers too.
In other words, factories are most useful when used with dynamic allocation,
so you can do things like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Abstract</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">virtual</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="nf">do</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">class</span><span class="w"> </span><span class="nt">Factory</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="n">Abstract</span><span class="w"> </span><span class="o">*</span><span class="nf">create</span><span class="p">();</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">Factory</span><span class="w"> </span><span class="nt">f</span><span class="o">;</span>
<span class="nt">Abstract</span><span class="w"> </span><span class="o">*</span><span class="nt">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">f</span><span class="p">.</span><span class="nc">create</span><span class="o">();</span>
<span class="nt">a-</span><span class="o">&gt;</span><span class="nt">do</span><span class="o">();</span>
</pre></div>

<p>In other cases, factories just help to solve minor problems like those with
overloads you have mentioned. It would be nice if it was possible to use them
in a uniform way, but it doesn't hurt much that it is probably impossible.</p>
<p><br></p>
<h3>Suggest</h3>
<h4>Simple Factory Example:</h4>
<div class="code"><pre class="code literal-block"><span class="c1">// Factory returns object and ownership</span>
<span class="c1">// Caller responsible for deletion.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="kr">class</span><span class="w"> </span><span class="nc">FactoryReleaseOwnership</span><span class="p">{</span>
<span class="w">  </span><span class="kr">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createFooInSomeWay</span><span class="p">(){</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Factory retains object ownership</span>
<span class="c1">// Thus returning a reference.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;boost/ptr_container/ptr_vector.hpp&gt;</span>
<span class="kr">class</span><span class="w"> </span><span class="nc">FactoryRetainOwnership</span><span class="p">{</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">ptr_vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w">  </span><span class="n">myFoo</span><span class="p">;</span>
<span class="w">  </span><span class="kr">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">createFooInSomeWay</span><span class="p">(){</span>
<span class="w">      </span><span class="c1">// Must take care that factory last longer than all references.</span>
<span class="w">      </span><span class="c1">// Could make myFoo static so it last as long as the application.</span>
<span class="w">      </span><span class="n">myFoo</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">some</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">));</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">myFoo</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2410.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2408.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
