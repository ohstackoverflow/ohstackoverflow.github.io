<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2567) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2567.html">
<link rel="prev" href="index-2568.html" type="text/html">
<link rel="next" href="index-2566.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-i-check-when-a-uitextfield-changes/" class="u-url">How do I check when a UITextField changes?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-i-check-when-a-uitextfield-changes/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T01:36:09+08:00" itemprop="datePublished" title="2023-03-05 01:36">2023-03-05 01:36</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am trying to check when a text field changes, equivalent too the function
used for textView - <code>textViewDidChange</code> so far I have done this:</p>
<div class="code"><pre class="code literal-block"><span class="w">  </span><span class="k">func</span><span class="w"> </span><span class="n">textFieldDidBeginEditing</span><span class="p">(</span><span class="n">textField</span><span class="p">:</span><span class="w"> </span><span class="n">UITextField</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">text</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">""</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">text</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">""</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="o">.</span><span class="n">topRightButton</span><span class="o">.</span><span class="n">enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">false</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">   </span>
<span class="w">            </span><span class="bp">self</span><span class="o">.</span><span class="n">topRightButton</span><span class="o">.</span><span class="n">enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>

<p>Which kind of works, but the <code>topRightButton</code> is enabled as soon as the text
field is pressed on, I want it to be enabled only when text is actually typed
in?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>SWIFT</strong></p>
<p><strong>Swift 4.2</strong></p>
<div class="code"><pre class="code literal-block"><span class="nv">textfield</span>.<span class="nv">addTarget</span><span class="ss">(</span><span class="nv">self</span>,<span class="w"> </span><span class="nv">action</span>:<span class="w"> </span>#<span class="nv">selector</span><span class="ss">(</span><span class="nv">ViewController</span>.<span class="nv">textFieldDidChange</span><span class="ss">(</span><span class="nv">_</span>:<span class="ss">))</span>,<span class="w"> </span><span class="k">for</span>:<span class="w"> </span>.<span class="nv">editingChanged</span><span class="ss">)</span>
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block"><span class="err">@</span><span class="n">objc</span><span class="w"> </span><span class="k">func</span><span class="w"> </span><span class="n">textFieldDidChange</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">textField</span><span class="p">:</span><span class="w"> </span><span class="n">UITextField</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>
</pre></div>

<p><strong>SWIFT 3 &amp; swift 4.1</strong></p>
<div class="code"><pre class="code literal-block"><span class="nv">textField</span>.<span class="nv">addTarget</span><span class="ss">(</span><span class="nv">self</span>,<span class="w"> </span><span class="nv">action</span>:<span class="w"> </span>#<span class="nv">selector</span><span class="ss">(</span><span class="nv">ViewController</span>.<span class="nv">textFieldDidChange</span><span class="ss">(</span><span class="nv">_</span>:<span class="ss">))</span>,<span class="w"> </span><span class="k">for</span>:<span class="w"> </span>.<span class="nv">editingChanged</span><span class="ss">)</span>
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block"><span class="k">func</span><span class="w"> </span><span class="n">textFieldDidChange</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">textField</span><span class="p">:</span><span class="w"> </span><span class="n">UITextField</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="p">}</span>
</pre></div>

<p><strong>SWIFT 2.2</strong></p>
<div class="code"><pre class="code literal-block">textField.addTarget(self, action: #selector(ViewController.textFieldDidChange(_:)), forControlEvents: UIControlEvents.EditingChanged)
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block"><span class="k">func</span><span class="w"> </span><span class="n">textFieldDidChange</span><span class="p">(</span><span class="n">textField</span><span class="p">:</span><span class="w"> </span><span class="n">UITextField</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="n">your</span><span class="w"> </span><span class="n">code</span>
<span class="p">}</span>
</pre></div>

<p><strong>OBJECTIVE-C</strong></p>
<div class="code"><pre class="code literal-block"><span class="p">[</span><span class="n">textField</span><span class="w"> </span><span class="n">addTarget</span><span class="o">:</span><span class="nb">self</span><span class="w"> </span><span class="n">action</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">textFieldDidChange</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="n">forControlEvents</span><span class="o">:</span><span class="n">UIControlEventEditingChanged</span><span class="p">];</span>
</pre></div>

<p>and textFieldDidChange method is</p>
<div class="code"><pre class="code literal-block">-(void)textFieldDidChange :(UITextField *) textField{
    //your code
}
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>You can make this connection in interface builder.</p>
<ol>
<li>
<p>In your storyboard, click the assistant editor at the top of the screen (two circles in the middle). <img alt="Assistant editor selected" src="images/4FH37.png"></p>
</li>
<li>
<p>Ctrl + Click on the textfield in interface builder.</p>
</li>
<li>
<p>Drag from EditingChanged to inside your view controller class in the assistant view. <img alt="Making connection" src="images/MfpD3.png"></p>
</li>
<li>
<p>Name your function ("textDidChange" for example) and click connect. <img alt="Naming function" src="images/H74o7.png"></p>
</li>
</ol>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/rootscope-broadcast-vs-scope-emit/" class="u-url">$rootScope.$broadcast vs. $scope.$emit</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/rootscope-broadcast-vs-scope-emit/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T01:34:37+08:00" itemprop="datePublished" title="2023-03-05 01:34">2023-03-05 01:34</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Now that the performance difference between <code>$broadcast</code> and <code>$emit</code> has been
eliminated, is there any reason to prefer <code>$scope.$emit</code> to
<code>$rootScope.$broadcast</code>?</p>
<p>They are different, yes.</p>
<p><code>$emit</code> is restricted to the scope hierarchy (upwards) - this may be good, if
it fits your design, but it seems to me a rather arbitrary restriction.</p>
<p><code>$rootScope.$broadcast</code> works across all that <em>choose</em> to listen to the event,
which is a more sensible restriction in my mind.</p>
<p>Am I missing something?</p>
<p><strong>EDIT:</strong></p>
<p>To clarify in response to an answer, the direction of the dispatch is not the
issue I'm after. <code>$scope.$emit</code> dispatches the event upwards, and
<code>$scope.$broadcast</code> - downwards. But why not always use
<code>$rootScope.$broadcast</code> to reach all the intended listeners?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>tl;dr</strong> <em>(this tl;dr is from @sp00m's answer below)</em></p>
<blockquote>
<p><code>$emit</code> dispatches an event upwards ... <code>$broadcast</code> dispatches an event
downwards</p>
</blockquote>
<p><strong>Detailed explanation</strong></p>
<p><code>$rootScope.$emit</code> only lets other <code>$rootScope</code> listeners catch it. This is
good when you don't want every <code>$scope</code> to get it. Mostly a high level
communication. Think of it as adults talking to each other in a room so the
kids can't hear them.</p>
<p><code>$rootScope.$broadcast</code> is a method that lets pretty much everything hear it.
This would be the equivalent of parents yelling that dinner is ready so
everyone in the house hears it.</p>
<p><code>$scope.$emit</code> is when you want that <code>$scope</code> and all its parents and
<code>$rootScope</code> to hear the event. This is a child whining to their parents at
home (but not at a grocery store where other kids can hear).</p>
<p><code>$scope.$broadcast</code> is for the <code>$scope</code> itself and its children. This is a
child whispering to its stuffed animals so their parents can't hear.</p>
<p><br></p>
<h3>Suggest</h3>
<p>They are not doing the same job: <code>$emit</code> dispatches an event <strong>upwards</strong>
through the scope hierarchy, while <code>$broadcast</code> dispatches an event
<strong>downwards</strong> to all child scopes.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/std-vector-versus-std-array-in-c/" class="u-url">std::vector versus std::array in C++</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/std-vector-versus-std-array-in-c/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T01:33:17+08:00" itemprop="datePublished" title="2023-03-05 01:33">2023-03-05 01:33</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What are the difference between a <code>std::vector</code> and an <code>std::array</code> in C++?
When should one be preferred over another? What are the pros and cons of each?
All my textbook does is list how they are the same.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><code>std::vector</code> is a template class that encapsulate a dynamic array1, stored in
the heap, that grows and shrinks automatically if elements are added or
removed. It provides all the hooks (<code>begin()</code>, <code>end()</code>, iterators, etc) that
make it work fine with the rest of the STL. It also has several useful methods
that let you perform operations that on a normal array would be cumbersome,
like e.g. inserting elements in the middle of a vector (it handles all the
work of moving the following elements behind the scenes).</p>
<p>Since it stores the elements in memory allocated on the heap, it has some
overhead in respect to static arrays.</p>
<p><code>std::array</code> is a template class that encapsulate a statically-sized array,
stored inside the object itself, which means that, if you instantiate the
class on the stack, the array itself will be on the stack. Its size has to be
known at compile time (it's passed as a template parameter), and it cannot
grow or shrink.</p>
<p>It's more limited than <code>std::vector</code>, but it's often more efficient,
especially for small sizes, because in practice it's mostly a lightweight
wrapper around a C-style array. However, it's more secure, since the implicit
conversion to pointer is disabled, and it provides much of the STL-related
functionality of <code>std::vector</code> and of the other containers, so you can use it
easily with STL algorithms &amp; co. Anyhow, for the very limitation of fixed size
it's much less flexible than <code>std::vector</code>.</p>
<p>For an introduction to <code>std::array</code>, have a look at this article; for a quick
introduction to <code>std::vector</code> and to the the operations that are possible on
it, you may want to look at its documentation.</p>
<hr>
<ol>
<li>
<del>Actually, I think that in the standard they are described in terms of maximum complexity of the different operations (e.g. random access in constant time, iteration over all the elements in linear time, add and removal of elements at the end in constant amortized time, etc), but AFAIK there's no other method of fulfilling such requirements other than using a dynamic array.</del> As stated by @Lucretiel, the standard actually requires that the elements are stored contiguously, so <em>it is</em> a dynamic array, stored where the associated allocator puts it.</li>
</ol>
<p><br></p>
<h3>Suggest</h3>
<p>To emphasize a point made by @MatteoItalia, the efficiency difference is where
the data is stored. Heap memory (required with <code>vector</code>) requires a call to
the system to allocate memory and this can be expensive if you are counting
cycles. Stack memory (possible for <code>array</code>) is virtually "zero-overhead" in
terms of time, because the memory is allocated by just adjusting the stack
pointer and it is done just once on entry to a function. The stack also avoids
memory fragmentation. To be sure, <code>std::array</code> won't always be on the stack;
it depends on where you allocate it, but it will still involve one less memory
allocation from the heap compared to vector. If you have a</p>
<ul>
<li>small "array" (under 100 elements say) - (a typical stack is about 8MB, so don't allocate more than a few KB on the stack or less if your code is recursive)</li>
<li>the size will be fixed</li>
<li>the lifetime is in the function scope (or is a member value with the same lifetime as the parent class)</li>
<li>you are counting cycles,</li>
</ul>
<p>definitely use a <code>std::array</code> over a vector. If any of those requirements is
not true, then use a <code>std::vector</code>.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2568.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2566.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
