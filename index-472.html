<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 472) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-472.html">
<link rel="prev" href="index-473.html" type="text/html">
<link rel="next" href="index-471.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ref-he-out-guan-jian-zi-you-shi-yao-qu-bie/" class="u-url">“ref”和“out”关键字有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ref-he-out-guan-jian-zi-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:49:16+08:00" itemprop="datePublished" title="2023-02-17 07:49">2023-02-17 07:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在创建一个函数，我需要在其中传递一个对象，以便该函数可以修改它。有什么区别：</p>
<div class="code"><pre class="code literal-block">public void myFunction(ref MyClass someClass)
</pre></div>

<p>和</p>
<div class="code"><pre class="code literal-block">public void myFunction(out MyClass someClass)
</pre></div>

<p>我应该使用哪个，为什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>ref</code>告诉编译器对象在进入函数之前被初始化，while<code>out</code>告诉编译器对象将在函数内部被初始化。</p>
<p>所以 while<code>ref</code>是双向的，<code>out</code>是唯一的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>修饰符<code>ref</code>意味着：</p>
<ol>
<li>该值已经设置并且</li>
<li>该方法可以读取和修改它。</li>
</ol>
<p>修饰符<code>out</code>意味着：</p>
<ol>
<li>
<em>该值未设置，并且在</em> 设置之前无法通过该方法读取。</li>
<li>该方法 <em>必须</em> 在返回之前设置它。</li>
</ol>
<p><br><br><a href="posts/what-s-the-difference-between-the-ref-and-out-keywords/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/cong-jian-zhi-dui-wen-jian-she-zhi-huan-jing-bian-liang/" class="u-url">从键/值对文件设置环境变量</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/cong-jian-zhi-dui-wen-jian-she-zhi-huan-jing-bian-liang/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:48:47+08:00" itemprop="datePublished" title="2023-02-17 07:48">2023-02-17 07:48</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>TL;DR：</strong> 如何将一组键/值对从文本文件导出到 shell 环境中？</p>
<hr>
<p>作为记录，以下是问题的原始版本，并附有示例。</p>
<p>我正在用 bash 编写一个脚本，它在某个文件夹中解析具有 3 个变量的文件，这是其中之一：</p>
<div class="code"><pre class="code literal-block"><span class="n">MINIENTREGA_FECHALIMITE</span><span class="o">=</span><span class="s">"2011-03-31"</span>
<span class="n">MINIENTREGA_FICHEROS</span><span class="o">=</span><span class="s">"informe.txt programa.c"</span>
<span class="n">MINIENTREGA_DESTINO</span><span class="o">=</span><span class="s">"./destino/entrega-prac1"</span>
</pre></div>

<p>该文件存储在<code>./conf/prac1</code></p>
<p>然后我的脚本<code>minientrega.sh</code>使用以下代码解析文件：</p>
<div class="code"><pre class="code literal-block"><span class="n">cat</span><span class="w"> </span><span class="o">./</span><span class="n">conf</span><span class="o">/$</span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w"> </span><span class="n">do</span>
<span class="w">    </span><span class="k">export</span><span class="w"> </span><span class="o">$</span><span class="n">line</span>
<span class="n">done</span>
</pre></div>

<p>但是当我<code>minientrega.sh prac1</code>在命令行中执行时它没有设置环境变量</p>
<p>我也试过使用<code>source ./conf/$1</code>但同样的问题仍然存在</p>
<p>也许还有其他方法可以做到这一点，我只需要使用我传递的文件的环境变量作为我的脚本的参数。</p>
<p><br><br></p>
<h2>解答</h2>
<p>您的方法的问题是<code>export</code>in<code>while</code>循环发生在子 shell 中，并且这些变量在当前 shell（while 循环的父 shell）中不可用。</p>
<p><code>export</code>在文件本身中添加命令：</p>
<div class="code"><pre class="code literal-block"><span class="k">export</span><span class="w"> </span><span class="n">MINIENTREGA_FECHALIMITE</span><span class="o">=</span><span class="s2">"2011-03-31"</span>
<span class="k">export</span><span class="w"> </span><span class="n">MINIENTREGA_FICHEROS</span><span class="o">=</span><span class="s2">"informe.txt programa.c"</span>
<span class="k">export</span><span class="w"> </span><span class="n">MINIENTREGA_DESTINO</span><span class="o">=</span><span class="s2">"./destino/entrega-prac1"</span>
</pre></div>

<p>然后您需要使用以下命令在当前 shell 中获取文件：</p>
<div class="code"><pre class="code literal-block">. ./conf/prac1
</pre></div>

<p>或者</p>
<div class="code"><pre class="code literal-block">source ./conf/prac1
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p><code>-o allexport</code>允许导出所有以下变量定义。<code>+o allexport</code>禁用此功能。</p>
<div class="code"><pre class="code literal-block"><span class="n">set</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">allexport</span>
<span class="n">source</span><span class="w"> </span><span class="n">conf</span><span class="o">-</span><span class="n">file</span>
<span class="n">set</span><span class="w"> </span><span class="o">+</span><span class="n">o</span><span class="w"> </span><span class="n">allexport</span>
</pre></div>

<p><br><br><a href="posts/set-environment-variables-from-file-of-key-value-pairs/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/c-17-you-na-xie-xin-te-xing/" class="u-url">C++17 有哪些新特性？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/c-17-you-na-xie-xin-te-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:48:12+08:00" itemprop="datePublished" title="2023-02-17 07:48">2023-02-17 07:48</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>C++17 现在功能完备，因此不太可能经历大的变化。为 C++17 提出了数百个提案。</p>
<p>在 C++17 中，哪些功能被添加到 C++ 中？</p>
<p>使用支持“C++1z”的 C++ 编译器时，当编译器更新到 C++17 时，哪些功能将可用？</p>
<p><br><br></p>
<h2>解答</h2>
<h2>语言特点：</h2>
<h3>模板和通用代码</h3>
<ul>
<li>
<p>类模板的模板参数推导</p>
<ul>
<li>就像函数如何推导模板参数一样，现在构造函数可以推导类的模板参数</li>
<li>http://wg21.link/p0433r2  http://wg21.link/p0620r0  http://wg21.link/p0512r0</li>
<li>
<p><code>template &lt;auto&gt;</code></p>
</li>
<li>
<p>表示任何（非类型模板参数）类型的值。</p>
</li>
<li>非类型模板参数修复</li>
</ul>
</li>
<li>
<p><code>template&lt;template&lt;class...&gt;typename bob&gt; struct foo {}</code></p>
</li>
<li>
<p>（折叠 + ... + 表达式）和修订</p>
</li>
<li>
<p><code>auto x{8};</code>是一个<code>int</code></p>
</li>
<li>
<p><code>using</code>使用<code>...</code>和列表进行现代化</p>
</li>
</ul>
<h3>拉姆达</h3>
<ul>
<li>
<p>constexpr lambdas</p>
<ul>
<li>如果符合条件，Lambda 是隐式 constexpr</li>
<li>
<p><code>*this</code>在 lambda 中捕获</p>
</li>
<li>
<p><code>[*this]{ std::cout &lt;&lt; could &lt;&lt; " be " &lt;&lt; useful &lt;&lt; '\n'; }</code></p>
</li>
</ul>
</li>
</ul>
<h3>属性</h3>
<ul>
<li>
<p><code>[[fallthrough]]</code>, <code>[[nodiscard]]</code>,<code>[[maybe_unused]]</code>属性</p>
</li>
<li>
<p><code>[[attributes]]</code>在<code>namespace</code>s 和<code>enum { erator[[s]] }</code></p>
</li>
<li>
<p><code>using</code>在属性中避免重复属性命名空间。</p>
</li>
<li>
<p>现在要求编译器忽略它们无法识别的非标准属性。</p>
<ul>
<li>C++14 的措辞允许编译器拒绝未知范围的属性。</li>
</ul>
</li>
</ul>
<h3>语法清理</h3>
<ul>
<li>
<p>行内变量</p>
<ul>
<li>像内联函数</li>
<li>编译器选择实例实例化的位置</li>
<li>弃用 static constexpr redeclaration，现在隐式内联。</li>
<li><code>namespace A::B</code></li>
</ul>
</li>
<li>
<p>简单<code>static_assert(expression);</code>的没有字符串</p>
</li>
<li>
<p>不，<code>throw</code>除非<code>throw()</code>，而且<code>throw()</code>是<code>noexcept(true)</code>。</p>
</li>
</ul>
<h3>更清洁的多回流和流量控制</h3>
<ul>
<li>
<p>结构化绑定</p>
<ul>
<li>基本上，一流<code>std::tie</code>的<code>auto</code>
</li>
<li>例子： </li>
<li><code>const auto [it, inserted] = map.insert( {"foo", bar} );</code></li>
<li>创建变量<code>it</code>并从返回的<code>inserted</code>推导类型。<code>pair``map::insert</code>
</li>
<li>适用于 tuple/pair-likes &amp; <code>std::array</code>s 和相对扁平的结构</li>
<li>实际上在标准中命名结构化绑定</li>
<li>
<p><code>if (init; condition)</code>和<code>switch (init; condition)</code></p>
</li>
<li>
<p><code>if (const auto [it, inserted] = map.insert( {"foo", bar} ); inserted)</code></p>
</li>
<li>将 扩展到无法合理转换为布尔值的<code>if(decl)</code>情况。<code>decl</code>
</li>
<li>
<p>泛化基于范围的 for 循环</p>
</li>
<li>
<p>似乎主要支持哨兵或与开始迭代器类型不同的结束迭代器，这有助于空终止循环等。</p>
</li>
<li>
<p>如果constexpr</p>
</li>
<li>
<p>很多人要求的功能来简化几乎通用的代码。</p>
</li>
</ul>
</li>
</ul>
<h3>杂项</h3>
<ul>
<li>
<p>十六进制浮点数</p>
</li>
<li>
<p>过度对齐数据的动态内存分配</p>
</li>
<li>
<p>保证复制省略</p>
<ul>
<li>最后！</li>
<li>并非在所有情况下，但将“只是创建一些东西”的语法与“真正的省略”区分开来。</li>
<li>
<p>修复了（某些）表达式的求值顺序并进行了一些修改</p>
</li>
<li>
<p>不包括函数参数，但现在禁止函数参数评估交错</p>
</li>
<li>让一堆损坏的代码大部分工作，并<code>.then</code>在未来的工作中发挥作用。</li>
<li>枚举的直接列表初始化</li>
</ul>
</li>
<li>
<p>前向进度保证 (FPG)（也称为并行算法的 FPG）</p>
<ul>
<li>我认为这是在说“实现可能不会永远停止线程”？</li>
<li>
<code>u8'U', u8'T', u8'F', u8'8'</code>字符文字（字符串已经存在）</li>
</ul>
</li>
<li>
<p>类型系统中的“noexcept”</p>
</li>
<li>
<p><code>__has_include</code></p>
<ul>
<li>测试头文件包含是否会出错</li>
<li>使从实验迁移到标准几乎无缝</li>
<li>指针转换数组修复</li>
</ul>
</li>
<li>
<p>继承的构造函数修复了一些极端情况（有关行为更改的示例，请参阅P0136R0 ）</p>
</li>
<li>
<p>聚合初始化与继承。</p>
</li>
<li>
<p><code>std::launder</code>, 输入双关等</p>
</li>
</ul>
<h2>Library additions:</h2>
<h3>Data types</h3>
<ul>
<li>
<p><code>std::variant&lt;Ts...&gt;</code></p>
<ul>
<li>Almost-always non-empty last I checked?</li>
<li>Tagged union type</li>
<li>{awesome|useful}</li>
<li>
<p><code>std::optional</code></p>
</li>
<li>
<p>Maybe holds one of something</p>
</li>
<li>Ridiculously useful</li>
<li>
<p><code>std::any</code></p>
</li>
<li>
<p>Holds one of anything (that is copyable)</p>
</li>
<li>
<p><code>std::string_view</code></p>
</li>
<li>
<p><code>std::string</code> like reference-to-character-array or substring</p>
</li>
<li>Never take a <code>string const&amp;</code> again. Also can make parsing a bajillion times faster.</li>
<li><code>"hello world"sv</code></li>
<li>constexpr <code>char_traits</code>
</li>
<li>
<p><code>std::byte</code> off more than they could chew.</p>
</li>
<li>
<p>Neither an integer nor a character, just data</p>
</li>
</ul>
</li>
</ul>
<h3>Invoke stuff</h3>
<ul>
<li>
<p><code>std::invoke</code></p>
<ul>
<li>Call any callable (function pointer, function, member pointer) with one syntax. From the standard INVOKE concept.</li>
<li>
<p><code>std::apply</code></p>
</li>
<li>
<p>Takes a function-like and a tuple, and unpacks the tuple into the call.</p>
</li>
<li>
<code>std::make_from_tuple</code>, <code>std::apply</code> applied to object construction</li>
</ul>
</li>
<li>
<p><code>is_invocable</code>, <code>is_invocable_r</code>, <code>invoke_result</code></p>
<ul>
<li>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0077r2.html</li>
<li>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html</li>
<li>Deprecates <code>result_of</code>
</li>
<li>
<code>is_invocable&lt;Foo(Args...), R&gt;</code> is "can you call <code>Foo</code> with <code>Args...</code> and get something compatible with <code>R</code>", where <code>R=void</code> is default.</li>
<li>
<code>invoke_result&lt;Foo, Args...&gt;</code> is <code>std::result_of_t&lt;Foo(Args...)&gt;</code> but apparently less confusing?</li>
</ul>
</li>
</ul>
<h3>File System TS v1</h3>
<ul>
<li>
<p><code>[class.path]</code></p>
</li>
<li>
<p><code>[class.filesystem.error]</code></p>
</li>
<li>
<p><code>[class.file_status]</code></p>
</li>
<li>
<p><code>[class.directory_entry]</code></p>
</li>
<li>
<p><code>[class.directory_iterator]</code> and <code>[class.recursive_directory_iterator]</code></p>
</li>
<li>
<p><code>[fs.ops.funcs]</code></p>
</li>
<li>
<p><code>fstream</code>s can be opened with <code>path</code>s, as well as with <code>const path::value_type*</code> strings.</p>
</li>
</ul>
<h3>New algorithms</h3>
<ul>
<li>
<p><code>for_each_n</code></p>
</li>
<li>
<p><code>reduce</code></p>
</li>
<li>
<p><code>transform_reduce</code></p>
</li>
<li>
<p><code>exclusive_scan</code></p>
</li>
<li>
<p><code>inclusive_scan</code></p>
</li>
<li>
<p><code>transform_exclusive_scan</code></p>
</li>
<li>
<p><code>transform_inclusive_scan</code></p>
</li>
<li>
<p>Added for threading purposes, exposed even if you aren't using them threaded</p>
</li>
</ul>
<h3>Threading</h3>
<ul>
<li>
<p><code>std::shared_mutex</code></p>
<ul>
<li>Untimed, which can be more efficient if you don't need it.</li>
<li><code>atomic&lt;T&gt;``::is_always_lockfree</code></li>
</ul>
</li>
<li>
<p><code>scoped_lock&lt;Mutexes...&gt;</code></p>
<ul>
<li>Saves some <code>std::lock</code> pain when locking more than one mutex at a time.</li>
<li>
<p>Parallelism TS v1</p>
</li>
<li>
<p>The linked paper from 2014, may be out of date</p>
</li>
<li>Parallel versions of <code>std</code> algorithms, and related machinery</li>
<li>hardware_*_interference_size</li>
</ul>
</li>
</ul>
<h3>(parts of) Library Fundamentals TS v1 not covered above or below</h3>
<ul>
<li>
<p><code>[func.searchers]</code> and <code>[alg.search]</code></p>
<ul>
<li>A searching algorithm and techniques</li>
<li>
<p><code>[pmr]</code></p>
</li>
<li>
<p>Polymorphic allocator, like <code>std::function</code> for allocators</p>
</li>
<li>And some standard memory resources to go with it.</li>
<li>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0358r1.html</li>
<li>
<code>std::sample</code>, sampling from a range?</li>
</ul>
</li>
</ul>
<h3>Container Improvements</h3>
<ul>
<li>
<p><code>try_emplace</code> and <code>insert_or_assign</code></p>
<ul>
<li>gives better guarantees in some cases where spurious move/copy would be bad</li>
<li>
<p>Splicing for <code>map&lt;&gt;</code>, <code>unordered_map&lt;&gt;</code>, <code>set&lt;&gt;</code>, and <code>unordered_set&lt;&gt;</code></p>
</li>
<li>
<p>Move nodes between containers cheaply.</p>
</li>
<li>Merge whole containers cheaply.</li>
<li>non-const <code>.data()</code> for string.</li>
</ul>
</li>
<li>
<p>non-member <code>std::size</code>, <code>std::empty</code>, <code>std::data</code></p>
<ul>
<li>like <code>std::begin</code>/<code>end</code>
</li>
<li>Minimal incomplete type support in containers</li>
</ul>
</li>
<li>
<p>Contiguous iterator "concept"</p>
</li>
<li>
<p><code>constexpr</code> iterators</p>
</li>
<li>
<p>The <code>emplace</code> family of functions now returns a reference to the created object.</p>
</li>
</ul>
<h3>Smart pointer changes</h3>
<ul>
<li>
<code>unique_ptr&lt;T[]&gt;</code> fixes and other <code>unique_ptr</code> tweaks.</li>
<li>
<code>weak_from_this</code> and some fixed to shared from this</li>
</ul>
<h3>Other <code>std</code> datatype improvements:</h3>
<ul>
<li>
<code>{}</code> construction of <code>std::tuple</code> and other improvements</li>
<li>TriviallyCopyable reference_wrapper, can be performance boost</li>
</ul>
<h3>Misc</h3>
<ul>
<li>
<p>C++17 library is based on C11 instead of C99</p>
</li>
<li>
<p>Reserved <code>std[0-9]+</code> for future standard libraries</p>
</li>
<li>
<p><code>destroy(_at|_n)</code>, <code>uninitialized_move(_n)</code>, <code>uninitialized_value_construct(_n)</code>, <code>uninitialized_default_construct(_n)</code></p>
<ul>
<li>utility code already in most <code>std</code> implementations exposed</li>
<li>
<p>Special math functions</p>
</li>
<li>
<p>scientists may like them</p>
</li>
<li>
<p><code>std::clamp()</code></p>
</li>
<li>
<p><code>std::clamp( a, b, c ) == std::max( b, std::min( a, c ) )</code> roughly</p>
</li>
<li>
<code>gcd</code> and <code>lcm</code>
</li>
</ul>
</li>
<li>
<p><code>std::uncaught_exceptions</code></p>
<ul>
<li>Required if you want to only throw if safe from destructors</li>
<li><code>std::as_const</code></li>
</ul>
</li>
<li>
<p><code>std::bool_constant</code></p>
</li>
<li>
<p>A whole bunch of <code>_v</code> template variables</p>
</li>
<li>
<p><code>std::void_t&lt;T&gt;</code></p>
<ul>
<li>Surprisingly useful when writing templates</li>
<li>
<p><code>std::owner_less&lt;void&gt;</code></p>
</li>
<li>
<p>like <code>std::less&lt;void&gt;</code>, but for smart pointers to sort based on contents</p>
</li>
<li>
<code>std::chrono</code> polish</li>
</ul>
</li>
<li>
<p><code>std::conjunction</code>, <code>std::disjunction</code>, <code>std::negation</code> exposed</p>
</li>
<li>
<p><code>std::not_fn</code></p>
<ul>
<li>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0358r1.html</li>
<li>Rules for noexcept within <code>std</code>
</li>
</ul>
</li>
<li>
<p>std::is_contiguous_layout, useful for efficient hashing</p>
</li>
<li>
<p>std::to_chars/std::from_chars, high performance, locale agnostic number conversion; finally a way to serialize/deserialize to human readable formats (JSON &amp; co)</p>
</li>
<li>
<p><del>std::default_order, indirection over<code>std::less</code>.</del> (breaks ABI of some compilers due to name mangling, removed.)</p>
</li>
<li>
<p><code>memory_order_consume</code>, added language to prefer use of <code>memory_order_acquire</code></p>
</li>
</ul>
<h3>Traits</h3>
<ul>
<li>swap</li>
<li>is_aggregate</li>
<li>has_unique_object_representations</li>
</ul>
<h3>Deprecated</h3>
<ul>
<li>Some C libraries,</li>
<li><code>&lt;codecvt&gt;</code></li>
<li>
<code>result_of</code>, replaced with <code>invoke_result</code>
</li>
<li>
<code>shared_ptr::unique</code>, it isn't very threadsafe</li>
</ul>
<p>Isocpp.org has has an independent list of changes since C++14; it has been
partly pillaged.</p>
<p>Naturally TS work continues in parallel, so there are some TS that are not-
quite-ripe that will have to wait for the next iteration. The target for the
next iteration is C++20 as previously planned, not C++19 as some rumors
implied. C++1O has been avoided.</p>
<p>Initial list taken from this reddit post and this reddit post, with links
added via googling or from the above isocpp.org page.</p>
<p>Additional entries pillaged from SD-6 feature-test list.</p>
<p>clang's feature list and library feature list are next to be pillaged. This
doesn't seem to be reliable, as it is C++1z, not C++17.</p>
<p>these slides had some features missing elsewhere.</p>
<p>While "what was removed" was not asked, here is a short list of a few things
((mostly?) previous deprecated) that are removed in C++17 from C++:</p>
<h2>Removed:</h2>
<ul>
<li>
<code>register</code>, keyword reserved for future use</li>
<li><code>bool b; ++b;</code></li>
<li>trigraphs <ul>
<li>if you still need them, they are now part of your source file encoding, not part of language</li>
</ul>
</li>
<li>ios aliases</li>
<li>auto_ptr, old <code>&lt;functional&gt;</code> stuff, <code>random_shuffle</code>
</li>
<li>allocators in <code>std::function</code>
</li>
</ul>
<p>There were rewordings. I am unsure if these have any impact on code, or if
they are just cleanups in the standard:</p>
<h2>Papers not yet integrated into above:</h2>
<ul>
<li>
<p>P0505R0 (constexpr chrono)</p>
</li>
<li>
<p>P0418R2 (atomic tweaks)</p>
</li>
<li>
<p>P0512R0 (template argument deduction tweaks)</p>
</li>
<li>
<p>P0490R0 (structured binding tweaks)</p>
</li>
<li>
<p>P0513R0 (changes to <code>std::hash</code>)</p>
</li>
<li>
<p>P0502R0 (parallel exceptions)</p>
</li>
<li>
<p>P0509R1 (updating restrictions on exception handling)</p>
</li>
<li>
<p>P0012R1 (make exception specifications be part of the type system)</p>
</li>
<li>
<p>P0510R0 (restrictions on variants)</p>
</li>
<li>
<p>P0504R0 (tags for optional/variant/any)</p>
</li>
<li>
<p>P0497R0 (shared ptr tweaks)</p>
</li>
<li>
<p>P0508R0 (structured bindings node handles)</p>
</li>
<li>
<p>P0521R0 (shared pointer use count and unique changes?)</p>
</li>
</ul>
<h2>Spec changes:</h2>
<ul>
<li>exception specs and throw expressions</li>
</ul>
<h2>Further reference:</h2>
<ul>
<li>
<p>papers grouped by year; not all accepted</p>
</li>
<li>
<p>https://isocpp.org/files/papers/p0636r0.html</p>
<ul>
<li>Should be updated to "Modifications to existing features" here.</li>
</ul>
</li>
</ul>
<p><br><br><a href="posts/what-are-the-new-features-in-c-17/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-473.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-471.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
