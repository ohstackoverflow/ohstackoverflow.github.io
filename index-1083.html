<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1083) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1083.html">
<link rel="prev" href="index-1084.html" type="text/html">
<link rel="next" href="index-1082.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-dockerfile-zhong-fa-biao-ping-lun/" class="u-url">如何在 Dockerfile 中发表评论？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-dockerfile-zhong-fa-biao-ping-lun/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:03:13+08:00" itemprop="datePublished" title="2023-02-18 01:03">2023-02-18 01:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在写一个 Dockerfile。有没有办法在这个文件中发表评论？</p>
<p>Docker 是否有一个评论选项可以忽略一行的其余部分？</p>
<p><br><br></p>
<h2>解答</h2>
<p>您可以<code>#</code>在一行的开头使用开始注释（允许之前的空格<code>#</code>）：</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">stuff</span>
<span class="nv">RUN</span><span class="w"> </span><span class="nv">apt</span><span class="o">-</span><span class="nv">get</span><span class="w"> </span><span class="nv">update</span><span class="w"> </span>\
<span class="w">    </span>#<span class="w"> </span><span class="nv">install</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">packages</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">apt</span><span class="o">-</span><span class="nv">get</span><span class="w"> </span><span class="nv">install</span><span class="w"> </span><span class="o">-</span><span class="nv">y</span><span class="w"> </span><span class="nv">cron</span>
</pre></div>

<p><code>#</code>字符串中间的 's 被传递给命令本身，例如：</p>
<div class="code"><pre class="code literal-block">RUN echo 'we are running some # of cool things'
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>正如其他人所提到的，评论用 a
引用<code>#</code>并在此处记录。但是，与某些语言不同，the<code>#</code>必须位于行首。如果它们出现在行的中途，它们将被解释为参数并可能导致意外行为。</p>
<div class="code"><pre class="code literal-block"># This is a comment

COPY test_dir target_dir # This is not a comment, it is an argument to COPY

RUN echo hello world # This is an argument to RUN but the shell may ignore it
</pre></div>

<p>还应该注意的是，解析器指令最近已添加到 Dockerfile
中，其语法与注释相同。它们需要出现在文件的顶部，在任何其他注释或命令之前。最初，添加此指令是为了更改转义字符以支持 Windows：</p>
<div class="code"><pre class="code literal-block"># escape=`

FROM microsoft/nanoserver
COPY testfile.txt c:\
RUN dir c:\
</pre></div>

<p>第一行虽然看起来是注释，但实际上是一个解析器指令，用于将转义字符更改为反引号，以便 和
命令<code>COPY</code>可以<code>RUN</code>在路径中使用反斜杠。解析器指令也与BuildKit一起使用，用一行更改前端解析器<code>syntax</code>。有关如何在实践中使用它的更多详细信息，请参阅实验语法。</p>
<p>使用多行命令，注释行将被忽略，但您需要单独注释掉每一行：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>cat<span class="w"> </span>Dockerfile
FROM<span class="w"> </span>busybox:latest
RUN<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>first<span class="w"> </span><span class="nb">command</span><span class="w"> </span><span class="se">\</span>
<span class="c1"># &amp;&amp; echo second command disabled \</span>
<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span>third<span class="w"> </span><span class="nb">command</span>

$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>.
Sending<span class="w"> </span>build<span class="w"> </span>context<span class="w"> </span>to<span class="w"> </span>Docker<span class="w"> </span>daemon<span class="w">  </span><span class="m">23</span>.04kB
Step<span class="w"> </span><span class="m">1</span>/2<span class="w"> </span>:<span class="w"> </span>FROM<span class="w"> </span>busybox:latest
<span class="w"> </span>---&gt;<span class="w"> </span>59788edf1f3e
Step<span class="w"> </span><span class="m">2</span>/2<span class="w"> </span>:<span class="w"> </span>RUN<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>first<span class="w"> </span><span class="nb">command</span><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span>third<span class="w"> </span><span class="nb">command</span>
<span class="w"> </span>---&gt;<span class="w"> </span>Running<span class="w"> </span><span class="k">in</span><span class="w"> </span>b1177e7b563d
first<span class="w"> </span><span class="nb">command</span>
third<span class="w"> </span><span class="nb">command</span>
Removing<span class="w"> </span>intermediate<span class="w"> </span>container<span class="w"> </span>b1177e7b563d
<span class="w"> </span>---&gt;<span class="w"> </span>5442cfe321ac
Successfully<span class="w"> </span>built<span class="w"> </span>5442cfe321ac
</pre></div>

<p><br><br><a href="posts/how-do-i-make-a-comment-in-a-dockerfile/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-linq-cha-xun-zhong-diao-yong-tolist-huo-toarray-na-ge-geng-hao/" class="u-url">在 LINQ 查询中调用 ToList() 或 ToArray() 哪个更好？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-linq-cha-xun-zhong-diao-yong-tolist-huo-toarray-na-ge-geng-hao/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:02:49+08:00" itemprop="datePublished" title="2023-02-18 01:02">2023-02-18 01:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我经常遇到这样的情况，我想在我声明它的地方评估一个查询。这通常是因为我需要多次迭代它 <em>并且</em> 计算成本很高。例如：</p>
<div class="code"><pre class="code literal-block"><span class="n">string</span><span class="w"> </span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"..."</span><span class="p">;</span>
<span class="k">var</span><span class="w"> </span><span class="n">lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">raw</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="w">             </span><span class="n">let</span><span class="w"> </span><span class="n">ll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="o">.</span><span class="n">Trim</span><span class="p">()</span>
<span class="w">             </span><span class="n">where</span><span class="w"> </span><span class="o">!</span><span class="n">string</span><span class="o">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
<span class="w">             </span><span class="n">select</span><span class="w"> </span><span class="n">ll</span><span class="p">)</span><span class="o">.</span><span class="n">ToList</span><span class="p">();</span>
</pre></div>

<p>这很好用。 <strong>但</strong> 如果我不打算修改结果，那么我不妨调用而不是<code>ToArray()</code>调用<code>ToList()</code>.</p>
<p>但是，我想知道是否<code>ToArray()</code>是通过第一次调用实现的<code>ToList()</code>，因此内存效率低于仅调用<code>ToList()</code>.</p>
<p>我疯了吗？我是否应该打电话<code>ToArray()</code>- 知道内存不会被分配两次而安全可靠？</p>
<p><br><br></p>
<h2>解答</h2>
<p>除非您只需要一个数组来满足您应该使用的其他约束<code>ToList</code>。在大多数情况下<code>ToArray</code>会分配比<code>ToList</code>.</p>
<p>两者都使用数组进行存储，但<code>ToList</code>具有更灵活的约束。它需要数组至少与集合中元素的数量一样大。如果数组更大，那不是问题。但是<code>ToArray</code>需要将数组的大小精确地调整为元素的数量。</p>
<p>满足这个约束<code>ToArray</code>往往比
多做一次分配<code>ToList</code>。一旦它有一个足够大的数组，它就会分配一个大小正确的数组，并将元素复制回该数组。它唯一可以避免这种情况的情况是当数组的增长算法恰好与需要存储的元素数量一致时（绝对是少数）。</p>
<p><strong>编辑</strong></p>
<p>有几个人问我在值中有额外未使用的内存的后果<code>List&lt;T&gt;</code>。</p>
<p>这是一个合理的担忧。如果创建的集合长期存在，在创建后从未被修改并且很有可能进入 Gen2 堆，那么您最好预先分配额外的内存<code>ToArray</code>。</p>
<p>总的来说，虽然我发现这是罕见的情况。更常见的是，许多<code>ToArray</code>调用会立即传递给其他短暂的内存使用，在这种情况下<code>ToList</code>显然更好。</p>
<p>这里的关键是剖析、剖析然后再剖析一些。</p>
<p><br></p>
<h3>更多建议</h3>
<p>性能差异将是微不足道的，因为<code>List&lt;T&gt;</code>它是作为动态大小的数组实现的。调用<code>ToArray()</code>（它使用内部<code>Buffer&lt;T&gt;</code>类来增长数组）或<code>ToList()</code>（调用<code>List&lt;T&gt;(IEnumerable&lt;T&gt;)</code>构造函数）最终将成为将它们放入数组并增长数组直到它适合它们的问题。</p>
<p>如果您希望具体确认这一事实，请检查 Reflector 中相关方法的实现——您会发现它们归结为几乎相同的代码。</p>
<p><br><br><a href="posts/is-it-better-to-call-tolist-or-toarray-in-linq-queries/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-java-time-localdatetime-he-java-util-date-zhi-jian-zhuan-huan/" class="u-url">在 java.time.LocalDateTime 和 java.util.Date 之间转换</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-java-time-localdatetime-he-java-util-date-zhi-jian-zhuan-huan/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:01:51+08:00" itemprop="datePublished" title="2023-02-18 01:01">2023-02-18 01:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Java 8 有一个全新的日期和时间 API。此 API 中最有用的类之一是<code>LocalDateTime</code>，用于保存与时区无关的日期和时间值。</p>
<p><code>java.util.Date</code>为此，可能有数百万行代码使用遗留类。因此，在连接新旧代码时，需要在两者之间进行转换。由于似乎没有直接的方法可以做到这一点，那怎么办呢？</p>
<p><br><br></p>
<h2>解答</h2>
<p>简短回答：</p>
<div class="code"><pre class="code literal-block">Date in = new Date();
LocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());
Date out = Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());
</pre></div>

<p>解释：（基于这个关于 的问题<code>LocalDate</code>）</p>
<p>尽管它的名字，<code>java.util.Date</code>代表时间线上的瞬间，而不是“日期”。对象中存储的实际数据是<code>long</code>自
1970-01-01T00:00Z（1970 GMT/UTC 开始的午夜）以来的毫秒数。</p>
<p><code>java.util.Date</code>JSR-310 中的等效类是<code>Instant</code>，因此有方便的方法来提供来回转换：</p>
<div class="code"><pre class="code literal-block">Date input = new Date();
Instant instant = input.toInstant();
Date output = Date.from(instant);
</pre></div>

<p>一个<code>java.util.Date</code>实例没有时区的概念。如果您调用<code>toString()</code>a
，这可能看起来很奇怪<code>java.util.Date</code>，因为<code>toString</code>是相对于时区的。然而，该方法实际上使用 Java
的默认时区来提供字符串。时区不是实际状态的一部分<code>java.util.Date</code>。</p>
<p>An<code>Instant</code>也不包含有关时区的任何信息。因此，要从 an 转换<code>Instant</code>为本地日期时间，必须指定时区。这可能是默认时区 -
<code>ZoneId.systemDefault()</code>-
或者它可能是您的应用程序控制的时区，例如来自用户首选项的时区。<code>LocalDateTime</code>有一个方便的工厂方法，它同时采用即时和时区：</p>
<div class="code"><pre class="code literal-block">Date in = new Date();
LocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());
</pre></div>

<p>相反，<code>LocalDateTime</code>时区是通过调用该方法指定的<code>atZone(ZoneId)</code>。然后可以<code>ZonedDateTime</code>将
直接转换为<code>Instant</code>：</p>
<div class="code"><pre class="code literal-block">LocalDateTime ldt = ...
ZonedDateTime zdt = ldt.atZone(ZoneId.systemDefault());
Date output = Date.from(zdt.toInstant());
</pre></div>

<p><code>LocalDateTime</code>请注意，从到的转换<code>ZonedDateTime</code>有可能引入意外行为。这是因为由于夏令时，并非每个本地日期时间都存在。在秋季/秋季，本地时间线有重叠，同一本地日期时间出现两次。在春天，有一个间隙，一个小时消失了。<code>atZone(ZoneId)</code>有关转换将执行的操作的更多定义，请参见
的 Javadoc 。</p>
<p>总结，如果你往返 a<code>java.util.Date</code>到 a<code>LocalDateTime</code>并返回
a<code>java.util.Date</code>你可能会因为夏令时而得到不同的时刻。</p>
<p>附加信息：还有另一个差异会影响非常旧的日期。<code>java.util.Date</code>使用的日历在 1582 年 10 月 15
日更改，在此之前的日期使用儒略历而不是公历。相比之下，<code>java.time.*</code>所有时间都使用 ISO 日历系统（相当于公历）。在大多数用例中，ISO
日历系统是您想要的，但在比较 1582 年之前的日期时，您可能会看到奇怪的效果。</p>
<p><br></p>
<h3>更多建议</h3>
<p>这是我想出的（并且像所有日期时间难题一样，它可能会根据一些奇怪的时区 - 闰年 - 夏令时调整而被推翻 :D ）</p>
<h2>往返：<code>Date</code>&lt;&lt;-&gt;&gt;<code>LocalDateTime</code>
</h2>
<p>鉴于：<code>Date date = [some date]</code></p>
<p><strong>(1)<code>LocalDateTime</code>&lt;&lt; <code>Instant</code>&lt;&lt;<code>Date</code></strong></p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nv">Instant</span><span class="w"> </span><span class="nv">instant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Instant</span>.<span class="nv">ofEpochMilli</span><span class="ss">(</span><span class="nv">date</span>.<span class="k">getTime</span><span class="ss">())</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">LocalDateTime</span><span class="w"> </span><span class="nv">ldt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">LocalDateTime</span>.<span class="nv">ofInstant</span><span class="ss">(</span><span class="nv">instant</span>,<span class="w"> </span><span class="nv">ZoneOffset</span>.<span class="nv">UTC</span><span class="ss">)</span><span class="c1">;</span>
</pre></div>

<p><strong>(2)<code>Date</code>&lt;&lt; <code>Instant</code>&lt;&lt;<code>LocalDateTime</code></strong></p>
<div class="code"><pre class="code literal-block">    Instant instant = ldt.toInstant(ZoneOffset.UTC);
    Date date = Date.from(instant);
</pre></div>

<p>例子：</p>
<h3>鉴于：</h3>
<div class="code"><pre class="code literal-block"><span class="nt">Date</span><span class="w"> </span><span class="nt">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">new</span><span class="w"> </span><span class="nt">Date</span><span class="o">();</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="nt">date</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" long: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">date</span><span class="p">.</span><span class="nc">getTime</span><span class="o">());</span>
</pre></div>

<h2>(1) <code>LocalDateTime</code>&lt;&lt; <code>Instant</code>&lt;&lt; <code>Date</code>：</h2>
<p><strong>创建<code>Instant</code>自<code>Date</code>：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">Instant</span><span class="w"> </span><span class="nt">instant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Instant</span><span class="p">.</span><span class="nc">ofEpochMilli</span><span class="o">(</span><span class="nt">date</span><span class="p">.</span><span class="nc">getTime</span><span class="o">());</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">"Instant from Date:\n"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">instant</span><span class="o">);</span>
</pre></div>

<p><strong>创建<code>Date</code>自<code>Instant</code>（不是必需的，但为了说明）：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Date</span><span class="p">.</span><span class="nc">from</span><span class="o">(</span><span class="nt">instant</span><span class="o">);</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">"Date from Instant:\n"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">date</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" long: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">date</span><span class="p">.</span><span class="nc">getTime</span><span class="o">());</span>
</pre></div>

<p><strong>创建<code>LocalDateTime</code>自<code>Instant</code></strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">LocalDateTime</span><span class="w"> </span><span class="nt">ldt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">LocalDateTime</span><span class="p">.</span><span class="nc">ofInstant</span><span class="o">(</span><span class="nt">instant</span><span class="o">,</span><span class="w"> </span><span class="nt">ZoneOffset</span><span class="p">.</span><span class="nc">UTC</span><span class="o">);</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">"LocalDateTime from Instant:\n"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">ldt</span><span class="o">);</span>
</pre></div>

<h2>(2) <code>Date</code>&lt;&lt; <code>Instant</code>&lt;&lt;<code>LocalDateTime</code>
</h2>
<p><strong>创建<code>Instant</code>自<code>LocalDateTime</code>：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">instant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">ldt</span><span class="p">.</span><span class="nc">toInstant</span><span class="o">(</span><span class="nt">ZoneOffset</span><span class="p">.</span><span class="nc">UTC</span><span class="o">);</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">"Instant from LocalDateTime:\n"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">instant</span><span class="o">);</span>
</pre></div>

<p><strong>创建<code>Date</code>自<code>Instant</code>：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Date</span><span class="p">.</span><span class="nc">from</span><span class="o">(</span><span class="nt">instant</span><span class="o">);</span>
<span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">"Date from Instant:\n"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">date</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" long: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">date</span><span class="p">.</span><span class="nc">getTime</span><span class="o">());</span>
</pre></div>

<h2>输出是：</h2>
<div class="code"><pre class="code literal-block">Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574

Instant from Date:
2013-11-01T14:13:04.574Z

Date from Instant:
Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574

LocalDateTime from Instant:
2013-11-01T14:13:04.574

Instant from LocalDateTime:
2013-11-01T14:13:04.574Z

Date from Instant:
Fri Nov 01 07:13:04 PDT 2013 long: 1383315184574
</pre></div>

<p><br><br><a href="posts/converting-between-java-time-localdatetime-and-java-util-date/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1084.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1082.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
