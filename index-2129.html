<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2129) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2129.html">
<link rel="prev" href="index-2130.html" type="text/html">
<link rel="next" href="index-2128.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/method-can-be-made-static-but-should-it/" class="u-url">Method can be made static, but should it?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/method-can-be-made-static-but-should-it/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:38:20+08:00" itemprop="datePublished" title="2023-03-03 17:38">2023-03-03 17:38</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>ReSharper likes to point out multiple functions per ASP.NET page that could be
made static. Does it help me if I do make them static? Should I make them
static and move them to a utility class?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Static methods versus Instance methods</strong><br>
Static and instance members of the C# Language Specification explains the
difference. Generally, static methods can provide a very small performance
enhancement over instance methods, but only in somewhat extreme situations
(see this answer for some more details on that).</p>
<p>Rule CA1822 in FxCop or Code Analysis states:</p>
<blockquote>
<p><em>"After [marking members as static], the compiler will emit non-virtual call
sites to these members which will prevent a check at runtime for each call
that ensures the current object pointer is non-null. This can result in a
measurable performance gain for performance-sensitive code. In some cases,
the failure to access the current object instance represents a correctness
issue."</em></p>
</blockquote>
<p><strong>Utility Class</strong><br>
You shouldn't move them to a utility class unless it makes sense in your
design. If the static method relates to a particular type, like a
<code>ToRadians(double degrees)</code> method relates to a class representing angles, it
makes sense for that method to exist as a static member of that type (note,
this is a convoluted example for the purposes of demonstration).</p>
<p><br></p>
<h3>Suggest</h3>
<p><strong>Static methods versus Instance methods</strong><br>
Static and instance members of the C# Language Specification explains the
difference. Generally, static methods can provide a very small performance
enhancement over instance methods, but only in somewhat extreme situations
(see this answer for some more details on that).</p>
<p>Rule CA1822 in FxCop or Code Analysis states:</p>
<blockquote>
<p><em>"After [marking members as static], the compiler will emit non-virtual call
sites to these members which will prevent a check at runtime for each call
that ensures the current object pointer is non-null. This can result in a
measurable performance gain for performance-sensitive code. In some cases,
the failure to access the current object instance represents a correctness
issue."</em></p>
</blockquote>
<p><strong>Utility Class</strong><br>
You shouldn't move them to a utility class unless it makes sense in your
design. If the static method relates to a particular type, like a
<code>ToRadians(double degrees)</code> method relates to a class representing angles, it
makes sense for that method to exist as a static member of that type (note,
this is a convoluted example for the purposes of demonstration).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-the-hashmap-and-map-objects-in-java/" class="u-url">What is the difference between the HashMap and Map objects in Java?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-the-hashmap-and-map-objects-in-java/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:37:55+08:00" itemprop="datePublished" title="2023-03-03 17:37">2023-03-03 17:37</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What is the difference between the following maps I create (in another
question, people answered using them seemingly interchangeably and I'm
wondering if/how they are different):</p>
<div class="code"><pre class="code literal-block">HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>There is no difference between the objects; you have a <code>HashMap&lt;String,
Object&gt;</code> in both cases. There is a difference in the <em>interface</em> you have to
the object. In the first case, the interface is <code>HashMap&lt;String, Object&gt;</code>,
whereas in the second it's <code>Map&lt;String, Object&gt;</code>. But the underlying object is
the same.</p>
<p>The advantage to using <code>Map&lt;String, Object&gt;</code> is that you can change the
underlying object to be a different kind of map without breaking your contract
with any code that's using it. If you declare it as <code>HashMap&lt;String, Object&gt;</code>,
you have to change your contract if you want to change the underlying
implementation.</p>
<hr>
<p>Example: Let's say I write this class:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span> {
    <span class="nb">private</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span> <span class="n">things</span>;
    <span class="nb">private</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span> <span class="n">moreThings</span>;

    <span class="n">protected</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span> <span class="n">getThings</span>() {
        <span class="k">return</span> <span class="n">this</span>.<span class="n">things</span>;
    }

    <span class="n">protected</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span> <span class="n">getMoreThings</span>() {
        <span class="k">return</span> <span class="n">this</span>.<span class="n">moreThings</span>;
    }

    <span class="n">public</span> <span class="n">Foo</span>() {
        <span class="n">this</span>.<span class="n">things</span> = <span class="nb">new</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span>();
        <span class="n">this</span>.<span class="n">moreThings</span> = <span class="nb">new</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span>();
    }

    // ...<span class="n">more</span>...
}
</pre></div>

<p>The class has a couple of internal maps of string-&gt;object which it shares (via
accessor methods) with subclasses. Let's say I write it with <code>HashMap</code>s to
start with because I think that's the appropriate structure to use when
writing the class.</p>
<p>Later, Mary writes code subclassing it. She has something she needs to do with
both <code>things</code> and <code>moreThings</code>, so naturally she puts that in a common method,
and she uses the same type I used on <code>getThings</code>/<code>getMoreThings</code> when defining
her method:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">SpecialFoo</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">doSomething</span><span class="p">(</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb nb-Type">String</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">whatever</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">getThings</span><span class="p">());</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">getMoreThings</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span><span class="n">more</span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>Later, I decide that actually, it's better if I use <code>TreeMap</code> instead of
<code>HashMap</code> in <code>Foo</code>. I update <code>Foo</code>, changing <code>HashMap</code> to <code>TreeMap</code>. Now,
<code>SpecialFoo</code> doesn't compile anymore, because I've broken the contract: <code>Foo</code>
used to say it provided <code>HashMap</code>s, but now it's providing <code>TreeMaps</code> instead.
So we have to fix <code>SpecialFoo</code> now (and this kind of thing can ripple through
a codebase).</p>
<p>Unless I had a really good reason for sharing that my implementation was using
a <code>HashMap</code> (and that does happen), what I should have done was declare
<code>getThings</code> and <code>getMoreThings</code> as just returning <code>Map&lt;String, Object&gt;</code>
without being any more specific than that. In fact, barring a good reason to
do something else, even within <code>Foo</code> I should probably declare <code>things</code> and
<code>moreThings</code> as <code>Map</code>, not <code>HashMap</code>/<code>TreeMap</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span> {
    <span class="nb">private</span> <span class="nb">Map</span><span class="s">&lt;String, Object&gt;</span> <span class="n">things</span>;             // &lt;== <span class="n">Changed</span>
    <span class="nb">private</span> <span class="nb">Map</span><span class="s">&lt;String, Object&gt;</span> <span class="n">moreThings</span>;         // &lt;== <span class="n">Changed</span>

    <span class="n">protected</span> <span class="nb">Map</span><span class="s">&lt;String, Object&gt;</span> <span class="n">getThings</span>() {     // &lt;== <span class="n">Changed</span>
        <span class="k">return</span> <span class="n">this</span>.<span class="n">things</span>;
    }

    <span class="n">protected</span> <span class="nb">Map</span><span class="s">&lt;String, Object&gt;</span> <span class="n">getMoreThings</span>() { // &lt;== <span class="n">Changed</span>
        <span class="k">return</span> <span class="n">this</span>.<span class="n">moreThings</span>;
    }

    <span class="n">public</span> <span class="n">Foo</span>() {
        <span class="n">this</span>.<span class="n">things</span> = <span class="nb">new</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span>();
        <span class="n">this</span>.<span class="n">moreThings</span> = <span class="nb">new</span> <span class="n">HashMap</span><span class="s">&lt;String, Object&gt;</span>();
    }

    // ...<span class="n">more</span>...
}
</pre></div>

<p>Note how I'm now using <code>Map&lt;String, Object&gt;</code> everywhere I can, only being
specific when I create the actual objects.</p>
<p>If I had done that, then Mary would have done this:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">SpecialFoo</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">doSomething</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="nb nb-Type">String</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="o">&lt;==</span><span class="w"> </span><span class="n">Changed</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">whatever</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">getThings</span><span class="p">());</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">getMoreThings</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>...and changing <code>Foo</code> wouldn't have made <code>SpecialFoo</code> stop compiling.</p>
<p>Interfaces (and base classes) let us reveal <em>only as much as is necessary</em> ,
keeping our flexibility under the covers to make changes as appropriate. In
general, we want to have our references be as basic as possible. If we don't
need to know it's a <code>HashMap</code>, just call it a <code>Map</code>.</p>
<p>This isn't a blind rule, but in general, <em>coding to the most general
interface</em> is going to be less brittle than coding to something more specific.
If I'd remembered that, I wouldn't have created a <code>Foo</code> that set Mary up for
failure with <code>SpecialFoo</code>. If <em>Mary</em> had remembered that, then even though I
messed up <code>Foo</code>, she would have declared her private method with <code>Map</code> instead
of <code>HashMap</code> and my changing <code>Foo</code>'s contract wouldn't have impacted her code.</p>
<p>Sometimes you can't do that, sometimes you have to be specific. But unless you
have a reason to be, err toward the least-specific interface.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Map is an interface that HashMap implements. The difference is that in the
second implementation your reference to the HashMap will only allow the use of
functions defined in the Map interface, while the first will allow the use of
any public functions in HashMap (which includes the Map interface).</p>
<p>It will probably make more sense if you read Sun's interface tutorial</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-usefulness-of-enable-shared-from-this/" class="u-url">What is the usefulness of `enable_shared_from_this`?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-usefulness-of-enable-shared-from-this/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:37:30+08:00" itemprop="datePublished" title="2023-03-03 17:37">2023-03-03 17:37</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I ran across <code>enable_shared_from_this</code> while reading the Boost.Asio examples
and after reading the documentation I am still lost for how this should
correctly be used. Can someone please give me an example and explanation of
when using this class makes sense.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It enables you to get a valid <code>shared_ptr</code> instance to <code>this</code>, when all you
have is <code>this</code>. Without it, you would have no way of getting a <code>shared_ptr</code> to
<code>this</code>, unless you already had one as a member. This example from the boost
documentation for enable_shared_from_this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Y</span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">enable_shared_from_this</span><span class="o">&lt;</span><span class="nt">Y</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="nf">shared_from_this</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span>

<span class="nt">int</span><span class="w"> </span><span class="nt">main</span><span class="o">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">shared_ptr&lt;Y&gt;</span><span class="w"> </span><span class="err">p(new</span><span class="w"> </span><span class="err">Y)</span><span class="p">;</span>
<span class="w">    </span><span class="err">shared_ptr&lt;Y&gt;</span><span class="w"> </span><span class="err">q</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">p-&gt;f()</span><span class="p">;</span>
<span class="w">    </span><span class="err">assert(p</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">q)</span><span class="p">;</span>
<span class="w">    </span><span class="err">assert(!(p</span><span class="w"> </span><span class="err">&lt;</span><span class="w"> </span><span class="err">q</span><span class="w"> </span><span class="err">||</span><span class="w"> </span><span class="err">q</span><span class="w"> </span><span class="err">&lt;</span><span class="w"> </span><span class="err">p))</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">and</span><span class="w"> </span><span class="err">q</span><span class="w"> </span><span class="err">must</span><span class="w"> </span><span class="err">share</span><span class="w"> </span><span class="err">ownership</span>
<span class="p">}</span>
</pre></div>

<p>The method <code>f()</code> returns a valid <code>shared_ptr</code>, even though it had no member
instance. Note that you cannot simply do this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Y</span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">enable_shared_from_this</span><span class="o">&lt;</span><span class="nt">Y</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">return</span><span class="w"> </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span>
</pre></div>

<p>The shared pointer that this returned will have a different reference count
from the "proper" one, and one of them will end up losing and holding a
dangling reference when the object is deleted.</p>
<p><code>enable_shared_from_this</code> has become part of C++ 11 standard. You can also get
it from there as well as from boost.</p>
<p><br></p>
<h3>Suggest</h3>
<p>from Dr Dobbs article on weak pointers, I think this example is easier to
understand (source: http://drdobbs.com/cpp/184402026):</p>
<p>...code like this won't work correctly:</p>
<div class="code"><pre class="code literal-block">int *ip = new int;
shared_ptr&lt;int&gt; sp1(ip);
shared_ptr&lt;int&gt; sp2(ip);
</pre></div>

<p>Neither of the two <code>shared_ptr</code> objects knows about the other, so both will
try to release the resource when they are destroyed. That usually leads to
problems.</p>
<p>Similarly, if a member function needs a <code>shared_ptr</code> object that owns the
object that it's being called on, it can't just create an object on the fly:</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">S</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dangerous</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="kr">return</span><span class="w"> </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="w">   </span><span class="c1">// don't do this!</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp1</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="w">   </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp1</span><span class="o">-&gt;</span><span class="n">dangerous</span><span class="p">();</span>
<span class="w">   </span><span class="kr">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>This code has the same problem as the earlier example, although in a more
subtle form. When it is constructed, the <code>shared_pt</code>r object <code>sp1</code> owns the
newly allocated resource. The code inside the member function <code>S::dangerous</code>
doesn't know about that <code>shared_ptr</code> object, so the <code>shared_ptr</code> object that
it returns is distinct from <code>sp1</code>. Copying the new <code>shared_ptr</code> object to
<code>sp2</code> doesn't help; when <code>sp2</code> goes out of scope, it will release the
resource, and when <code>sp1</code> goes out of scope, it will release the resource
again.</p>
<p>The way to avoid this problem is to use the class template
<code>enable_shared_from_this</code>. The template takes one template type argument,
which is the name of the class that defines the managed resource. That class
must, in turn, be derived publicly from the template; like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">not_dangerous</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">shared_from_this</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp1</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="w">   </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp1</span><span class="o">-&gt;</span><span class="n">not_dangerous</span><span class="p">();</span>
<span class="w">   </span><span class="kr">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>When you do this, keep in mind that the object on which you call
<code>shared_from_this</code> must be owned by a <code>shared_ptr</code> object. This won't work:</p>
<div class="code"><pre class="code literal-block"><span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">S</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">S</span><span class="p">;</span>
<span class="w">   </span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">not_dangerous</span><span class="p">();</span><span class="w">     </span><span class="c1">// don't do this</span>
<span class="p">}</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2130.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2128.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
