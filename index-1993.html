<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1993) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1993.html">
<link rel="prev" href="index-1994.html" type="text/html">
<link rel="next" href="index-1992.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/where-does-scala-look-for-implicits/" class="u-url">Where does Scala look for implicits?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/where-does-scala-look-for-implicits/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:19:55+08:00" itemprop="datePublished" title="2023-03-03 14:19">2023-03-03 14:19</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>An <em>implicit</em> question to newcomers to Scala seems to be: where does the
compiler look for implicits? I mean implicit because the question never seems
to get fully formed, as if there weren't words for it. :-) For example, where
do the values for <code>integral</code> below come from?</p>
<div class="code"><pre class="code literal-block"><span class="n">scala</span><span class="o">&gt;</span> <span class="kn">import</span> <span class="nn">scala.math._</span>
<span class="kn">import</span> <span class="nn">scala.math._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)(</span><span class="n">implicit</span> <span class="n">integral</span><span class="p">:</span> <span class="n">Integral</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="p">{</span><span class="n">println</span><span class="p">(</span><span class="n">integral</span><span class="p">)}</span>
<span class="n">foo</span><span class="p">:</span> <span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)(</span><span class="n">implicit</span> <span class="n">integral</span><span class="p">:</span> <span class="n">scala</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">Integral</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="n">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">scala</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">Numeric</span><span class="err">$</span><span class="n">IntIsIntegral</span><span class="err">$</span><span class="o">@</span><span class="mi">3</span><span class="n">dbea611</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">0</span><span class="n">L</span><span class="p">)</span>
<span class="n">scala</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">Numeric</span><span class="err">$</span><span class="n">LongIsIntegral</span><span class="err">$</span><span class="o">@</span><span class="mi">48</span><span class="n">c610af</span>
</pre></div>

<p>Another question that does follow up to those who decide to learn the answer
to the first question is how does the compiler choose which implicit to use,
in certain situations of apparent ambiguity (but that compile anyway)?</p>
<p>For instance, <code>scala.Predef</code> defines two conversions from <code>String</code>: one to
<code>WrappedString</code> and another to <code>StringOps</code>. Both classes, however, share a lot
of methods, so why doesn't Scala complain about ambiguity when, say, calling
<code>map</code>?</p>
<p><strong>Note:</strong> this question was inspired by this other question, in the hopes of
stating the problem in a more general manner. The example was copied from
there, because it is referred to in the answer.</p>
<p><br><br></p>
<h2>Answer</h2>
<h2>Types of Implicits</h2>
<p>Implicits in Scala refers to either a value that can be passed
"automatically", so to speak, or a conversion from one type to another that is
made automatically.</p>
<h3>Implicit Conversion</h3>
<p>Speaking very briefly about the latter type, if one calls a method <code>m</code> on an
object <code>o</code> of a class <code>C</code>, and that class does not support method <code>m</code>, then
Scala will look for an implicit conversion from <code>C</code> to something that <em>does</em>
support <code>m</code>. A simple example would be the method <code>map</code> on <code>String</code>:</p>
<div class="code"><pre class="code literal-block">"abc".map(_.toInt)
</pre></div>

<p><code>String</code> does not support the method <code>map</code>, but <code>StringOps</code> does, and there's
an implicit conversion from <code>String</code> to <code>StringOps</code> available (see <code>implicit
def augmentString</code> on <code>Predef</code>).</p>
<h3>Implicit Parameters</h3>
<p>The other kind of implicit is the implicit <em>parameter</em>. These are passed to
method calls like any other parameter, but the compiler tries to fill them in
automatically. If it can't, it will complain. One <em>can</em> pass these parameters
explicitly, which is how one uses <code>breakOut</code>, for example (see question about
<code>breakOut</code>, on a day you are feeling up for a challenge).</p>
<p>In this case, one has to declare the need for an implicit, such as the <code>foo</code>
method declaration:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">foo</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span><span class="w"> </span><span class="n">T</span><span class="p">)(</span><span class="n">implicit</span><span class="w"> </span><span class="nl">integral</span><span class="p">:</span><span class="w"> </span><span class="n">Integral</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="n">println</span><span class="p">(</span><span class="n">integral</span><span class="p">)</span><span class="err">}</span>
</pre></div>

<h3>View Bounds</h3>
<p>There's one situation where an implicit is both an implicit conversion and an
implicit parameter. For example:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">getIndex</span><span class="o">[</span><span class="n">T, CC</span><span class="o">]</span><span class="p">(</span><span class="nl">seq</span><span class="p">:</span><span class="w"> </span><span class="n">CC</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="err">:</span><span class="w"> </span><span class="n">T</span><span class="p">)(</span><span class="n">implicit</span><span class="w"> </span><span class="nl">conv</span><span class="p">:</span><span class="w"> </span><span class="n">CC</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Seq</span><span class="o">[</span><span class="n">T</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>

<span class="n">getIndex</span><span class="p">(</span><span class="ss">"abc"</span><span class="p">,</span><span class="w"> </span><span class="s1">'a'</span><span class="p">)</span>
</pre></div>

<p>The method <code>getIndex</code> can receive any object, as long as there is an implicit
conversion available from its class to <code>Seq[T]</code>. Because of that, I can pass a
<code>String</code> to <code>getIndex</code>, and it will work.</p>
<p>Behind the scenes, the compiler changes <code>seq.IndexOf(value)</code> to
<code>conv(seq).indexOf(value)</code>.</p>
<p>This is so useful that there is syntactic sugar to write them. Using this
syntactic sugar, <code>getIndex</code> can be defined like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">getIndex</span><span class="o">[</span><span class="n">T, CC &lt;% Seq[T</span><span class="o">]</span><span class="err">]</span><span class="p">(</span><span class="nl">seq</span><span class="p">:</span><span class="w"> </span><span class="n">CC</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="err">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>
</pre></div>

<p>This syntactic sugar is described as a <em>view bound</em> , akin to an <em>upper bound</em>
(<code>CC &lt;: Seq[Int]</code>) or a <em>lower bound</em> (<code>T &gt;: Null</code>).</p>
<h3>Context Bounds</h3>
<p>Another common pattern in implicit parameters is the <em>type class pattern</em>.
This pattern enables the provision of common interfaces to classes which did
not declare them. It can both serve as a bridge pattern -- gaining separation
of concerns -- and as an adapter pattern.</p>
<p>The <code>Integral</code> class you mentioned is a classic example of type class pattern.
Another example on Scala's standard library is <code>Ordering</code>. There's a library
that makes heavy use of this pattern, called Scalaz.</p>
<p>This is an example of its use:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">sum</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="nb">list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">])(</span><span class="n">implicit</span> <span class="n">integral</span><span class="p">:</span> <span class="n">Integral</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="n">T</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kn">import</span> <span class="nn">integral._</span>   <span class="o">//</span> <span class="n">get</span> <span class="n">the</span> <span class="n">implicits</span> <span class="ow">in</span> <span class="n">question</span> <span class="n">into</span> <span class="n">scope</span>
    <span class="nb">list</span><span class="o">.</span><span class="n">foldLeft</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">zero</span><span class="p">)(</span><span class="n">_</span> <span class="o">+</span> <span class="n">_</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>There is also syntactic sugar for it, called a <em>context bound</em> , which is made
less useful by the need to refer to the implicit. A straight conversion of
that method looks like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">sum</span><span class="p">[</span><span class="n">T</span> <span class="p">:</span> <span class="n">Integral</span><span class="p">](</span><span class="nb">list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="n">T</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">val</span> <span class="n">integral</span> <span class="o">=</span> <span class="n">implicitly</span><span class="p">[</span><span class="n">Integral</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
    <span class="kn">import</span> <span class="nn">integral._</span>   <span class="o">//</span> <span class="n">get</span> <span class="n">the</span> <span class="n">implicits</span> <span class="ow">in</span> <span class="n">question</span> <span class="n">into</span> <span class="n">scope</span>
    <span class="nb">list</span><span class="o">.</span><span class="n">foldLeft</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">zero</span><span class="p">)(</span><span class="n">_</span> <span class="o">+</span> <span class="n">_</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>Context bounds are more useful when you just need to <em>pass</em> them to other
methods that use them. For example, the method <code>sorted</code> on <code>Seq</code> needs an
implicit <code>Ordering</code>. To create a method <code>reverseSort</code>, one could write:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">reverseSort</span><span class="p">[</span><span class="n">T</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Ordering</span><span class="p">](</span><span class="n">seq</span><span class="o">:</span><span class="w"> </span><span class="n">Seq</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="p">.</span><span class="n">sorted</span><span class="p">.</span><span class="n">reverse</span>
</pre></div>

<p>Because <code>Ordering[T]</code> was implicitly passed to <code>reverseSort</code>, it can then pass
it implicitly to <code>sorted</code>.</p>
<h2>Where do Implicits come from?</h2>
<p>When the compiler sees the need for an implicit, either because you are
calling a method which does not exist on the object's class, or because you
are calling a method that requires an implicit parameter, it will search for
an implicit that will fit the need.</p>
<p>This search obey certain rules that define which implicits are visible and
which are not. The following table showing where the compiler will search for
implicits was taken from an excellent presentation (timestamp 20:20) about
implicits by Josh Suereth, which I heartily recommend to anyone wanting to
improve their Scala knowledge. It has been complemented since then with
feedback and updates.</p>
<p>The implicits available under number 1 below has precedence over the ones
under number 2. Other than that, if there are several eligible arguments which
match the implicit parameter’s type, a most specific one will be chosen using
the rules of static overloading resolution (see Scala Specification §6.26.3).
More detailed information can be found in a question I link to at the end of
this answer.</p>
<ol>
<li>First look in current scope <ul>
<li>Implicits defined in current scope</li>
<li>Explicit imports</li>
<li>wildcard imports</li>
<li><del>Same scope in other files</del></li>
</ul>
</li>
<li>Now look at associated types in <ul>
<li>Companion objects of a type</li>
<li>Implicit scope of an argument's type <strong>(2.9.1)</strong>
</li>
<li>Implicit scope of type arguments <strong>(2.8.0)</strong>
</li>
<li>Outer objects for nested types</li>
<li>Other dimensions</li>
</ul>
</li>
</ol>
<p>Let's give some examples for them:</p>
<h3>Implicits Defined in Current Scope</h3>
<div class="code"><pre class="code literal-block">implicit<span class="w"> </span>val<span class="w"> </span>n:<span class="w"> </span>Int<span class="w"> </span>=<span class="w"> </span>5
def<span class="w"> </span>add(x:<span class="w"> </span>Int)(implicit<span class="w"> </span>y:<span class="w"> </span>Int)<span class="w"> </span>=<span class="w"> </span>x<span class="w"> </span>+<span class="w"> </span>y
add(5)<span class="w"> </span>//<span class="w"> </span>takes<span class="w"> </span>n<span class="w"> </span>from<span class="w"> </span>the<span class="w"> </span>current<span class="w"> </span>scope
</pre></div>

<h3>Explicit Imports</h3>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">scala.collection.JavaConversions.mapAsScalaMap</span>
<span class="k">def</span> <span class="nf">env</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="n">getenv</span><span class="p">()</span> <span class="o">//</span> <span class="n">Java</span> <span class="nb">map</span>
<span class="n">val</span> <span class="n">term</span> <span class="o">=</span> <span class="n">env</span><span class="p">(</span><span class="s2">"TERM"</span><span class="p">)</span>    <span class="o">//</span> <span class="n">implicit</span> <span class="n">conversion</span> <span class="kn">from</span> <span class="nn">Java</span> <span class="n">Map</span> <span class="n">to</span> <span class="n">Scala</span> <span class="n">Map</span>
</pre></div>

<h3>Wildcard Imports</h3>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">sum</span><span class="p">[</span><span class="n">T</span> <span class="p">:</span> <span class="n">Integral</span><span class="p">](</span><span class="nb">list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="n">T</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">val</span> <span class="n">integral</span> <span class="o">=</span> <span class="n">implicitly</span><span class="p">[</span><span class="n">Integral</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
    <span class="kn">import</span> <span class="nn">integral._</span>   <span class="o">//</span> <span class="n">get</span> <span class="n">the</span> <span class="n">implicits</span> <span class="ow">in</span> <span class="n">question</span> <span class="n">into</span> <span class="n">scope</span>
    <span class="nb">list</span><span class="o">.</span><span class="n">foldLeft</span><span class="p">(</span><span class="n">integral</span><span class="o">.</span><span class="n">zero</span><span class="p">)(</span><span class="n">_</span> <span class="o">+</span> <span class="n">_</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h3>Same Scope in Other Files</h3>
<p><strong>Edit</strong> : It seems this does not have a different precedence. If you have
some example that demonstrates a precedence distinction, please make a
comment. Otherwise, don't rely on this one.</p>
<p>This is like the first example, but assuming the implicit definition is in a
different file than its usage. See also how package objects might be used in
to bring in implicits.</p>
<h3>Companion Objects of a Type</h3>
<p>There are two object companions of note here. First, the object companion of
the "source" type is looked into. For instance, inside the object <code>Option</code>
there is an implicit conversion to <code>Iterable</code>, so one can call <code>Iterable</code>
methods on <code>Option</code>, or pass <code>Option</code> to something expecting an <code>Iterable</code>.
For example:</p>
<div class="code"><pre class="code literal-block"><span class="n">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">List</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">Some</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="nf">yield </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
</pre></div>

<p>That expression is translated by the compiler to</p>
<div class="code"><pre class="code literal-block">List(1, 2, 3).flatMap(x =&gt; Some('x').map(y =&gt; (x, y)))
</pre></div>

<p>However, <code>List.flatMap</code> expects a <code>TraversableOnce</code>, which <code>Option</code> is not.
The compiler then looks inside <code>Option</code>'s object companion and finds the
conversion to <code>Iterable</code>, which is a <code>TraversableOnce</code>, making this expression
correct.</p>
<p>Second, the companion object of the expected type:</p>
<div class="code"><pre class="code literal-block">List(1, 2, 3).sorted
</pre></div>

<p>The method <code>sorted</code> takes an implicit <code>Ordering</code>. In this case, it looks
inside the object <code>Ordering</code>, companion to the class <code>Ordering</code>, and finds an
implicit <code>Ordering[Int]</code> there.</p>
<p>Note that companion objects of super classes are also looked into. For
example:</p>
<div class="code"><pre class="code literal-block">class<span class="w"> </span>A(val<span class="w"> </span>n:<span class="w"> </span>Int)
object<span class="w"> </span>A<span class="w"> </span>{<span class="w"> </span>
<span class="w">    </span>implicit<span class="w"> </span>def<span class="w"> </span>str(a:<span class="w"> </span>A)<span class="w"> </span>=<span class="w"> </span>"A:<span class="w"> </span>%d"<span class="w"> </span>format<span class="w"> </span>a.n
}
class<span class="w"> </span>B(val<span class="w"> </span>x:<span class="w"> </span>Int,<span class="w"> </span>y:<span class="w"> </span>Int)<span class="w"> </span>extends<span class="w"> </span>A(y)
val<span class="w"> </span>b<span class="w"> </span>=<span class="w"> </span>new<span class="w"> </span>B(5,<span class="w"> </span>2)
val<span class="w"> </span>s:<span class="w"> </span>String<span class="w"> </span>=<span class="w"> </span>b<span class="w">  </span>//<span class="w"> </span>s<span class="w"> </span>==<span class="w"> </span>"A:<span class="w"> </span>2"
</pre></div>

<p>This is how Scala found the implicit <code>Numeric[Int]</code> and <code>Numeric[Long]</code> in
your question, by the way, as they are found inside <code>Numeric</code>, not <code>Integral</code>.</p>
<h3>Implicit Scope of an Argument's Type</h3>
<p>If you have a method with an argument type <code>A</code>, then the implicit scope of
type <code>A</code> will also be considered. By "implicit scope" I mean that all these
rules will be applied recursively -- for example, the companion object of <code>A</code>
will be searched for implicits, as per the rule above.</p>
<p>Note that this does not mean the implicit scope of <code>A</code> will be searched for
conversions of that parameter, but of the whole expression. For example:</p>
<div class="code"><pre class="code literal-block">class<span class="w"> </span>A(val<span class="w"> </span>n:<span class="w"> </span>Int)<span class="w"> </span>{
<span class="w">  </span>def<span class="w"> </span>+(other:<span class="w"> </span>A)<span class="w"> </span>=<span class="w"> </span>new<span class="w"> </span>A(n<span class="w"> </span>+<span class="w"> </span>other.n)
}
object<span class="w"> </span>A<span class="w"> </span>{
<span class="w">  </span>implicit<span class="w"> </span>def<span class="w"> </span>fromInt(n:<span class="w"> </span>Int)<span class="w"> </span>=<span class="w"> </span>new<span class="w"> </span>A(n)
}

//<span class="w"> </span>This<span class="w"> </span>becomes<span class="w"> </span>possible:
1<span class="w"> </span>+<span class="w"> </span>new<span class="w"> </span>A(1)
//<span class="w"> </span>because<span class="w"> </span>it<span class="w"> </span>is<span class="w"> </span>converted<span class="w"> </span>into<span class="w"> </span>this:
A.fromInt(1)<span class="w"> </span>+<span class="w"> </span>new<span class="w"> </span>A(1)
</pre></div>

<p><strong>This is available since Scala 2.9.1.</strong></p>
<h3>Implicit Scope of Type Arguments</h3>
<p>This is required to make the type class pattern really work. Consider
<code>Ordering</code>, for instance: It comes with some implicits in its companion
object, but you can't add stuff to it. So how can you make an <code>Ordering</code> for
your own class that is automatically found?</p>
<p>Let's start with the implementation:</p>
<div class="code"><pre class="code literal-block">class<span class="w"> </span>A(val<span class="w"> </span>n:<span class="w"> </span>Int)
object<span class="w"> </span>A<span class="w"> </span>{
<span class="w">    </span>implicit<span class="w"> </span>val<span class="w"> </span>ord<span class="w"> </span>=<span class="w"> </span>new<span class="w"> </span>Ordering[A]<span class="w"> </span>{
<span class="w">        </span>def<span class="w"> </span>compare(x:<span class="w"> </span>A,<span class="w"> </span>y:<span class="w"> </span>A)<span class="w"> </span>=<span class="w"> </span>implicitly[Ordering[Int]].compare(x.n,<span class="w"> </span>y.n)
<span class="w">    </span>}
}
</pre></div>

<p>So, consider what happens when you call</p>
<div class="code"><pre class="code literal-block">List(new A(5), new A(2)).sorted
</pre></div>

<p>As we saw, the method <code>sorted</code> expects an <code>Ordering[A]</code> (actually, it expects
an <code>Ordering[B]</code>, where <code>B &gt;: A</code>). There isn't any such thing inside
<code>Ordering</code>, and there is no "source" type on which to look. Obviously, it is
finding it inside <code>A</code>, which is a <em>type argument</em> of <code>Ordering</code>.</p>
<p>This is also how various collection methods expecting <code>CanBuildFrom</code> work: the
implicits are found inside companion objects to the type parameters of
<code>CanBuildFrom</code>.</p>
<p><strong>Note</strong> : <code>Ordering</code> is defined as <code>trait Ordering[T]</code>, where <code>T</code> is a type
parameter. Previously, I said that Scala looked inside type parameters, which
doesn't make much sense. The implicit looked for above is <code>Ordering[A]</code>, where
<code>A</code> is an actual type, not type parameter: it is a <em>type argument</em> to
<code>Ordering</code>. See section 7.2 of the Scala specification.</p>
<p><strong>This is available since Scala 2.8.0.</strong></p>
<h3>Outer Objects for Nested Types</h3>
<p>I haven't actually seen examples of this. I'd be grateful if someone could
share one. The principle is simple:</p>
<div class="code"><pre class="code literal-block">class<span class="w"> </span>A(val<span class="w"> </span>n:<span class="w"> </span>Int)<span class="w"> </span>{
<span class="w">  </span>class<span class="w"> </span>B(val<span class="w"> </span>m:<span class="w"> </span>Int)<span class="w"> </span>{<span class="w"> </span>require(m<span class="w"> </span><span class="nt">&lt; n</span><span class="err">)</span><span class="w"> </span><span class="err">}</span>
<span class="err">}</span>
<span class="err">object</span><span class="w"> </span><span class="err">A</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="err">implicit</span><span class="w"> </span><span class="err">def</span><span class="w"> </span><span class="err">bToString(b:</span><span class="w"> </span><span class="err">A#B)</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">"B:</span><span class="w"> </span><span class="err">%d"</span><span class="w"> </span><span class="err">format</span><span class="w"> </span><span class="err">b.m</span>
<span class="err">}</span>
<span class="err">val</span><span class="w"> </span><span class="na">a =</span><span class="w"> </span><span class="s">new</span><span class="w"> </span><span class="err">A(5)</span>
<span class="err">val</span><span class="w"> </span><span class="na">b =</span><span class="w"> </span><span class="s">new</span><span class="w"> </span><span class="err">a.B(3)</span>
<span class="err">val</span><span class="w"> </span><span class="err">s:</span><span class="w"> </span><span class="na">String =</span><span class="w"> </span><span class="s">b</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="na">s =</span><span class="s">=</span><span class="w"> </span><span class="err">"B:</span><span class="w"> </span><span class="err">3"</span>
</pre></div>

<h3>Other Dimensions</h3>
<p>I'm pretty sure this was a joke, but this answer might not be up-to-date. So
don't take this question as being the final arbiter of what is happening, and
if you do noticed it has gotten out-of-date, please inform me so that I can
fix it.</p>
<p><strong>EDIT</strong></p>
<p>Related questions of interest:</p>
<ul>
<li>Context and view bounds</li>
<li>Chaining implicits</li>
<li>Scala: Implicit parameter resolution precedence</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>I wanted to find out the precedence of the implicit parameter resolution, not
just where it looks for, so I wrote a blog post revisiting implicits without
import tax (and implicit parameter precedence again after some feedback).</p>
<p>Here's the list:</p>
<ul>
<li>1) implicits visible to current invocation scope via local declaration, imports, outer scope, inheritance, package object that are accessible without prefix.</li>
<li>2) <em>implicit scope</em> , which contains all sort of companion objects and package object that bear some relation to the implicit's type which we search for (i.e. package object of the type, companion object of the type itself, of its type constructor if any, of its parameters if any, and also of its supertype and supertraits).</li>
</ul>
<p>If at either stage we find more than one implicit, static overloading rule is
used to resolve it.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-benefit/" class="u-url">How do the likely/unlikely macros in the Linux kernel work and what is their benefit?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-benefit/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:19:30+08:00" itemprop="datePublished" title="2023-03-03 14:19">2023-03-03 14:19</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I've been digging through some parts of the Linux kernel, and found calls like
this:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">unlikely</span><span class="ss">(</span><span class="nv">fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="ss">))</span>
{
<span class="w">    </span><span class="cm">/* Do something */</span>
}
</pre></div>

<p>or</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">likely</span><span class="ss">(</span><span class="o">!</span><span class="nv">err</span><span class="ss">))</span>
{
<span class="w">    </span><span class="cm">/* Do something */</span>
}
</pre></div>

<p>I've found the definition of them:</p>
<div class="code"><pre class="code literal-block">#define likely(x)       __builtin_expect((x),1)
#define unlikely(x)     __builtin_expect((x),0)
</pre></div>

<p>I know that they are for optimization, but how do they work? And how much
performance/size decrease can be expected from using them? And is it worth the
hassle (and losing the portability probably) at least in bottleneck code (in
userspace, of course).</p>
<p><br><br></p>
<h2>Answer</h2>
<p>They are hint to the compiler to emit instructions that will cause branch
prediction to favour the "likely" side of a jump instruction. This can be a
big win, if the prediction is correct it means that the jump instruction is
basically free and will take zero cycles. On the other hand if the prediction
is wrong, then it means the processor pipeline needs to be flushed and it can
cost several cycles. So long as the prediction is correct most of the time,
this will tend to be good for performance.</p>
<p>Like all such performance optimisations you should only do it after extensive
profiling to ensure the code really is in a bottleneck, and probably given the
micro nature, that it is being run in a tight loop. Generally the Linux
developers are pretty experienced so I would imagine they would have done
that. They don't really care too much about portability as they only target
gcc, and they have a very close idea of the assembly they want it to generate.</p>
<p><br></p>
<h3>Suggest</h3>
<p><strong>Let's decompile to see what GCC 4.8 does with it</strong></p>
<p><strong>Without<code>__builtin_expect</code></strong></p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">"stdio.h"</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">"time.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Use time to prevent it from being optimized away. */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Compile and decompile with GCC 4.8.2 x86_64 Linux:</p>
<div class="code"><pre class="code literal-block">gcc -c -O3 -std=gnu11 main.c
objdump -dr main.o
</pre></div>

<p>Output:</p>
<div class="code"><pre class="code literal-block"><span class="mf">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="p">:</span>
<span class="w">   </span><span class="mf">0</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">83</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="mf">08</span><span class="w">             </span><span class="n">sub</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x8</span><span class="p">,</span><span class="err">%</span><span class="n">rsp</span>
<span class="w">   </span><span class="mf">4</span><span class="p">:</span><span class="w">       </span><span class="mf">31</span><span class="w"> </span><span class="n">ff</span><span class="w">                   </span><span class="n">xor</span><span class="w">    </span><span class="err">%</span><span class="n">edi</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">   </span><span class="mf">6</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">xb</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">7</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">        </span><span class="n">time</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">   </span><span class="n">b</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">85</span><span class="w"> </span><span class="n">c0</span><span class="w">                </span><span class="n">test</span><span class="w">   </span><span class="err">%</span><span class="n">rax</span><span class="p">,</span><span class="err">%</span><span class="n">rax</span>
<span class="w">   </span><span class="n">e</span><span class="p">:</span><span class="w">       </span><span class="mf">75</span><span class="w"> </span><span class="mf">14</span><span class="w">                   </span><span class="n">jne</span><span class="w">    </span><span class="mf">24</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x24</span><span class="o">&gt;</span>
<span class="w">  </span><span class="mf">10</span><span class="p">:</span><span class="w">       </span><span class="n">ba</span><span class="w"> </span><span class="mf">01</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x1</span><span class="p">,</span><span class="err">%</span><span class="n">edx</span>
<span class="w">  </span><span class="mf">15</span><span class="p">:</span><span class="w">       </span><span class="n">be</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x0</span><span class="p">,</span><span class="err">%</span><span class="n">esi</span>
<span class="w">                    </span><span class="mf">16</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_32</span><span class="w"> </span><span class="mf">.</span><span class="n">rodata</span><span class="mf">.</span><span class="n">str1</span><span class="mf">.1</span>
<span class="w">  </span><span class="mf">1</span><span class="n">a</span><span class="p">:</span><span class="w">       </span><span class="n">bf</span><span class="w"> </span><span class="mf">01</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x1</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">  </span><span class="mf">1</span><span class="n">f</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="mf">24</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x24</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">20</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">       </span><span class="n">__printf_chk</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">24</span><span class="p">:</span><span class="w">       </span><span class="n">bf</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x0</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">                    </span><span class="mf">25</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_32</span><span class="w"> </span><span class="mf">.</span><span class="n">rodata</span><span class="mf">.</span><span class="n">str1</span><span class="mf">.1</span><span class="o">+</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">29</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="mf">2</span><span class="n">e</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x2e</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">2</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">       </span><span class="n">puts</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">2</span><span class="n">e</span><span class="p">:</span><span class="w">       </span><span class="mf">31</span><span class="w"> </span><span class="n">c0</span><span class="w">                   </span><span class="n">xor</span><span class="w">    </span><span class="err">%</span><span class="n">eax</span><span class="p">,</span><span class="err">%</span><span class="n">eax</span>
<span class="w">  </span><span class="mf">30</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">83</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="mf">08</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x8</span><span class="p">,</span><span class="err">%</span><span class="n">rsp</span>
<span class="w">  </span><span class="mf">34</span><span class="p">:</span><span class="w">       </span><span class="n">c3</span><span class="w">                      </span><span class="n">retq</span>
</pre></div>

<p>The instruction order in memory was unchanged: first the <code>printf</code> and then
<code>puts</code> and the <code>retq</code> return.</p>
<p><strong>With<code>__builtin_expect</code></strong></p>
<p>Now replace <code>if (i)</code> with:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">__builtin_expect</span><span class="ss">(</span><span class="nv">i</span>,<span class="w"> </span><span class="mi">0</span><span class="ss">))</span>
</pre></div>

<p>and we get:</p>
<div class="code"><pre class="code literal-block"><span class="mf">0000000000000000</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="p">:</span>
<span class="w">   </span><span class="mf">0</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">83</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="mf">08</span><span class="w">             </span><span class="n">sub</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x8</span><span class="p">,</span><span class="err">%</span><span class="n">rsp</span>
<span class="w">   </span><span class="mf">4</span><span class="p">:</span><span class="w">       </span><span class="mf">31</span><span class="w"> </span><span class="n">ff</span><span class="w">                   </span><span class="n">xor</span><span class="w">    </span><span class="err">%</span><span class="n">edi</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">   </span><span class="mf">6</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">xb</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">7</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">        </span><span class="n">time</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">   </span><span class="n">b</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">85</span><span class="w"> </span><span class="n">c0</span><span class="w">                </span><span class="n">test</span><span class="w">   </span><span class="err">%</span><span class="n">rax</span><span class="p">,</span><span class="err">%</span><span class="n">rax</span>
<span class="w">   </span><span class="n">e</span><span class="p">:</span><span class="w">       </span><span class="mf">74</span><span class="w"> </span><span class="mf">11</span><span class="w">                   </span><span class="n">je</span><span class="w">     </span><span class="mf">21</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x21</span><span class="o">&gt;</span>
<span class="w">  </span><span class="mf">10</span><span class="p">:</span><span class="w">       </span><span class="n">bf</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x0</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">                    </span><span class="mf">11</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_32</span><span class="w"> </span><span class="mf">.</span><span class="n">rodata</span><span class="mf">.</span><span class="n">str1</span><span class="mf">.1</span><span class="o">+</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">15</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="mf">1</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x1a</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">16</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">       </span><span class="n">puts</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">1</span><span class="n">a</span><span class="p">:</span><span class="w">       </span><span class="mf">31</span><span class="w"> </span><span class="n">c0</span><span class="w">                   </span><span class="n">xor</span><span class="w">    </span><span class="err">%</span><span class="n">eax</span><span class="p">,</span><span class="err">%</span><span class="n">eax</span>
<span class="w">  </span><span class="mf">1</span><span class="n">c</span><span class="p">:</span><span class="w">       </span><span class="mf">48</span><span class="w"> </span><span class="mf">83</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="mf">08</span><span class="w">             </span><span class="n">add</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x8</span><span class="p">,</span><span class="err">%</span><span class="n">rsp</span>
<span class="w">  </span><span class="mf">20</span><span class="p">:</span><span class="w">       </span><span class="n">c3</span><span class="w">                      </span><span class="n">retq</span>
<span class="w">  </span><span class="mf">21</span><span class="p">:</span><span class="w">       </span><span class="n">ba</span><span class="w"> </span><span class="mf">01</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x1</span><span class="p">,</span><span class="err">%</span><span class="n">edx</span>
<span class="w">  </span><span class="mf">26</span><span class="p">:</span><span class="w">       </span><span class="n">be</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x0</span><span class="p">,</span><span class="err">%</span><span class="n">esi</span>
<span class="w">                    </span><span class="mf">27</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_32</span><span class="w"> </span><span class="mf">.</span><span class="n">rodata</span><span class="mf">.</span><span class="n">str1</span><span class="mf">.1</span>
<span class="w">  </span><span class="mf">2</span><span class="n">b</span><span class="p">:</span><span class="w">       </span><span class="n">bf</span><span class="w"> </span><span class="mf">01</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">mov</span><span class="w">    </span><span class="err">$</span><span class="mf">0</span><span class="n">x1</span><span class="p">,</span><span class="err">%</span><span class="n">edi</span>
<span class="w">  </span><span class="mf">30</span><span class="p">:</span><span class="w">       </span><span class="n">e8</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w"> </span><span class="mf">00</span><span class="w">          </span><span class="n">callq</span><span class="w">  </span><span class="mf">35</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x35</span><span class="o">&gt;</span>
<span class="w">                    </span><span class="mf">31</span><span class="p">:</span><span class="w"> </span><span class="n">R_X86_64_PC32</span><span class="w">       </span><span class="n">__printf_chk</span><span class="o">-</span><span class="mf">0</span><span class="n">x4</span>
<span class="w">  </span><span class="mf">35</span><span class="p">:</span><span class="w">       </span><span class="n">eb</span><span class="w"> </span><span class="n">d9</span><span class="w">                   </span><span class="n">jmp</span><span class="w">    </span><span class="mf">10</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mf">0</span><span class="n">x10</span><span class="o">&gt;</span>
</pre></div>

<p>The <code>printf</code> (compiled to <code>__printf_chk</code>) was moved to the very end of the
function, after <code>puts</code> and the return to improve branch prediction as
mentioned by other answers.</p>
<p>So it is basically the same as:</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">main</span><span class="o">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">int</span><span class="w"> </span><span class="err">i</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">!time(NULL)</span><span class="p">;</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(i)</span>
<span class="w">        </span><span class="err">goto</span><span class="w"> </span><span class="err">printf</span><span class="p">;</span>
<span class="n">puts</span><span class="p">:</span>
<span class="w">    </span><span class="nf">puts</span><span class="p">(</span><span class="s2">"a"</span><span class="p">);</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">:</span>
<span class="w">    </span><span class="nf">printf</span><span class="p">(</span><span class="s2">"%d\n"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="err">goto</span><span class="w"> </span><span class="err">puts</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>This optimization was not done with <code>-O0</code>.</p>
<p>But good luck on writing an example that runs faster with <code>__builtin_expect</code>
than without, CPUs are really smart these days. My naive attempts are here.</p>
<p><strong>C++20<code>[[likely]]</code> and <code>[[unlikely]]</code></strong></p>
<p>C++20 has standardized those C++ built-ins: How to use C++20's likely/unlikely
attribute in if-else statement They will likely (a pun!) do the same thing.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/spring-transactional-what-happens-in-background/" class="u-url">Spring - @Transactional - What happens in background?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/spring-transactional-what-happens-in-background/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:19:05+08:00" itemprop="datePublished" title="2023-03-03 14:19">2023-03-03 14:19</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I want to know what actually happens when you annotate a method with
<code>@Transactional</code>? Of course, I know that Spring will wrap that method in a
Transaction.</p>
<p>But, I have the following doubts:</p>
<ol>
<li>I heard that Spring creates a <strong>proxy class</strong>? Can someone explain this in more <strong>depth</strong>. <strong>What actually resides in that proxy class? What happens to the actual class? And how can I see Spring's created proxied class</strong>
</li>
<li>I also read in Spring docs that: </li>
</ol>
<blockquote>
<p><em>Note: Since this mechanism is based on proxies, <strong>only 'external' method
calls coming in through the proxy will be intercepted</strong>. This means that
'self-invocation', i.e. a method within the target object calling some other
method of the target object, won't lead to an actual transaction at runtime
even if the invoked method is marked with <code>@Transactional</code>!</em></p>
</blockquote>
<p>Source:
http://static.springsource.org/spring/docs/2.0.x/reference/transaction.html</p>
<p><strong>Why only external method calls will be under Transaction and not the self-
invocation methods?</strong></p>
<p><br><br></p>
<h2>Answer</h2>
<p>This is a big topic. The Spring reference doc devotes multiple chapters to it.
I recommend reading the ones on Aspect-Oriented Programming and Transactions,
as Spring's declarative transaction support uses AOP at its foundation.</p>
<p>But at a very high level, Spring creates proxies for classes that declare
<code>@Transactional</code> on the class itself or on members. The proxy is mostly
invisible at runtime. It provides a way for Spring to inject behaviors before,
after, or around method calls into the object being proxied. Transaction
management is just one example of the behaviors that can be hooked in.
Security checks are another. And you can provide your own, too, for things
like logging. So when you annotate a method with <code>@Transactional</code>, Spring
dynamically creates a proxy that implements the same interface(s) as the class
you're annotating. And when clients make calls into your object, the calls are
intercepted and the behaviors injected via the proxy mechanism.</p>
<p>Transactions in EJB work similarly, by the way.</p>
<p>As you observed, through, the proxy mechanism only works when calls come in
from some external object. When you make an internal call within the object,
you're really making a call through the <code>this</code> reference, which bypasses the
proxy. There are ways of working around that problem, however. I explain one
approach in this forum post in which I use a <code>BeanFactoryPostProcessor</code> to
inject an instance of the proxy into "self-referencing" classes at runtime. I
save this reference to a member variable called <code>me</code>. Then if I need to make
internal calls that require a change in the transaction status of the thread,
I direct the call through the proxy (e.g. <code>me.someMethod()</code>.) The forum post
explains in more detail.</p>
<p>Note that the <code>BeanFactoryPostProcessor</code> code would be a little different now,
as it was written back in the Spring 1.x timeframe. But hopefully it gives you
an idea. I have an updated version that I could probably make available.</p>
<p><br></p>
<h3>Suggest</h3>
<p>When Spring loads your bean definitions, and has been configured to look for
<code>@Transactional</code> annotations, it will create these <strong>proxy objects</strong> around
your actual <strong>bean</strong>. These proxy objects are instances of classes that are
auto-generated at runtime. The default behaviour of these proxy objects when a
method is invoked is just to invoke the same method on the "target" bean (i.e.
your bean).</p>
<p>However, the proxies can also be supplied with interceptors, and when present
these interceptors will be invoked by the proxy before it invokes your target
bean's method. For target beans annotated with <code>@Transactional</code>, Spring will
create a <code>TransactionInterceptor</code>, and pass it to the generated proxy object.
So when you call the method from client code, you're calling the method on the
proxy object, which first invokes the <code>TransactionInterceptor</code> (which begins a
transaction), which in turn invokes the method on your target bean. When the
invocation finishes, the <code>TransactionInterceptor</code> commits/rolls back the
transaction. It's transparent to the client code.</p>
<p>As for the "external method" thing, if your bean invokes one of its own
methods, then it will not be doing so via the proxy. Remember, Spring wraps
your bean in the proxy, your bean has no knowledge of it. Only calls from
"outside" your bean go through the proxy.</p>
<p>Does that help?</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1994.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1992.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
