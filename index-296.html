<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 296) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-296.html">
<link rel="prev" href="index-297.html" type="text/html">
<link rel="next" href="index-295.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/utf-8-all-the-way-through/" class="u-url">UTF-8 all the way through</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/utf-8-all-the-way-through/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:58+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm setting up a new server and want to support UTF-8 fully in my web
application. I have tried this in the past on existing servers and always seem
to end up having to fall back to ISO-8859-1.</p>
<p>Where exactly do I need to set the encoding/charsets? I'm aware that I need to
configure Apache, MySQL, and PHP to do this — is there some standard checklist
I can follow, or perhaps troubleshoot where the mismatches occur?</p>
<p>This is for a new Linux server, running MySQL 5, PHP, 5 and Apache 2.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Data Storage</strong> :</p>
<ul>
<li>
<p>Specify the <code>utf8mb4</code> character set on all tables and text columns in your database. This makes MySQL physically store and retrieve values encoded natively in UTF-8. Note that MySQL will implicitly use <code>utf8mb4</code> encoding if a <code>utf8mb4_*</code> collation is specified (without any explicit character set).</p>
</li>
<li>
<p>In older versions of MySQL (&lt; 5.5.3), you'll unfortunately be forced to use simply <code>utf8</code>, which only supports a subset of Unicode characters. I wish I were kidding.</p>
</li>
</ul>
<p><strong>Data Access</strong> :</p>
<ul>
<li>
<p>In your application code (e.g. PHP), in whatever DB access method you use, you'll need to set the connection charset to <code>utf8mb4</code>. This way, MySQL does no conversion from its native UTF-8 when it hands data off to your application and vice versa.</p>
</li>
<li>
<p>Some drivers provide their own mechanism for configuring the connection character set, which both updates its own internal state and informs MySQL of the encoding to be used on the connection—this is usually the preferred approach. In PHP:</p>
<ul>
<li>
<p>If you're using the PDO abstraction layer with PHP ≥ 5.3.6, you can specify <code>charset</code> in the DSN:</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="o">$</span><span class="nt">dbh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">new</span><span class="w"> </span><span class="nt">PDO</span><span class="o">(</span><span class="s1">'mysql:charset=utf8mb4'</span><span class="o">);</span>
</pre></div>

</li>
<li>
<p>If you're using mysqli, you can call <code>set_charset()</code>:</p>
<div class="code"><pre class="code literal-block"><span class="w">      </span><span class="err">$</span><span class="n">mysqli</span><span class="o">-&gt;</span><span class="n">set_charset</span><span class="p">(</span><span class="s">'utf8mb4'</span><span class="p">);</span><span class="w">       </span><span class="c1">// object oriented style</span>
</pre></div>

<p>mysqli_set_charset($link, 'utf8mb4');  // procedural style</p>
</li>
<li>
<p>If you're stuck with plain mysql but happen to be running PHP ≥ 5.2.3, you can call <code>mysql_set_charset</code>.</p>
</li>
</ul>
</li>
<li>
<p>If the driver does not provide its own mechanism for setting the connection character set, you may have to issue a query to tell MySQL how your application expects data on the connection to be encoded: <code>SET NAMES 'utf8mb4'</code>.</p>
</li>
<li>
<p>The same consideration regarding <code>utf8mb4</code>/<code>utf8</code> applies as above.</p>
</li>
</ul>
<p><strong>Output</strong> :</p>
<ul>
<li>UTF-8 should be set in the HTTP header, such as <code>Content-Type: text/html; charset=utf-8</code>. You can achieve that either by setting <code>default_charset</code> in php.ini (preferred), or manually using <code>header()</code> function.</li>
<li>If your application transmits text to other systems, they will also need to be informed of the character encoding. With web applications, the browser must be informed of the encoding in which data is sent (through HTTP response headers or HTML metadata).</li>
<li>When encoding the output using <code>json_encode()</code>, add <code>JSON_UNESCAPED_UNICODE</code> as a second parameter.</li>
</ul>
<p><strong>Input</strong> :</p>
<ul>
<li>Browsers will submit data in the character set specified for the document, hence nothing particular has to be done on the input.</li>
<li>In case you have doubts about request encoding (in case it could be tampered with), you may verify every received string as being valid UTF-8 before you try to store it or use it anywhere. PHP's <code>mb_check_encoding()</code> does the trick, but you have to use it religiously. There's really no way around this, as malicious clients can submit data in whatever encoding they want, and I haven't found a trick to get PHP to do this for you reliably.</li>
</ul>
<p><strong>Other Code Considerations</strong> :</p>
<ul>
<li>
<p>Obviously enough, all files you'll be serving (PHP, HTML, JavaScript, etc.) should be encoded in valid UTF-8.</p>
</li>
<li>
<p>You need to make sure that every time you process a UTF-8 string, you do so safely. This is, unfortunately, the hard part. You'll probably want to make extensive use of PHP's <code>mbstring</code> extension.</p>
</li>
<li>
<p><strong>PHP's built-in string operations are <em>not</em> by default UTF-8 safe.</strong> There are some things you can safely do with normal PHP string operations (like concatenation), but for most things you should use the equivalent <code>mbstring</code> function.</p>
</li>
<li>
<p>To know what you're doing (read: not mess it up), you really need to know UTF-8 and how it works on the lowest possible level. Check out any of the links from utf8.com for some good resources to learn everything you need to know.</p>
</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>I'd like to add one thing to chazomaticus' excellent answer:</p>
<p>Don't forget the META tag either (like this, or the HTML4 or XHTML version of
it):</p>
<div class="code"><pre class="code literal-block">&lt;meta charset="utf-8"&gt;
</pre></div>

<p>That seems trivial, but IE7 has given me problems with that before.</p>
<p>I was doing everything right; the database, database connection and Content-
Type HTTP header were all set to UTF-8, and it worked fine in all other
browsers, but Internet Explorer still insisted on using the "Western European"
encoding.</p>
<p>It turned out the page was missing the META tag. Adding that solved the
problem.</p>
<p><strong>Edit:</strong></p>
<p>The W3C actually has a rather large section dedicated to I18N. They have a
number of articles related to this issue – describing the HTTP, (X)HTML and
CSS side of things:</p>
<ul>
<li>FAQ: Changing (X)HTML page encoding to UTF-8</li>
<li>Declaring character encodings in HTML</li>
<li>Tutorial: Character sets &amp; encodings in XHTML, HTML and CSS</li>
<li>Setting the HTTP charset parameter</li>
</ul>
<p>They recommend using both the HTTP header and HTML meta tag (or XML
declaration in case of XHTML served as XML).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-do-a-line-break-line-continuation-in-python/" class="u-url">How can I do a line break (line continuation) in Python?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-do-a-line-break-line-continuation-in-python/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:31+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Given:</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' + 'c' + 'd'
</pre></div>

<p>How do I write the above in two lines?</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' +
    'c' + 'd'
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>What is the line? You can just have arguments on the next line without any
problems:</p>
<div class="code"><pre class="code literal-block">a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, 
            blahblah6, blahblah7)
</pre></div>

<p>Otherwise you can do something like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span>
<span class="w">    </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span><span class="ss">)</span>:
</pre></div>

<p>or with explicit line break:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span>\
<span class="w">   </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span>:
</pre></div>

<p>Check the style guide for more information.</p>
<p>Using parentheses, your example can be written over multiple lines:</p>
<div class="code"><pre class="code literal-block">a = ('1' + '2' + '3' +
    '4' + '5')
</pre></div>

<p>The same effect can be obtained using explicit line break:</p>
<div class="code"><pre class="code literal-block">a = '1' + '2' + '3' + \
    '4' + '5'
</pre></div>

<p>Note that the style guide says that using the implicit continuation with
parentheses is preferred, but in this particular case just adding parentheses
around your expression is probably the wrong way to go.</p>
<p><br></p>
<h3>Suggest</h3>
<p>From <em>PEP 8 -- Style Guide for Python Code</em> :</p>
<blockquote>
<p><strong>The preferred way of wrapping long lines is by using Python's implied line
continuation inside parentheses, brackets and braces.</strong> Long lines can be
broken over multiple lines by wrapping expressions in parentheses. These
should be used in preference to using a backslash for line continuation.</p>
<p>Backslashes may still be appropriate at times. For example, long, multiple
with-statements cannot use implicit continuation, so backslashes are
acceptable:</p>
<div class="code"><pre class="code literal-block">with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
     file_2.write(file_1.read())
</pre></div>

<p>Another such case is with assert statements.</p>
<p>Make sure to indent the continued line appropriately. The preferred place to
break around a binary operator is <strong>after</strong> the operator, not before it.
Some examples:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Rectangle</span>(<span class="nb">Blob</span>):

  <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                <span class="n">color</span>=<span class="s">'black'</span>, <span class="n">emphasis</span>=<span class="n">None</span>, <span class="n">highlight</span>=<span class="mi">0</span>):
       <span class="k">if</span> (<span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span>
          <span class="n">color</span> == <span class="s">'red'</span> <span class="o">and</span> <span class="n">emphasis</span> == <span class="s">'strong'</span> <span class="o">or</span>
           <span class="n">highlight</span> &gt; <span class="mi">100</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"sorry, you lose"</span>)
       <span class="k">if</span> <span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span> (<span class="n">color</span> == <span class="s">'red'</span> <span class="o">or</span>
                                          <span class="n">emphasis</span> <span class="k">is</span> <span class="n">None</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"I don't think so -- values are %s, %s"</span> %
                            (<span class="n">width</span>, <span class="n">height</span>))
       <span class="nb">Blob</span>.<span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                     <span class="n">color</span>, <span class="n">emphasis</span>,
</pre></div>

<p>highlight)file_2.write(file_1.read())
</p>
</blockquote>
<p>PEP8 now recommends the <em>opposite convention</em> (for breaking at binary
operations) used by mathematicians and their publishers to improve
readability.</p>
<p>Donald Knuth's style of breaking <strong>before</strong> a binary operator aligns operators
vertically, thus reducing the eye's workload when determining which items are
added and subtracted.</p>
<p>From PEP8: <em>Should a line break before or after a binary operator?</em> :</p>
<blockquote>
<p>Donald Knuth explains the traditional rule in his Computers and Typesetting
series: "Although formulas within a paragraph always break after binary
operations and relations, displayed formulas always break before binary
operations"[3].</p>
<p>Following the tradition from mathematics usually results in more readable
code:</p>
<div class="code"><pre class="code literal-block"># Yes: easy to match operators with operands
</pre></div>

</blockquote>
<div class="code"><pre class="code literal-block">income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</pre></div>

<blockquote>
<p>In Python code, it is permissible to break before or after a binary
operator, as long as the convention is consistent locally. For new code
Knuth's style is suggested.</p>
</blockquote>
<p>[3]: Donald Knuth's The TeXBook, pages 195 and 196</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/" class="u-url">Where and why do I have to put the "template" and "typename" keywords?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:05+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In templates, where and why do I have to put <code>typename</code> and <code>template</code> on
dependent names?<br>
What exactly are dependent names anyway?</p>
<p>I have the following code:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="nt">will</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="nt">too</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="n">Q</span><span class="p">:</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="kc">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">typename</span><span class="o">/</span><span class="n">template</span><span class="w"> </span><span class="n">here</span><span class="o">?</span>
<span class="w">        </span><span class="n">typedef</span><span class="w"> </span><span class="n">Tail</span><span class="o">::</span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
<span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">For</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">last</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="nt">Tn</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">char</span><span class="w"> </span><span class="err">fail</span><span class="cp">[</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">sizeof</span><span class="p">(</span><span class="nx">U</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Cannot</span><span class="w"> </span><span class="err">be</span><span class="w"> </span><span class="err">instantiated</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">any</span><span class="w"> </span><span class="err">U</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>The problem I have is in the <code>typedef Tail::inUnion&lt;U&gt; dummy</code> line. I'm fairly
certain that <code>inUnion</code> is a dependent name, and VC++ is quite right in choking
on it.<br>
I also know that I should be able to add <code>template</code> somewhere to tell the
compiler that inUnion is a template-id. But where exactly? And should it then
assume that inUnion is a class template, i.e. <code>inUnion&lt;U&gt;</code> names a type and
not a function?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>(See here also for my C++11 answer)</p>
<p>In order to parse a C++ program, the compiler needs to know whether certain
names are types or not. The following example demonstrates that:</p>
<div class="code"><pre class="code literal-block">t * f;
</pre></div>

<p>How should this be parsed? For many languages a compiler doesn't need to know
the meaning of a name in order to parse and basically know what action a line
of code does. In C++, the above however can yield vastly different
interpretations depending on what <code>t</code> means. If it's a type, then it will be a
declaration of a pointer <code>f</code>. However if it's not a type, it will be a
multiplication. So the C++ Standard says at paragraph (3/7):</p>
<blockquote>
<p>Some names denote types or templates. In general, whenever a name is
encountered it is necessary to determine whether that name denotes one of
these entities before continuing to parse the program that contains it. The
process that determines this is called name lookup.</p>
</blockquote>
<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to
a template type parameter? <code>x</code> could be a static int data member that could be
multiplied or could equally well be a nested class or typedef that could yield
to a declaration. <strong>If a name has this property - that it can't be looked up
until the actual template arguments are known - then it's called a <em>dependent
name</em> (it "depends" on the template parameters).</strong></p>
<p>You might recommend to just wait till the user instantiates the template:</p>
<blockquote>
<p><em>Let's wait until the user instantiates the template, and then later find
out the real meaning of<code>t::x * f;</code>.</em></p>
</blockquote>
<p>This will work and actually is allowed by the Standard as a possible
implementation approach. These compilers basically copy the template's text
into an internal buffer, and only when an instantiation is needed, they parse
the template and possibly detect errors in the definition. But instead of
bothering the template's users (poor colleagues!) with errors made by a
template's author, other implementations choose to check templates early on
and give errors in the definition as soon as possible, before an instantiation
even takes place.</p>
<p>So there has to be a way to tell the compiler that certain names are types and
that certain names aren't.</p>
<h3>The "typename" keyword</h3>
<p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a
dependent name, then we need to prefix it by <code>typename</code> to tell the compiler
to parse it in a certain way. The Standard says at (14.6/2):</p>
<blockquote>
<p>A name used in a template declaration or definition and that is dependent on
a template-parameter is assumed not to name a type unless the applicable
name lookup finds a type name or the name is qualified by the keyword
typename.</p>
</blockquote>
<p>There are many names for which <code>typename</code> is not necessary, because the
compiler can, with the applicable name lookup in the template definition,
figure out how to parse a construct itself - for example with <code>T *f;</code>, when
<code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it
must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name
is taken to be a non-type, but when instantiation finds it denotes a type, the
usual error messages are emitted by the compiler. Sometimes, the error
consequently is given at definition time:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// t::x is taken as non-type, but as an expression the following misses an</span>
<span class="c1">// operator between the two names or a semicolon separating them.</span>
<span class="n">t</span><span class="p">::</span><span class="n">x</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
</pre></div>

<p><em>The syntax allows<code>typename</code> only before qualified names</em> - it is therefor
taken as granted that unqualified names are always known to refer to types if
they do so.</p>
<p>A similar gotcha exists for names that denote templates, as hinted at by the
introductory text.</p>
<h3>The "template" keyword</h3>
<p>Remember the initial quote above and how the Standard requires special
handling for templates as well? Let's take the following innocent-looking
example:</p>
<div class="code"><pre class="code literal-block"><span class="nt">boost</span><span class="p">::</span><span class="nd">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nt">int</span><span class="o">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">f</span><span class="o">;</span>
</pre></div>

<p>It might look obvious to a human reader. Not so for the compiler. Imagine the
following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nt">namespace</span><span class="w"> </span><span class="nt">boost</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">function</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">main</span><span class="o">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="err">int</span><span class="w"> </span><span class="err">f</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">boost</span><span class="p">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nf">int</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>That's actually a valid <em>expression</em>! It uses the less-than operator to
compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-
than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you
might well know, <code>boost::function</code> in real life is a template, so the compiler
knows (14.2/3):</p>
<blockquote>
<p>After name lookup (3.4) finds that a name is a template-name, if this name
is followed by a &lt;, the &lt; is always taken as the beginning of a template-
argument-list and never as a name followed by the less-than operator.</p>
</blockquote>
<p>Now we are back to the same problem as with <code>typename</code>. What if we can't know
yet whether the name is a template when parsing the code? We will need to
insert <code>template</code> immediately before the template name, as specified by
<code>14.2/4</code>. This looks like:</p>
<div class="code"><pre class="code literal-block"><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">f</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">call</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">template</span>
</pre></div>

<p>Template names can not only occur after a <code>::</code> but also after a <code>-&gt;</code> or <code>.</code> in
a class member access. You need to insert the keyword there too:</p>
<div class="code"><pre class="code literal-block"><span class="n">this</span><span class="o">-&gt;</span><span class="n">template</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// call a function template</span>
</pre></div>

<hr>
<h3>Dependencies</h3>
<p>For the people that have thick Standardese books on their shelf and that want
to know what exactly I was talking about, I'll talk a bit about how this is
specified in the Standard.</p>
<p>In template declarations some constructs have different meanings depending on
what template arguments you use to instantiate the template: Expressions may
have different types or values, variables may have different types or function
calls might end up calling different functions. Such constructs are generally
said to <em>depend</em> on template parameters.</p>
<p>The Standard defines precisely the rules by whether a construct is dependent
or not. It separates them into logically different groups: One catches types,
another catches expressions. Expressions may depend by their value and/or
their type. So we have, with typical examples appended:</p>
<ul>
<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>
<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>
<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>
</ul>
<p>Most of the rules are intuitive and are built up recursively: For example, a
type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent
expression or <code>T</code> is a dependent type. The details of this can be read in
section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent
expressions and <code>(14.6.2.3)</code> for value-dependent expressions.</p>
<h4>Dependent names</h4>
<p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a
simple read (you know, the principle of least surprise), all it defines as a
<em>dependent name</em> is the special case for function names below. But since
clearly <code>T::x</code> also needs to be looked up in the instantiation context, it
also needs to be a dependent name (fortunately, as of mid C++14 the committee
has started to look into how to fix this confusing definition).</p>
<p>To avoid this problem, I have resorted to a simple interpretation of the
Standard text. Of all the constructs that denote dependent types or
expressions, a subset of them represent names. Those names are therefore
"dependent names". A name can take different forms - the Standard says:</p>
<blockquote>
<p>A name is a use of an identifier (2.11), operator-function-id (13.5),
conversion-function-id (12.3.2), or template-id (14.2) that denotes an
entity or label (6.6.4, 6.1)</p>
</blockquote>
<p>An identifier is just a plain sequence of characters / digits, while the next
two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-
name &lt;argument list&gt;</code>. All these are names, and by conventional use in the
Standard, a name can also include qualifiers that say what namespace or class
a name should be looked up in.</p>
<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of
all dependent constructs that are names is called <em>dependent name</em>. Function
names, however, may have different meaning in different instantiations of a
template, but unfortunately are not caught by this general rule.</p>
<h4>Dependent function names</h4>
<p>Not primarily a concern of this article, but still worth mentioning: Function
names are an exception that are handled separately. An identifier function
name is dependent not by itself, but by the type dependent argument
expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name.
In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>
<h3>Additional notes and examples</h3>
<p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should
look like the following</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">typedef</span><span class="w"> </span><span class="err">typename</span><span class="w"> </span><span class="n">Tail</span><span class="p">:</span><span class="o">:</span><span class="n">template</span><span class="w"> </span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>The keyword <code>template</code> doesn't always have to appear in the last part of a
name. It can appear in the middle before a class name that's used as a scope,
like in the following example</p>
<div class="code"><pre class="code literal-block"><span class="nt">typename</span><span class="w"> </span><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">iterator</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">value_type</span><span class="w"> </span><span class="nt">v</span><span class="o">;</span>
</pre></div>

<p>In some cases, the keywords are forbidden, as detailed below</p>
<ul>
<li>
<p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : /<em> typename </em>/ SomeBase<t>::type 
 { };</t></p>
</li>
<li>
<p>In using-declarations it's not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee said not to work on a solution. </p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : SomeBase<t> {
    using SomeBase<t>::template type; // error
    using typename SomeBase<t>::type; // typename <em>is</em> allowed
 };</t></t></t></p>
</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<h3>C++11</h3>
<h4>Problem</h4>
<p>While the rules in C++03 about when you need <code>typename</code> and <code>template</code> are
largely reasonable, there is one annoying disadvantage of its formulation</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typedef</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">result_type</span><span class="p">;</span>

<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// error, "this" is dependent, "template" keyword needed</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// error, "A&lt;T&gt;" is dependent, "typename" keyword needed</span>
<span class="w">    </span><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">result_type</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>

<p>As can be seen, we need the disambiguation keyword even if the compiler could
perfectly figure out itself that <code>A::result_type</code> can only be <code>int</code> (and is
hence a type), and <code>this-&gt;g</code> can only be the member template <code>g</code> declared
later (even if <code>A</code> is explicitly specialized somewhere, that would not affect
the code within that template, so its meaning cannot be affected by a later
specialization of <code>A</code>!).</p>
<h4>Current instantiation</h4>
<p>To improve the situation, in C++11 the language tracks when a type refers to
the enclosing template. To know that, the type must have been formed by using
a certain form of name, which is its own name (in the above, <code>A</code>, <code>A&lt;T&gt;</code>,
<code>::A&lt;T&gt;</code>). A type referenced by such a name is known to be the <em>current
instantiation</em>. There may be multiple types that are all the current
instantiation if the type from which the name is formed is a member/nested
class (then, <code>A::NestedClass</code> and <code>A</code> are both current instantiations).</p>
<p>Based on this notion, the language says that <code>CurrentInstantiation::Foo</code>,
<code>Foo</code> and <code>CurrentInstantiationTyped-&gt;Foo</code> (such as <code>A *a = this; a-&gt;Foo</code>) are
all <em>member of the current instantiation</em> <strong>if</strong> they are found to be members
of a class that is the current instantiation or one of its non-dependent base
classes (by just doing the name lookup immediately).</p>
<p>The keywords <code>typename</code> and <code>template</code> are now not required anymore if the
qualifier is a member of the current instantiation. A keypoint here to
remember is that <code>A&lt;T&gt;</code> is <em>still</em> a type-dependent name (after all <code>T</code> is
also type dependent). But <code>A&lt;T&gt;::result_type</code> is known to be a type - the
compiler will "magically" look into this kind of dependent types to figure
this out.</p>
<div class="code"><pre class="code literal-block"><span class="nt">struct</span><span class="w"> </span><span class="nt">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">typedef</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">result_type</span><span class="p">;</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">could</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">specialized</span><span class="o">!</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="nt">C</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">void</span><span class="w"> </span><span class="err">f()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK,</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation!</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="n">A</span><span class="p">:</span><span class="o">:</span><span class="n">result_type</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">dependent</span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="n">D</span><span class="o">::</span><span class="n">result_type</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">error,</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r2</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">relying</span><span class="w"> </span><span class="err">on</span><span class="w"> </span><span class="err">C&lt;T&gt;</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">provide</span><span class="w"> </span><span class="err">it</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">But</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="err">typename</span><span class="w"> </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r3</span><span class="p">;</span><span class="w">        </span>
<span class="w">  </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>That's impressive, but can we do better? The language even goes further and
<em>requires</em> that an implementation again looks up <code>D::result_type</code> when
instantiating <code>D::f</code> (even if it found its meaning already at definition
time). When now the lookup result differs or results in ambiguity, the program
is ill-formed and a diagnostic must be given. Imagine what happens if we
defined <code>C</code> like this</p>
<div class="code"><pre class="code literal-block">template&lt;&gt;
struct C&lt;int&gt; {
  typedef bool result_type;
  typedef int questionable_type;
};
</pre></div>

<p>A compiler is required to catch the error when instantiating <code>D&lt;int&gt;::f</code>. So
you get the best of the two worlds: "Delayed" lookup protecting you if you
could get in trouble with dependent base classes, and also "Immediate" lookup
that frees you from <code>typename</code> and <code>template</code>.</p>
<h4>Unknown specializations</h4>
<p>In the code of <code>D</code>, the name <code>typename D::questionable_type</code> is not a member
of the current instantiation. Instead the language marks it as a <em>member of an
unknown specialization</em>. In particular, this is always the case when you are
doing <code>DependentTypeName::Foo</code> or <code>DependentTypedName-&gt;Foo</code> and either the
dependent type is <em>not</em> the current instantiation (in which case the compiler
can give up and say "we will look later what <code>Foo</code> is) or it <em>is</em> the current
instantiation and the name was not found in it or its non-dependent base
classes and there are also dependent base classes.</p>
<p>Imagine what happens if we had a member function <code>h</code> within the above defined
<code>A</code> class template</p>
<div class="code"><pre class="code literal-block">void h() {
  typename A&lt;T&gt;::questionable_type x;
}
</pre></div>

<p>In C++03, the language allowed to catch this error because there could never
be a valid way to instantiate <code>A&lt;T&gt;::h</code> (whatever argument you give to <code>T</code>).
In C++11, the language now has a further check to give more reason for
compilers to implement this rule. Since <code>A</code> has no dependent base classes, and
<code>A</code> declares no member <code>questionable_type</code>, the name <code>A&lt;T&gt;::questionable_type</code>
is <em>neither</em> a member of the current instantiation <em>nor</em> a member of an
unknown specialization. In that case, there should be no way that that code
could validly compile at instantiation time, so the language forbids a name
where the qualifier is the current instantiation to be neither a member of an
unknown specialization nor a member of the current instantiation (however,
this violation is still not required to be diagnosed).</p>
<h4>Examples and trivia</h4>
<p>You can try this knowledge on this answer and see whether the above
definitions make sense for you on a real-world example (they are repeated
slightly less detailed in that answer).</p>
<p>The C++11 rules make the following valid C++03 code ill-formed (which was not
intended by the C++ committee, but will probably not be fixed)</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="n">C</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">g</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>This valid C++03 code would bind <code>this-&gt;f</code> to <code>A::f</code> at instantiation time and
everything is fine. C++11 however immediately binds it to <code>B::f</code> and requires
a double-check when instantiating, checking whether the lookup still matches.
However when instantiating <code>C&lt;A&gt;::g</code>, the Dominance Rule applies and lookup
will find <code>A::f</code> instead.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-297.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-295.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
