<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 296) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-296.html">
<link rel="prev" href="index-297.html" type="text/html">
<link rel="next" href="index-295.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-do-a-line-break-line-continuation-in-python/" class="u-url">How can I do a line break (line continuation) in Python?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-do-a-line-break-line-continuation-in-python/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:31+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Given:</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' + 'c' + 'd'
</pre></div>

<p>How do I write the above in two lines?</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' +
    'c' + 'd'
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>What is the line? You can just have arguments on the next line without any
problems:</p>
<div class="code"><pre class="code literal-block">a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, 
            blahblah6, blahblah7)
</pre></div>

<p>Otherwise you can do something like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span>
<span class="w">    </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span><span class="ss">)</span>:
</pre></div>

<p>or with explicit line break:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span>\
<span class="w">   </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span>:
</pre></div>

<p>Check the style guide for more information.</p>
<p>Using parentheses, your example can be written over multiple lines:</p>
<div class="code"><pre class="code literal-block">a = ('1' + '2' + '3' +
    '4' + '5')
</pre></div>

<p>The same effect can be obtained using explicit line break:</p>
<div class="code"><pre class="code literal-block">a = '1' + '2' + '3' + \
    '4' + '5'
</pre></div>

<p>Note that the style guide says that using the implicit continuation with
parentheses is preferred, but in this particular case just adding parentheses
around your expression is probably the wrong way to go.</p>
<p><br></p>
<h3>Suggest</h3>
<p>From <em>PEP 8 -- Style Guide for Python Code</em> :</p>
<blockquote>
<p><strong>The preferred way of wrapping long lines is by using Python's implied line
continuation inside parentheses, brackets and braces.</strong> Long lines can be
broken over multiple lines by wrapping expressions in parentheses. These
should be used in preference to using a backslash for line continuation.</p>
<p>Backslashes may still be appropriate at times. For example, long, multiple
with-statements cannot use implicit continuation, so backslashes are
acceptable:</p>
<div class="code"><pre class="code literal-block">with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
     file_2.write(file_1.read())
</pre></div>

<p>Another such case is with assert statements.</p>
<p>Make sure to indent the continued line appropriately. The preferred place to
break around a binary operator is <strong>after</strong> the operator, not before it.
Some examples:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Rectangle</span>(<span class="nb">Blob</span>):

  <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                <span class="n">color</span>=<span class="s">'black'</span>, <span class="n">emphasis</span>=<span class="n">None</span>, <span class="n">highlight</span>=<span class="mi">0</span>):
       <span class="k">if</span> (<span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span>
          <span class="n">color</span> == <span class="s">'red'</span> <span class="o">and</span> <span class="n">emphasis</span> == <span class="s">'strong'</span> <span class="o">or</span>
           <span class="n">highlight</span> &gt; <span class="mi">100</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"sorry, you lose"</span>)
       <span class="k">if</span> <span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span> (<span class="n">color</span> == <span class="s">'red'</span> <span class="o">or</span>
                                          <span class="n">emphasis</span> <span class="k">is</span> <span class="n">None</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"I don't think so -- values are %s, %s"</span> %
                            (<span class="n">width</span>, <span class="n">height</span>))
       <span class="nb">Blob</span>.<span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                     <span class="n">color</span>, <span class="n">emphasis</span>,
</pre></div>

<p>highlight)file_2.write(file_1.read())
</p>
</blockquote>
<p>PEP8 now recommends the <em>opposite convention</em> (for breaking at binary
operations) used by mathematicians and their publishers to improve
readability.</p>
<p>Donald Knuth's style of breaking <strong>before</strong> a binary operator aligns operators
vertically, thus reducing the eye's workload when determining which items are
added and subtracted.</p>
<p>From PEP8: <em>Should a line break before or after a binary operator?</em> :</p>
<blockquote>
<p>Donald Knuth explains the traditional rule in his Computers and Typesetting
series: "Although formulas within a paragraph always break after binary
operations and relations, displayed formulas always break before binary
operations"[3].</p>
<p>Following the tradition from mathematics usually results in more readable
code:</p>
<div class="code"><pre class="code literal-block"># Yes: easy to match operators with operands
</pre></div>

</blockquote>
<div class="code"><pre class="code literal-block">income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</pre></div>

<blockquote>
<p>In Python code, it is permissible to break before or after a binary
operator, as long as the convention is consistent locally. For new code
Knuth's style is suggested.</p>
</blockquote>
<p>[3]: Donald Knuth's The TeXBook, pages 195 and 196</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/" class="u-url">Where and why do I have to put the "template" and "typename" keywords?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:05+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In templates, where and why do I have to put <code>typename</code> and <code>template</code> on
dependent names?<br>
What exactly are dependent names anyway?</p>
<p>I have the following code:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="nt">will</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="nt">too</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="n">Q</span><span class="p">:</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="kc">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">typename</span><span class="o">/</span><span class="n">template</span><span class="w"> </span><span class="n">here</span><span class="o">?</span>
<span class="w">        </span><span class="n">typedef</span><span class="w"> </span><span class="n">Tail</span><span class="o">::</span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
<span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">For</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">last</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="nt">Tn</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">char</span><span class="w"> </span><span class="err">fail</span><span class="cp">[</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">sizeof</span><span class="p">(</span><span class="nx">U</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Cannot</span><span class="w"> </span><span class="err">be</span><span class="w"> </span><span class="err">instantiated</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">any</span><span class="w"> </span><span class="err">U</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>The problem I have is in the <code>typedef Tail::inUnion&lt;U&gt; dummy</code> line. I'm fairly
certain that <code>inUnion</code> is a dependent name, and VC++ is quite right in choking
on it.<br>
I also know that I should be able to add <code>template</code> somewhere to tell the
compiler that inUnion is a template-id. But where exactly? And should it then
assume that inUnion is a class template, i.e. <code>inUnion&lt;U&gt;</code> names a type and
not a function?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>(See here also for my C++11 answer)</p>
<p>In order to parse a C++ program, the compiler needs to know whether certain
names are types or not. The following example demonstrates that:</p>
<div class="code"><pre class="code literal-block">t * f;
</pre></div>

<p>How should this be parsed? For many languages a compiler doesn't need to know
the meaning of a name in order to parse and basically know what action a line
of code does. In C++, the above however can yield vastly different
interpretations depending on what <code>t</code> means. If it's a type, then it will be a
declaration of a pointer <code>f</code>. However if it's not a type, it will be a
multiplication. So the C++ Standard says at paragraph (3/7):</p>
<blockquote>
<p>Some names denote types or templates. In general, whenever a name is
encountered it is necessary to determine whether that name denotes one of
these entities before continuing to parse the program that contains it. The
process that determines this is called name lookup.</p>
</blockquote>
<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to
a template type parameter? <code>x</code> could be a static int data member that could be
multiplied or could equally well be a nested class or typedef that could yield
to a declaration. <strong>If a name has this property - that it can't be looked up
until the actual template arguments are known - then it's called a <em>dependent
name</em> (it "depends" on the template parameters).</strong></p>
<p>You might recommend to just wait till the user instantiates the template:</p>
<blockquote>
<p><em>Let's wait until the user instantiates the template, and then later find
out the real meaning of<code>t::x * f;</code>.</em></p>
</blockquote>
<p>This will work and actually is allowed by the Standard as a possible
implementation approach. These compilers basically copy the template's text
into an internal buffer, and only when an instantiation is needed, they parse
the template and possibly detect errors in the definition. But instead of
bothering the template's users (poor colleagues!) with errors made by a
template's author, other implementations choose to check templates early on
and give errors in the definition as soon as possible, before an instantiation
even takes place.</p>
<p>So there has to be a way to tell the compiler that certain names are types and
that certain names aren't.</p>
<h3>The "typename" keyword</h3>
<p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a
dependent name, then we need to prefix it by <code>typename</code> to tell the compiler
to parse it in a certain way. The Standard says at (14.6/2):</p>
<blockquote>
<p>A name used in a template declaration or definition and that is dependent on
a template-parameter is assumed not to name a type unless the applicable
name lookup finds a type name or the name is qualified by the keyword
typename.</p>
</blockquote>
<p>There are many names for which <code>typename</code> is not necessary, because the
compiler can, with the applicable name lookup in the template definition,
figure out how to parse a construct itself - for example with <code>T *f;</code>, when
<code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it
must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name
is taken to be a non-type, but when instantiation finds it denotes a type, the
usual error messages are emitted by the compiler. Sometimes, the error
consequently is given at definition time:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// t::x is taken as non-type, but as an expression the following misses an</span>
<span class="c1">// operator between the two names or a semicolon separating them.</span>
<span class="n">t</span><span class="p">::</span><span class="n">x</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
</pre></div>

<p><em>The syntax allows<code>typename</code> only before qualified names</em> - it is therefor
taken as granted that unqualified names are always known to refer to types if
they do so.</p>
<p>A similar gotcha exists for names that denote templates, as hinted at by the
introductory text.</p>
<h3>The "template" keyword</h3>
<p>Remember the initial quote above and how the Standard requires special
handling for templates as well? Let's take the following innocent-looking
example:</p>
<div class="code"><pre class="code literal-block"><span class="nt">boost</span><span class="p">::</span><span class="nd">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nt">int</span><span class="o">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">f</span><span class="o">;</span>
</pre></div>

<p>It might look obvious to a human reader. Not so for the compiler. Imagine the
following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nt">namespace</span><span class="w"> </span><span class="nt">boost</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">function</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">main</span><span class="o">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="err">int</span><span class="w"> </span><span class="err">f</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">boost</span><span class="p">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nf">int</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>That's actually a valid <em>expression</em>! It uses the less-than operator to
compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-
than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you
might well know, <code>boost::function</code> in real life is a template, so the compiler
knows (14.2/3):</p>
<blockquote>
<p>After name lookup (3.4) finds that a name is a template-name, if this name
is followed by a &lt;, the &lt; is always taken as the beginning of a template-
argument-list and never as a name followed by the less-than operator.</p>
</blockquote>
<p>Now we are back to the same problem as with <code>typename</code>. What if we can't know
yet whether the name is a template when parsing the code? We will need to
insert <code>template</code> immediately before the template name, as specified by
<code>14.2/4</code>. This looks like:</p>
<div class="code"><pre class="code literal-block"><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">f</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">call</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">template</span>
</pre></div>

<p>Template names can not only occur after a <code>::</code> but also after a <code>-&gt;</code> or <code>.</code> in
a class member access. You need to insert the keyword there too:</p>
<div class="code"><pre class="code literal-block"><span class="n">this</span><span class="o">-&gt;</span><span class="n">template</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// call a function template</span>
</pre></div>

<hr>
<h3>Dependencies</h3>
<p>For the people that have thick Standardese books on their shelf and that want
to know what exactly I was talking about, I'll talk a bit about how this is
specified in the Standard.</p>
<p>In template declarations some constructs have different meanings depending on
what template arguments you use to instantiate the template: Expressions may
have different types or values, variables may have different types or function
calls might end up calling different functions. Such constructs are generally
said to <em>depend</em> on template parameters.</p>
<p>The Standard defines precisely the rules by whether a construct is dependent
or not. It separates them into logically different groups: One catches types,
another catches expressions. Expressions may depend by their value and/or
their type. So we have, with typical examples appended:</p>
<ul>
<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>
<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>
<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>
</ul>
<p>Most of the rules are intuitive and are built up recursively: For example, a
type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent
expression or <code>T</code> is a dependent type. The details of this can be read in
section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent
expressions and <code>(14.6.2.3)</code> for value-dependent expressions.</p>
<h4>Dependent names</h4>
<p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a
simple read (you know, the principle of least surprise), all it defines as a
<em>dependent name</em> is the special case for function names below. But since
clearly <code>T::x</code> also needs to be looked up in the instantiation context, it
also needs to be a dependent name (fortunately, as of mid C++14 the committee
has started to look into how to fix this confusing definition).</p>
<p>To avoid this problem, I have resorted to a simple interpretation of the
Standard text. Of all the constructs that denote dependent types or
expressions, a subset of them represent names. Those names are therefore
"dependent names". A name can take different forms - the Standard says:</p>
<blockquote>
<p>A name is a use of an identifier (2.11), operator-function-id (13.5),
conversion-function-id (12.3.2), or template-id (14.2) that denotes an
entity or label (6.6.4, 6.1)</p>
</blockquote>
<p>An identifier is just a plain sequence of characters / digits, while the next
two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-
name &lt;argument list&gt;</code>. All these are names, and by conventional use in the
Standard, a name can also include qualifiers that say what namespace or class
a name should be looked up in.</p>
<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of
all dependent constructs that are names is called <em>dependent name</em>. Function
names, however, may have different meaning in different instantiations of a
template, but unfortunately are not caught by this general rule.</p>
<h4>Dependent function names</h4>
<p>Not primarily a concern of this article, but still worth mentioning: Function
names are an exception that are handled separately. An identifier function
name is dependent not by itself, but by the type dependent argument
expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name.
In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>
<h3>Additional notes and examples</h3>
<p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should
look like the following</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">typedef</span><span class="w"> </span><span class="err">typename</span><span class="w"> </span><span class="n">Tail</span><span class="p">:</span><span class="o">:</span><span class="n">template</span><span class="w"> </span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>The keyword <code>template</code> doesn't always have to appear in the last part of a
name. It can appear in the middle before a class name that's used as a scope,
like in the following example</p>
<div class="code"><pre class="code literal-block"><span class="nt">typename</span><span class="w"> </span><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">iterator</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">value_type</span><span class="w"> </span><span class="nt">v</span><span class="o">;</span>
</pre></div>

<p>In some cases, the keywords are forbidden, as detailed below</p>
<ul>
<li>
<p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : /<em> typename </em>/ SomeBase<t>::type 
 { };</t></p>
</li>
<li>
<p>In using-declarations it's not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee said not to work on a solution. </p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : SomeBase<t> {
    using SomeBase<t>::template type; // error
    using typename SomeBase<t>::type; // typename <em>is</em> allowed
 };</t></t></t></p>
</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<h3>C++11</h3>
<h4>Problem</h4>
<p>While the rules in C++03 about when you need <code>typename</code> and <code>template</code> are
largely reasonable, there is one annoying disadvantage of its formulation</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typedef</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">result_type</span><span class="p">;</span>

<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// error, "this" is dependent, "template" keyword needed</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// error, "A&lt;T&gt;" is dependent, "typename" keyword needed</span>
<span class="w">    </span><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">result_type</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>

<p>As can be seen, we need the disambiguation keyword even if the compiler could
perfectly figure out itself that <code>A::result_type</code> can only be <code>int</code> (and is
hence a type), and <code>this-&gt;g</code> can only be the member template <code>g</code> declared
later (even if <code>A</code> is explicitly specialized somewhere, that would not affect
the code within that template, so its meaning cannot be affected by a later
specialization of <code>A</code>!).</p>
<h4>Current instantiation</h4>
<p>To improve the situation, in C++11 the language tracks when a type refers to
the enclosing template. To know that, the type must have been formed by using
a certain form of name, which is its own name (in the above, <code>A</code>, <code>A&lt;T&gt;</code>,
<code>::A&lt;T&gt;</code>). A type referenced by such a name is known to be the <em>current
instantiation</em>. There may be multiple types that are all the current
instantiation if the type from which the name is formed is a member/nested
class (then, <code>A::NestedClass</code> and <code>A</code> are both current instantiations).</p>
<p>Based on this notion, the language says that <code>CurrentInstantiation::Foo</code>,
<code>Foo</code> and <code>CurrentInstantiationTyped-&gt;Foo</code> (such as <code>A *a = this; a-&gt;Foo</code>) are
all <em>member of the current instantiation</em> <strong>if</strong> they are found to be members
of a class that is the current instantiation or one of its non-dependent base
classes (by just doing the name lookup immediately).</p>
<p>The keywords <code>typename</code> and <code>template</code> are now not required anymore if the
qualifier is a member of the current instantiation. A keypoint here to
remember is that <code>A&lt;T&gt;</code> is <em>still</em> a type-dependent name (after all <code>T</code> is
also type dependent). But <code>A&lt;T&gt;::result_type</code> is known to be a type - the
compiler will "magically" look into this kind of dependent types to figure
this out.</p>
<div class="code"><pre class="code literal-block"><span class="nt">struct</span><span class="w"> </span><span class="nt">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">typedef</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">result_type</span><span class="p">;</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">could</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">specialized</span><span class="o">!</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="nt">C</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">void</span><span class="w"> </span><span class="err">f()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK,</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation!</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="n">A</span><span class="p">:</span><span class="o">:</span><span class="n">result_type</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">dependent</span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="n">D</span><span class="o">::</span><span class="n">result_type</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">error,</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r2</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">relying</span><span class="w"> </span><span class="err">on</span><span class="w"> </span><span class="err">C&lt;T&gt;</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">provide</span><span class="w"> </span><span class="err">it</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">But</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="err">typename</span><span class="w"> </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r3</span><span class="p">;</span><span class="w">        </span>
<span class="w">  </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>That's impressive, but can we do better? The language even goes further and
<em>requires</em> that an implementation again looks up <code>D::result_type</code> when
instantiating <code>D::f</code> (even if it found its meaning already at definition
time). When now the lookup result differs or results in ambiguity, the program
is ill-formed and a diagnostic must be given. Imagine what happens if we
defined <code>C</code> like this</p>
<div class="code"><pre class="code literal-block">template&lt;&gt;
struct C&lt;int&gt; {
  typedef bool result_type;
  typedef int questionable_type;
};
</pre></div>

<p>A compiler is required to catch the error when instantiating <code>D&lt;int&gt;::f</code>. So
you get the best of the two worlds: "Delayed" lookup protecting you if you
could get in trouble with dependent base classes, and also "Immediate" lookup
that frees you from <code>typename</code> and <code>template</code>.</p>
<h4>Unknown specializations</h4>
<p>In the code of <code>D</code>, the name <code>typename D::questionable_type</code> is not a member
of the current instantiation. Instead the language marks it as a <em>member of an
unknown specialization</em>. In particular, this is always the case when you are
doing <code>DependentTypeName::Foo</code> or <code>DependentTypedName-&gt;Foo</code> and either the
dependent type is <em>not</em> the current instantiation (in which case the compiler
can give up and say "we will look later what <code>Foo</code> is) or it <em>is</em> the current
instantiation and the name was not found in it or its non-dependent base
classes and there are also dependent base classes.</p>
<p>Imagine what happens if we had a member function <code>h</code> within the above defined
<code>A</code> class template</p>
<div class="code"><pre class="code literal-block">void h() {
  typename A&lt;T&gt;::questionable_type x;
}
</pre></div>

<p>In C++03, the language allowed to catch this error because there could never
be a valid way to instantiate <code>A&lt;T&gt;::h</code> (whatever argument you give to <code>T</code>).
In C++11, the language now has a further check to give more reason for
compilers to implement this rule. Since <code>A</code> has no dependent base classes, and
<code>A</code> declares no member <code>questionable_type</code>, the name <code>A&lt;T&gt;::questionable_type</code>
is <em>neither</em> a member of the current instantiation <em>nor</em> a member of an
unknown specialization. In that case, there should be no way that that code
could validly compile at instantiation time, so the language forbids a name
where the qualifier is the current instantiation to be neither a member of an
unknown specialization nor a member of the current instantiation (however,
this violation is still not required to be diagnosed).</p>
<h4>Examples and trivia</h4>
<p>You can try this knowledge on this answer and see whether the above
definitions make sense for you on a real-world example (they are repeated
slightly less detailed in that answer).</p>
<p>The C++11 rules make the following valid C++03 code ill-formed (which was not
intended by the C++ committee, but will probably not be fixed)</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="n">C</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">g</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>This valid C++03 code would bind <code>this-&gt;f</code> to <code>A::f</code> at instantiation time and
everything is fine. C++11 however immediately binds it to <code>B::f</code> and requires
a double-check when instantiating, checking whether the lookup still matches.
However when instantiating <code>C&lt;A&gt;::g</code>, the Dominance Rule applies and lookup
will find <code>A::f</code> instead.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/d-less-efficient-than-0-9/" class="u-url">\d less efficient than [0-9]</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/d-less-efficient-than-0-9/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:15:40+08:00" itemprop="datePublished" title="2023-02-17 03:15">2023-02-17 03:15</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I made a comment yesterday on an answer where someone had used <code>[0123456789]</code>
in a regex rather than <code>[0-9]</code> or <code>\d</code>. I said it was probably more efficient
to use a range or digit specifier than a character set.</p>
<p>I decided to test that out today and found out to my surprise that (in the .net-c#
regex engine at least) <code>\d</code> appears to be less efficient than either of the
other two which don't seem to differ much. Here is my test output over 10000
random strings of 1000 random characters with 5077 actually containing a
digit:</p>
<div class="code"><pre class="code literal-block">Regex \d           took 00:00:00.2141226 result: 5077/10000
Regex [0-9]        took 00:00:00.1357972 result: 5077/10000  63.42 % of first
Regex [0123456789] took 00:00:00.1388997 result: 5077/10000  64.87 % of first
</pre></div>

<p>It's a surprise to me for two reasons, that I would be interested if anyone
can shed some light on:</p>
<ol>
<li>I would have thought the range would be implemented much more efficiently than the set.</li>
<li>I can't understand why <code>\d</code> is worse than <code>[0-9]</code>. Is there more to <code>\d</code> than simply shorthand for <code>[0-9]</code>?</li>
</ol>
<p>Here is the test code:</p>
<div class="code"><pre class="code literal-block"><span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Linq</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">RegularExpressions</span><span class="p">;</span>

<span class="n">namespace</span><span class="w"> </span><span class="n">SO_RegexPerformance</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="n">Program</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Random</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">            </span><span class="c1">//10K random strings</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//generate random string</span>
<span class="w">                </span><span class="n">var</span><span class="w"> </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">();</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//add a-z randomly</span>
<span class="w">                    </span><span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">((</span><span class="kt">char</span><span class="p">)(</span><span class="sc">'a'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">26</span><span class="p">)));</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="c1">//in roughly 50% of them, put a digit</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//replace 1 char with a digit 0-9</span>
<span class="w">                    </span><span class="n">sb</span><span class="p">[</span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">Length</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="sc">'0'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">strings</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">baseTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">@"\d"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">();</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">testTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">"[0-9]"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"  {0:P2} of first"</span><span class="p">,</span><span class="w"> </span><span class="n">testTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">baseTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="p">);</span>
<span class="w">            </span><span class="n">testTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">"[0123456789]"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"  {0:P2} of first"</span><span class="p">,</span><span class="w"> </span><span class="n">testTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">baseTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">TimeSpan</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">regex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">sw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Stopwatch</span><span class="p">();</span>

<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">successes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">rex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Regex</span><span class="p">(</span><span class="n">regex</span><span class="p">);</span>

<span class="w">            </span><span class="n">sw</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">            </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rex</span><span class="p">.</span><span class="n">Match</span><span class="p">(</span><span class="n">str</span><span class="p">).</span><span class="n">Success</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">successes</span><span class="o">++</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">sw</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>

<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">"Regex {0,-12} took {1} result: {2}/{3}"</span><span class="p">,</span><span class="w"> </span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">,</span><span class="w"> </span><span class="n">successes</span><span class="p">,</span><span class="w"> </span><span class="n">strings</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p><code>\d</code> checks all Unicode digits, while <code>[0-9]</code> is limited to these 10
characters. For example, Persian digits, <code>۱۲۳۴۵۶۷۸۹</code>, are an example of
Unicode digits which are matched with <code>\d</code>, but not <code>[0-9]</code>.</p>
<p>You can generate a list of all such characters using the following code:</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">UInt16</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="kt">UInt16</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Convert</span><span class="p">.</span><span class="n">ToChar</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Regex</span><span class="p">.</span><span class="n">IsMatch</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="s">@"\d"</span><span class="p">))</span>
<span class="w">        </span><span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</pre></div>

<p>Which generates:</p>
<blockquote>
<p>0123456789٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹߀߁߂߃߄߅߆߇߈߉०१२३४५६७८९০১২৩৪৫৬৭৮৯੦੧੨੩੪੫੬੭੮੯૦૧૨૩૪૫૬૭૮૯୦୧୨୩୪୫୬୭୮୯௦௧௨௩௪௫௬௭௮௯౦౧౨౩౪౫౬౭౮౯೦೧೨೩೪೫೬೭೮೯൦൧൨൩൪൫൬൭൮൯๐๑๒๓๔๕๖๗๘๙໐໑໒໓໔໕໖໗໘໙༠༡༢༣༤༥༦༧༨༩၀၁၂၃၄၅၆၇၈၉႐႑႒႓႔႕႖႗႘႙០១២៣៤៥៦៧៨៩᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙᥆᥇᥈᥉᥊᥋᥌᥍᥎᥏᧐᧑᧒᧓᧔᧕᧖᧗᧘᧙᭐᭑᭒᭓᭔᭕᭖᭗᭘᭙᮰᮱᮲᮳᮴᮵᮶᮷᮸᮹᱀᱁᱂᱃᱄᱅᱆᱇᱈᱉᱐᱑᱒᱓᱔᱕᱖᱗᱘᱙꘠꘡꘢꘣꘤꘥꘦꘧꘨꘩꣐꣑꣒꣓꣔꣕꣖꣗꣘꣙꤀꤁꤂꤃꤄꤅꤆꤇꤈꤉꩐꩑꩒꩓꩔꩕꩖꩗꩘꩙０１２３４５６７８９</p>
</blockquote>
<p><br></p>
<h3>Suggest</h3>
<p>Credit to ByteBlast for noticing this in the docs. Just changing the regex
constructor:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">rex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Regex</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">RegexOptions</span><span class="o">.</span><span class="n">ECMAScript</span><span class="p">);</span>
</pre></div>

<p>Gives new timings:</p>
<div class="code"><pre class="code literal-block">Regex \d           took 00:00:00.1355787 result: 5077/10000
Regex [0-9]        took 00:00:00.1360403 result: 5077/10000  100.34 % of first
Regex [0123456789] took 00:00:00.1362112 result: 5077/10000  100.47 % of first
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-297.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-295.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
