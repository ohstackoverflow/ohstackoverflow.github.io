<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 20) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-20.html">
<link rel="prev" href="index-21.html" type="text/html">
<link rel="next" href="index-19.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-i-create-a-guid-uuid/" class="u-url">How do I create a GUID / UUID?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-i-create-a-guid-uuid/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:46:48+08:00" itemprop="datePublished" title="2023-02-16 18:46">2023-02-16 18:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How do I create GUIDs (globally-unique identifiers) in JavaScript? The GUID /
UUID should be at least 32 characters and should stay in the ASCII range to
avoid trouble when passing them around.</p>
<p>I'm not sure what routines are available on all browsers, how "random" and
seeded the built-in random number generator is, etc.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique
IDentifier), according to RFC 4122, are identifiers designed to provide
certain uniqueness guarantees.</p>
<p>While it is possible to implement RFC-compliant UUIDs in a few lines of
JavaScript code (e.g., see @broofa's answer, below) there are several common
pitfalls:</p>
<ul>
<li>Invalid id format (UUIDs must be of the form "<code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</code>", where x is one of [0-9, a-f] <em>M</em> is one of [1-5], and <em>N</em> is [8, 9, a, or b]</li>
<li>Use of a low-quality source of randomness (such as <code>Math.random</code>)</li>
</ul>
<p>Thus, developers writing code for production environments are encouraged to
use a rigorous, well-maintained implementation such as the uuid module.</p>
<p><br></p>
<h3>Suggest</h3>
<p>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique
IDentifier), according to RFC 4122, are identifiers designed to provide
certain uniqueness guarantees.</p>
<p>While it is possible to implement RFC-compliant UUIDs in a few lines of
JavaScript code (e.g., see @broofa's answer, below) there are several common
pitfalls:</p>
<ul>
<li>Invalid id format (UUIDs must be of the form "<code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</code>", where x is one of [0-9, a-f] <em>M</em> is one of [1-5], and <em>N</em> is [8, 9, a, or b]</li>
<li>Use of a low-quality source of randomness (such as <code>Math.random</code>)</li>
</ul>
<p>Thus, developers writing code for production environments are encouraged to
use a rigorous, well-maintained implementation such as the uuid module.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-inner-join-and-outer-join/" class="u-url">What is the difference between "INNER JOIN" and "OUTER JOIN"?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-inner-join-and-outer-join/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:46:03+08:00" itemprop="datePublished" title="2023-02-16 18:46">2023-02-16 18:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Also, how do <code>LEFT OUTER JOIN</code>, <code>RIGHT OUTER JOIN</code>, and <code>FULL OUTER JOIN</code> fit
in?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Assuming you're joining on columns with no duplicates, which is a very common
case:</p>
<ul>
<li>
<p>An inner join of A and B gives the result of A intersect B, i.e. the inner part of a Venn diagram intersection.</p>
</li>
<li>
<p>An outer join of A and B gives the results of A union B, i.e. the outer parts of a Venn diagram union.</p>
</li>
</ul>
<p><strong>Examples</strong></p>
<p>Suppose you have two tables, with a single column each, and data as follows:</p>
<div class="code"><pre class="code literal-block">A    B
<span class="m">-</span>    -
1    3
2    4
3    5
4    6
</pre></div>

<p>Note that (1,2) are unique to A, (3,4) are common, and (5,6) are unique to B.</p>
<p><strong>Inner join</strong></p>
<p>An inner join using either of the equivalent queries gives the intersection of
the two tables, i.e. the two rows they have in common.</p>
<div class="code"><pre class="code literal-block">select * from a INNER JOIN b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b;

a | b
--+--
3 | 3
4 | 4
</pre></div>

<p><strong>Left outer join</strong></p>
<p>A left outer join will give all rows in A, plus any common rows in B.</p>
<div class="code"><pre class="code literal-block">select * from a LEFT OUTER JOIN b on a.a = b.b;
select a.*, b.*  from a,b where a.a = b.b(+);

a |  b
--+-----
1 | null
2 | null
3 |    3
4 |    4
</pre></div>

<p><strong>Right outer join</strong></p>
<p>A right outer join will give all rows in B, plus any common rows in A.</p>
<div class="code"><pre class="code literal-block">select * from a RIGHT OUTER JOIN b on a.a = b.b;
select a.*, b.*  from a,b where a.a(+) = b.b;

a    |  b
-----+----
3    |  3
4    |  4
null |  5
null |  6
</pre></div>

<p><strong>Full outer join</strong></p>
<p>A full outer join will give you the union of A and B, i.e. all the rows in A
and all the rows in B. If something in A doesn't have a corresponding datum in
B, then the B portion is null, and vice versa.</p>
<div class="code"><pre class="code literal-block">select * from a FULL OUTER JOIN b on a.a = b.b;

 a   |  b
-----+-----
   1 | null
   2 | null
   3 |    3
   4 |    4
null |    6
null |    5
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>The Venn diagrams don't really do it for me.</p>
<p>They don't show any distinction between a cross join and an inner join, for
example, or more generally show any distinction between different types of
join predicate or provide a framework for reasoning about how they will
operate.</p>
<p>There is no substitute for understanding the logical processing and it is
relatively straightforward to grasp anyway.</p>
<ol>
<li>Imagine a cross join.</li>
<li>Evaluate the <code>on</code> clause against all rows from step 1 keeping those where the predicate evaluates to <code>true</code>
</li>
<li>(For outer joins only) add back in any outer rows that were lost in step 2.</li>
</ol>
<p>(NB: In practice the query optimiser may find more efficient ways of executing
the query than the purely logical description above but the final result must
be the same)</p>
<p>I'll start off with an animated version of a <strong>full outer join</strong>. Further
explanation follows.</p>
<p><img alt="enter image description here" src="images/VUkfU.gif"></p>
<hr>
<h2>Explanation</h2>
<p><strong>Source Tables</strong></p>
<p><img alt="enter link description here" src="images/LVYKx.png"></p>
<p>First start with a <code>CROSS JOIN</code> (AKA Cartesian Product). This does not have an
<code>ON</code> clause and simply returns every combination of rows from the two tables.</p>
<p><strong>SELECT A.Colour, B.Colour FROM A CROSS JOIN B</strong></p>
<p><img alt="enter link description here" src="images/cv3t6.png"></p>
<p>Inner and Outer joins have an "ON" clause predicate.</p>
<ul>
<li>
<strong>Inner Join.</strong> Evaluate the condition in the "ON" clause for all rows in the cross join result. If true return the joined row. Otherwise discard it.</li>
<li>
<strong>Left Outer Join.</strong> Same as inner join then for any rows in the left table that did not match anything output these with NULL values for the right table columns.</li>
<li>
<strong>Right Outer Join.</strong> Same as inner join then for any rows in the right table that did not match anything output these with NULL values for the left table columns.</li>
<li>
<strong>Full Outer Join.</strong> Same as inner join then preserve left non matched rows as in left outer join and right non matching rows as per right outer join.</li>
</ul>
<h2>Some examples</h2>
<p><strong>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour = B.Colour</strong></p>
<p>The above is the classic equi join.</p>
<p><img alt="Inner Join" src="images/a8IHd.png"></p>
<h3>Animated Version</h3>
<p><img alt="enter image description here" src="images/kZcvR.gif"></p>
<h4>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON A.Colour NOT IN</h4>
<p>('Green','Blue')</p>
<p>The inner join condition need not necessarily be an equality condition and it
need not reference columns from both (or even either) of the tables.
Evaluating <code>A.Colour NOT IN ('Green','Blue')</code> on each row of the cross join
returns.</p>
<p><img alt="inner 2" src="images/ZwoCi.png"></p>
<p><strong>SELECT A.Colour, B.Colour FROM A INNER JOIN B ON 1 =1</strong></p>
<p>The join condition evaluates to true for all rows in the cross join result so
this is just the same as a cross join. I won't repeat the picture of the 16
rows again.</p>
<h4>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>Outer Joins are logically evaluated in the same way as inner joins except that
if a row from the left table (for a left join) does not join with any rows
from the right hand table at all it is preserved in the result with <code>NULL</code>
values for the right hand columns.</p>
<p><img alt="LOJ" src="images/4bzv2.png"></p>
<h4>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>WHERE B.Colour IS NULL</p>
<p>This simply restricts the previous result to only return the rows where
<code>B.Colour IS NULL</code>. In this particular case these will be the rows that were
preserved as they had no match in the right hand table and the query returns
the single red row not matched in table <code>B</code>. This is known as an anti semi
join.</p>
<p>It is important to select a column for the <code>IS NULL</code> test that is either not
nullable or for which the join condition ensures that any <code>NULL</code> values will
be excluded in order for this pattern to work correctly and avoid just
bringing back rows which happen to have a <code>NULL</code> value for that column in
addition to the un matched rows.</p>
<p><img alt="loj is null" src="images/d6CVF.png"></p>
<h4>SELECT A.Colour, B.Colour FROM A RIGHT OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>Right outer joins act similarly to left outer joins except they preserve non
matching rows from the right table and null extend the left hand columns.</p>
<p><img alt="ROJ" src="images/LIOW4.png"></p>
<h4>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>Full outer joins combine the behaviour of left and right joins and preserve
the non matching rows from both the left and the right tables.</p>
<p><img alt="FOJ" src="images/iVoqu.png"></p>
<h4>SELECT A.Colour, B.Colour FROM A FULL OUTER JOIN B ON 1 = 0</h4>
<p>No rows in the cross join match the <code>1=0</code> predicate. All rows from both sides
are preserved using normal outer join rules with NULL in the columns from the
table on the other side.</p>
<p><img alt="FOJ 2" src="images/gtIhf.png"></p>
<h4>SELECT COALESCE(A.Colour, B.Colour) AS Colour FROM A FULL OUTER JOIN B ON</h4>
<p>1 = 0</p>
<p>With a minor amend to the preceding query one could simulate a <code>UNION ALL</code> of
the two tables.</p>
<p><img alt="UNION ALL" src="images/WPu9W.png"></p>
<h4>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>WHERE B.Colour = 'Green'</p>
<p>Note that the <code>WHERE</code> clause (if present) logically runs after the join. One
common error is to perform a left outer join and then include a WHERE clause
with a condition on the right table that ends up excluding the non matching
rows. The above ends up performing the outer join...</p>
<p><img alt="LOJ" src="images/4bzv2.png"></p>
<p>... And then the "Where" clause runs. <code>NULL= 'Green'</code> does not evaluate to
true so the row preserved by the outer join ends up discarded (along with the
blue one) effectively converting the join back to an inner one.</p>
<p><img alt="LOJtoInner" src="images/tRHdf.png"></p>
<p>If the intention was to include only rows from B where Colour is Green and all
rows from A regardless the correct syntax would be</p>
<h4>SELECT A.Colour, B.Colour FROM A LEFT OUTER JOIN B ON A.Colour = B.Colour</h4>
<p>AND B.Colour = 'Green'</p>
<p><img alt="enter image description here" src="images/cvJ1s.png"></p>
<h3>SQL Fiddle</h3>
<p>See these examples run live at SQLFiddle.com.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/regular-expression-to-match-a-line-that-doesn-t-contain-a-word/" class="u-url">Regular expression to match a line that doesn't contain a word</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/regular-expression-to-match-a-line-that-doesn-t-contain-a-word/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:44:36+08:00" itemprop="datePublished" title="2023-02-16 18:44">2023-02-16 18:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I know it's possible to match a word and then reverse the matches using other
tools (e.g. <code>grep -v</code>). However, is it possible to match lines that do not
contain a specific word, e.g. <code>hede</code>, using a regular expression?</p>
<h6>Input:</h6>
<div class="code"><pre class="code literal-block">hoho
hihi
haha
hede
</pre></div>

<h6>Code:</h6>
<div class="code"><pre class="code literal-block"><span class="nv">grep</span><span class="w"> </span><span class="s2">"&lt;Regex for 'doesn't contain hede'&gt;"</span><span class="w"> </span><span class="nv">input</span>
</pre></div>

<h6>Desired output:</h6>
<div class="code"><pre class="code literal-block">hoho
hihi
haha
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>The notion that regex doesn't support inverse matching is not entirely true.
You can mimic this behavior by using negative look-arounds:</p>
<div class="code"><pre class="code literal-block"><span class="o">^</span><span class="p">((</span>?<span class="o">!</span><span class="nv">hede</span><span class="p">)</span><span class="o">.</span><span class="p">)</span><span class="o">*</span><span class="p">$</span>
</pre></div>

<p>The regex above will match any string, or line without a line break, <strong>not</strong>
containing the (sub)string 'hede'. As mentioned, this is not something regex
is "good" at (or should do), but still, it <em>is</em> possible.</p>
<p>And if you need to match line break chars as well, use the DOT-ALL modifier
(the trailing <code>s</code> in the following pattern):</p>
<div class="code"><pre class="code literal-block">/^((?!hede).)*$/s
</pre></div>

<p>or use it inline:</p>
<div class="code"><pre class="code literal-block">/(?s)^((?!hede).)*$/
</pre></div>

<p><em>(where the<code>/.../</code> are the regex delimiters, i.e., not part of the pattern)</em></p>
<p>If the DOT-ALL modifier is not available, you can mimic the same behavior with
the character class <code>[\s\S]</code>:</p>
<div class="code"><pre class="code literal-block">/^((?!hede)[\s\S])*$/
</pre></div>

<h3>Explanation</h3>
<p>A string is just a list of <code>n</code> characters. Before, and after each character,
there's an empty string. So a list of <code>n</code> characters will have <code>n+1</code> empty
strings. Consider the string <code>"ABhedeCD"</code>:</p>
<div class="code"><pre class="code literal-block">    ┌──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┐
S = │e1│ A │e2│ B │e3│ h │e4│ e │e5│ d │e6│ e │e7│ C │e8│ D │e9│
    └──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┘

index    0      1      2      3      4      5      6      7
</pre></div>

<p>where the <code>e</code>'s are the empty strings. The regex <code>(?!hede).</code> looks ahead to
see if there's no substring <code>"hede"</code> to be seen, and if that is the case (so
something else is seen), then the <code>.</code> (dot) will match any character except a
line break. Look-arounds are also called <em>zero-width-assertions</em> because they
don't <em>consume</em> any characters. They only assert/validate something.</p>
<p>So, in my example, every empty string is first validated to see if there's no
<code>"hede"</code> up ahead, before a character is consumed by the <code>.</code> (dot). The regex
<code>(?!hede).</code> will do that only once, so it is wrapped in a group, and repeated
zero or more times: <code>((?!hede).)*</code>. Finally, the start- and end-of-input are
anchored to make sure the entire input is consumed: <code>^((?!hede).)*$</code></p>
<p>As you can see, the input <code>"ABhedeCD"</code> will fail because on <code>e3</code>, the regex
<code>(?!hede)</code> fails (there <em>is</em> <code>"hede"</code> up ahead!).</p>
<p><br></p>
<h3>Suggest</h3>
<p>Note that the solution to <strong>does not <em>start with</em> “hede”</strong>:</p>
<div class="code"><pre class="code literal-block"><span class="o">^</span><span class="p">(</span>?<span class="o">!</span><span class="nv">hede</span><span class="p">)</span><span class="o">.*</span><span class="p">$</span>
</pre></div>

<p>is generally much more efficient than the solution to <strong>does not <em>contain</em>
“hede”</strong>:</p>
<div class="code"><pre class="code literal-block"><span class="o">^</span><span class="p">((</span>?<span class="o">!</span><span class="nv">hede</span><span class="p">)</span><span class="o">.</span><span class="p">)</span><span class="o">*</span><span class="p">$</span>
</pre></div>

<p>The former checks for “hede” only at the input string’s first position, rather
than at every position.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-21.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-19.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
