<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 575) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-575.html">
<link rel="prev" href="index-576.html" type="text/html">
<link rel="next" href="index-574.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-python-zhong-de-future-yong-yu-yi-ji-ru-he-he-shi-shi-yong-ta-yi-ji-ta-shi-ru-he-gong-zuo-de/" class="u-url">什么是 Python 中的 __future__ 用于以及如何/何时使用它，以及它是如何工作的</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-python-zhong-de-future-yong-yu-yi-ji-ru-he-he-shi-shi-yong-ta-yi-ji-ta-shi-ru-he-gong-zuo-de/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:30:28+08:00" itemprop="datePublished" title="2023-02-17 10:30">2023-02-17 10:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>__future__</code>经常出现在 Python 模块中。即使在阅读了Python
的文档之后，我也不明白<code>__future__</code>它的用途以及如何/何时使用它。<code>__future__</code></p>
<p>任何人都可以用例子解释吗？</p>
<p><code>__future__</code>关于我收到的基本用法的一些答案似乎是正确的。</p>
<p>但是，我需要了解有关工作原理的另一件事<code>__future__</code>：</p>
<p>对我来说最令人困惑的概念是当前的 python 版本如何包含未来版本的功能，以及如何在当前版本的 Python 中成功编译使用未来版本的功能的程序。</p>
<p>我猜测当前版本包含了未来的潜在功能。但是，这些功能只能通过使用来使用，<code>__future__</code>因为它们不是当前标准。如果我是对的，请告诉我。</p>
<p><br><br></p>
<h2>解答</h2>
<p>随着<code>__future__</code>模块的包含，您可以慢慢习惯不兼容的更改或引入新关键字的更改。</p>
<p>例如，要使用上下文管理器，您必须<code>from __future__ import with_statement</code>在 2.5
中执行此操作，因为<code>with</code>关键字是新的并且不应再用作变量名。为了<code>with</code>在 Python 2.5 或更早版本中用作 Python
关键字，您需要使用上面的导入。</p>
<p>另一个例子是</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="nb">print</span> <span class="mi">8</span><span class="o">/</span><span class="mi">7</span>  <span class="c1"># prints 1.1428571428571428</span>
<span class="nb">print</span> <span class="mi">8</span><span class="o">//</span><span class="mi">7</span> <span class="c1"># prints 1</span>
</pre></div>

<p>没有这些<code>__future__</code>东西，两个<code>print</code>语句都会打印出来<code>1</code>。</p>
<p>内部区别在于，如果没有该导入，<code>/</code>则映射到该<code>__div__()</code>方法，而如果有该导入，<code>__truediv__()</code>则使用该方法。（无论如何，<code>//</code>调用<code>__floordiv__()</code>。）</p>
<p>Apropos <code>print</code>:<code>print</code>成为 3.x 中的函数，失去了作为关键字的特殊属性。所以这是相反的。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="nb">print</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>当你做</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">whatever</span>
</pre></div>

<p>您实际上不是在使用<code>import</code>statement，而是future statement。您正在阅读错误的文档，因为您实际上并没有导入该模块。</p>
<p><strong>Future 语句很特殊——它们改变了 Python 模块的解析方式，这就是它们必须</strong>
位于文件顶部的原因。它们为文件中的单词或符号赋予新的或不同的含义。从文档：</p>
<blockquote>
<p>future 语句是对编译器的指令，指示特定模块应该使用在指定的未来 Python 版本中可用的语法或语义进行编译。future 语句旨在简化向
Python 的未来版本的迁移，这些版本引入了对该语言的不兼容更改。它允许在功能成为标准的发布之前基于每个模块使用新功能。</p>
</blockquote>
<p>如果你真的想导入<code>__future__</code>模块，就这样做</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">__future__</span>
</pre></div>

<p>然后像往常一样访问它。</p>
<p><br><br><a href="posts/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/data-table-vs-dplyr-yi-ge-ren-neng-zuo-hao-yi-jian-shi-qing-er-ling-yi-ge-ren-bu-neng-zuo-huo-zuo-de-bu-hao-ma/" class="u-url">data.table vs dplyr：一个人能做好一件事情而另一个人不能做或做得不好吗？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/data-table-vs-dplyr-yi-ge-ren-neng-zuo-hao-yi-jian-shi-qing-er-ling-yi-ge-ren-bu-neng-zuo-huo-zuo-de-bu-hao-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:30:03+08:00" itemprop="datePublished" title="2023-02-17 10:30">2023-02-17 10:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <h4>概述</h4>
<p>我比较熟悉<code>data.table</code>，不太熟悉<code>dplyr</code>。我已经阅读了一些出现在 SO 上的<code>dplyr</code>小插曲和示例，到目前为止，我的结论是：</p>
<ol>
<li>
<code>data.table</code>并且<code>dplyr</code>速度相当，除非有很多（即&gt; 10-100K）组，并且在某些其他情况下（参见下面的基准）</li>
<li>
<code>dplyr</code>具有更易于访问的语法</li>
<li>
<code>dplyr</code>抽象（或将）潜在的数据库交互</li>
<li>有一些细微的功能差异（请参阅下面的“示例/用法”）</li>
</ol>
<p>在我看来，2.
并没有太大的影响力，因为我对它相当熟悉<code>data.table</code>，尽管我知道对于两者都不熟悉的用户来说，这将是一个重要因素。我想避免争论哪个更直观，因为这与我从已经熟悉<code>data.table</code>.
我还想避免讨论“更直观”如何导致更快的分析（当然是这样，但同样，这不是我在这里最感兴趣的）。</p>
<h4>问题</h4>
<p>我想知道的是：</p>
<ol>
<li>对于熟悉软件包的人来说，是否存在使用一个或另一个软件包更容易编写代码的分析任务（即所需的击键与所需的深奥程度的某种组合，其中每个较少是一件好事）。</li>
<li>是否有分析任务在一个包中比另一个包更有效地执行（即超过 2 倍）。</li>
</ol>
<p>最近的一个SO 问题让我对这个问题有了更多的思考，因为在那之前我认为不会<code>dplyr</code>提供超出我在<code>data.table</code>. 这是<code>dplyr</code>解决方案（Q
末尾的数据）：</p>
<div class="code"><pre class="code literal-block">dat %.%
  group_by(name, job) %.%
  filter(job != "Boss" | year == min(year)) %.%
  mutate(cumu_job2 = cumsum(job2))
</pre></div>

<p>这比我对解决方案的破解尝试要好得多<code>data.table</code>。也就是说，好的<code>data.table</code>解决方案也非常好（感谢 Jean-
Robert、Arun，并注意这里我更喜欢单一语句而不是严格的最佳解决方案）：</p>
<div class="code"><pre class="code literal-block"><span class="nf">setDT</span><span class="p">(</span><span class="nv">dat</span><span class="p">)[,</span>
<span class="w">  </span><span class="o">.</span><span class="nv">SD</span><span class="p">[</span><span class="nv">job</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">"Boss"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">year</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="nv">year</span><span class="p">)][,</span><span class="w"> </span><span class="nv">cumjob</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">cumsum</span><span class="p">(</span><span class="nv">job2</span><span class="p">)],</span><span class="w"> </span>
<span class="w">  </span><span class="nv">by</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="nv">id</span><span class="p">,</span><span class="w"> </span><span class="nv">job</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>

<p>后者的语法可能看起来非常深奥，但如果您习惯了<code>data.table</code>（即不使用一些更深奥的技巧），它实际上非常简单。</p>
<p>理想情况下，我希望看到一些很好的例子，这些例子<code>dplyr</code>或<code>data.table</code>方法更加简洁或表现得更好。</p>
<h4>例子</h4>
<p>用法</p>
<ul>
<li>
<code>dplyr</code>不允许返回任意行数的分组操作（来自 <strong>eddi 的问题</strong> ，注意：这看起来将在 <strong>dplyr 0.5</strong><code>do</code>中实现，此外，@beginneR 显示了在@eddi 的问题的答案中使用的潜在变通方法）。</li>
<li>
<code>data.table</code>支持 <strong>滚动连接</strong> （感谢@dholstius）以及 <strong>重叠连接</strong>
</li>
<li>
<code>data.table</code>通过 <em>自动索引</em> 在使用相同的基本 R 语法的同时 <em>使用</em> 二进制 <em>搜索</em> 来内部优化<code>DT[col == value]</code>or形式的表达式。有关更多详细信息和一个小基准，请参见此处。<code>DT[col %in% values]</code> <strong> </strong> __</li>
<li>
<code>dplyr</code>提供可以简化程序化使用的函数的标准评估版本（例如<code>regroup</code>, ）<code>summarize_each_``dplyr``data.table</code>
</li>
</ul>
<p>基准</p>
<ul>
<li>我运行了 <strong>自己的基准测试</strong> ，发现这两个包在“拆分应用组合”风格分析中具有可比性，除非有大量的组（&gt; 100K），此时速度要<code>data.table</code>快得多。</li>
<li>@Arun <strong>在 joins 上运行了一些基准测试</strong> ，表明随着组数量的增加，它的<code>data.table</code>扩展性更好<code>dplyr</code>（更新了两个包和最新版本的 R 中的最新增强功能）。此外，尝试获取 <strong>唯一值</strong> 时的基准测试速度快了<code>data.table</code>约 6 倍。</li>
<li>（未验证）<code>data.table</code>在较大版本的组/应用/排序上快 75%，而<code>dplyr</code>在较小的版本上快 40%（ <strong>来自评论的另一个 SO 问题</strong> ，感谢 danas）。</li>
<li>的主要作者 Matt在 <strong>和</strong> <strong>python</strong> <strong>上对多达 20 亿行（RAM 中约 100GB）的</strong> <strong>分组操作</strong><code>data.table</code>进行了基准测试。 <strong><code>data.table``dplyr``pandas</code></strong>
</li>
<li>
<strong>80K 组的旧基准测试</strong> 速度快约<code>data.table</code>8 倍</li>
</ul>
<h4>数据</h4>
<p>这是我在问题部分展示的第一个例子。</p>
<div class="code"><pre class="code literal-block"><span class="n">dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">structure</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span>
<span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="m">2L</span><span class="p">),</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Jane"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="s">"Bob"</span><span class="p">),</span><span class="w"> </span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1980L</span><span class="p">,</span><span class="w"> </span><span class="m">1981L</span><span class="p">,</span><span class="w"> </span><span class="m">1982L</span><span class="p">,</span><span class="w"> </span><span class="m">1983L</span><span class="p">,</span><span class="w"> </span><span class="m">1984L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1985L</span><span class="p">,</span><span class="w"> </span><span class="m">1986L</span><span class="p">,</span><span class="w"> </span><span class="m">1987L</span><span class="p">,</span><span class="w"> </span><span class="m">1985L</span><span class="p">,</span><span class="w"> </span><span class="m">1986L</span><span class="p">,</span><span class="w"> </span><span class="m">1987L</span><span class="p">,</span><span class="w"> </span><span class="m">1988L</span><span class="p">,</span><span class="w"> </span><span class="m">1989L</span><span class="p">,</span><span class="w"> </span><span class="m">1990L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1991L</span><span class="p">,</span><span class="w"> </span><span class="m">1992L</span><span class="p">),</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span><span class="s">"Manager"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">,</span><span class="w"> </span><span class="s">"Boss"</span><span class="p">),</span><span class="w"> </span><span class="n">job2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span>
<span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="m">0L</span><span class="p">)),</span><span class="w"> </span><span class="n">.Names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">"id"</span><span class="p">,</span><span class="w"> </span>
<span class="s">"name"</span><span class="p">,</span><span class="w"> </span><span class="s">"year"</span><span class="p">,</span><span class="w"> </span><span class="s">"job"</span><span class="p">,</span><span class="w"> </span><span class="s">"job2"</span><span class="p">),</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"data.frame"</span><span class="p">,</span><span class="w"> </span><span class="n">row.names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span>
<span class="m">-16L</span><span class="p">))</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>我们至少需要涵盖这些方面以提供全面的答案/比较（重要性不分先后）：<code>Speed</code>、、<code>Memory usage</code>和。<code>Syntax``Features</code></p>
<p>我的目的是从 data.table 的角度尽可能清楚地涵盖其中的每一个。</p>
<blockquote>
<p>注意：除非另有明确说明，否则通过引用 dplyr，我们指的是 dplyr 的 data.frame 接口，其内部结构在 C++ 中使用 Rcpp。</p>
</blockquote>
<hr>
<p>data.table 语法在其形式上是一致的 - <code>DT[i, j, by]</code>。保持<code>i</code>,<code>j</code>和<code>by</code>在一起是设计使然。通过将相关操作放在一起，它可以
<em>轻松优化</em> 操作 <em>速度</em> ，更重要的 <em>是内存使用</em> ，还提供一些 <em>强大的功能</em> ，同时保持语法的一致性。</p>
<h4>1.速度</h4>
<p><em>相当多的基准（虽然主要是关于分组操作）已经被添加到已经显示 data.table 比 dplyr更快</em>
的问题中，因为要分组的组和/或行的数量增加，包括Matt 的基准从 <em>1000 万到分组</em> <em>100 - 1000 万组</em> 和不同的分组列上的 <em>20
亿行</em> （100GB RAM） ，这也比较了<code>pandas</code>. 另请参阅更新的基准测试，其中包括<code>Spark</code>和<code>pydatatable</code>。</p>
<p>在基准测试中，最好也涵盖这些剩余的方面：</p>
<ul>
<li>
<p><em>涉及行子集的</em> 分组操作- 即<code>DT[x &gt; val, sum(y), by = z]</code>类型操作。</p>
</li>
<li>
<p>对其他操作进行基准测试，例如 <em>update</em> 和 <em>joins</em> 。</p>
</li>
<li>
<p>除了运行时之外，还对每个操作的 <em>内存占用进行基准测试。</em></p>
</li>
</ul>
<h4>2.内存使用</h4>
<ol>
<li>
<code>filter()</code>涉及或在 dplyr 中的操作<code>slice()</code>可能内存效率低下（在 data.frames 和 data.tables 上）。看到这篇文章。</li>
</ol>
<blockquote>
<p>请注意，Hadley 的评论谈到了 <em>速度</em> （dplyr 对他来说足够快），而这里主要关注的是 <em>memory</em> 。</p>
</blockquote>
<ol>
<li>data.table 接口目前允许 <em>通过引用</em> 修改/更新列（请注意，我们不需要将结果重新分配回变量）。<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="n">sub</span><span class="o">-</span><span class="k">assign</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">updates</span><span class="w"> </span><span class="sc">'y'</span><span class="w"> </span><span class="n">in</span><span class="o">-</span><span class="n">place</span>
</pre></div>

<p>DT[x &gt;= 1L, y := NA]</p>
</li>
</ol>
<p>但是 dplyr <em>永远不会</em> 通过引用更新。dplyr 等价物是（注意结果需要重新赋值）：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1"># copies the entire 'y' column</span>
<span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nf">mutate</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="nf">which</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">1L</span><span class="p">),</span><span class="w"> </span><span class="kc">NA</span><span class="p">))</span>
</pre></div>

<p>对此的关注是 <em>引用透明性</em> 。通过引用更新 data.table
对象，尤其是在函数中，可能并不总是可取的。但这是一个非常有用的功能：有关有趣的案例，请参阅此和此帖子。我们想保留它。</p>
<p>因此，我们正在努力<code>shallow()</code>在 data.table 中导出函数，这将为用户提供 <em>两种可能性</em> 。例如，如果不希望在一个函数中修改输入
data.table，那么可以这样做：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">foo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">DT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">shallow</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w">          </span><span class="c1">## shallow copy DT</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">1L</span><span class="p">]</span><span class="w">        </span><span class="c1">## does not affect the original DT </span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">2L</span><span class="p">]</span><span class="w">  </span><span class="c1">## no need to copy (internally), as this column exists only in shallow copied DT</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">3L</span><span class="p">]</span><span class="w">       </span><span class="c1">## have to copy (like base R / dplyr does always); otherwise original DT will </span>
<span class="w">                               </span><span class="c1">## also get modified.</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p>通过不使用<code>shallow()</code>，保留了旧功能：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">bar</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">DT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[,</span><span class="w"> </span><span class="n">newcol</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">1L</span><span class="p">]</span><span class="w">        </span><span class="c1">## old behaviour, original DT gets updated by reference</span>
<span class="w">     </span><span class="n">DT</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2L</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="m">3L</span><span class="p">]</span><span class="w">       </span><span class="c1">## old behaviour, update column x in original DT.</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p>通过使用创建 <em>浅表副本</em><code>shallow()</code>，我们了解到您不想修改原始对象。我们在内部处理所有事情，以确保在确保 <em>仅在绝对必要时才</em>
复制您修改的列。实施后，这应该完全解决 <em>引用透明性</em> 问题，同时为用户提供两种可能性。</p>
<blockquote>
<p>此外，一旦<code>shallow()</code>导出 dplyr 的 data.table 接口，应避免几乎所有副本。所以那些喜欢 dplyr 语法的人可以将它与
data.tables 一起使用。</p>
<p>但它仍然缺少 data.table 提供的许多功能，包括通过引用进行（子）赋值。</p>
</blockquote>
<ol>
<li>加入时聚合：</li>
</ol>
<p>假设你有两个 data.tables 如下：</p>
<div class="code"><pre class="code literal-block">     DT1 = data.table(x=c(1,1,1,1,2,2,2,2), y=c("a", "a", "b", "b"), z=1:8, key=c("x", "y"))
 #    x y z
 # 1: 1 a 1
 # 2: 1 a 2
 # 3: 1 b 3
 # 4: 1 b 4
 # 5: 2 a 5
 # 6: 2 a 6
 # 7: 2 b 7
 # 8: 2 b 8
 DT2 = data.table(x=1:2, y=c("a", "b"), mul=4:3, key=c("x", "y"))
 #    x y mul
 # 1: 1 a   4
 # 2: 2 b   3
</pre></div>

<p>并且您想在按列连接时<code>sum(z) * mul</code>获取每一行。我们可以：<code>DT2``x,y</code></p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w">       </span><span class="mf">1.</span><span class="w"> </span><span class="n">聚合</span><span class="n n-Quoted">`DT1`</span><span class="n">得到</span><span class="n n-Quoted">`sum(z)`</span><span class="n">，2</span><span class="p">)</span><span class="w"> </span><span class="n">执行连接和</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">乘法（或）</span>
</pre></div>

<h2>数据表方式</h2>
<p>DT1[, .(z = sum(z)), keyby = .(x,y)][DT2][, z := z*mul][]</p>
<h2>dplyr等效</h2>
<p>DF1 %&gt;% group_by(x, y) %&gt;% summarise(z = sum(z)) %&gt;% right_join(DF2) %&gt;%
mutate(z = z * mul)</p>
<div class="code"><pre class="code literal-block">*       2. 一次完成所有操作（使用`by = .EACHI`功能）：
</pre></div>

<p>DT1[DT2, 列表(z=sum(z) * mul), by = .EACHI]</p>
<p>有什么好处？</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w"> </span><span class="n">我们不必为中间结果分配内存。</span>

<span class="o">*</span><span class="w"> </span><span class="n">我们不必两次分组</span><span class="o">/</span><span class="n">散列（一次用于聚合，另一次用于加入）。</span>

<span class="o">*</span><span class="w"> </span><span class="n n-Quoted">`j`</span><span class="n">更重要的是，通过查看</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">中的内容，我们想要执行的操作一目了然。</span>
</pre></div>

<p>检查这篇文章以获得详细的解释<code>by = .EACHI</code>。没有实现任何中间结果，并且一次执行连接+聚合。</p>
<p>查看这个、这个和这个帖子了解真实的使用场景。</p>
<p>在中，<code>dplyr</code>您必须先 join and aggregate 或 aggregate 然后
join，就内存而言（这反过来又转化为速度），两者都没有那么高效。</p>
<ol>
<li>更新并加入：</li>
</ol>
<p>考虑如下所示的 data.table 代码：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="nv">DT1</span><span class="p">[</span><span class="nv">DT2</span><span class="p">,</span><span class="w"> </span><span class="nv">col</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">i</span><span class="o">.</span><span class="nv">mul</span><span class="p">]</span>
</pre></div>

<p>在的键列匹配的那些行上使用from添加/更新<code>DT1</code>的列。我认为在
中没有与此操作完全相同的操作，即，如果不避免操作，则必须复制整个操作才能向其添加新列，这是不必要的。<code>col``mul``DT2``DT2``DT1``dplyr``*_join``DT1</code></p>
<p>查看这篇文章以了解真实的使用场景。</p>
<blockquote>
<p>总而言之，重要的是要认识到优化的每一点都很重要。正如 <strong>Grace Hopper</strong> 所说， <strong>注意你的纳秒</strong> ！</p>
</blockquote>
<h4>3.语法</h4>
<p>现在让我们看看 <em>语法</em> 。哈德利在这里评论道：</p>
<blockquote>
<p>数据表非常快，但我认为它们的简洁性使得它 <em>更难学习</em> ，并且 <em>使用它的代码在编写后更难阅读</em>......</p>
</blockquote>
<p>我觉得这句话毫无意义，因为它非常主观。我们或许可以尝试的是对比 <em>语法的一致性</em> 。我们将并排比较 data.table 和 dplyr 语法。</p>
<p>我们将使用如下所示的虚拟数据：</p>
<div class="code"><pre class="code literal-block">DT = data.table(x=1:10, y=11:20, z=rep(1:2, each=5))
DF = as.data.frame(DT)
</pre></div>

<ol>
<li>
<p>基本聚合/更新操作。</p>
<div class="code"><pre class="code literal-block"> # case (a)
</pre></div>

<p>DT[, sum(y), by = z]                       ## data.table syntax
 DF %&gt;% group_by(z) %&gt;% summarise(sum(y)) ## dplyr syntax
 DT[, y := cumsum(y), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate(y = cumsum(y))</p>
<p># case (b)
 DT[x &gt; 2, sum(y), by = z]
 DF %&gt;% filter(x&gt;2) %&gt;% group_by(z) %&gt;% summarise(sum(y))
 DT[x &gt; 2, y := cumsum(y), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate(y = replace(y, which(x &gt; 2), cumsum(y)))</p>
<p># case (c)
 DT[, if(any(x &gt; 5L)) y[1L]-y[2L] else y[2L], by = z]
 DF %&gt;% group_by(z) %&gt;% summarise(if (any(x &gt; 5L)) y[1L] - y[2L] else y[2L])
 DT[, if(any(x &gt; 5L)) y[1L] - y[2L], by = z]
 DF %&gt;% group_by(z) %&gt;% filter(any(x &gt; 5L)) %&gt;% summarise(y[1L] - y[2L])</p>
<ul>
<li>
<p>data.table 语法紧凑而 dplyr 非常冗长。在情况 (a) 中，事情或多或少是等价的。</p>
</li>
<li>
<p>在情况 (b) 中，我们不得不在 <em>汇总</em><code>filter()</code>时使用 in dplyr 。但是在 <em>更新的</em> 时候，我们不得不把逻辑移到里面。然而，在 data.table 中，我们用相同的逻辑来表达这两种操作——在行上操作 where ，但在第一种情况下， get ，而在第二种情况下，用其累积和更新这些行。 <strong> </strong><code>mutate()``x &gt; 2``sum(y)``y</code></p>
</li>
</ul>
</li>
</ol>
<p>这就是我们所说的<code>DT[i, j, by]</code>形式 <em>一致的</em> 意思。</p>
<div class="code"><pre class="code literal-block"><span class="o">*</span><span class="w"> </span><span class="n">与情况</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">类似，当我们</span><span class="n n-Quoted">`if-else`</span><span class="n">有条件时，我们能够在</span><span class="w"> </span><span class="k">data</span><span class="p">.</span><span class="k">table</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="n">dplyr</span><span class="w"> </span><span class="n">中</span><span class="w"> </span><span class="n">_“按原样”表达逻辑。_</span><span class="w"> </span><span class="n">但是，如果我们只想返回</span><span class="n n-Quoted">`if`</span><span class="n">满足条件的那些行并跳过其他行，我们不能</span><span class="n n-Quoted">`summarise()`</span><span class="n">直接使用</span><span class="w"> </span><span class="p">(</span><span class="n">AFAICT</span><span class="p">)</span><span class="n">。我们必须</span><span class="n n-Quoted">`filter()`</span><span class="n">先总结再总结，因为</span><span class="n n-Quoted">`summarise()`</span><span class="n">总是期望一个</span><span class="w"> </span><span class="n">_单一的价值_</span><span class="w"> </span><span class="n">。</span>
</pre></div>

<p>虽然它返回相同的结果，但<code>filter()</code>在这里使用会使实际操作不那么明显。</p>
<p>在第一种情况下也很有可能使用<code>filter()</code>（对我来说似乎并不明显），但我的观点是我们不必这样做。</p>
<ol>
<li>
<p>多列聚合/更新</p>
<div class="code"><pre class="code literal-block"> # case (a)
</pre></div>

<p>DT[, lapply(.SD, sum), by = z]                     ## data.table syntax
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(sum)) ## dplyr syntax
 DT[, (cols) := lapply(.SD, sum), by = z]
 ans &lt;- DF %&gt;% group_by(z) %&gt;% mutate_each(funs(sum))</p>
<p># case (b)
 DT[, c(lapply(.SD, sum), lapply(.SD, mean)), by = z]
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(sum, mean))</p>
<p># case (c)
 DT[, c(.N, lapply(.SD, sum)), by = z]   <br>
 DF %&gt;% group_by(z) %&gt;% summarise_each(funs(n(), mean))</p>
<ul>
<li>
<p>In case (a), the codes are more or less equivalent. data.table uses familiar base function <code>lapply()</code>, whereas <code>dplyr</code> introduces <code>*_each()</code> along with a bunch of functions to <code>funs()</code>.</p>
</li>
<li>
<p>data.table's <code>:=</code> requires column names to be provided, whereas dplyr generates it automatically.</p>
</li>
<li>
<p>In case (b), dplyr's syntax is relatively straightforward. Improving aggregations/updates on multiple functions is on data.table's list.</p>
</li>
<li>
<p>In case (c) though, dplyr would return <code>n()</code> as many times as many columns, instead of just once. In data.table, all we need to do is to return a list in <code>j</code>. Each element of the list will become a column in the result. So, we can use, once again, the familiar base function <code>c()</code> to concatenate <code>.N</code> to a <code>list</code> which returns a <code>list</code>.</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>Note: Once again, in data.table, all we need to do is return a list in <code>j</code>.
Each element of the list will become a column in result. You can use <code>c()</code>,
<code>as.list()</code>, <code>lapply()</code>, <code>list()</code> etc... base functions to accomplish this,
without having to learn any new functions.</p>
<p>You will need to learn just the special variables - <code>.N</code> and <code>.SD</code> at least.
The equivalent in dplyr are <code>n()</code> and <code>.</code></p>
</blockquote>
<ol>
<li>Joins</li>
</ol>
<p>dplyr provides separate functions for each type of join where as data.table
allows joins using the same syntax <code>DT[i, j, by]</code> (and with reason). It also
provides an equivalent <code>merge.data.table()</code> function as an alternative.</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">setkey</span><span class="p">(</span><span class="n">DT1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2</span><span class="o">]</span><span class="w">            </span><span class="err">##</span><span class="w"> </span><span class="k">data</span><span class="p">.</span><span class="nc">table</span><span class="w"> </span><span class="n">syntax</span>
<span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">DT2</span><span class="p">,</span><span class="w"> </span><span class="n">DT1</span><span class="p">)</span><span class="w"> </span><span class="err">##</span><span class="w"> </span><span class="n">dplyr</span><span class="w"> </span><span class="n">syntax</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span><span class="w">    </span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, .(z, i.mul)</span><span class="o">]</span>
<span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="k">select</span><span class="p">(</span><span class="n">DT2</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">mul</span><span class="p">),</span><span class="w"> </span><span class="k">select</span><span class="p">(</span><span class="n">DT1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="k">aggregate</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, .(sum(z) * i.mul), by = .EACHI</span><span class="o">]</span>
<span class="w"> </span><span class="n">DF1</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">group_by</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">summarise</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span>
<span class="w">     </span><span class="n">inner_join</span><span class="p">(</span><span class="n">DF2</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="o">*</span><span class="n">mul</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">select</span><span class="p">(</span><span class="o">-</span><span class="n">mul</span><span class="p">)</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, z := cumsum(z) * i.mul, by = .EACHI</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">5.</span><span class="w"> </span><span class="n">rolling</span><span class="w"> </span><span class="k">join</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, roll = -Inf</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>

<span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="mf">6.</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="k">output</span>
<span class="w"> </span><span class="n">DT1</span><span class="o">[</span><span class="n">DT2, mult = "first"</span><span class="o">]</span>
<span class="w"> </span><span class="vm">??</span>
</pre></div>

<ul>
<li>
<p>Some might find a separate function for each joins much nicer (left, right, inner, anti, semi etc), whereas as others might like data.table's <code>DT[i, j, by]</code>, or <code>merge()</code> which is similar to base R.</p>
</li>
<li>
<p>However dplyr joins do just that. Nothing more. Nothing less.</p>
</li>
<li>
<p>data.tables can select columns while joining (2), and in dplyr you will need to <code>select()</code> first on both data.frames before to join as shown above. Otherwise you would materialiase the join with unnecessary columns only to remove them later and that is inefficient.</p>
</li>
<li>
<p>data.tables can aggregate while joining (3) and also update while joining (4), using by = .EACHI feature. Why materialse the entire join result to add/update just a few columns?</p>
</li>
<li>
<p>data.table is capable of <em>rolling joins</em> (5) - roll forward, LOCF, roll backward, NOCB, nearest.</p>
</li>
<li>
<p>data.table also has <code>mult =</code> argument which selects <em>first</em> , <em>last</em> or <em>all</em> matches (6).</p>
</li>
<li>
<p>data.table has <code>allow.cartesian = TRUE</code> argument to protect from accidental invalid joins.</p>
</li>
</ul>
<blockquote>
<p>Once again, the syntax is consistent with <code>DT[i, j, by]</code> with additional
arguments allowing for controlling the output further.</p>
</blockquote>
<ol>
<li>
<code>do()</code>...</li>
</ol>
<p>dplyr's summarise is specially designed for functions that return a single
value. If your function returns multiple/unequal values, you will have to
resort to <code>do()</code>. You have to know beforehand about all your functions return
value.</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">list</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]<span class="w">                 </span>##<span class="w"> </span><span class="nv">data</span>.<span class="nv">table</span><span class="w"> </span><span class="nv">syntax</span>
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">summarise</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">dplyr</span><span class="w"> </span><span class="nv">syntax</span>
<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">list</span><span class="ss">(</span><span class="nv">x</span>[<span class="mi">1</span>:<span class="mi">2</span>],<span class="w"> </span><span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span>.$<span class="nv">x</span>[<span class="mi">1</span>:<span class="mi">2</span>],<span class="w"> </span>.$<span class="nv">y</span>[<span class="mi">1</span>]<span class="ss">))</span>

<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">25</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">summarise</span><span class="ss">(</span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">25</span><span class="ss">))</span>
<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">quantile</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="mi">0</span>.<span class="mi">25</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">75</span><span class="ss">))</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span><span class="nv">quantile</span><span class="ss">(</span>.$<span class="nv">x</span>,<span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="mi">0</span>.<span class="mi">25</span>,<span class="w"> </span><span class="mi">0</span>.<span class="mi">75</span><span class="ss">))))</span>

<span class="w"> </span><span class="nv">DT</span>[,<span class="w"> </span><span class="nv">as</span>.<span class="nv">list</span><span class="ss">(</span><span class="nv">summary</span><span class="ss">(</span><span class="nv">x</span><span class="ss">))</span>,<span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">z</span>]
<span class="w"> </span><span class="nv">DF</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="nv">group_by</span><span class="ss">(</span><span class="nv">z</span><span class="ss">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="k">do</span><span class="ss">(</span><span class="nv">data</span>.<span class="nv">frame</span><span class="ss">(</span><span class="nv">as</span>.<span class="nv">list</span><span class="ss">(</span><span class="nv">summary</span><span class="ss">(</span>.$<span class="nv">x</span><span class="ss">))))</span>
</pre></div>

<ul>
<li>
<p><code>.SD</code>'s equivalent is <code>.</code></p>
</li>
<li>
<p>In data.table, you can throw pretty much anything in <code>j</code> - the only thing to remember is for it to return a list so that each element of the list gets converted to a column.</p>
</li>
<li>
<p>In dplyr, cannot do that. Have to resort to <code>do()</code> depending on how sure you are as to whether your function would always return a single value. And it is quite slow.</p>
</li>
</ul>
<blockquote>
<p>Once again, data.table's syntax is consistent with <code>DT[i, j, by]</code>. We can
just keep throwing expressions in <code>j</code> without having to worry about these
things.</p>
</blockquote>
<p>Have a look at this SO question and this one. I wonder if it would be possible
to express the answer as straightforward using dplyr's syntax...</p>
<blockquote>
<p>To summarise, I have particularly highlighted <em>several</em> instances where
dplyr's syntax is either inefficient, limited or fails to make operations
straightforward. This is particularly because data.table gets quite a bit of
backlash about "harder to read/learn" syntax (like the one pasted/linked
above). Most posts that cover dplyr talk about most straightforward
operations. And that is great. But it is important to realise its syntax and
feature limitations as well, and I am yet to see a post on it.</p>
<p>data.table has its quirks as well (some of which I have pointed out that we
are attempting to fix). We are also attempting to improve data.table's joins
as I have highlighted here.</p>
<p>But one should also consider the number of features that dplyr lacks in
comparison to data.table.</p>
</blockquote>
<h4>4. Features</h4>
<p>I have pointed out most of the features here and also in this post. In
addition:</p>
<ul>
<li>
<p><strong>fread</strong> - fast file reader has been available for a long time now.</p>
</li>
<li>
<p><strong>fwrite</strong> - a <em>parallelised</em> fast file writer is now available. See this post for a detailed explanation on the implementation and #1664 for keeping track of further developments.</p>
</li>
<li>
<p>Automatic indexing - another handy feature to optimise base R syntax as is, internally.</p>
</li>
<li>
<p><strong>Ad-hoc grouping</strong> : <code>dplyr</code> automatically sorts the results by grouping variables during <code>summarise()</code>, which may not be always desirable.</p>
</li>
<li>
<p>Numerous advantages in data.table joins (for speed / memory efficiency and syntax) mentioned above.</p>
</li>
<li>
<p><strong>Non-equi joins</strong> : Allows joins using other operators <code>&lt;=, &lt;, &gt;, &gt;=</code> along with all other advantages of data.table joins.</p>
</li>
<li>
<p>Overlapping range joins was implemented in data.table recently. Check this post for an overview with benchmarks.</p>
</li>
<li>
<p><code>setorder()</code> function in data.table that allows really fast reordering of data.tables by reference.</p>
</li>
<li>
<p>dplyr provides interface to databases using the same syntax, which data.table does not at the moment.</p>
</li>
<li>
<p><code>data.table</code> provides faster equivalents of <em>set operations</em> (written by Jan Gorecki) - <code>fsetdiff</code>, <code>fintersect</code>, <code>funion</code> and <code>fsetequal</code> with additional <code>all</code> argument (as in SQL).</p>
</li>
<li>
<p>data.table loads cleanly with no masking warnings and has a mechanism described here for <code>[.data.frame</code> compatibility when passed to any R package. dplyr changes base functions <code>filter</code>, <code>lag</code> and <code>[</code> which can cause problems; e.g. here and here.</p>
</li>
</ul>
<hr>
<p>Finally:</p>
<ul>
<li>
<p>On databases - there is no reason why data.table cannot provide similar interface, but this is not a priority now. It might get bumped up if users would very much like that feature.. not sure.</p>
</li>
<li>
<p>On parallelism - Everything is difficult, until someone goes ahead and does it. Of course it will take effort (being thread safe).</p>
<ul>
<li>Progress is being made currently (in v1.9.7 devel) towards parallelising known time consuming parts for incremental performance gains using <code>OpenMP</code>.</li>
</ul>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>这是我从 dplyr 的角度尝试综合回答，遵循 Arun 回答的大纲（但根据不同的优先级进行了一些重新排列）。</p>
<h3>句法</h3>
<p>语法有一些主观性，但我坚持我的说法，即 data.table 的简洁性使其更难学习和阅读。这部分是因为 dplyr 正在解决一个更容易的问题！</p>
<p>dplyr 为您做的一件非常重要的事情是它 <em>限制了</em>
您的选择。我声称大多数单表问题只需五个关键动词过滤、选择、变异、排列和总结，以及一个“按组”副词即可解决。当你学习数据操作时，这个约束是一个很大的帮助，因为它有助于你对问题的思考。在
dplyr 中，这些动词中的每一个都映射到一个函数。每个功能做一项工作，孤立起来很容易理解。</p>
<p>通过将这些简单的操作与<code>%&gt;%</code>. 这是 Arun链接到的帖子之一的示例：</p>
<div class="code"><pre class="code literal-block">diamonds %&gt;%
  filter(cut != "Fair") %&gt;%
  group_by(cut) %&gt;%
  summarize(
    AvgPrice = mean(price),
    MedianPrice = as.numeric(median(price)),
    Count = n()
  ) %&gt;%
  arrange(desc(Count))
</pre></div>

<p>即使您以前从未见过 dplyr（甚至是 R！），您仍然可以了解正在发生的事情的要点，因为这些函数都是英语动词。英语动词的缺点是它们比
需要更多的打字<code>[</code>，但我认为可以通过更好的自动完成在很大程度上减轻这一点。</p>
<p>这是等效的 data.table 代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">diamondsDT</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">data.table</span><span class="p">(</span><span class="n">diamonds</span><span class="p">)</span>
<span class="n">diamondsDT</span><span class="p">[</span>
<span class="w">  </span><span class="n">cut</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">"Fair"</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="nf">.</span><span class="p">(</span><span class="n">AvgPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="n">price</span><span class="p">),</span>
<span class="w">    </span><span class="n">MedianPrice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">as.numeric</span><span class="p">(</span><span class="nf">median</span><span class="p">(</span><span class="n">price</span><span class="p">)),</span>
<span class="w">    </span><span class="n">Count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">.N</span>
<span class="w">  </span><span class="p">),</span><span class="w"> </span>
<span class="w">  </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cut</span>
<span class="p">][</span><span class="w"> </span>
<span class="w">  </span><span class="nf">order</span><span class="p">(</span><span class="o">-</span><span class="n">Count</span><span class="p">)</span><span class="w"> </span>
<span class="p">]</span>
</pre></div>

<p>除非您已经熟悉 data.table，否则很难遵循此代码。（我也无法弄清楚如何以<code>[</code>一种看起来不错的方式缩进重复）。就个人而言，当我看 6
个月前写的代码时，就像看陌生人写的代码一样，所以我更喜欢直接但冗长的代码。</p>
<p>我认为另外两个轻微降低可读性的次要因素：</p>
<ul>
<li>
<p>由于几乎每个数据表操作都使用<code>[</code>您需要额外的上下文来弄清楚发生了什么。例如，是<code>x[y]</code>连接两个数据表还是从数据框中提取列？这只是一个小问题，因为在编写良好的代码中，变量名应该表明正在发生的事情。</p>
</li>
<li>
<p>我喜欢这<code>group_by()</code>是 dplyr 中的一个单独操作。它从根本上改变了计算，所以我认为在浏览代码时应该很明显，而且<code>group_by()</code>比.<code>by``[.data.table</code></p>
</li>
</ul>
<p>我也喜欢管道不仅限于一个包装。您可以先使用tidyr整理数据，然后在ggvis中绘制图表。而且您不限于我编写的程序包 -
任何人都可以编写一个函数来形成数据操作管道的无缝部分。事实上，我更喜欢以前的 data.table 代码重写为<code>%&gt;%</code>：</p>
<div class="code"><pre class="code literal-block">diamonds %&gt;% 
  data.table() %&gt;% 
  .[cut != "Fair", 
    .(AvgPrice = mean(price),
      MedianPrice = as.numeric(median(price)),
      Count = .N
    ), 
    by = cut
  ] %&gt;% 
  .[order(-Count)]
</pre></div>

<p>pipe with 的想法<code>%&gt;%</code>不仅限于数据框架，而且很容易推广到其他上下文：交互式网络图形、网络抓取、要点、运行时合同……）</p>
<h3>内存和性能</h3>
<p>我把它们放在一起，因为对我来说，它们并不那么重要。大多数 R 用户使用的数据远少于 100 万行，而 dplyr
的速度足够快，足以处理您不知道处理时间的数据量。我们针对媒体数据的表现力优化了 dplyr；随意使用 data.table 来获得更大数据的原始速度。</p>
<p>dplyr 的灵活性还意味着您可以使用相同的语法轻松调整性能特征。如果带有数据框后端的 dplyr 的性能对您来说不够好，您可以使用 data.table
后端（尽管功能集有些受限）。如果您正在使用的数据不适合内存，那么您可以使用数据库后端。</p>
<p>尽管如此，从长远来看，dplyr 的性能会变得更好。我们肯定会实现 data.table
的一些很棒的想法，比如基数排序和使用相同的索引进行连接和过滤器。我们也在致力于并行化，以便我们可以利用多核。</p>
<h3>特征</h3>
<p>我们计划在 2015 年开展的一些工作：</p>
<ul>
<li>
<p>包<code>readr</code>，使从磁盘和内存中获取文件变得容易，类似于<code>fread()</code>.</p>
</li>
<li>
<p>更灵活的连接，包括对非等连接的支持。</p>
</li>
<li>
<p>更灵活的分组，如 bootstrap 样本、汇总等</p>
</li>
</ul>
<p>我还投入时间改进 R 的数据库连接器、与web api对话的能力，并使抓取 html 页面变得更容易。</p>
<p><br><br><a href="posts/data-table-vs-dplyr-can-one-do-something-well-the-other-can-t-or-does-poorly/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-shi-bie-yun-xing-python-de-cao-zuo-xi-tong/" class="u-url">如何识别运行 Python 的操作系统？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-shi-bie-yun-xing-python-de-cao-zuo-xi-tong/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:29:20+08:00" itemprop="datePublished" title="2023-02-17 10:29">2023-02-17 10:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我需要查看什么才能确定我是在 Windows 还是 Unix 等平台上？</p>
<p><br><br></p>
<h2>解答</h2>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span>
<span class="s1">'posix'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">platform</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
<span class="s1">'Linux'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="s1">'2.6.22-15-generic'</span>
</pre></div>

<p>的输出<code>platform.system()</code>如下：</p>
<ul>
<li>Linux：<code>Linux</code>
</li>
<li>苹果：<code>Darwin</code>
</li>
<li>视窗：<code>Windows</code>
</li>
</ul>
<p>请参阅：<code>platform</code>- 访问底层平台的识别数据</p>
<p><br></p>
<h3>更多建议</h3>
<p>该死的——Louis Brandy 先发制人，但这并不意味着我不能为您提供 Vista 的系统结果！</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span>
<span class="s1">'nt'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">platform</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
<span class="s1">'Windows'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="s1">'Vista'</span>
</pre></div>

<p>...而且我不敢相信还没有人发布适用于 Windows 10 的帖子：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span>
<span class="s1">'nt'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">platform</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
<span class="s1">'Windows'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">platform</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="s1">'10'</span>
</pre></div>

<p><br><br><a href="posts/how-to-identify-which-os-python-is-running-on/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-576.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-574.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
