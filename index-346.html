<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 346) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-346.html">
<link rel="prev" href="index-347.html" type="text/html">
<link rel="next" href="index-345.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-do-branch-tag-and-trunk-mean-in-subversion-repositories/" class="u-url">What do "branch", "tag" and "trunk" mean in Subversion repositories?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-do-branch-tag-and-trunk-mean-in-subversion-repositories/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:31:07+08:00" itemprop="datePublished" title="2023-02-17 04:31">2023-02-17 04:31</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I've seen these words a lot around Subversion (and I guess general repository)
discussions.<br>
I have been using <strong>SVN</strong> for my projects for the last few years, but I've
never grasped the complete concept of these directories.</p>
<p>What do they mean?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Hmm, not sure I agree with Nick re tag being similar to a branch. A tag is
just a marker</p>
<ul>
<li>
<p><strong>Trunk</strong> would be the main body of development, originating from the start of the project until the present.</p>
</li>
<li>
<p><strong>Branch</strong> will be a copy of code derived from a certain point in the trunk that is used for applying major changes to the code while preserving the integrity of the code in the trunk. If the major changes work according to plan, they are usually merged back into the trunk. </p>
</li>
<li>
<p><strong>Tag</strong> will be a point in time on the trunk or a branch that you wish to preserve. The two main reasons for preservation would be that either this is a major release of the software, whether alpha, beta, RC or RTM, or this is the most stable point of the software before major revisions on the trunk were applied.</p>
</li>
</ul>
<p>In open source projects, major branches that are not accepted into the trunk
by the project stakeholders can become the bases for <em>forks</em> -- e.g., totally
separate projects that share a common origin with other source code.</p>
<p>The branch and tag subtrees are distinguished from the trunk in the following
ways:</p>
<p>Subversion allows sysadmins to create <em>hook scripts</em> which are triggered for
execution when certain events occur; for instance, committing a change to the
repository. It is very common for a typical Subversion repository
implementation to treat any path containing "/tag/" to be write-protected
after creation; the net result is that tags, once created, are immutable (at
least to "ordinary" users). This is done via the hook scripts, which enforce
the immutability by preventing further changes if <strong>tag</strong> is a parent node of
the changed object.</p>
<p>Subversion also has added features, since version 1.5, relating to "branch
merge tracking" so that changes committed to a <strong>branch</strong> can be merged back
into the trunk with support for incremental, "smart" merging.</p>
<p><br></p>
<h3>Suggest</h3>
<p>First of all, as @AndrewFinnell and @KenLiu point out, in SVN the directory
names themselves mean nothing -- "trunk, branches and tags" are simply a
common convention that is used by most repositories. Not all projects use all
of the directories (it's reasonably common not to use "tags" at all), and in
fact, nothing is stopping you from calling them anything you'd like, though
breaking convention is often confusing.</p>
<p>I'll describe probably the most common usage scenario of branches and tags,
and give an example scenario of how they are used.</p>
<ul>
<li>
<p><strong>Trunk</strong> : The main development area. This is where your next major release of the code lives, and generally has all the newest features. </p>
</li>
<li>
<p><strong>Branches</strong> : Every time you release a major version, it gets a branch created. This allows you to do bug fixes and make a new release without having to release the newest - possibly unfinished or untested - features. </p>
</li>
<li>
<p><strong>Tags</strong> : Every time you release a version (final release, release candidates (RC), and betas) you make a tag for it. This gives you a point-in-time copy of the code as it was at that state, allowing you to go back and reproduce any bugs if necessary in a past version, or re-release a past version exactly as it was. Branches and tags in SVN are lightweight - on the server, it does not make a full copy of the files, just a marker saying "these files were copied at this revision" that only takes up a few bytes. With this in mind, you should never be concerned about creating a tag for any released code. As I said earlier, tags are often omitted and instead, a changelog or other document clarifies the revision number when a release is made.</p>
</li>
</ul>
<hr>
<p>For example, let's say you start a new project. You start working in "trunk",
on what will eventually be released as version 1.0.</p>
<ul>
<li><strong>trunk/ - development version, soon to be 1.0</strong></li>
<li>branches/ - empty</li>
</ul>
<p>Once 1.0.0 is finished, you branch trunk into a new "1.0" branch, and create a
"1.0.0" tag. Now work on what will eventually be 1.1 continues in trunk.</p>
<ul>
<li>trunk/ - development version, <strong>soon to be 1.1</strong>
</li>
<li><strong>branches/1.0 - 1.0.0 release version</strong></li>
<li><strong>tags/1.0.0 - 1.0.0 release version</strong></li>
</ul>
<p>You come across some bugs in the code, and fix them in trunk, and then merge
the fixes over to the 1.0 branch. You can also do the opposite, and fix the
bugs in the 1.0 branch and then merge them back to trunk, but commonly
projects stick with merging one-way only to lessen the chance of missing
something. Sometimes a bug can only be fixed in 1.0 because it is obsolete in
1.1. It doesn't really matter: you only want to make sure that you don't
release 1.1 with the same bugs that have been fixed in 1.0.</p>
<ul>
<li>trunk/ - development version, soon to be 1.1</li>
<li>branches/1.0 - <strong>upcoming 1.0.1 release</strong>
</li>
<li>tags/1.0.0 - 1.0.0 release version</li>
</ul>
<p>Once you find enough bugs (or maybe one critical bug), you decide to do a
1.0.1 release. So you make a tag "1.0.1" from the 1.0 branch, and release the
code. At this point, trunk will contain what will be 1.1, and the "1.0" branch
contains 1.0.1 code. The next time you release an update to 1.0, it would be
1.0.2.</p>
<ul>
<li>trunk/ - development version, soon to be 1.1</li>
<li>branches/1.0 - <strong>upcoming 1.0.2 release</strong>
</li>
<li>tags/1.0.0 - 1.0.0 release version</li>
<li><strong>tags/1.0.1 - 1.0.1 release version</strong></li>
</ul>
<p>Eventually you are almost ready to release 1.1, but you want to do a beta
first. In this case, you likely do a "1.1" branch, and a "1.1beta1" tag. Now,
work on what will be 1.2 (or 2.0 maybe) continues in trunk, but work on 1.1
continues in the "1.1" branch.</p>
<ul>
<li>trunk/ - development version, <strong>soon to be 1.2</strong>
</li>
<li>branches/1.0 - upcoming 1.0.2 release</li>
<li><strong>branches/1.1 - upcoming 1.1.0 release</strong></li>
<li>tags/1.0.0 - 1.0.0 release version</li>
<li>tags/1.0.1 - 1.0.1 release version</li>
<li><strong>tags/1.1beta1 - 1.1 beta 1 release version</strong></li>
</ul>
<p>Once you release 1.1 final, you do a "1.1" tag from the "1.1" branch.</p>
<p>You can also continue to maintain 1.0 if you'd like, porting bug fixes between
all three branches (1.0, 1.1, and trunk). The important takeaway is that for
every main version of the software you are maintaining, you have a branch that
contains the latest version of code for that version.</p>
<hr>
<p>Another use of branches is for features. This is where you branch trunk (or
one of your release branches) and work on a new feature in isolation. Once the
feature is completed, you merge it back in and remove the branch.</p>
<ul>
<li>trunk/ - development version, soon to be 1.2</li>
<li>branches/1.1 - upcoming 1.1.0 release</li>
<li><strong>branches/ui-rewrite - experimental feature branch</strong></li>
</ul>
<p>The idea of this is when you're working on something disruptive (that would
hold up or interfere with other people from doing their work), something
experimental (that may not even make it in), or possibly just something that
takes a long time (and you're afraid if it holding up a 1.2 release when
you're ready to branch 1.2 from trunk), you can do it in isolation in branch.
Generally you keep it up to date with trunk by merging changes into it all the
time, which makes it easier to re-integrate (merge back to trunk) when you're
finished.</p>
<hr>
<p>Also note, the versioning scheme I used here is just one of many. Some teams
would do bug fix/maintenance releases as 1.1, 1.2, etc., and major changes as
1.x, 2.x, etc. The usage here is the same, but you may name the branch "1" or
"1.x" instead of "1.0" or "1.0.x". (Aside, semantic versioning is a good guide
on how to do version numbers).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-pipe-stderr-and-not-stdout/" class="u-url">How can I pipe stderr, and not stdout?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-pipe-stderr-and-not-stdout/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:30:41+08:00" itemprop="datePublished" title="2023-02-17 04:30">2023-02-17 04:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have a program that writes information to <code>stdout</code> and <code>stderr</code>, and I need
to process the <code>stderr</code> with <code>grep</code>, leaving <code>stdout</code> aside.</p>
<p>Using a temporary file, one could do it in two steps:</p>
<div class="code"><pre class="code literal-block">command &gt; /dev/null 2&gt; temp.file
grep 'something' temp.file
</pre></div>

<p>But how can this be achieved without temp files, using one command and pipes?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>First redirect stderr to stdout — the pipe; then redirect stdout to
<code>/dev/null</code> (without changing where stderr is going):</p>
<div class="code"><pre class="code literal-block">command 2&gt;&amp;1 &gt;/dev/null | grep 'something'
</pre></div>

<p>For the details of I/O redirection in all its variety, see the chapter on
Redirections in the Bash reference manual.</p>
<p>Note that the sequence of I/O redirections is interpreted left-to-right, but
pipes are set up before the I/O redirections are interpreted. File descriptors
such as 1 and 2 are references to open file descriptions. The operation <code>2&gt;&amp;1</code>
makes file descriptor 2 aka stderr refer to the same open file description as
file descriptor 1 aka stdout is currently referring to (see <code>dup2()</code> and
<code>open()</code>). The operation <code>&gt;/dev/null</code> then changes file descriptor 1 so that
it refers to an open file description for <code>/dev/null</code>, but that doesn't change
the fact that file descriptor 2 refers to the open file description which file
descriptor 1 was originally pointing to — namely, the pipe.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Or to swap the output from standard error and standard output over, use:</p>
<div class="code"><pre class="code literal-block">command 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3
</pre></div>

<p>This creates a new file descriptor (3) and assigns it to the same place as 1
(standard output), then assigns fd 1 (standard output) to the same place as fd
2 (standard error) and finally assigns fd 2 (standard error) to the same place
as fd 3 (standard output).</p>
<p>Standard error is now available as standard output and the old standard output
is preserved in standard error. This may be overkill, but it hopefully gives
more details on Bash file descriptors (there are nine available to each
process).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/parsing-json-with-unix-tools/" class="u-url">Parsing JSON with Unix tools</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/parsing-json-with-unix-tools/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:30:10+08:00" itemprop="datePublished" title="2023-02-17 04:30">2023-02-17 04:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm trying to parse JSON returned from a curl request, like so:</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span><span class="w"> </span><span class="s1">'http://twitter.com/users/username.json'</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="n">sed</span><span class="w"> </span><span class="o">-</span><span class="n">e</span><span class="w"> </span><span class="s1">'s/[{}]/''/g'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="n">awk</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="ss">"text"</span><span class="w"> </span><span class="s1">'{n=split($0,a,","); for (i=1; i&lt;=n; i++) print a[i]}'</span>
</pre></div>

<p>The above splits the JSON into fields, for example:</p>
<div class="code"><pre class="code literal-block"><span class="c">% ...</span>
<span class="s">"geo_enabled"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"friends_count"</span><span class="p">:</span><span class="mi">245</span>
<span class="s">"profile_text_color"</span><span class="p">:</span><span class="s">"000000"</span>
<span class="s">"status"</span><span class="p">:</span><span class="s">"in_reply_to_screen_name"</span><span class="p">:</span><span class="nb">null</span>
<span class="s">"source"</span><span class="p">:</span><span class="s">"web"</span>
<span class="s">"truncated"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"text"</span><span class="p">:</span><span class="s">"My status"</span>
<span class="s">"favorited"</span><span class="p">:</span><span class="nb">false</span>
<span class="c">% ...</span>
</pre></div>

<p>How do I print a specific field (denoted by the <code>-v k=text</code>)?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>There are a number of tools specifically designed for the purpose of
manipulating JSON from the command line, and will be a lot easier and more
reliable than doing it with Awk, such as <code>jq</code>:</p>
<div class="code"><pre class="code literal-block">curl -s 'https://api.github.com/users/lambda' | jq -r '.name'
</pre></div>

<p>You can also do this with tools that are likely already installed on your
system, like Python using the <code>json</code> module, and so avoid any extra
dependencies, while still having the benefit of a proper JSON parser. The
following assume you want to use UTF-8, which the original JSON should be
encoded in and is what most modern terminals use as well:</p>
<p>Python 3:</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python3</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print(json.load(sys.stdin)['name'])"</span>
</pre></div>

<p>Python 2:</p>
<div class="code"><pre class="code literal-block"><span class="n">export</span> <span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python2</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print json.load(sys.stdin)['name']"</span>
</pre></div>

<h3>Frequently Asked Questions</h3>
<h4>Why not a pure shell solution?</h4>
<p>The standard POSIX/Single Unix Specification shell is a very limited language
which doesn't contain facilities for representing sequences (list or arrays)
or associative arrays (also known as hash tables, maps, dicts, or objects in
some other languages). This makes representing the result of parsing JSON
somewhat tricky in portable shell scripts. There are somewhat hacky ways to do
it, but many of them can break if keys or values contain certain special
characters.</p>
<p>Bash 4 and later, zsh, and ksh have support for arrays and associative arrays,
but these shells are not universally available (macOS stopped updating Bash at
Bash 3, due to a change from GPLv2 to GPLv3, while many Linux systems don't
have zsh installed out of the box). It's possible that you could write a
script that would work in either Bash 4 or zsh, one of which is available on
most macOS, Linux, and BSD systems these days, but it would be tough to write
a shebang line that worked for such a polyglot script.</p>
<p>Finally, writing a full fledged JSON parser in shell would be a significant
enough dependency that you might as well just use an existing dependency like
jq or Python instead. It's not going to be a one-liner, or even small five-
line snippet, to do a good implementation.</p>
<h4>Why not use awk, sed, or grep?</h4>
<p>It is possible to use these tools to do some quick extraction from JSON with a
known shape and formatted in a known way, such as one key per line. There are
several examples of suggestions for this in other answers.</p>
<p>However, these tools are designed for line based or record based formats; they
are not designed for recursive parsing of matched delimiters with possible
escape characters.</p>
<p>So these quick and dirty solutions using awk/sed/grep are likely to be
fragile, and break if some aspect of the input format changes, such as
collapsing whitespace, or adding additional levels of nesting to the JSON
objects, or an escaped quote within a string. A solution that is robust enough
to handle all JSON input without breaking will also be fairly large and
complex, and so not too much different than adding another dependency on <code>jq</code>
or Python.</p>
<p>I have had to deal with large amounts of customer data being deleted due to
poor input parsing in a shell script before, so I never recommend quick and
dirty methods that may be fragile in this way. If you're doing some one-off
processing, see the other answers for suggestions, but I still highly
recommend just using an existing tested JSON parser.</p>
<h3>Historical notes</h3>
<p>This answer originally recommended jsawk, which should still work, but is a
little more cumbersome to use than <code>jq</code>, and depends on a standalone
JavaScript interpreter being installed which is less common than a Python
interpreter, so the above answers are probably preferable:</p>
<div class="code"><pre class="code literal-block"><span class="nv">curl</span><span class="w"> </span><span class="o">-</span><span class="nv">s</span><span class="w"> </span><span class="s1">'https://api.github.com/users/lambda'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">jsawk</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="s1">'return this.name'</span>
</pre></div>

<p>This answer also originally used the Twitter API from the question, but that
API no longer works, making it hard to copy the examples to test out, and the
new Twitter API requires API keys, so I've switched to using the GitHub API
which can be used easily without API keys. The first answer for the original
question would be:</p>
<div class="code"><pre class="code literal-block">curl 'http://twitter.com/users/username.json' | jq -r '.text'
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>To quickly extract the values for a particular key, I personally like to use
"grep -o", which only returns the regex's match. For example, to get the
"text" field from tweets, something like:</p>
<div class="code"><pre class="code literal-block">grep -Po '"text":.*?[^\\]",' tweets.json
</pre></div>

<p>This regex is more robust than you might think; for example, it deals fine
with strings having embedded commas and escaped quotes inside them. I think
with a little more work you could make one that is actually guaranteed to
extract the value, if it's atomic. (If it has nesting, then a regex can't do
it of course.)</p>
<p>And to further clean (albeit keeping the string's original escaping) you can
use something like: <code>| perl -pe 's/"text"://; s/^"//; s/",$//'</code>. (I did this
for this analysis.)</p>
<p>To all the haters who insist you should use a real JSON parser -- yes, that is
essential for correctness, but</p>
<ol>
<li>To do a really quick analysis, like counting values to check on data cleaning bugs or get a general feel for the data, banging out something on the command line is faster. Opening an editor to write a script is distracting.</li>
<li>
<code>grep -o</code> is orders of magnitude faster than the Python standard <code>json</code> library, at least when doing this for tweets (which are ~2 KB each). I'm not sure if this is just because <code>json</code> is slow (I should compare to yajl sometime); but in principle, a regex should be faster since it's finite state and much more optimizable, instead of a parser that has to support recursion, and in this case, spends lots of CPU building trees for structures you don't care about. (If someone wrote a finite state transducer that did proper (depth-limited) JSON parsing, that would be fantastic! In the meantime we have "grep -o".)</li>
</ol>
<p>To write maintainable code, I always use a real parsing library. I haven't
tried jsawk, but if it works well, that would address point #1.</p>
<p>One last, wackier, solution: I wrote a script that uses Python <code>json</code> and
extracts the keys you want, into tab-separated columns; then I pipe through a
wrapper around <code>awk</code> that allows named access to columns. In here: the
json2tsv and tsvawk scripts. So for this example it would be:</p>
<div class="code"><pre class="code literal-block">json2tsv id text &lt; tweets.json | tsvawk '{print "tweet " $id " is: " $text}'
</pre></div>

<p>This approach doesn't address #2, is more inefficient than a single Python
script, and it's a little brittle: it forces normalization of newlines and
tabs in string values, to play nice with awk's field/record-delimited view of
the world. But it does let you stay on the command line, with more correctness
than <code>grep -o</code>.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-347.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-345.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
