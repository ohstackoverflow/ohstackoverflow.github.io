<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 378) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-378.html">
<link rel="prev" href="index-379.html" type="text/html">
<link rel="next" href="index-377.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/" class="u-url">分组函数（tapply、by、aggregate）和 *apply 系列</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:24:17+08:00" itemprop="datePublished" title="2023-02-17 05:24">2023-02-17 05:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>每当我想在 R 中做一些“映射”py 时，我通常会尝试使用家族中的函数<code>apply</code>。</p>
<p>然而，我从来没有完全理解它们之间的区别——如何将函数应用到输入/分组输入，输出看起来像什么，甚至输入可以是什么——所以我<code>sapply</code>经常<code>lapply</code>只是通过他们，直到我得到我想要的。</p>
<p>有人可以解释一下何时使用哪个吗？</p>
<p>我目前（可能不正确/不完整）的理解是......</p>
<ol>
<li>
<p><code>sapply(vec, f)</code>：输入是一个向量。output 是一个向量/矩阵，其中 element<code>i</code>是，如果有一个多元素输出，<code>f(vec[i])</code>则给你一个矩阵<code>f</code></p>
</li>
<li>
<p><code>lapply(vec, f)</code>: 与 相同<code>sapply</code>，但输出是一个列表？</p>
</li>
<li>
<p><code>apply(matrix, 1/2, f)</code>：输入是一个矩阵。输出是一个向量，其中元素<code>i</code>是 f（矩阵的行/列 i）</p>
</li>
<li>
<code>tapply(vector, grouping, f)</code>：输出是一个矩阵/数组，其中矩阵/数组中的元素是向量<code>f</code>分组中的值，并被推送到行/列名称<code>g``g</code>
</li>
<li>
<code>by(dataframe, grouping, f)</code>: 让我们<code>g</code>成为一个分组。适用<code>f</code>于组/数据框的每一列。<code>f</code>漂亮地打印每列的分组和值。</li>
<li>
<code>aggregate(matrix, grouping, f)</code>：类似于<code>by</code>，但聚合不是漂亮地打印输出，而是将所有内容粘贴到数据框中。</li>
</ol>
<p>附带问题：我还没有学会 plyr 或 reshape —— 会<code>plyr</code>或<code>reshape</code>完全取代所有这些吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>R 有许多 <em>apply
函数，这些函数在帮助文件（例如<code>?apply</code>）中有巧妙的描述。但是，它们已经足够多了，初学者可能难以决定哪一个适合他们的情况，甚至难以记住它们。他们可能有一种普遍的感觉，即“我应该在这里使用
</em>apply 函数”，但一开始很难让他们保持直截了当。</p>
<p>尽管事实（在其他答案中指出） *apply 系列的大部分功能都包含在非常流行的<code>plyr</code>包中，但基本功能仍然有用且值得了解。</p>
<p>该答案旨在充当新用户的一种 <strong>路标</strong> ，以帮助将他们引导至针对其特定问题的正确 <em>apply 功能。请注意，这并不是 </em><em>简单</em><em> 地重复或替换 R
文档！希望这个答案可以帮助您决定哪个 </em>apply 函数适合您的情况，然后由您进一步研究。除了一个例外，性能差异将不会被解决。</p>
<ul>
<li>
<p><strong>apply</strong> - <em>当你想将一个函数应用于矩阵的行或列（和更高维的类似物）时； 通常不建议用于数据帧，因为它会首先强制转换为矩阵。</em></p>
<div class="code"><pre class="code literal-block"> # Two dimensional matrix
</pre></div>

<p>M &lt;- matrix(seq(1,16), 4, 4)</p>
<p># apply min to rows
 apply(M, 1, min)
 [1] 1 2 3 4</p>
<p># apply max to columns
 apply(M, 2, max)
 [1]  4  8 12 16</p>
<p># 3 dimensional array
 M &lt;- array( seq(32), dim = c(4,4,2))</p>
<p># Apply sum across each M[*, , ] - i.e Sum across 2nd and 3rd dimension
 apply(M, 1, sum)
 # Result is one-dimensional
 [1] 120 128 136 144</p>
<p># Apply sum across each M[<em>, </em>, ] - i.e Sum across 3rd dimension
 apply(M, c(1,2), sum)
 # Result is two-dimensional
      [,1] [,2] [,3] [,4]
 [1,]   18   26   34   42
 [2,]   20   28   36   44
 [3,]   22   30   38   46
 [4,]   24   32   40   48</p>
</li>
</ul>
<p>如果您想要二维矩阵的行/列均值或求和，请务必研究高度优化的、闪电般快速的<code>colMeans</code>, <code>rowMeans</code>, <code>colSums</code>,
<code>rowSums</code>。</p>
<ul>
<li>
<strong>lapply</strong> - <em>当您想依次将函数应用于列表的每个元素并获取列表时。</em>
</li>
</ul>
<p>这是许多其他 *apply 函数的主力。翻开他们的代码，您通常会<code>lapply</code>在下面找到它们。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="nf">lapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="o">$</span><span class="n">a</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">1</span>
<span class="w"> </span><span class="o">$</span><span class="n">b</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">3</span>
<span class="w"> </span><span class="o">$</span><span class="n">c</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">91</span>
<span class="w"> </span><span class="nf">lapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="o">$</span><span class="n">a</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">1</span>
<span class="w"> </span><span class="o">$</span><span class="n">b</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">6</span>
<span class="w"> </span><span class="o">$</span><span class="n">c</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">5005</span>
</pre></div>

<ul>
<li>
<strong>sapply</strong> - <em>当您想依次将函数应用于列表的每个元素时，但您想要返回一个 <strong>向量</strong> 而不是列表。</em>
</li>
</ul>
<p>如果您发现自己在打字<code>unlist(lapply(...))</code>，请停下来考虑一下<code>sapply</code>。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span>
<span class="w"> </span><span class="c1"># Compare with above; a named vector, not a list </span>
<span class="w"> </span><span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w">  </span>
<span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="n">b</span><span class="w">  </span><span class="n">c</span><span class="w">   </span>
<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">91</span>

<span class="w"> </span><span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">   </span>
<span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="n">b</span><span class="w">    </span><span class="n">c</span><span class="w">    </span>
<span class="w"> </span><span class="m">1</span><span class="w">    </span><span class="m">6</span><span class="w"> </span><span class="m">5005</span>
</pre></div>

<p>在更高级的使用中，<code>sapply</code>如果合适，它将尝试将结果强制转换为多维数组。例如，如果我们的函数返回相同长度的向量，<code>sapply</code>将把它们用作矩阵的列：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) rnorm(3,x))
</pre></div>

<p>如果我们的函数返回一个二维矩阵，<code>sapply</code>将做基本相同的事情，将每个返回的矩阵视为一个长向量：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) matrix(x,2,2))
</pre></div>

<p>除非我们指定<code>simplify = "array"</code>，在这种情况下它将使用单个矩阵来构建多维数组：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) matrix(x,2,2), simplify = "array")
</pre></div>

<p>当然，这些行为中的每一个都取决于我们的函数返回相同长度或维度的向量或矩阵。</p>
<ul>
<li>
<strong>vapply</strong> - <em>当您想要使用<code>sapply</code>但可能需要从您的代码中挤出更多速度或想要更多类型安全时。</em>
</li>
</ul>
<p>对于<code>vapply</code>，您基本上为 R 提供了一个示例，说明您的函数将返回什么样的东西，这可以节省一些时间来强制返回值以适应单个原子向量。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span>
<span class="w"> </span><span class="c1">#Note that since the advantage here is mainly speed, this</span>
<span class="w"> </span><span class="c1"># example is only for illustration. We're telling R that</span>
<span class="w"> </span><span class="c1"># everything returned by length() should be an integer of </span>
<span class="w"> </span><span class="c1"># length 1. </span>
<span class="w"> </span><span class="nf">vapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">FUN.VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0L</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="n">b</span><span class="w">  </span><span class="n">c</span><span class="w">  </span>
<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">91</span>
</pre></div>

<ul>
<li>
<strong>mapply</strong> - <em>当你有多个数据结构（例如向量，列表）并且你想将一个函数应用于每个的第一个元素，然后是每个的第二个元素，等等，将结果强制转换为向量/数组，如<code>sapply</code>.</em>
</li>
</ul>
<p>这是多元的，因为你的函数必须接受多个参数。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span>#<span class="nv">Sums</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="mi">1</span><span class="nv">st</span><span class="w"> </span><span class="nv">elements</span>,<span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="mi">2</span><span class="nv">nd</span><span class="w"> </span><span class="nv">elements</span>,<span class="w"> </span><span class="nv">etc</span>.<span class="w"> </span>
<span class="w"> </span><span class="nv">mapply</span><span class="ss">(</span><span class="nv">sum</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span><span class="ss">)</span><span class="w"> </span>
<span class="w"> </span>[<span class="mi">1</span>]<span class="w">  </span><span class="mi">3</span><span class="w">  </span><span class="mi">6</span><span class="w">  </span><span class="mi">9</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">15</span>
<span class="w"> </span>#<span class="nv">To</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">rep</span><span class="ss">(</span><span class="mi">1</span>,<span class="mi">4</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">rep</span><span class="ss">(</span><span class="mi">2</span>,<span class="mi">3</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">etc</span>.
<span class="w"> </span><span class="nv">mapply</span><span class="ss">(</span><span class="nv">rep</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">4</span>,<span class="w"> </span><span class="mi">4</span>:<span class="mi">1</span><span class="ss">)</span><span class="w">   </span>
<span class="w"> </span>[[<span class="mi">1</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span>

<span class="w"> </span>[[<span class="mi">2</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span>

<span class="w"> </span>[[<span class="mi">3</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span>

<span class="w"> </span>[[<span class="mi">4</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">4</span>
</pre></div>

<ul>
<li>
<p><strong>Map</strong> - <em>with</em> <em>的包装器 ，因此它保证返回一个列表。<code>mapply``SIMPLIFY = FALSE</code></em></p>
<div class="code"><pre class="code literal-block"> Map(sum, 1:5, 1:5, 1:5)
</pre></div>

<p>[[1]]
 [1] 3</p>
<p>[[2]]
 [1] 6</p>
<p>[[3]]
 [1] 9</p>
<p>[[4]]
 [1] 12</p>
<p>[[5]]
 [1] 15</p>
</li>
<li>
<p><strong>rapply</strong> - <em>当你想递归地将函数应用于 <strong>嵌套列表</strong> 结构的每个元素时。</em></p>
</li>
</ul>
<p>为了让您了解这有多不常见<code>rapply</code>，我在第一次发布此答案时忘记了它！显然，我敢肯定很多人都在使用它，但是
YMMV。<code>rapply</code>最好用一个用户定义的函数来说明：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1"># Append ! to string, otherwise increment</span>
<span class="w"> </span><span class="n">myFun</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
<span class="w">     </span><span class="nf">if</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">x</span><span class="p">)){</span>
<span class="w">       </span><span class="nf">return</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">"!"</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">""</span><span class="p">))</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="n">else</span><span class="p">{</span>
<span class="w">       </span><span class="nf">return</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">#A nested list structure</span>
<span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Boo"</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Eeek"</span><span class="p">),</span><span class="w"> </span>
<span class="w">           </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Yikes"</span><span class="p">,</span><span class="w"> </span>
<span class="w">           </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hey"</span><span class="p">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)))</span>


<span class="w"> </span><span class="c1"># Result is named vector, coerced to character          </span>
<span class="w"> </span><span class="nf">rapply</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">myFun</span><span class="p">)</span>

<span class="w"> </span><span class="c1"># Result is a nested list like l, with values altered</span>
<span class="w"> </span><span class="nf">rapply</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">myFun</span><span class="p">,</span><span class="w"> </span><span class="n">how</span><span class="o">=</span><span class="s">"replace"</span><span class="p">)</span>
</pre></div>

<ul>
<li>
<strong>tapply</strong> - <em>当您想要将函数应用于向量的 <strong>子集</strong> 并且子集由某个其他向量定义时，通常是一个因子。</em>
</li>
</ul>
<p>*apply 家族的害群之马。帮助文件中使用的短语“参差不齐的数组”可能有点令人困惑，但实际上非常简单。</p>
<p>向量：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">20</span>
</pre></div>

<p>定义组的因子（长度相同！）：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="kc">letters</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">],</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">))</span>
</pre></div>

<p><code>x</code>将以下定义的每个子组中的值相加<code>y</code>：</p>
<div class="code"><pre class="code literal-block">     tapply(x, y, sum)  
  a  b  c  d  e  
 10 26 42 58 74
</pre></div>

<p>可以处理更复杂的示例，其中子组由多个因素列表的唯一组合定义。<code>tapply</code>在精神上类似于 R 中常见的拆分-应用-
组合函数（<code>aggregate</code>、<code>by</code>、<code>ave</code>、<code>ddply</code>等），因此它是害群之马。</p>
<p><br></p>
<h3>更多建议</h3>
<p>在旁注中，这里是各种<code>plyr</code>功能如何对应于基本<code>*apply</code>功能（来自 plyr 网页http://had.co.nz/plyr/的介绍到 plyr
文档）</p>
<div class="code"><pre class="code literal-block"><span class="n">Base</span><span class="w"> </span><span class="k">function</span><span class="w">   </span><span class="n">Input</span><span class="w">   </span><span class="n">Output</span><span class="w">   </span><span class="n">plyr</span><span class="w"> </span><span class="k">function</span><span class="w"> </span>
<span class="o">---------------------------------------</span>
<span class="n">aggregate</span><span class="w">        </span><span class="n">d</span><span class="w">       </span><span class="n">d</span><span class="w">       </span><span class="n">ddply</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">colwise</span><span class="w"> </span>
<span class="n">apply</span><span class="w">            </span><span class="n">a</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">aaply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">alply</span><span class="w"> </span>
<span class="n">by</span><span class="w">               </span><span class="n">d</span><span class="w">       </span><span class="n">l</span><span class="w">       </span><span class="n">dlply</span><span class="w"> </span>
<span class="n">lapply</span><span class="w">           </span><span class="n">l</span><span class="w">       </span><span class="n">l</span><span class="w">       </span><span class="n">llply</span><span class="w">  </span>
<span class="n">mapply</span><span class="w">           </span><span class="n">a</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">maply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mlply</span><span class="w"> </span>
<span class="n">replicate</span><span class="w">        </span><span class="n">r</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">raply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">rlply</span><span class="w"> </span>
<span class="n">sapply</span><span class="w">           </span><span class="n">l</span><span class="w">       </span><span class="n">a</span><span class="w">       </span><span class="n">laply</span>
</pre></div>

<p>的目标之一<code>plyr</code>是为每个函数提供一致的命名约定，在函数名称中对输入和输出数据类型进行编码。它还提供了输出的一致性，因为输出<code>dlply()</code>可以很容易地传递到<code>ldply()</code>以产生有用的输出等。</p>
<p>从概念上讲，学习<code>plyr</code>并不比理解基本函数更难<code>*apply</code>。</p>
<p><code>plyr``reshape</code>在我的日常使用中，功能几乎取代了所有这些功能。但是，同样来自 Intro to Plyr 文档：</p>
<blockquote>
<p>相关函数在 中<code>tapply</code>没有<code>sweep</code>相应的函数<code>plyr</code>，仍然有用。<code>merge</code>对于将摘要与原始数据相结合很有用。</p>
</blockquote>
<p><br><br><a href="posts/grouping-functions-tapply-by-aggregate-and-the-apply-family/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-python-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-bu-er-zhi/" class="u-url">在 Python 中将字符串转换为布尔值</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-python-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-bu-er-zhi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:23:49+08:00" itemprop="datePublished" title="2023-02-17 05:23">2023-02-17 05:23</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何在 Python 中将字符串转换为布尔值？此尝试返回<code>True</code>：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; bool("False")
True
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>实际上，您只需将字符串与您希望接受的代表 true 的任何内容进行比较，这样您就可以这样做：</p>
<div class="code"><pre class="code literal-block">s == 'True'
</pre></div>

<p>或者检查一大堆值：</p>
<div class="code"><pre class="code literal-block">s.lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']
</pre></div>

<p>使用以下内容时要小心：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; bool("foo")
True
&gt;&gt;&gt; bool("")
False
</pre></div>

<p>空字符串的计算结果为<code>False</code>，但其他所有内容的计算结果为<code>True</code>。所以这不应该用于任何类型的解析目的。</p>
<p><br></p>
<h3>更多建议</h3>
<h5>警告：从 Python 3.12 开始，这个答案将不再有效（从 3.10 开始不推荐使用）</h5>
<p>使用：</p>
<div class="code"><pre class="code literal-block">bool(distutils.util.strtobool(some_string))
</pre></div>

<ul>
<li>
<strong>Python 2</strong> ：http ://docs.python.org/2/distutils/apiref.html?highlight=distutils.util#distutils.util.strtobool</li>
<li>
<strong>Python &gt;=3, &lt;3.12</strong>：https://docs.python.org/3/distutils/apiref.html#distutils.util.strtobool</li>
<li>
<strong>Python &gt;=3.12</strong>：由于PEP 632，不再是标准库的一部分</li>
</ul>
<blockquote>
<p>真值为 y、yes、t、true、on 和 1；false 值为 n、no、f、false、off 和 0。如果 val 是其他值，则引发
ValueError。</p>
</blockquote>
<p>请注意，<code>distutils.util.strtobool()</code>返回整数表示形式，因此需要将其包装起来<code>bool()</code>以获得布尔值。</p>
<p>鉴于 distutils 将不再是标准库的一部分，这里是代码<code>distutils.util.strtobool()</code>（参见源代码）。</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">strtobool</span><span class="w"> </span><span class="ss">(</span><span class="nv">val</span><span class="ss">)</span>:
<span class="w">    </span><span class="s2">""</span><span class="err">"Convert a string representation of truth to true (1) or false (0).</span>
<span class="err">    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values</span>
<span class="err">    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if</span>
<span class="err">    'val' is anything else.</span>
<span class="w">    </span><span class="s2">""</span><span class="err">"</span>
<span class="err">    val = val.lower()</span>
<span class="err">    if val in ('y', 'yes', 't', 'true', 'on', '1'):</span>
<span class="err">        return 1</span>
<span class="err">    elif val in ('n', 'no', 'f', 'false', 'off', '0'):</span>
<span class="err">        return 0</span>
<span class="err">    else:</span>
<span class="w">        </span><span class="nv">raise</span><span class="w"> </span><span class="nv">ValueError</span><span class="ss">(</span><span class="s2">"invalid truth value %r"</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="ss">(</span><span class="nv">val</span>,<span class="ss">))</span>
</pre></div>

<p><br><br><a href="posts/converting-from-a-string-to-boolean-in-python/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/websockets-yu-fu-wu-qi-fa-song-de-shi-jian-eventsource/" class="u-url">WebSockets 与服务器发送的事件/EventSource</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/websockets-yu-fu-wu-qi-fa-song-de-shi-jian-eventsource/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:23:20+08:00" itemprop="datePublished" title="2023-02-17 05:23">2023-02-17 05:23</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>WebSockets和Server-Sent
Events都能够将数据推送到浏览器。对我来说，它们似乎是相互竞争的技术。它们之间有什么区别？你什么时候会选择一个而不是另一个？</p>
<p><br><br></p>
<h2>解答</h2>
<p>Websockets 和 SSE（服务器发送事件）都能够将数据推送到浏览器，但它们不是竞争技术。</p>
<p>Websockets 连接既可以向浏览器发送数据，也可以从浏览器接收数据。可以使用 websockets 的应用程序的一个很好的例子是聊天应用程序。</p>
<p>SSE 连接只能向浏览器推送数据。在线股票报价或更新时间线或提要的推特是可以从 SSE 中受益的应用程序的好例子。</p>
<p>在实践中，由于可以用 SSE 完成的所有事情也可以用 Websockets 完成，因此 Websockets 得到了更多的关注和喜爱，支持
Websockets 的浏览器比 SSE 多得多。</p>
<p>但是，对于某些类型的应用程序来说，它可能有点矫枉过正，后端可以更容易地使用 SSE 等协议来实现。</p>
<p>此外，可以使用 JavaScript 将 SSE 填充到不原生支持它的旧浏览器中。SSE polyfill 的一些实现可以在Modernizr github
页面上找到。</p>
<p><strong>陷阱：</strong></p>
<ul>
<li>SSE 受到最大打开连接数的限制，这在打开各种选项卡时会特别痛苦，因为限制是针对每个 <em>浏览器的</em> ，并且设置为非常低的数量 (6)。该问题已在Chrome和Firefox中标记为“Won't fix” 。此限制是针对每个浏览器 + 域的，因此这意味着您可以在所有选项卡上打开 6 个 SSE 连接，<code>www.example1.com</code>并打开另外 6 个 SSE 连接<code>www.example2.com</code>（感谢 Phate）。</li>
<li>只有 WS 可以同时传输二进制数据和 UTF-8，SSE 仅限于 UTF-8。（感谢 Chado Nihi）。</li>
<li>一些具有数据包检查功能的企业防火墙在处理 WebSocket 时遇到问题（Sophos XG Firewall、WatchGuard、McAfee Web Gateway）。</li>
</ul>
<p>HTML5Rocks有一些关于 SSE 的好信息。从那个页面：</p>
<blockquote>
<h2>服务器发送的事件与 WebSockets</h2>
<p>为什么选择服务器发送事件而不是 WebSockets？好问题。</p>
<p>SSE 一直处于阴影中的一个原因是因为后来的 API（如
WebSockets）提供了更丰富的协议来执行双向、全双工通信。拥有双向通道对于游戏、消息传递应用程序以及需要双向近乎实时更新的情况更具吸引力。但是，在某些情况下，不需要从客户端发送数据。您只需要来自某些服务器操作的更新。一些例子是朋友的状态更新、股票代码、新闻提要或其他自动数据推送机制（例如更新客户端
Web SQL 数据库或 IndexedDB 对象存储）。如果您需要向服务器发送数据，XMLHttpRequest 永远是您的好帮手。</p>
<p>SSE 通过传统 HTTP 发送。这意味着它们不需要特殊的协议或服务器实现即可工作。另一方面，WebSockets 需要全双工连接和新的 Web
Socket 服务器来处理协议。此外，Server-Sent Events 具有 WebSockets 在设计上缺乏的各种功能，例如自动重新连接、事件
ID 和发送任意事件的能力。</p>
</blockquote>
<hr>
<h2>TLDR 摘要：</h2>
<p><strong>SSE 相对于 Websockets 的优势：</strong></p>
<ul>
<li>通过简单的 HTTP 而不是自定义协议传输</li>
<li>可以用 javascript 填充以将 SSE“反向移植”到尚不支持它的浏览器。</li>
<li>内置对重新连接和事件 ID 的支持</li>
<li>更简单的协议</li>
<li>公司防火墙进行数据包检查没有问题</li>
</ul>
<p><strong>Websockets 相对于 SSE 的优势：</strong></p>
<ul>
<li>实时、双向通信。</li>
<li>更多浏览器的原生支持</li>
</ul>
<p><strong>SSE 的理想用例：</strong></p>
<ul>
<li>股票代码流</li>
<li>推特提要更新</li>
<li>浏览器通知</li>
</ul>
<p><strong>SSE陷阱：</strong></p>
<ul>
<li>没有二进制支持</li>
<li>最大打开连接限制</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>根据 caniuse.com：</p>
<ul>
<li>98.35% 的全球用户原生支持 WebSockets</li>
<li>98.03% 的全球用户原生支持服务器发送的事件</li>
</ul>
<p>您可以使用仅限客户端的 polyfill 将 SSE 的支持扩展到许多其他浏览器。对于 WebSockets，这种情况不太可能发生。一些
EventSource polyfill：</p>
<ul>
<li>Remy Sharp 的EventSource，没有其他库依赖项 (IE7+)</li>
<li>jQuery.EventSource作者：Rick Waldron</li>
<li>Yaffle的EventSource（替换本机实现，规范跨浏览器的行为）</li>
</ul>
<p>如果您需要支持所有浏览器，请考虑使用像web-socket-js、SignalR或socket.io这样的库，它们支持多种传输，例如
WebSockets、SSE、Forever Frame 和 AJAX 长轮询。这些通常也需要对服​​务器端进行修改。</p>
<p>从以下位置了解有关 SSE 的更多信息：</p>
<ul>
<li>HTML5 摇滚文章</li>
<li>W3C 规范（已发布版本，编辑草稿）</li>
</ul>
<p>从以下位置了解有关 WebSocket 的更多信息：</p>
<ul>
<li>HTML5 摇滚文章</li>
<li>W3C 规范（已发布版本，编辑草稿）</li>
</ul>
<p>其他区别：</p>
<ul>
<li>WebSockets支持任意二进制数据，SSE只使用UTF-8</li>
</ul>
<p><br><br><a href="posts/websockets-vs-server-sent-events-eventsource/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-379.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-377.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
