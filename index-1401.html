<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1401) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1401.html">
<link rel="prev" href="index-1402.html" type="text/html">
<link rel="next" href="index-1400.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/time-complexity-of-uniform-cost-search/" class="u-url">Time complexity of uniform-cost search</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/time-complexity-of-uniform-cost-search/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:13:47+08:00" itemprop="datePublished" title="2023-02-28 03:13">2023-02-28 03:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am reading the book <em>Artificial Intelligence: A Modern Approach</em>. I came
across this sentence describing the time complexity of uniform cost search:</p>
<blockquote>
<p>Uniform-cost search is guided by path costs rather than depths, so its
complexity is not easily characterized in terms of b and d. Instead, let C
be the cost of the optimal solution, and assume that every action costs at
least ε. Then the algorithm’s worst-case time and space complexity is
O(b^(1+C/ε)), which can be much greater than b^d.</p>
</blockquote>
<p>As to my understanding, C is the cost of the optimal solution, and every
action costs at least ε, so that C/ε would be the number of steps taken to the
destination. But I don't know how the complexity is derived.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>If the branching factor is b, every time you expand out a node, you will
encounter k more nodes. Therefore, there are</p>
<ul>
<li>1 node at level 0,</li>
<li>b nodes at level 1,</li>
<li>b2 nodes at level 2,</li>
<li>b3 nodes at level 3,</li>
<li>...</li>
<li>bk nodes at level k.</li>
</ul>
<p>So let's suppose that the search stops after you reach level k. When this
happens, the total number of nodes you'll have visited will be</p>
<blockquote>
<p>1 + b + b2 + ... + bk = (bk+1 - 1) / (b - 1)</p>
</blockquote>
<p>That equality follows from the sum of a geometric series. It happens to be the
case that bk+1 / (b - 1) = O(bk), so if your goal node is in layer k, then you
have to expand out O(bk) total nodes to find the one you want.</p>
<p>If C is your destination cost and each step gets you ε closer to the goal, the
number of steps you need to take is given by C / ε + 1. The reason for the +1
is that you start at distance 0 and end at C / ε, so you take steps at
distances</p>
<blockquote>
<p>0, ε, 2ε, 3ε, ..., (C / ε)ε</p>
</blockquote>
<p>And there are 1 + C / ε total steps here. Therefore, there are 1 + C / ε
layers, and so the total number of states you need to expand is O(b(1 + C /
ε)).</p>
<p>Hope this helps!</p>
<p><br></p>
<h3>Suggest</h3>
<p>templatetypedef's answer is somewhat incorrect. The +1 has nothing to do with
the fact that the starting depth is 0. If every step cost is at least ε &gt; 0,
and the cost of optimal solution is C, then the maximum depth of the optimal
solution occurs at floor(C / ε). But the worst case time/space complexity is
in fact O(b(1+floor(C/ε)). The +1 arises because in UCS, we only check whether
a node is a goal when we select it for expansion, and not when we generate it
(this is to ensure optimality). So in the worst case, we could potentially
generate the entire level of nodes that comes after the goal node's residing
level (this explains the +1). In comparison, BFS applies the goal test when
nodes are generated, so there is no corresponding +1 factor. This is a very
important point that he missed.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-there-any-self-improving-compiler-around/" class="u-url">Is there any self-improving compiler around?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-there-any-self-improving-compiler-around/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:13:25+08:00" itemprop="datePublished" title="2023-02-28 03:13">2023-02-28 03:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am not aware of any self-improving compiler, but then again I am not much of
a compiler-guy.</p>
<p><strong>Is there ANY self-improving compiler out there?</strong></p>
<p>Please note that I am talking about <em>a compiler that improves itself</em> - not
<em>a compiler that improves the code it compiles</em>.</p>
<p>Any pointers appreciated!</p>
<p><strong>Side-note</strong> : in case you're wondering why I am asking have a look at this
post. Even if I agree with most of the arguments I am not too sure about the
following:</p>
<blockquote>
<p>We have programs that can improve their code without human input now —
they’re called compilers.</p>
</blockquote>
<p>... hence my question.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>While it is true that compilers can improve code without human interference,
however, the claim that "compilers are self-improving" is rather dubious.
These "improvements" that compilers make are merely based on a set of rules
that are written by humans (cyborgs anyone?). So the answer to your question
is : No.</p>
<p>On a side note, if there was anything like a self improving compiler, we'd
know... first the thing would improve the language, then its own code and
finally, it would modify its code to become a virus and make all developers
use it... and then finally we'd have one of those classic computer-versus-
humans-last-hope-for-humanity kind of things... so ... No.</p>
<p><br></p>
<h3>Suggest</h3>
<p>MilepostGCC is a MachineLearning compiler, which improve itself with time in
the sense that it is able to change itself in order to become "better" with
time. A simpler iterative compilation approach is able to improve pretty much
any compiler.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/artificial-intelligence-in-tic-tac-toe-using-c/" class="u-url">Artificial Intelligence in Tic-Tac-Toe using C#</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/artificial-intelligence-in-tic-tac-toe-using-c/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:13:05+08:00" itemprop="datePublished" title="2023-02-28 03:13">2023-02-28 03:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have made a Tic-Tac-Toe game for 2 players. Now, I want to give the game
<strong>Artificial Intelligence.</strong></p>
<p>So that game can be played between <strong>1 player and computer</strong>.<br>
Please, help How do I start?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>With Tic Tac Toe it's not so much an AI but a lookup table: For each possible
board layout, find the best spot.</p>
<p>XKCD has such a lookup table. Basically each Board Layout gets a unique ID and
the address of the field where to set the next mark. Wikipedia has that table
in another format.</p>
<p>The table works like this: X goes first, then O. X puts his X into one of the
9 cells. When O goes, there are now 9 possible Board Layouts, depending on
which Cell has the X:</p>
<div class="code"><pre class="code literal-block"> X  |    |
----+----+----
    |    |
----+----+----
    |    |
</pre></div>

<p>If you look at the map of O, there are 9 big grids in it, and the one in the
top left has X in the top left spot, so that is the one to use. Place O in the
Middle.</p>
<p>Now when X goes again, it needs to find this board layout:</p>
<div class="code"><pre class="code literal-block"> X  |    |
----+----+----
    | O  |
----+----+----
    |    |
</pre></div>

<p>You will find this in the middle. Red is where to put the X in the XKCD image,
and that shows you put it in the lower right:</p>
<div class="code"><pre class="code literal-block"> X  |    |
----+----+----
    | O  |
----+----+----
    |    | X
</pre></div>

<p>Now, O goes again and looks for the above board layout, which is in the bottom
right small grid in the top left big grid. O needs to be placed into the
middle bottom:</p>
<div class="code"><pre class="code literal-block"> X  |    |
----+----+----
    | O  |
----+----+----
    | O  | X
</pre></div>

<p>And so forth. The diagram is a bit hard to read at first (click on it to
enlarge it) as it's nested, but as said: You create a Lookup table that has
each unique board layout and information where to put the next mark.</p>
<p>This creates a perfect opponent though: The computer will never ever lose. How
to make him more human is then fine-tuning (e.g., randomly discard the choice
and place the mark in a random cell)</p>
<p><br></p>
<h3>Suggest</h3>
<p>I actually wrote such a beast many moons ago, an actual automaton that learnt
from its mistakes.</p>
<p>The nature of the game means that you could store outcomes for every possible
position. While not practicable for a game like chess, TicTacToe only has 39,
or 19683, states.</p>
<p>Here's the intelligence bit I used.</p>
<p>An array of bytes was allocated giving the desirability of every single state
and these were all initialised to 127 so that all states were equally
desirable. In order for the AI to select a move to make, it added up the
scores of all states that could result from a <em>possible</em> move and used that to
generate a random number to select which move it would make.</p>
<p>In other words, if only two moves were possible and the outcomes had scores of
200 and 50, the AI would generate a random number from 0 to 249 and use that
to select one, with the former would be four times (values 0-199) more likely
than the latter (values 200-249).</p>
<p>As to how the scores change, the AI simply remembered every state that existed
in the game that resulted from a move you made. If it won the game, the score
of all those positions would be bumped up by one (but limiting it to 255 of
course, since it had to fit in a byte). If it lost, it would drop the scores
(keeping them at one or more).</p>
<p>That way, positions that lead to a win would become more likely, while those
that led to a loss would become less likely.</p>
<p>The reason the desirability never dropped to zero was so that no state was
ever impossible to get. Of course, one with a desirability score of one was
<em>very</em> unlikely if all the others had higher scores.</p>
<p>It took quite a lot of games for the AI to become a decent player but you
could accelerate it by pitting it against an automated enemy that alternated
between the same AI and random moves.</p>
<p>And there were tricks you could use to bump up or drop more states than
existed in the game since you could rotate or mirror each state to get an
equivalent position.</p>
<p>You could also set a lower bound for the score to reach (other than one) -
this would make it more likely that the AI would select a less optimal move,
effectively dropping the intelligence level.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1402.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1400.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
