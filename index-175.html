<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 175) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-175.html">
<link rel="prev" href="index-176.html" type="text/html">
<link rel="next" href="index-174.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-should-i-use-a-pointer-rather-than-the-object-itself/" class="u-url">Why should I use a pointer rather than the object itself?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-should-i-use-a-pointer-rather-than-the-object-itself/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:54:07+08:00" itemprop="datePublished" title="2023-02-16 23:54">2023-02-16 23:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm coming from a Java background and have started working with objects in
C++. But one thing that occurred to me is that people often use pointers to
objects rather than the objects themselves, for example this declaration:</p>
<div class="code"><pre class="code literal-block">Object *myObject = new Object;
</pre></div>

<p>rather than:</p>
<div class="code"><pre class="code literal-block">Object myObject;
</pre></div>

<p>Or instead of using a function, let's say <code>testFunc()</code>, like this:</p>
<div class="code"><pre class="code literal-block">myObject.testFunc();
</pre></div>

<p>we have to write:</p>
<div class="code"><pre class="code literal-block"><span class="n">myObject</span><span class="o">-&gt;</span><span class="n">testFunc</span><span class="p">();</span>
</pre></div>

<p>But I can't figure out why should we do it this way. I would assume it has to
do with efficiency and speed since we get direct access to the memory address.
Am I right?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It's very unfortunate that you see dynamic allocation so often. That just
shows how many bad C++ programmers there are.</p>
<p>In a sense, you have two questions bundled up into one. The first is when
should we use dynamic allocation (using <code>new</code>)? The second is when should we
use pointers?</p>
<p>The important take-home message is that you should <strong>always use the
appropriate tool for the job</strong>. In almost all situations, there is something
more appropriate and safer than performing manual dynamic allocation and/or
using raw pointers.</p>
<h3>Dynamic allocation</h3>
<p>In your question, you've demonstrated two ways of creating an object. The main
difference is the storage duration of the object. When doing <code>Object
myObject;</code> within a block, the object is created with automatic storage
duration, which means it will be destroyed automatically when it goes out of
scope. When you do <code>new Object()</code>, the object has dynamic storage duration,
which means it stays alive until you explicitly <code>delete</code> it. You should only
use dynamic storage duration when you need it. That is, <strong>you should <em>always</em>
prefer creating objects with automatic storage duration when you can</strong>.</p>
<p>The main two situations in which you might require dynamic allocation:</p>
<ol>
<li>
<strong>You need the object to outlive the current scope</strong> - that specific object at that specific memory location, not a copy of it. If you're okay with copying/moving the object (most of the time you should be), you should prefer an automatic object.</li>
<li>
<strong>You need to allocate a lot of memory</strong> , which may easily fill up the stack. It would be nice if we didn't have to concern ourselves with this (most of the time you shouldn't have to), as it's really outside the purview of C++, but unfortunately, we have to deal with the reality of the systems we're developing for.</li>
</ol>
<p>When you do absolutely require dynamic allocation, you should encapsulate it
in a smart pointer or some other type that performs RAII (like the standard
containers). Smart pointers provide ownership semantics of dynamically
allocated objects. Take a look at <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, for
example. If you use them appropriately, you can almost entirely avoid
performing your own memory management (see the Rule of Zero).</p>
<h3>Pointers</h3>
<p>However, there are other more general uses for raw pointers beyond dynamic
allocation, but most have alternatives that you should prefer. As before,
<strong>always prefer the alternatives unless you really need pointers</strong>.</p>
<ol>
<li>
<p><strong>You need reference semantics</strong>. Sometimes you want to pass an object using a pointer (regardless of how it was allocated) because you want the function to which you're passing it to have access that that specific object (not a copy of it). However, in most situations, you should prefer reference types to pointers, because this is specifically what they're designed for. Note this is not necessarily about extending the lifetime of the object beyond the current scope, as in situation 1 above. As before, if you're okay with passing a copy of the object, you don't need reference semantics.</p>
</li>
<li>
<p><strong>You need polymorphism</strong>. You can only call functions polymorphically (that is, according to the dynamic type of an object) through a pointer or reference to the object. If that's the behavior you need, then you need to use pointers or references. Again, references should be preferred.</p>
</li>
<li>
<p><strong>You want to represent that an object is optional</strong> by allowing a <code>nullptr</code> to be passed when the object is being omitted. If it's an argument, you should prefer to use default arguments or function overloads. Otherwise, you should preferably use a type that encapsulates this behavior, such as <code>std::optional</code> (introduced in C++17 - with earlier C++ standards, use <code>boost::optional</code>).</p>
</li>
<li>
<p><strong>You want to decouple compilation units to improve compilation time</strong>. The useful property of a pointer is that you only require a forward declaration of the pointed-to type (to actually use the object, you'll need a definition). This allows you to decouple parts of your compilation process, which may significantly improve compilation time. See the Pimpl idiom.</p>
</li>
<li>
<p><strong>You need to interface with a C library</strong> or a C-style library. At this point, you're forced to use raw pointers. The best thing you can do is make sure you only let your raw pointers loose at the last possible moment. You can get a raw pointer from a smart pointer, for example, by using its <code>get</code> member function. If a library performs some allocation for you which it expects you to deallocate via a handle, you can often wrap the handle up in a smart pointer with a custom deleter that will deallocate the object appropriately.</p>
</li>
</ol>
<p><br></p>
<h3>Suggest</h3>
<p>There are many use cases for pointers.</p>
<p><strong>Polymorphic behavior</strong>. For polymorphic types, pointers (or references) are
used to avoid slicing:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Base</span> { ... };
<span class="k">class</span> <span class="n">Derived</span> : <span class="n">public</span> <span class="n">Base</span> { ... };

<span class="n">void</span> <span class="n">fun</span>(<span class="n">Base</span> <span class="n">b</span>) { ... }
<span class="n">void</span> <span class="n">gun</span>(<span class="n">Base</span>* <span class="n">b</span>) { ... }
<span class="n">void</span> <span class="n">hun</span>(<span class="n">Base</span>&amp; <span class="n">b</span>) { ... }

<span class="n">Derived</span> <span class="nb">d</span>;
<span class="n">fun</span>(<span class="nb">d</span>);    // <span class="n">oops</span>, <span class="nb">all</span> <span class="n">Derived</span> <span class="nb">parts</span> <span class="n">silently</span> <span class="s">"sliced"</span> <span class="n">off</span>
<span class="n">gun</span>(<span class="nv">&amp;d</span>);   // <span class="n">OK</span>, <span class="n">a</span> <span class="n">Derived</span> <span class="n">object</span> <span class="n">IS-A</span> <span class="n">Base</span> <span class="n">object</span>
<span class="n">hun</span>(<span class="nb">d</span>);    // <span class="o">also</span> <span class="n">OK</span>, <span class="n">reference</span> <span class="o">also</span> <span class="n">doesn't</span> <span class="n">slice</span>
</pre></div>

<p><strong>Reference semantics and avoiding copying</strong>. For non-polymorphic types, a
pointer (or a reference) will avoid copying a potentially expensive object</p>
<div class="code"><pre class="code literal-block"><span class="n">Base</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="n">fun</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// copies b, potentially expensive </span>
<span class="n">gun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// takes a pointer to b, no copying</span>
<span class="n">hun</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// regular syntax, behaves as a pointer</span>
</pre></div>

<p>Note that C++11 has move semantics that can avoid many copies of expensive
objects into function argument and as return values. But using a pointer will
definitely avoid those and will allow multiple pointers on the same object
(whereas an object can only be moved from once).</p>
<p><strong>Resource acquisition</strong>. Creating a pointer to a resource using the <code>new</code>
operator is an <strong>anti-pattern</strong> in modern C++. Use a special resource class
(one of the Standard containers) or a <strong>smart pointer</strong> (<code>std::unique_ptr&lt;&gt;</code>
or <code>std::shared_ptr&lt;&gt;</code>). Consider:</p>
<div class="code"><pre class="code literal-block">{
<span class="w">    </span><span class="nv">auto</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">Base</span><span class="c1">;</span>
<span class="w">    </span>...<span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="nv">oops</span>,<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">an</span><span class="w"> </span><span class="nv">exception</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">thrown</span>,<span class="w"> </span><span class="nv">destructor</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">called</span><span class="o">!</span>
<span class="w">    </span><span class="nv">delete</span><span class="w"> </span><span class="nv">b</span><span class="c1">;</span>
}
</pre></div>

<p>vs.</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span>
<span class="w">    </span><span class="err">auto</span><span class="w"> </span><span class="err">b</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="err">...</span><span class="w">       </span><span class="err">//</span><span class="w"> </span><span class="err">OK,</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">exception</span><span class="w"> </span><span class="err">safe</span>
<span class="p">}</span>
</pre></div>

<p>A raw pointer should only be used as a "view" and not in any way involved in
ownership, be it through direct creation or implicitly through return values.
See also <strong>this Q &amp;A from the C++ FAQ</strong>.</p>
<p><strong>More fine-grained life-time control</strong> Every time a shared pointer is being
copied (e.g. as a function argument) the resource it points to is being kept
alive. Regular objects (not created by <code>new</code>, either directly by you or inside
a resource class) are destroyed when going out of scope.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/check-existence-of-input-argument-in-a-bash-shell-script/" class="u-url">Check existence of input argument in a Bash shell script</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/check-existence-of-input-argument-in-a-bash-shell-script/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:53:37+08:00" itemprop="datePublished" title="2023-02-16 23:53">2023-02-16 23:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I need to check the existence of an input argument. I have the following
script</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span>[<span class="w"> </span><span class="s2">"$1"</span><span class="w"> </span><span class="o">-</span><span class="nv">gt</span><span class="w"> </span><span class="s2">"-1"</span><span class="w"> </span>]
<span class="w">  </span><span class="k">then</span><span class="w"> </span><span class="nv">echo</span><span class="w"> </span><span class="nv">hi</span>
<span class="nv">fi</span>
</pre></div>

<p>I get</p>
<div class="code"><pre class="code literal-block">[: : integer expression expected
</pre></div>

<p>How do I check the input argument1 first to see if it exists?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It is:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span>[<span class="w"> </span>$#<span class="w"> </span><span class="o">-</span><span class="nv">eq</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span>]
<span class="w">  </span><span class="k">then</span>
<span class="w">    </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"No arguments supplied"</span>
<span class="nv">fi</span>
</pre></div>

<p>The <code>$#</code> variable will tell you the number of input arguments the script was
passed.</p>
<p>Or you can check if an argument is an empty string or not like:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span>[<span class="w"> </span><span class="o">-</span><span class="nv">z</span><span class="w"> </span><span class="s2">"$1"</span><span class="w"> </span>]
<span class="w">  </span><span class="k">then</span>
<span class="w">    </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"No argument supplied"</span>
<span class="nv">fi</span>
</pre></div>

<p>The <code>-z</code> switch will test if the expansion of <code>"$1"</code> is a null string or not.
If it is a null string then the body is executed.</p>
<p><br></p>
<h3>Suggest</h3>
<p>It is better to demonstrate this way</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span>[[<span class="w"> </span>$#<span class="w"> </span><span class="o">-</span><span class="nv">eq</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span>]]<span class="w"> </span><span class="c1">; then</span>
<span class="w">    </span><span class="nv">echo</span><span class="w"> </span><span class="s1">'some message'</span>
<span class="w">    </span><span class="k">exit</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">fi</span>
</pre></div>

<p>You normally need to exit if you have too few arguments.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/image-processing-algorithm-improvement-for-coca-cola-can-recognition/" class="u-url">Image Processing: Algorithm Improvement for 'Coca-Cola Can' Recognition</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/image-processing-algorithm-improvement-for-coca-cola-can-recognition/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:53:07+08:00" itemprop="datePublished" title="2023-02-16 23:53">2023-02-16 23:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>One of the most interesting projects I've worked on in the past couple of
years was a project about image processing. The goal was to develop a system
to be able to recognize Coca-Cola <strong>'cans'</strong> (note that I'm stressing the word
'cans', you'll see why in a minute). You can see a sample below, with the can
recognized in the <em>green rectangle</em> with scale and rotation.</p>
<p><img alt="Template matching" src="images/irQtR.png"></p>
<p>Some constraints on the project:</p>
<ul>
<li>The background could be very noisy.</li>
<li>The <em>can</em> could have any <em>scale</em> or <em>rotation</em> or even orientation (within reasonable limits).</li>
<li>The image could have some degree of fuzziness (contours might not be entirely straight).</li>
<li>There could be Coca-Cola bottles in the image, and the algorithm should only detect the <em>can</em>!</li>
<li>The brightness of the image could vary a lot (so you can't rely "too much" on color detection).</li>
<li>The <em>can</em> could be partly hidden on the sides or the middle and possibly partly hidden behind a bottle.</li>
<li>There could be no <em>can</em> at all in the image, in which case you had to find nothing and write a message saying so.</li>
</ul>
<p>So you could end up with tricky things like this (which in this case had my
algorithm totally fail):</p>
<p><img alt="Total fail" src="images/Byw82.png"></p>
<p>I did this project a while ago, and had a lot of fun doing it, and I had a
decent implementation. Here are some details about my implementation:</p>
<p><strong>Language</strong> : Done in C++ using OpenCV library.</p>
<p><strong>Pre-processing</strong> : For the image pre-processing, i.e. transforming the image
into a more raw form to give to the algorithm, I used 2 methods:</p>
<ol>
<li>Changing color domain from RGB to HSV and filtering based on "red" hue, saturation above a certain threshold to avoid orange-like colors, and filtering of low value to avoid dark tones. The end result was a binary black and white image, where all white pixels would represent the pixels that match this threshold. Obviously there is still a lot of crap in the image, but this reduces the number of dimensions you have to work with. <img alt="Binarized image" src="images/ktdAB.png">
</li>
<li>Noise filtering using median filtering (taking the median pixel value of all neighbors and replace the pixel by this value) to reduce noise.</li>
<li>Using Canny Edge Detection Filter to get the contours of all items after 2 precedent steps. <img alt="Contour detection" src="images/F9319.png">
</li>
</ol>
<p><strong>Algorithm</strong> : The algorithm itself I chose for this task was taken from this
awesome book on feature extraction and called Generalized Hough Transform
(pretty different from the regular Hough Transform). It basically says a few
things:</p>
<ul>
<li>You can describe an object in space without knowing its analytical equation (which is the case here).</li>
<li>It is resistant to image deformations such as scaling and rotation, as it will basically test your image for every combination of scale factor and rotation factor.</li>
<li>It uses a base model (a template) that the algorithm will "learn".</li>
<li>Each pixel remaining in the contour image will vote for another pixel which will supposedly be the center (in terms of gravity) of your object, based on what it learned from the model.</li>
</ul>
<p>In the end, you end up with a heat map of the votes, for example here all the
pixels of the contour of the can will vote for its gravitational center, so
you'll have a lot of votes in the same pixel corresponding to the center, and
will see a peak in the heat map as below:</p>
<p><img alt="GHT" src="images/wxrT1.png"></p>
<p>Once you have that, a simple threshold-based heuristic can give you the
location of the center pixel, from which you can derive the scale and rotation
and then plot your little rectangle around it (final scale and rotation factor
will obviously be relative to your original template). In theory at least...</p>
<p><strong>Results</strong> : Now, while this approach worked in the basic cases, it was
severely lacking in some areas:</p>
<ul>
<li>It is <strong>extremely slow</strong>! I'm not stressing this enough. Almost a full day was needed to process the 30 test images, obviously because I had a very high scaling factor for rotation and translation, since some of the cans were very small.</li>
<li>It was completely lost when bottles were in the image, and for some reason almost always found the bottle instead of the can (perhaps because bottles were bigger, thus had more pixels, thus more votes)</li>
<li>Fuzzy images were also no good, since the votes ended up in pixel at random locations around the center, thus ending with a very noisy heat map.</li>
<li>In-variance in translation and rotation was achieved, but not in orientation, meaning that a can that was not directly facing the camera objective wasn't recognized.</li>
</ul>
<p>Can you help me improve my <strong>specific</strong> algorithm, using <strong>exclusively
OpenCV</strong> features, to resolve the <strong>four specific</strong> issues mentioned?</p>
<p>I hope some people will also learn something out of it as well, after all I
think not only people who ask questions should learn. :)</p>
<p><br><br></p>
<h2>Answer</h2>
<p>An alternative approach would be to extract features (keypoints) using the
scale-invariant feature transform (SIFT) or Speeded Up Robust Features (SURF).</p>
<p>You can find a nice <code>OpenCV</code> code example in <code>Java</code>, <code>C++</code>, and <code>Python</code> on
this page: <em>Features2D + Homography to find a known object</em></p>
<p>Both algorithms are invariant to scaling and rotation. Since they work with
features, you can also handle occlusion (as long as enough keypoints are
visible).</p>
<p><img alt="Enter image description here" src="images/kF63R.jpg"></p>
<p>Image source: tutorial example</p>
<p>The processing takes a few hundred ms for SIFT, SURF is bit faster, but it not
suitable for real-time applications. ORB uses FAST which is weaker regarding
rotation invariance.</p>
<h4>The original papers</h4>
<ul>
<li>SURF: Speeded Up Robust Features</li>
<li>Distinctive Image Features from Scale-Invariant Keypoints</li>
<li>ORB: an efficient alternative to SIFT or SURF</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>To speed things up, I would take advantage of the fact that you are not asked
to find an arbitrary image/object, but specifically one with the Coca-Cola
logo. This is significant because this logo is very distinctive, and it should
have a characteristic, scale-invariant signature in the frequency domain,
particularly in the red channel of RGB. That is to say, the alternating
pattern of red-to-white-to-red encountered by a horizontal scan line (trained
on a horizontally aligned logo) will have a distinctive "rhythm" as it passes
through the central axis of the logo. That rhythm will "speed up" or "slow
down" at different scales and orientations, but will remain proportionally
equivalent. You could identify/define a few dozen such scanlines, both
horizontally and vertically through the logo and several more diagonally, in a
starburst pattern. Call these the "signature scan lines."</p>
<p><img alt="Signature scan line" src="images/KWVZw.jpg"></p>
<p>Searching for this signature in the target image is a simple matter of
scanning the image in horizontal strips. Look for a high-frequency in the red-
channel (indicating moving from a red region to a white one), and once found,
see if it is followed by one of the frequency rhythms identified in the
training session. Once a match is found, you will instantly know the scan-
line's orientation and location in the logo (if you keep track of those things
during training), so identifying the boundaries of the logo from there is
trivial.</p>
<p>I would be surprised if this weren't a linearly-efficient algorithm, or nearly
so. It obviously doesn't address your can-bottle discrimination, but at least
you'll have your logos.</p>
<p>(Update: for bottle recognition I would look for coke (the brown liquid)
adjacent to the logo -- that is, <em>inside</em> the bottle. Or, in the case of an
empty bottle, I would look for a <em>cap</em> which will always have the same basic
shape, size, and distance from the logo and will typically be all white or
red. Search for a solid color eliptical shape where a cap <em>should</em> be,
relative to the logo. Not foolproof of course, but your goal here should be to
find the <em>easy</em> ones <em>fast</em>.)</p>
<p>(It's been a few years since my image processing days, so I kept this
suggestion high-level and conceptual. I think it might slightly approximate
how a human eye might operate -- or at least how my brain does!)</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-176.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-174.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
