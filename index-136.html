<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 136) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-136.html">
<link rel="prev" href="index-137.html" type="text/html">
<link rel="next" href="index-135.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-fen-xi-zai-linux-shang-yun-xing-de-c-dai-ma/" class="u-url">如何分析在 Linux 上运行的 C++ 代码？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-fen-xi-zai-linux-shang-yun-xing-de-c-dai-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:41:29+08:00" itemprop="datePublished" title="2023-02-16 22:41">2023-02-16 22:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何找到在 Linux 上运行的 C++ 应用程序中运行缓慢的代码区域？</p>
<p><br><br></p>
<h2>解答</h2>
<p>如果您的目标是使用分析器，请使用建议的分析器之一。</p>
<p>但是，如果您赶时间并且可以在调试器下手动中断您的程序，而它主观上很慢，那么有一种简单的方法可以找到性能问题。</p>
<p>只需暂停几次，每次都查看调用堆栈。如果有一些代码浪费了一定百分比的时间，20% 或 50%
或其他任何时间，这就是您在每个样本的行为中捕获它的概率。因此，这大致就是您将看到它的样本百分比。不需要有根据的猜测。如果您确实猜测问题是什么，这将证明或反驳它。</p>
<p>您可能有多个不同大小的性能问题。如果你清除了其中任何一个，其余的将在随后的传递中占据更大的百分比，并且更容易被发现。这种 <em>放大效应</em>
，当在多个问题上复合时，会导致真正巨大的加速因子。</p>
<p><strong>警告</strong>
：程序员往往对这种技术持怀疑态度，除非他们自己使用过。他们会说探查器会为您提供此信息，但只有当他们对整个调用堆栈进行抽样然后让您检查一组随机样本时才会如此。（摘要是失去洞察力的地方。）调用图不会给你相同的信息，因为</p>
<ol>
<li>他们不在指令级别进行总结，并且</li>
<li>他们在存在递归的情况下给出了令人困惑的总结。</li>
</ol>
<p>他们还会说它只适用于玩具程序，而实际上它适用于任何程序，而且似乎在更大的程序上效果更好，因为它们往往有更多的问题需要发现。他们会说它有时会发现不是问题的东西，但只有当你看到某样东西时才会
<em>如此</em> 。如果您在不止一个样品上发现问题，那是真的。</p>
<p><strong>PS</strong> 这也可以在多线程程序上完成，如果有一种方法可以在某个时间点收集线程池的调用堆栈样本，就像在 Java 中那样。</p>
<p><strong>PPS</strong> 作为一个粗略的概括，您的软件中的抽象层越多，您就越有可能发现这是性能问题的原因（以及获得加速的机会）。</p>
<p><strong>补充</strong>
：这可能不是很明显，但堆栈采样技术在递归的情况下同样有效。原因是删除一条指令所节省的时间近似于包含它的样本的分数，而不管它在一个样本中可能出现的次数。</p>
<p>我经常听到的另一个反对意见是：“ <em>它会随机停在某个地方，它会错过真正的问题</em>
”。这是因为对真正的问题是什么有一个先验的概念。性能问题的一个关键属性是它们违背预期。抽样告诉您有问题，您的第一反应是难以置信。这很自然，但您可以确定它是否发现问题是真实存在的，反之亦然。</p>
<p><strong>补充</strong>
：让我对它的工作原理做一个贝叶斯解释。假设有一些指令<code>I</code>（调用或其他）在调用堆栈上有一段<code>f</code>时间（因此花费那么多）。为简单起见，假设我们不知道<code>f</code>是什么，但假设它是
0.1、0.2、0.3、... 0.9、1.0，并且每种可能性的先验概率都是 0.1，因此所有这些成本的可能性均等先验的。</p>
<p>然后假设我们只取 2 个堆栈样本，并且我们在两个样本上都看到了指令<code>I</code>，指定为 observation
<code>o=2/2</code>。这给了我们新的频率估计<code>f</code>，<code>I</code>根据这个：</p>
<div class="code"><pre class="code literal-block">Prior                                    
P(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp;f=x)  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x | o=2/2)

0.1    1     1             0.1          0.1            0.25974026
0.1    0.9   0.81          0.081        0.181          0.47012987
0.1    0.8   0.64          0.064        0.245          0.636363636
0.1    0.7   0.49          0.049        0.294          0.763636364
0.1    0.6   0.36          0.036        0.33           0.857142857
0.1    0.5   0.25          0.025        0.355          0.922077922
0.1    0.4   0.16          0.016        0.371          0.963636364
0.1    0.3   0.09          0.009        0.38           0.987012987
0.1    0.2   0.04          0.004        0.384          0.997402597
0.1    0.1   0.01          0.001        0.385          1

                  P(o=2/2) 0.385
</pre></div>

<p>最后一列表示，例如，&gt;= 0.5 的概率<code>f</code>为 92%，高于先前假设的 60%。</p>
<p>假设先验假设不同。假设我们假设<code>P(f=0.1)</code>是 .991（几乎可以肯定），所有其他可能性几乎都是不可能的
(0.001)。换句话说，我们事先确定的是<code>I</code>便宜。然后我们得到：</p>
<div class="code"><pre class="code literal-block">Prior                                    
P(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp; f=x)  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x | o=2/2)

0.001  1    1              0.001        0.001          0.072727273
0.001  0.9  0.81           0.00081      0.00181        0.131636364
0.001  0.8  0.64           0.00064      0.00245        0.178181818
0.001  0.7  0.49           0.00049      0.00294        0.213818182
0.001  0.6  0.36           0.00036      0.0033         0.24
0.001  0.5  0.25           0.00025      0.00355        0.258181818
0.001  0.4  0.16           0.00016      0.00371        0.269818182
0.001  0.3  0.09           0.00009      0.0038         0.276363636
0.001  0.2  0.04           0.00004      0.00384        0.279272727
0.991  0.1  0.01           0.00991      0.01375        1

                  P(o=2/2) 0.01375
</pre></div>

<p>现在它说<code>P(f &gt;= 0.5)</code>是 26%，高于之前假设的 0.6%。所以贝叶斯允许我们更新我们对
的可能成本的估计<code>I</code>。如果数据量很小，它并不能准确地告诉我们成本是多少，只是它大到值得修复。</p>
<p>另一种看待它的方式称为继承规则。如果你掷一枚硬币 2 次，两次都是正面朝上，这告诉你硬币的可能权重是多少？受人尊敬的回答方式是说它是 Beta
分布，平均值为<code>(number of hits + 1) / (number of tries + 2) = (2+1)/(2+2) = 75%</code>。</p>
<p>（关键是我们看到了<code>I</code>不止一次。如果我们只看到一次，那除了<code>f</code>&gt; 0 之外并没有告诉我们太多信息。）</p>
<p>因此，即使是非常少量的样本也可以告诉我们很多关于它所看到的指令的成本。（平均而言，它会看到它们的频率与它们的成本成正比。如果<code>n</code>样本被抽取，并且<code>f</code>是成本，那么<code>I</code>将出现在<code>nf+/-sqrt(nf(1-f))</code>样本上。示例，，，<code>n=10</code>即<code>f=0.3</code>样本<code>3+/-1.4</code>。）</p>
<hr>
<p><strong>添加</strong> ：为了直观地感受测量堆栈采样和随机堆栈采样之间的区别：<br>
现在有分析器对堆栈进行采样，即使是在挂钟时间，但 <em>得出的</em>
是测量值（或热点路径，或热点，从中“瓶颈”很容易隐藏）。他们没有向您展示（而且他们很容易可以）的是实际样本本身。如果您的目标是 <em>找到</em>
瓶颈，那么您需要查看的瓶颈数量 <em>平均</em> 为 2 除以所需时间。因此，如果花费 30% 的时间，则平均有 2/.3 = 6.7 个样本会显示它，而 20
个样本会显示它的机会为 99.2%。</p>
<p>这是检查测量值和检查堆栈样本之间差异的即兴说明。瓶颈可能是像这样的一个大斑点，也可能是许多小斑点，这没有区别。</p>
<p><img alt="在此处输入图像描述" src="images/FpWuS.png"></p>
<p>测量是水平的；它会告诉您特定例程需要多少时间。采样是垂直的。如果有任何方法可以避免整个程序在那一刻正在做的事情， <em>并且如果您在第二个示例中看到它</em>
，那么您就找到了瓶颈。这就是与众不同的原因 - 看到花费时间的全部原因，而不仅仅是多少。</p>
<p><br></p>
<h3>更多建议</h3>
<p>使用具有以下选项的Valgrind ：</p>
<div class="code"><pre class="code literal-block"><span class="n">valgrind</span><span class="w"> </span><span class="o">--</span><span class="k">tool</span><span class="o">=</span><span class="n">callgrind</span><span class="w"> </span><span class="o">./</span><span class="p">(</span><span class="n">Your</span><span class="w"> </span><span class="n">binary</span><span class="p">)</span>
</pre></div>

<p>这会生成一个名为<code>callgrind.out.x</code>. 使用该<code>kcachegrind</code>工具读取此文件。它将为您提供图形分析结果，例如哪些线路成本多少。</p>
<p><br><br><a href="posts/how-do-i-profile-c-code-running-on-linux/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-he-bing-liang-ge-git-cun-chu-ku/" class="u-url">如何合并两个 Git 存储库？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-he-bing-liang-ge-git-cun-chu-ku/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:40:40+08:00" itemprop="datePublished" title="2023-02-16 22:40">2023-02-16 22:40</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>考虑以下场景：</p>
<p>我在自己的 Git 仓库中开发了一个小型实验项目 A。它现在已经成熟，我希望 A 成为更大的项目 B 的一部分，它有自己的大存储库。我现在想将 A 添加为
B 的子目录。</p>
<p>如何将 A 合并到 B 而不会丢失任何一方的历史记录？</p>
<p><br><br></p>
<h2>解答</h2>
<p>另一个存储库的单个分支可以很容易地放置在保留其历史的子目录下。例如：</p>
<div class="code"><pre class="code literal-block">git subtree add --prefix=rails git://github.com/rails/rails.git master
</pre></div>

<p>这将显示为单个提交，其中 Rails master 分支的所有文件都被添加到“rails”目录中。但是，提交的标题包含对旧历史树的引用：</p>
<blockquote>
<p>从提交中添加“rails/”<code>&lt;rev&gt;</code></p>
</blockquote>
<p><code>&lt;rev&gt;</code>SHA-1 提交哈希在哪里。还可以看到历史，怪一些变化。</p>
<div class="code"><pre class="code literal-block">git log &lt;rev&gt;
git blame &lt;rev&gt; -- README.md
</pre></div>

<p>请注意，您无法从此处看到目录前缀，因为这是一个完整的实际旧分支。你应该像对待普通的文件移动提交一样对待它：到达它时你需要额外的跳转。</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">finishes</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">files</span><span class="w"> </span><span class="nv">added</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">once</span><span class="w"> </span><span class="nv">commit</span>
<span class="nv">git</span><span class="w"> </span><span class="nv">log</span><span class="w"> </span><span class="nv">rails</span><span class="o">/</span><span class="nv">README</span>.<span class="nv">md</span>

#<span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">original</span><span class="w"> </span><span class="nv">tree</span>
<span class="nv">git</span><span class="w"> </span><span class="nv">log</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">rev</span><span class="o">&gt;</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="nv">README</span>.<span class="nv">md</span>
</pre></div>

<p>有更复杂的解决方案，例如手动执行此操作或如其他答案中所述重写历史记录。</p>
<p>git-subtree 命令是官方 git-contrib 的一部分，一些数据包管理器默认安装它（OS X Homebrew）。但是除了 git
之外，您可能还必须自己安装它。</p>
<p><br></p>
<h3>更多建议</h3>
<p>这里有两种可能的解决方案：</p>
<h4>子模块</h4>
<p>将存储库 A 复制到更大的项目 B 中的单独目录，或者（也许更好）将存储库 A 克隆到项目 B 中的子目录中。然后使用git
submodule使该存储库成为存储库 B 的 <strong> <em>子模块。</em></strong></p>
<p>对于松散耦合的存储库，这是一个很好的解决方案，其中存储库 A 中的开发继续进行，并且开发的主要部分是 A 中的单独独立开发。另请参阅 Git Wiki 上的
SubmoduleSupport和GitSubmoduleTutorial页面。</p>
<h4>子树合并</h4>
<p><strong><em>您可以使用子树合并</em></strong> 策略将存储库 A 合并到项目 B 的子目录中。 <em>Markus Prinz 在Subtree Merging and
You</em> 中对此进行了描述。</p>
<div class="code"><pre class="code literal-block">git remote add -f Bproject /path/to/B
git merge -s ours --allow-unrelated-histories --no-commit Bproject/master
git read-tree --prefix=dir-B/ -u Bproject/master
git commit -m "Merge B project as our subdirectory"
git pull -s subtree Bproject master
</pre></div>

<p>（<code>--allow-unrelated-histories</code>Git &gt;= 2.9.0 需要选项。）</p>
<p>或者您可以使用apenwarr (Avery Pennarun) 的 <strong>git subtree</strong> 工具（GitHub 上的存储库），例如在他的博客文章A
new alternative to Git submodules: git subtree中宣布。</p>
<hr>
<p><em>我认为在你的情况下（A 是更大项目 B 的一部分）正确的解决方案是使用 <strong>subtree merge</strong></em> 。</p>
<p><br><br><a href="posts/how-do-you-merge-two-git-repositories/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-chuang-jian-bao-han-1-n-de-shu-zu/" class="u-url">如何创建包含 1...N 的数组</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-chuang-jian-bao-han-1-n-de-shu-zu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:40:03+08:00" itemprop="datePublished" title="2023-02-16 22:40">2023-02-16 22:40</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在寻找以下任何替代方法来创建包含 1 到 N 的 JavaScript 数组，其中 N 仅在运行时已知。</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">foo</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>对我来说，感觉应该有一种无需循环即可执行此操作的方法。</p>
<p><br><br></p>
<h2>解答</h2>
<p>如果我得到你想要的，你想要一个数字数组<code>1..n</code>，你可以稍后循环。</p>
<p>如果这就是您所需要的，您可以这样做吗？</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nb nb-Type">Array</span><span class="p">(</span><span class="mi">45</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="mi">45</span>
</pre></div>

<p>然后当你想使用它时......（未优化，仅作为示例）</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">foo</span><span class="o">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">  </span><span class="n">document</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'Item: '</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">' of '</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">foo</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">'&lt;br/&gt;'</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>例如，如果您不需要在数组中 <strong>存储任何内容，您只需要一个可以迭代的长度合适的容器……这可能更容易。</strong></p>
<p>在此处查看实际效果： http: //jsfiddle.net/3kcvm/</p>
<p><br></p>
<h3>更多建议</h3>
<p>你可以这样做：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span>
<span class="nb nb-Type">Array</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb nb-Type">null</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">length</span><span class="p">:</span><span class="w"> </span><span class="n">N</span><span class="p">})</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Number</span><span class="o">.</span><span class="n">call</span><span class="p">,</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
</pre></div>

<blockquote>
<p>结果：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
</blockquote>
<p>或随机值：</p>
<div class="code"><pre class="code literal-block"><span class="nv">Array</span>.<span class="nv">apply</span><span class="ss">(</span><span class="nv">null</span>,<span class="w"> </span>{<span class="nv">length</span>:<span class="w"> </span><span class="nv">N</span>}<span class="ss">)</span>.<span class="nv">map</span><span class="ss">(</span><span class="nv">Function</span>.<span class="nv">call</span>,<span class="w"> </span><span class="nv">Math</span>.<span class="k">random</span><span class="ss">)</span>
</pre></div>

<blockquote>
<p>result: [0.7082694901619107, 0.9572225909214467, 0.8586748542729765,
0.8653848143294454, 0.008339877473190427, 0.9911756622605026,
0.8133423360995948, 0.8377588465809822, 0.5577575915958732,
0.16363654541783035]</p>
</blockquote>
<h4>解释</h4>
<p>首先，请注意<code>Number.call(undefined, N)</code>等同于<code>Number(N)</code>，它只返回<code>N</code>。我们稍后会用到这个事实。</p>
<p><code>Array.apply(null, [undefined, undefined, undefined])</code>等同于<code>Array(undefined,
undefined, undefined)</code>，它生成一个三元素数组并分配<code>undefined</code>给每个元素。</p>
<p>您如何将其推广到 <em>N 个</em> 元素？考虑一下它是如何<code>Array()</code>工作的，它是这样的：</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="k">Array</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">arguments</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="s1">'number'</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">typeof</span><span class="w"> </span><span class="n">arguments</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="n">arguments</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="n">arguments</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">[</span><span class="n"> … </span><span class="o">]</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">arguments</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">generated</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">native</span><span class="w"> </span><span class="n">code</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="nf">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[]</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arguments</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">arguments</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>从 ECMAScript 5 开始，<code>Function.prototype.apply(thisArg, argsArray)</code>它还接受一个 duck-
typed array-like object 作为它的第二个参数。如果我们调用<code>Array.apply(null, { length: N
})</code>，那么它将执行</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="k">Array</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="nf">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[]</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="cm">/* arguments.length = */</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cm">/* arguments[i] = */</span><span class="w"> </span><span class="n">undefined</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>现在我们有一个 <em>N</em> 元素数组，每个元素都设置为<code>undefined</code>。当我们调用<code>.map(callback,
thisArg)</code>它时，每个元素都将被设置为 的结果<code>callback.call(thisArg, element, index,
array)</code>。因此，<code>[undefined, undefined, …, undefined].map(Number.call,
Number)</code>会将每个元素映射到<code>(Number.call).call(Number, undefined, index, array)</code>，这与
相同<code>Number.call(undefined, index,
array)</code>，正如我们之前观察到的，计算结果为<code>index</code>。这样就完成了元素与其索引相同的数组。</p>
<p><code>Array.apply(null, {length: N})</code>为什么要经历而不是的麻烦呢<code>Array(N)</code>？毕竟，这两个表达式都会产生一个 <em>N</em>
元素的未定义元素数组。不同之处在于，在前一个表达式中，每个元素都明确 <em>设置</em> 为未定义，而在后者中，每个元素从未设置。根据以下文件<code>.map()</code>：</p>
<blockquote>
<p><code>callback</code>仅针对已分配值的数组索引调用；它不会为已删除或从未赋值的索引调用。</p>
</blockquote>
<p>因此，<code>Array(N)</code>是不够的；<code>Array(N).map(Number.call, Number)</code>将导致长度为 <em>N</em> 的未初始化数组。</p>
<h4>兼容性</h4>
<p>由于此技术依赖于<code>Function.prototype.apply()</code>ECMAScript 5 中指定的行为，因此它不适用于ECMAScript 5
之前的浏览器，例如 Chrome 14 和 Internet Explorer 9。</p>
<p><br><br><a href="posts/how-to-create-an-array-containing-1-n/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-137.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-135.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
