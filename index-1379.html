<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1379) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1379.html">
<link rel="prev" href="index-1380.html" type="text/html">
<link rel="next" href="index-1378.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-the-greedy-best-first-search-algorithm-different-from-the-best-first-search-algorithm/" class="u-url">Is the greedy best-first search algorithm different from the best-first search algorithm?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-the-greedy-best-first-search-algorithm-different-from-the-best-first-search-algorithm/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:47:16+08:00" itemprop="datePublished" title="2023-02-28 02:47">2023-02-28 02:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Is the <em>greedy</em> best-first search algorithm different from the best-first
search algorithm?</p>
<p>The wiki page has a separate paragraph about Greedy BFS but it's a little
unclear.</p>
<p>My understanding is that Greedy BFS is just BFS where the "best node from
OPEN" in wikipedia's algorithm is a heuristic function one calculates for a
node. So implementing this:</p>
<div class="code"><pre class="code literal-block"><span class="n">OPEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">initial</span><span class="w"> </span><span class="n">state</span><span class="p">]</span>
<span class="n">CLOSED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="k">while</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">do</span>
<span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">.</span>
<span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">goal</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">through</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parents</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">path</span><span class="p">.</span>
<span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">Create</span><span class="w"> </span><span class="n">n</span><span class="err">'</span><span class="n">s</span><span class="w"> </span><span class="n">successors</span><span class="p">.</span>
<span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="k">do</span><span class="o">:</span>
<span class="w">   </span><span class="n">a</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">CLOSED</span><span class="o">:</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">parent</span><span class="p">.</span>
<span class="w">   </span><span class="n">b</span><span class="p">.</span><span class="w"> </span><span class="n">Otherwise</span><span class="o">:</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">done</span>
</pre></div>

<p>with "best node from OPEN" being a heuristic function estimating how close the
node is to the goal, is actually Greedy BFS. Am I right?</p>
<p><em>EDIT:</em> Comment on Anonymouse's answer:</p>
<p>So essentially a greedy BFS doesn't need an "OPEN list" and should base its
decisions only on the current node? Is this algorithm GBFS:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1.</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">START</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="n">node</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="n">Path</span><span class="w"> </span><span class="err">[</span><span class="ow">and</span><span class="w"> </span><span class="n">optinally</span><span class="p">,</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="kr">CLOSE</span><span class="n">D</span><span class="err">?]</span>
<span class="mf">3.</span><span class="w"> </span><span class="kr">If</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">GO</span><span class="n">AL</span><span class="p">,</span><span class="w"> </span><span class="n">exit</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">Evaluate</span><span class="w"> </span><span class="n">CURRENT</span><span class="err">'</span><span class="n">s</span><span class="w"> </span><span class="n">successors</span>
<span class="mf">5.</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">BEST</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="kr">go</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="mf">2.</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Ten years after I asked this question, I got back to it and <em>finally</em>
understood what that article in Wikipedia was saying.</p>
<p>Greedy BFS is greedy in expanding a potentially better successor of the
<strong>current</strong> node. The difference between the two algorithms is in the loop
that handles the evaluation of successors. Best-first search always exhausts
the current node's successors by evaluating them and continues with the best
one from them:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="mi">4</span>.<span class="w"> </span><span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">successor</span><span class="w"> </span><span class="k">do</span>:
<span class="w">        </span><span class="nv">a</span>.<span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">CLOSED</span>:<span class="w"> </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">it</span>,<span class="w"> </span><span class="nv">add</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">OPEN</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">record</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">parent</span>.
<span class="w">        </span><span class="nv">b</span>.<span class="w"> </span><span class="nv">Otherwise</span>:<span class="w"> </span><span class="nv">change</span><span class="w"> </span><span class="nv">recorded</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">better</span><span class="w"> </span><span class="nv">than</span><span class="w"> </span><span class="nv">previous</span><span class="w"> </span><span class="nv">one</span>.
</pre></div>

<p>Greedy BFS doesn't expand <strong>all</strong> successors of a node if it finds one that
has a better <em>heuristic</em> than the current node. Instead it <em>greedily</em> expands
this potentially better node, leaving some of the current node's successors
unexpanded. This means the current node shouldn't be removed from the OPEN
list unless all its successors have been evaluated. This is the pseudo-code:</p>
<div class="code"><pre class="code literal-block"><span class="n">OPEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">initial</span><span class="w"> </span><span class="n">state</span><span class="p">]</span>
<span class="n">CLOSED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="k">while</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">do</span>
<span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">.</span>
<span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">goal</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">through</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parents</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">path</span><span class="p">.</span>
<span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="k">do</span><span class="o">:</span>
<span class="w">   </span><span class="n">a</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">CLOSED</span><span class="o">:</span><span class="w"> </span>
<span class="w">       </span><span class="n">i</span><span class="p">.</span><span class="w"> </span><span class="n">Evaluate</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">parent</span>
<span class="w">       </span><span class="n">ii</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">heuristic</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="n">remove</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span>
<span class="w">           </span><span class="p">(</span><span class="n">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">successor</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="mf">3.</span>
<span class="w">   </span><span class="n">b</span><span class="p">.</span><span class="w"> </span><span class="n">Otherwise</span><span class="o">:</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">done</span>
</pre></div>

<p>I have removed the step <code>3. Create n's successors.</code> from the BFS code above
because some of n's successors may not be evaluated, so there is no use
creating them. Instead each successor should be created and immediately
evaluated in <code>3. For each successor do:</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>BFS is an instance of <em>tree search</em> and <em>graph search</em> algorithms in which a
node is selected for expansion based on the evaluation function <code>f(n) = g(n) +
h(n)</code>, where <code>g(n)</code> is length of the path from the root to <code>n</code> and <code>h(n)</code> is
an estimate of the length of the path from <code>n</code> to the goal node. In a BFS
algorithm, the node with the lowest evaluation (i.e. lowest <code>f(n)</code>) is
selected for expansion.</p>
<p>Greedy BFS uses the following evaluation function <code>f(n) = h(n)</code>, which is just
the heuristic function <code>h(n)</code>, which estimates the closeness of <code>n</code> to the
goal. Hence, greedy BFS tries to expand the node that is thought to be closest
to the goal, without taking into account previously gathered knowledge (i.e.
<code>g(n)</code>).</p>
<p>To summarize, the main difference between these (similar) search methods is
the evaluation function.</p>
<p>As a side note, the A<em> algorithm is a best-first search algorithm in which the
heuristic function <code>h</code> is an admissible heuristic (i.e. <code>h</code> is always an
underestimation of the perfect heuristic function <code>h*</code>, for all <code>n</code>). A</em> is
not a gredy BFS algorithm because its evaluation function is <code>f(n) = g(n) +
h(n)</code>.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-there-any-difference-between-an-activation-function-and-a-transfer-function/" class="u-url">Is there any difference between an activation function and a transfer function?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-there-any-difference-between-an-activation-function-and-a-transfer-function/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:46:55+08:00" itemprop="datePublished" title="2023-02-28 02:46">2023-02-28 02:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>It seems there is a bit of confusion between activation and transfer function.
From Wikipedia ANN:</p>
<p><img alt="enter image description here" src="images/ibYr3.png"></p>
<p>It seems that the transfer function calculates the net while the activation
function the output of the neuron. But on Matlab documentation of an
activation function I quote:</p>
<blockquote>
<p>satlin(N, FP) is a neural <strong>transfer</strong> function. Transfer functions
calculate a layer's output from its net input.</p>
</blockquote>
<p>So who is right? And can you use the term activation function or transfer
function interchangeably?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>No, they are the same</strong>. I also quote from wikipedia: "Usually the sums of
each node are weighted, and the sum is passed through a non-linear function
known as an <em>activation function or transfer function</em>. Don't take the matlab
documentation too literally, it's thousand of pages long so some words might
not be used in their strict sense.</p>
<p>In machine learning at least, they are used interchangeably by all books I've
read.</p>
<ul>
<li>
<em>activation function</em> is used almost exclusively nowadays.</li>
<li>
<em>transfer function</em> is mostly used in older (80/90's) books, when machine learning was uncommon, and most readers had an electrical engineering/signal processing background.</li>
</ul>
<p>So, to sum up</p>
<ul>
<li>prefer the term <em>activation function</em>. It's more common, and more appropriate, both from a biological point of view (neuron fires when you surpass a threshold) and an engineering point of view (an actual transfer function should describe the whole system)</li>
<li>if anyone else makes a distinction between them, ask them to clear up what they mean</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>After some research I've found in "Survey of Neural Transfer Functions", from
Duch and Jankowski (1999) that:</p>
<div class="code"><pre class="code literal-block">transfer_function = activation function + output function
</pre></div>

<p>And IMO the terminology makes sense now since we need to have a value (signal
strength) to verify it the neuron will be activated and then compute an output
from it. And what the whole process do is to transfer a signal from one layer
to another.</p>
<blockquote>
<p>Two functions determine the way signals are processed by neurons. The
<strong>activation function</strong> determines the total signal a neuron receives. The
value of the activation function is usually scalar and the arguments are
vectors. The second function determining neuron’s signal processing is the
<strong>output function</strong> o(I), operating on scalar activations and returning
scalar values. Typically a squashing function is used to keep the output
values within specified bounds. These two functions together determine the
values of the neuron outgoing signals. The composition of the activation and
the output function is called the <strong>transfer function</strong> o(I(x)).</p>
</blockquote>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/a-heuristic-overestimation-underestimation/" class="u-url">A* heuristic, overestimation/underestimation?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/a-heuristic-overestimation-underestimation/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:46:27+08:00" itemprop="datePublished" title="2023-02-28 02:46">2023-02-28 02:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am confused about the terms overestimation/underestimation. I perfectly get
how A* algorithm works, but i am unsure of the effects of having a heuristic
that overestimate or underestimate.</p>
<p>Is overestimation when you take the square of the direct birdview-line? And
why would it make the algorithm incorrect? The same heuristic is used for all
nodes.</p>
<p>Is underestimation when you take the squareroot of the direct birdview-line?
And why is the algorithm still correct?</p>
<p>I can't find an article which explains it nice and clear so I hope someone
here has a good description.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You're overestimating when the heuristic's estimate is higher than the actual
final path cost. You're underestimating when it's lower (you don't have to
underestimate, you just have to not overestimate; <em>correct</em> estimates are
fine). If your graph's edge costs are all 1, then the examples you give would
provide overestimates and underestimates, though the plain coordinate distance
also works peachy in a Cartesian space.</p>
<p>Overestimating doesn't exactly make the algorithm "incorrect"; what it means
is that you no longer have an <em>admissible heuristic</em> , which is a condition
for A* to be guaranteed to produce optimal behavior. With an inadmissible
heuristic, the algorithm can wind up doing tons of superfluous work examining
paths that it should be ignoring, and possibly finding suboptimal paths
because of exploring those. Whether that actually occurs depends on your
problem space. It happens because the path cost is 'out of joint' with the
estimate cost, which essentially gives the algorithm messed up ideas about
which paths are better than others.</p>
<p>I'm not sure whether you will have found it, but you may want to look at the
Wikipedia A* article. I mention (and link) mainly because it's almost
impossible to Google for it.</p>
<p><br></p>
<h3>Suggest</h3>
<p>From the Wikipedia A* article, the relevant part of the algorithm description
is:</p>
<blockquote>
<p>The algorithm continues until a goal node has a lower <strong><em>f</em></strong> value than any
node in the queue (or until the queue is empty).</p>
</blockquote>
<p>The key idea is that, with understimation, A<em> will only stop exploring a
potential path to the goal once it knows that the total cost of the path will
exceed the cost of a known path to the goal. Since the estimate of a path's
cost is always less than or equal to the path's real cost, A</em> can discard a
path as soon as the estimated cost exceeds the total cost of a known path.</p>
<p>With overestimation, A* has no idea when it can stop exploring a potential
path as there can be paths with lower actual cost but higher estimated cost
than the best currently known path to the goal.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1380.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1378.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
