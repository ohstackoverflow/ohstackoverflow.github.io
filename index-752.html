<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 752) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-752.html">
<link rel="prev" href="index-753.html" type="text/html">
<link rel="next" href="index-751.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ha-si-ke-er-ru-men/" class="u-url">哈斯克尔入门</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ha-si-ke-er-ru-men/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:13:59+08:00" itemprop="datePublished" title="2023-02-17 15:13">2023-02-17 15:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>几天来，我一直在努力思考 Haskell
中的函数式编程范例。我已经通过阅读教程和观看截屏视频来做到这一点，但似乎没有什么能真正坚持下去。现在，在学习各种命令式/OO 语言（如
C、Java、PHP）时，练习对我来说是一个很好的方式。但是因为我真的不知道 Haskell 有什么能力，而且有很多新概念可以利用，所以我不知道从哪里开始。</p>
<p>那么，你是如何学习 Haskell 的？是什么让你真正“打破僵局”？另外，开始练习有什么好的想法吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>我将根据您在 Haskell 中的技能水平来订购本指南，从绝对的初学者到专家。请注意，此过程将花费数月（数年？），因此相当长。</p>
<p><strong>绝对的新人</strong></p>
<p>首先，Haskell 无所不能，只要有足够的技巧。它非常快（根据我的经验，仅次于 C 和 C++），并且可用于从模拟到服务器、GUI 和 Web
应用程序的任何事物。</p>
<p>然而，对于 Haskell 的初学者来说，有些问题比其他问题更容易编写。数学问题和列表处理程序是很好的候选者，因为它们只需要最基本的 Haskell
知识就可以编写。</p>
<p>一些学习 Haskell 基础知识的好指南是快乐学习 Haskell 教程和Learn You a Haskell for Great
Good（或其JupyterLab 改编版）的前 6 章。在阅读这些内容的同时，用你所知道的知识解决简单的问题是一个很好的主意。</p>
<p>另外两个很好的资源是Haskell Programming from first principles和Programming in
Haskell。它们都为每一章提供了练习，所以你会遇到与你在最后几页学到的内容相匹配的小问题。</p>
<p>要尝试的一个很好的问题列表是haskell 99
问题页面。这些从非常基础开始，随着您的继续变得越来越困难。做很多这样的事情是很好的练习，因为它们可以让你练习递归和高阶函数的技能。我建议跳过任何需要随机性的问题，因为这在
Haskell 中有点困难。如果您想使用 QuickCheck 测试您的解决方案，请检查此 SO 问题（请参阅下面的 <em>中级</em> ）。</p>
<p>一旦你完成了其中的一些，你就可以继续解决一些Project Euler问题。这些按完成的人数排序，这是难度的一个很好的指示。这些比前面的问题更考验你的逻辑和
Haskell，但你应该仍然能够做前几个。Haskell 在处理这些问题时的一大优势是整数不受大小限制。要完成其中的一些问题，阅读《学习
Haskell》的第 7 章和第 8 章将很有用。</p>
<p><strong>初学者</strong></p>
<p>在那之后，你应该对递归和高阶函数有相当好的处理，所以现在是开始解决一些更现实世界问题的好时机。一个很好的起点是Real World
Haskell（在线书籍，您也可以购买纸质版）。我发现前几章对于以前从未做过函数式编程/使用过递归的人来说介绍得太快太快了。然而，通过你在做前面的问题时所做的练习，你应该会发现它是完全可以理解的。</p>
<p>解决书中的问题是学习如何在 Haskell 中管理抽象和构建可重用组件的好方法。这对于习惯面向对象 (oo) 编程的人来说至关重要，因为普通的 oo
抽象方法（oo 类）不会出现在 Haskell 中（Haskell 有类型类，但它们与 oo 类有很大不同，更像是 oo 接口).
我不认为跳过章节是个好主意，因为每一章都会介绍很多在后面的章节中使用的新想法。</p>
<p>一段时间后，您将进入第 14 章，可怕的单子一章 (dum dum dummmm)。几乎所有学习 Haskell 的人都难以理解
monad，因为这个概念太抽象了。我想不出另一种语言中有任何概念像函数式编程中的 monad 一样抽象。Monads 允许将许多想法（例如 IO
操作、可能会失败的计算、解析...）统一在一个想法下。因此，如果您在阅读了 monads 章节后还没有真正理解它们，请不要感到气馁。我发现阅读许多关于
monad 的不同解释很有用；每个人都对问题提出了新的看法。这是一个非常好的monad 教程列表。我强烈推荐All About
Monads，但其他的也不错。</p>
<p>此外，概念真正深入人心需要一段时间。这是通过使用来实现的，但也需要时间。我发现有时睡在一个问题上比什么都重要！最终，这个想法会成功，你会想知道为什么你很难理解一个在现实中非常简单的概念。当这种情况发生时真是太棒了，当它发生时，您可能会发现
Haskell 是您最喜欢的命令式编程语言 :)</p>
<p>为了确保您完全理解 Haskell 类型系统，您应该尝试解决20 个中级 Haskell
练习。这些练习使用有趣的函数名称，如“furry”和“banana”，并帮助您很好地理解一些基本的函数式编程概念（如果您还没有的话）。在一堆覆盖着箭头、独角兽、香肠和毛茸茸的香蕉的纸上度过一个美好的夜晚。</p>
<p><strong>中间的</strong></p>
<p>一旦你了解了 Monads，我认为你已经从初级 Haskell 程序员过渡到中级 haskell
程序员。那么从这里去哪里呢？我要推荐的第一件事（如果你还没有从学习 monad 中学到它们的话）是各种类型的 monad，比如 Reader、Writer
和 State。同样，Real world Haskell 和 All about monads 对此进行了很好的介绍。要完成你的 monad 培训，学习
monad transformers 是必须的。这些使您可以将不同类型的 Monad（例如 Reader 和 State
monad）组合为一个。这可能一开始看起来毫无用处，但在使用了一段时间后，您会想知道没有它们您是如何生活的。</p>
<p>如果你愿意，现在你可以完成真实世界的 Haskell 书。现在跳过章节并不重要，只要你有 monads down pat。只需选择您感兴趣的内容即可。</p>
<p>有了你现在拥有的知识，你应该能够使用 cabal 上的大部分包（以及至少有文档记录的包......），以及 Haskell
附带的大部分库。要尝试的有趣库列表是：</p>
<ul>
<li>
<p>Parsec：用于解析程序和文本。比使用正则表达式好得多。优秀的文档，还有真实世界的 Haskell 章节。</p>
</li>
<li>
<p>QuickCheck：一个非常酷的测试程序。您所做的是编写一个应该始终为真的谓词（例如<code>length (reverse lst) == length lst</code>）。然后您将谓词传递给 QuickCheck，它将生成大量随机值（在本例中为列表）并测试谓词是否对所有结果都为真。另请参阅联机手册。</p>
</li>
<li>
<p>HUnit：Haskell 中的单元测试。</p>
</li>
<li>
<p>gtk2hs：最流行的 Haskell 图形用户界面框架，可让您编写 gtk 应用程序。</p>
</li>
<li>
<p>happstack：Haskell 的 Web 开发框架。不使用数据库，而是使用数据类型存储。非常好的文档（其他流行的框架是snap和yesod）。</p>
</li>
</ul>
<p>此外，还有许多您最终应该学习的概念（如 Monad 概念）。这将比第一次学习 Monad
更容易，因为您的大脑将习惯于处理所涉及的抽象级别。Typeclassopedia是学习这些高级概念以及它们如何组合在一起的一个很好的概述。</p>
<ul>
<li>
<p>Applicative：类似于 Monads 的接口，但功能较弱。每个 Monad 都是适用的，但反之则不然。这很有用，因为有些类型是适用的但不是 Monad。此外，使用 Applicative 函数编写的代码通常比使用 Monad 函数编写等效代码更具可组合性。请参阅learn you a haskell 指南中的Functors、Applicative Functors 和 Monoids 。</p>
</li>
<li>
<p>Foldable，Traversable：抽象许多列表操作的类型类，以便可以将相同的功能应用于其他容器类型。另请参阅haskell wiki 解释。</p>
</li>
<li>
<p>Monoid：Monoid 是一种具有零（或空）值的类型，以及一个将<code>&lt;&gt;</code>两个 Monoid 连接在一起的操作，例如<code>x &lt;&gt; mempty = mempty &lt;&gt; x = x</code>and <code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z</code>。这些被称为恒等律和结合律。许多类型都是幺半群，例如数字，带有<code>mempty = 0</code>和<code>&lt;&gt; = +</code>。这在很多情况下都很有用。</p>
</li>
<li>
<p>箭头：箭头是表示接受输入并返回输出的计算的一种方式。函数是最基本的箭头类型，但还有许多其他类型。该库还有许多非常有用的操作箭头的函数——即使只与普通的旧 Haskell 函数一起使用，它们也非常有用。</p>
</li>
<li>
<p>数组：Haskell 中的各种可变/不可变数组。</p>
</li>
<li>
<p>ST Monad：让你编写具有可变状态的代码，运行速度非常快，同时在 monad 之外仍然保持纯净。请参阅链接查看更多细节。</p>
</li>
<li>
<p>FRP：Functional Reactive Programming，一种新的、实验性的编写处理事件、触发器、输入和输出（例如 gui）代码的方法。不过我对此了解不多。Paul Hudak 关于 yampa 的演讲是一个好的开始。</p>
</li>
</ul>
<p>您应该了解许多新的语言功能。我只是列出它们，您可以从 google、 haskell wikibook、haskellwiki.org 网站和ghc
文档中找到很多关于它们的信息。</p>
<ul>
<li>多参数类型类/功能依赖</li>
<li>类型族</li>
<li>存在量化类型</li>
<li>幻影类型</li>
<li>贸易协定</li>
<li>其他的...</li>
</ul>
<p>很多 Haskell 都是基于范畴论的，所以你可能想研究一下。一个很好的起点是计算机科学家的范畴论。不想买书的话，作者的相关文章也很棒。</p>
<p>最后，您将想要了解更多有关各种 Haskell 工具的信息。这些包括：</p>
<ul>
<li>ghc（及其所有功能）</li>
<li>cabal：Haskell 包系统</li>
<li>darcs：一个用 Haskell 编写的分布式版本控制系统，在 Haskell 程序中非常流行。</li>
<li>黑线鳕：Haskell 自动文档生成器</li>
</ul>
<p>在学习所有这些新库和概念的同时，用 Haskell
编写一个中等规模的项目非常有用。它可以是任何东西（例如小游戏、数据分析器、网站、编译器）。从事这项工作将使您能够应用您现在正在学习的许多东西。你在这个水平上停留了很长时间（这就是我所在的位置）。</p>
<p><strong>专家</strong></p>
<p>到达这个阶段需要几年的时间（你好，从 2009 年开始！），但我猜你从这里开始写 phd 论文、新的 ghc 扩展，并提出新的抽象。</p>
<p><strong>获得帮助</strong></p>
<p>最后，在学习的任何阶段，都有多个获取信息的地方。这些都是：</p>
<ul>
<li>
<h2>haskell irc频道</h2>
</li>
<li>邮件列表。这些值得注册，只是为了阅读发生的讨论——有些非常有趣。</li>
<li>haskell.org 主页上列出的其他地方</li>
</ul>
<p><strong>结论</strong></p>
<p>好吧，结果比我预期的要长......无论如何，我认为精通 Haskell
是一个非常好的主意。这需要很长时间，但这主要是因为你正在通过这样做学习一种全新的思维方式。这不像是学了Java再学Ruby，而是学了C再学Java。另外，我发现我的面向对象编程技能由于学习了Haskell而得到了提高，因为我看到了许多抽象思想的新方法。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我的一些同事在Learn You a Haskell for Great Good 方面有很好的经验！.</p>
<blockquote>
<p>教程针对具有命令式编程语言经验但之前没有使用函数式语言编程的人。</p>
</blockquote>
<p>也在这里检查答案</p>
<p><br><br><a href="posts/getting-started-with-haskell/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/liao-jie-java-zhong-de-yi-jian-cha-yi-chang-yu-wei-jian-cha-yi-chang/" class="u-url">了解 Java 中的已检查异常与未检查异常</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/liao-jie-java-zhong-de-yi-jian-cha-yi-chang-yu-wei-jian-cha-yi-chang/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:13:33+08:00" itemprop="datePublished" title="2023-02-17 15:13">2023-02-17 15:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Joshua Bloch 在“ <em>Effective Java</em> ”中说</p>
<blockquote>
<p>对可恢复条件使用检查异常，对编程错误使用运行时异常（第 2 版第 58 项）</p>
</blockquote>
<p>让我们看看我是否理解正确。</p>
<p>这是我对检查异常的理解：</p>
<div class="code"><pre class="code literal-block">try{
    String userInput = //read in user input
    Long id = Long.parseLong(userInput);
}catch(NumberFormatException e){
    id = 0; //recover the situation by setting the id to 0
}
</pre></div>

<p><strong>1.以上是否被视为已检查异常？</strong></p>
<p><strong>2. RuntimeException 是未检查的异常吗？</strong></p>
<p>这是我对未经检查的异常的理解：</p>
<div class="code"><pre class="code literal-block"><span class="nv">try</span>{
<span class="w">    </span><span class="nv">File</span><span class="w"> </span><span class="nv">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">File</span><span class="ss">(</span><span class="s2">"my/file/path"</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">FileInputStream</span><span class="w"> </span><span class="nv">fis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">FileInputStream</span><span class="ss">(</span><span class="nv">file</span><span class="ss">)</span><span class="c1">;   </span>
}<span class="nv">catch</span><span class="ss">(</span><span class="nv">FileNotFoundException</span><span class="w"> </span><span class="nv">e</span><span class="ss">)</span>{

<span class="o">//</span><span class="mi">3</span>.<span class="w"> </span><span class="nv">What</span><span class="w"> </span><span class="nv">should</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">here</span>?
<span class="w">    </span><span class="o">//</span><span class="nv">Should</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="s2">"throw new FileNotFoundException("</span><span class="nv">File</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">found</span><span class="s2">");"</span>?
<span class="w">    </span><span class="o">//</span><span class="nv">Should</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="nv">log</span>?
<span class="w">    </span><span class="o">//</span><span class="nv">Or</span><span class="w"> </span><span class="nv">should</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="nv">System</span>.<span class="k">exit</span><span class="ss">(</span><span class="mi">0</span><span class="ss">)</span><span class="c1">;?</span>
}
</pre></div>

<p><strong>4. 现在，上面的代码不能也是一个检查异常吗？ 我可以尝试恢复这样的情况吗？我可以吗？</strong>（注意：我的第三个问题在上面<code>catch</code>）</p>
<div class="code"><pre class="code literal-block">try{
    String filePath = //read in from user input file path
    File file = new File(filePath);
    FileInputStream fis = new FileInputStream(file);   
}catch(FileNotFoundException e){
    //Kindly prompt the user an error message
    //Somehow ask the user to re-enter the file path.
}
</pre></div>

<p><strong>5. 人们为什么要这样做？</strong></p>
<div class="code"><pre class="code literal-block">public void someMethod throws Exception{

}
</pre></div>

<p>他们为什么要让异常冒出来？越早处理错误不是更好吗？为什么要冒泡？</p>
<p><strong>6. 我应该冒出确切的异常还是使用 Exception 屏蔽它？</strong></p>
<p><strong>以下是我的读物</strong></p>
<p>在 Java 中，什么时候应该创建检查异常，什么时候应该创建运行时异常？</p>
<p>何时选择已检查和未检查的异常</p>
<p><br><br></p>
<h2>解答</h2>
<p>许多人说根本不应该使用已检查的异常（即您应该明确捕获或重新抛出的异常）。例如，它们在 C#
中被淘汰，大多数语言都没有它们。所以你总是可以抛出一个子类<code>RuntimeException</code>（未经检查的异常）</p>
<p>但是，我认为已检查的异常很有用 - 当您想要强制 API 的用户考虑如何处理异常情况（如果它是可恢复的）时，可以使用它们。只是checked
exception在Java平台被过度使用，让人讨厌。</p>
<p>这是我对该主题的扩展观点。</p>
<p>至于具体问题：</p>
<ol>
<li>
<p><strong>考虑是<code>NumberFormatException</code>已检查的异常吗？</strong><br>
No.<code>NumberFormatException</code>未选中（= 是
的子类<code>RuntimeException</code>）。为什么？我不知道。（但应该有一个方法<code>isValidInteger(..)</code>）</p>
</li>
<li>
<p><strong>是<code>RuntimeException</code>未经检查的异常吗？</strong><br>
对，就是这样。</p>
</li>
<li>
<p><strong>我应该在这里做什么？</strong><br>
这取决于此代码的位置以及您想要发生的事情。如果它在 UI 层 - 捕获它并显示警告；如果它在服务层 - 根本不要抓住它 -
让它冒泡。只是不要吞下例外。如果在大多数情况下发生异常，您应该选择以下之一：</p>
<ul>
<li>记录并返回</li>
<li>重新抛出它（声明它被方法抛出）</li>
<li>通过在构造函数中传递当前异常来构造一个新异常</li>
<li>
<strong>现在，上面的代码不能也是一个已检查的异常吗？ 我可以尝试恢复这样的情况吗？我可以吗？</strong><br>
本来可以的。但是也没有什么能阻止您捕获未经检查的异常</li>
</ul>
</li>
<li>
<p><strong>为什么人们要<code>Exception</code>在 throws 子句中添加类？</strong><br>
最常见的原因是人们懒于考虑捕捉什么和重新扔掉什么。投掷<code>Exception</code>是一种不好的做法，应该避免。</p>
</li>
</ol>
<p>las，没有单一的规则可以让您确定何时捕获、何时重新抛出、何时使用已检查以及何时使用未检查的异常。我同意这会导致很多混乱和很多错误代码。一般原则由
Bloch 陈述（您引用了其中的一部分）。总的原则是将异常重新抛到您可以处理的层。</p>
<p><br></p>
<h3>更多建议</h3>
<p>某事是否是“已检查异常”与您是否捕获它或您在 catch 块中执行的操作无关。它是异常类的一个属性。任何属于<code>Exception</code> <em>except</em>
for<code>RuntimeException</code>及其子类的子类都是已检查异常。</p>
<p>Java 编译器强制您捕获已检查的异常或在方法签名中声明它们。它本应提高程序的安全性，但大多数人的意见似乎是它不值得它造成的设计问题。</p>
<blockquote>
<p>他们为什么要让异常冒出来？处理错误不是越早越好吗？为什么要冒泡？</p>
</blockquote>
<p>因为这就是例外的全部 <em>意义所在</em>
。如果没有这种可能性，您将不需要异常。它们使您能够在您选择的级别处理错误，而不是强迫您在错误最初发生的地方以低级别方法处理它们。</p>
<p><br><br><a href="posts/understanding-checked-vs-unchecked-exceptions-in-java/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/react-zhong-de-state-he-props-you-shi-yao-qu-bie/" class="u-url">React 中的 state 和 props 有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/react-zhong-de-state-he-props-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:13:01+08:00" itemprop="datePublished" title="2023-02-17 15:13">2023-02-17 15:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我在看一个关于 React 的 Pluralsight 课程，讲师说 props 不应该被改变。我现在正在阅读一篇关于 props vs. state
的文章（uberVU/react-guide），它说</p>
<blockquote>
<p>道具和状态更改都会触发渲染更新。</p>
</blockquote>
<p>文章后面说：</p>
<blockquote>
<p>道具（属性的缩写）是组件的配置，如果可以的话，它是选项。它们是从上面接收的并且是不可变的。</p>
</blockquote>
<ul>
<li>所以道具可以改变但他们应该是不可变的？</li>
<li>什么时候应该使用道具，什么时候应该使用状态？</li>
<li>如果你有一个 React 组件需要的数据，它应该通过 props 传递还是在 React 组件中通过 setup 传递<code>getInitialState</code>？</li>
</ul>
<p><br><br></p>
<h2>解答</h2>
<p>道具和状态是相关的。一个组件的状态通常会成为子组件的道具。道具在父级的渲染方法中作为第二个参数传递给子级，<code>React.createElement()</code>或者，如果您使用的是
JSX，则是更熟悉的标签属性。</p>
<div class="code"><pre class="code literal-block">&lt;MyChild name={this.state.childsName} /&gt;
</pre></div>

<p>父级的状态值<code>childsName</code>变为子级的状态值<code>this.props.name</code>。从孩子的角度来看，name prop
是不可变的。如果需要更改，父级应该只更改其内部状态：</p>
<div class="code"><pre class="code literal-block"><span class="nt">this</span><span class="p">.</span><span class="nc">setState</span><span class="o">(</span><span class="p">{</span><span class="w"> </span><span class="n">childsName</span><span class="p">:</span><span class="w"> </span><span class="s1">'New name'</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
</pre></div>

<p>React
会为您将其传播给孩子。一个自然而然的后续问题是：如果孩子需要更改其名称道具怎么办？这通常是通过子事件和父回调来完成的。孩子可能会公开一个名为的事件，例如，<code>onNameChanged</code>。然后父级将通过传递回调处理程序来订阅该事件。</p>
<div class="code"><pre class="code literal-block">&lt;MyChild name={this.state.childsName} onNameChanged={this.handleName} /&gt;
</pre></div>

<p>孩子将通过调用将其请求的新名称作为参数传递给事件回调，例如 ，<code>this.props.onNameChanged('New
name')</code>而父母将使用事件处理程序中的名称来更新其状态。</p>
<div class="code"><pre class="code literal-block"><span class="n">handleName</span><span class="o">:</span><span class="w"> </span><span class="kd">function</span><span class="o">(</span><span class="n">newName</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span><span class="k">this</span><span class="o">.</span><span class="na">setState</span><span class="o">({</span><span class="w"> </span><span class="n">childsName</span><span class="o">:</span><span class="w"> </span><span class="n">newName</span><span class="w"> </span><span class="o">});</span>
<span class="o">}</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>亲子交流，传递props即可。</p>
<p>使用 <strong>状态</strong> 在控制器视图中存储当前页面所需的数据。</p>
<p>使用 <strong>道具</strong> 将数据和事件处理程序向下传递给您的子组件。</p>
<p>这些列表应该有助于指导您处理组件中的数据。</p>
<p><strong>道具</strong></p>
<ul>
<li>是不可变的 <ul>
<li>让 React 进行快速参考检查</li>
</ul>
</li>
<li>用于从您的视图控制器向下传递数据 <ul>
<li>你的顶级组件</li>
</ul>
</li>
<li>有更好的表现 <ul>
<li>使用它来将数据传递给子组件</li>
</ul>
</li>
</ul>
<p><strong>状态</strong></p>
<ul>
<li>应该在您的视图控制器中进行管理 <ul>
<li>你的顶级组件</li>
</ul>
</li>
<li>是可变的</li>
<li>表现较差</li>
<li>不应从子组件访问 <ul>
<li>用道具传递下去</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于没有父子关系的两个组件之间的通信，您可以设置自己的全局事件系统。在componentDidMount()中订阅事件，在componentWillUnmount()中取消订阅，收到事件后调用setState()。通量模式是一种可能的安排方式。-
https://facebook.github.io/react/tips/communicate-between-components.html</p>
<p><strong>哪些组件应该有状态？</strong></p>
<p>你的大部分组件应该简单地从 props 中获取一些数据并渲染它。然而，有时您需要响应用户输入、服务器请求或时间流逝。为此，您使用状态。</p>
<p>尝试让尽可能多的组件保持 <strong>无状态</strong> 。通过这样做，您会将状态隔离到其最合乎逻辑的位置并最大限度地减少冗余，从而更容易推理您的应用程序。</p>
<p>一种常见的模式是创建几个仅渲染数据的 <strong>无状态</strong> 组件，并在层次结构中在它们之上有一个有状态组件，该组件通过 props
将其状态传递给其子组件。有状态组件封装了所有交互逻辑，而无状态组件负责以声明方式呈现数据。-
https://facebook.github.io/react/docs/interactivity-and-dynamic-
uis.html#what-c​​omponents-should -have-state</p>
<p><strong>状态应该是什么？</strong></p>
<p>状态应该包含组件的事件处理程序可能更改以触发 UI 更新的数据。在实际应用程序中，此数据往往非常小且可通过 JSON
序列化。在构建有状态组件时，考虑其状态的最小可能表示，并且只将这些属性存储在 this.state 中。在 render()
内部，只需根据此状态计算您需要的任何其他信息。你会发现以这种方式思考和编写应用程序往往会导致最正确的应用程序，因为向状态添加冗余或计算值意味着你需要明确地保持它们同步而不是依赖
React 为你计算它们。- https://facebook.github.io/react/docs/interactivity-and-
dynamic-uis.html#what-should-go-in-state</p>
</blockquote>
<p><br><br><a href="posts/what-is-the-difference-between-state-and-props-in-react/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-753.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-751.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
