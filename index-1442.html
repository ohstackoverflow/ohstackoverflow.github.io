<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1442) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1442.html">
<link rel="prev" href="index-1443.html" type="text/html">
<link rel="next" href="index-1441.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/developing-an-ai-system-to-pick-a-fantasy-football-team/" class="u-url">Developing an AI system to pick a fantasy football team</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/developing-an-ai-system-to-pick-a-fantasy-football-team/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:57:01+08:00" itemprop="datePublished" title="2023-02-28 03:57">2023-02-28 03:57</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm looking to build an AI system to "pick" a fantasy football team. I have
only basic knowledge of AI techniques (especially when it comes to game
theory), so I am looking for advice on what techniques could be used to
accomplish this and pointers to some reading materials.</p>
<p>I am aware that this may be a very difficult or maybe even impossible task for
AI to accurately complete: however I am not too concerned on the accuracy,
rather I am interested in learning some AI and this seems like a fun way to
apply it.</p>
<p>Some basic facts about the game:</p>
<ul>
<li>A team of 14 players must be picked</li>
<li>There is a limit on the total cost of players picked</li>
<li>The players picked must adhere to a certain configuration (there must always be one goalkeeper, at least two defenders, one midfielder and one forward)</li>
<li>The team may be altered on a weekly basis but removing/adding more than one player a week will inccur a penalty</li>
</ul>
<p>P.S. I have stats on every match played in last season, could this be used to
train the AI system?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>This is interesting.</p>
<p>So if you didn't really care about accuracy at all, you could just come up
with some heuristic for the quality of a team. For instance, assign a point
value to each player and then try to maximize it using dynamic programming.
Something like:
http://www.cse.unl.edu/~goddard/Courses/CSCE310J/Lectures/Lecture8-DynamicProgramming.pdf</p>
<p>This would be similar to the knapsack problem.</p>
<p>Technically this is AI since a computer is deciding something but maybe not
what you had in mind.</p>
<p>You sound like you want a learning AI
(http://en.wikipedia.org/wiki/Machine_learning) which is an interesting field.
Here's how you can approach the problem.</p>
<p>Define your inputs. Right now you have last years data. You'll probably want
data on many years. Also, you might be able to include the ranking of pundits,
maybe a bunch of magazines rank players or something, that seems useful as
well.</p>
<p>Take your inputs and feed them into some machine learning algorithm for each
season. Wikipedia will help you out there.</p>
<p>Essentially, for each season you'll want to feed in your data, have your AI
pick a team, and then rate the performance of the team based on the seasons
results.</p>
<p>Keep doing this and maybe your bot will get better at picking teams, and you
can apply to this year's data.</p>
<p>(If you only have last year's data, it's okay to train the algorithm with just
that but your AI will probably be over trained on that one set and won't be as
accurate.)</p>
<p>This was just a sketch of how it might look. For a romp into AI, this problem
is probably pretty hard so don't feel disheartened if it seems overwhelming at
first.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-best-way-to-filter-spam-with-javascript/" class="u-url">What is the best way to filter spam with JavaScript?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-best-way-to-filter-spam-with-javascript/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:56:43+08:00" itemprop="datePublished" title="2023-02-28 03:56">2023-02-28 03:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have recently been inspired to write spam filters in JavaScript,
Greasemonkey-style, for several websites I use that are prone to spam
(especially in comments). When considering my options about how to go about
this, I realize I have several options, each with pros/cons. <strong>My goal for
this question is to expand on this list I have created, and hopefully
determine the best way of client-side spam filtering with JavaScript.</strong></p>
<p>As for what makes a spam filter the "best", I would say these are the
criteria:</p>
<ul>
<li>Most accurate</li>
<li>Least vulnerable to attacks</li>
<li>Fastest</li>
<li>Most transparent</li>
</ul>
<p><strong>Also, please note that I am trying to filter content that already exists on
websites that aren't mine, using Greasemonkey Userscripts. In other words, I
can't prevent spam; I can only filter it.</strong></p>
<p>Here is my attempt, so far, to compile a list of the various methods along
with their shortcomings and benefits:</p>
<hr>
<p><strong>Rule-based filters:</strong></p>
<p><em>What it does:</em> "Grades" a message by assigning a point value to different
criteria (i.e. all uppercase, all non-alphanumeric, etc.) Depending on the
score, the message is discarded or kept.</p>
<p><em>Benefits:</em></p>
<ul>
<li>Easy to implement</li>
<li>Mostly transparent</li>
</ul>
<p><em>Shortcomings:</em></p>
<ul>
<li>Transparent- it's usually easy to reverse engineer the code to discover the rules, and thereby craft messages which won't be picked up</li>
<li>Hard to balance point values (false positives)</li>
<li>Can be slow; multiple rules have to be executed on each message, a lot of times using regular expressions</li>
<li>In a client-side environment, server interaction or user interaction is required to update the rules</li>
</ul>
<p><strong>Bayesian filtering:</strong></p>
<p><em>What it does:</em> Analyzes word frequency (or trigram frequency) and compares it
against the data it has been <em>trained</em> with.</p>
<p><em>Benefits</em> :</p>
<ul>
<li>No need to craft rules</li>
<li>Fast (relatively)</li>
<li>Tougher to reverse engineer</li>
</ul>
<p><em>Shortcomings:</em></p>
<ul>
<li>Requires training to be effective</li>
<li>Trained data must still be accessible to JavaScript; usually in the form of human-readable JSON, XML, or flat file</li>
<li>Data set can get pretty large</li>
<li>Poorly designed filters are easy to confuse with a good helping of common words to lower the <em>spamacity</em> rating</li>
<li>Words that haven't been seen before can't be accurately classified; sometimes resulting in incorrect classification of entire message</li>
<li>In a client-side environment, server interaction or user interaction is required to update the rules</li>
</ul>
<p><strong>Bayesian filtering- server-side:</strong></p>
<p><em>What it does:</em> Applies Bayesian filtering server side by submitting each
message to a remote server for analysis.</p>
<p><em>Benefits:</em></p>
<ul>
<li>All the benefits of regular Bayesian filtering</li>
<li>Training data is not revealed to users/reverse engineers</li>
</ul>
<p><em>Shortcomings:</em></p>
<ul>
<li>Heavy traffic</li>
<li>Still vulnerable to uncommon words</li>
<li>Still vulnerable to adding common words to decrease spamacity</li>
<li>The service itself may be abused</li>
<li>To train the classifier, it may be desirable to allow users to submit spam samples for training. Attackers may abuse this service</li>
</ul>
<p><strong>Blacklisting:</strong></p>
<p><em>What it does:</em> Applies a set of criteria to a message or some attribute of
it. If one or more (or a specific number of) criteria match, the message is
rejected. A lot like <strong>rule-based filtering</strong> , so see its description for
details.</p>
<p><strong>CAPTCHAs, and the like:</strong></p>
<p>Not feasible for this type of application. I am trying to apply these methods
to sites that already exist. Greasemonkey will be used to do this; I can't
start requiring CAPTCHAs in places that they weren't before someone installed
my script.</p>
<hr>
<p>Can anyone help me fill in the blanks? Thank you,</p>
<p><br><br></p>
<h2>Answer</h2>
<p>There is no "best" way, especially for all users or all situations.</p>
<p>Keep it simple:</p>
<ol>
<li>Have the GM script initially hide all comments that contain links and maybe universally bad words (F*ck, Presbyterian, etc.). ;) </li>
<li>Then the script contacts your server and lets the server judge each comment by X criteria (more on that, below).</li>
<li>Show or hide comments based on the server response. In the event of a timeout, show or reveal based on a user preference setting ("What to do when the filter server is down? (show/hide comments with links) ).</li>
<li>That's it for the GM script; the rest is handled by the server.</li>
</ol>
<p>As for the actual server/filtering criteria...<br>
Most important is <strong>do not dare to assume that you can guess what a user will
want filtered!</strong> This will vary wildly from person to person, or even mood to
mood.</p>
<p>Setup the server to use a combination of bad words, bad link destinations (.ru
and .cn domains, for example) and public spam-filtering services.</p>
<p>The most important thing is to offer users some way to choose and ideally
adjust what is applied, for them.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/clustering-algorithm-with-discrete-and-continuous-attributes/" class="u-url">Clustering Algorithm with discrete and continuous attributes?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/clustering-algorithm-with-discrete-and-continuous-attributes/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:56:19+08:00" itemprop="datePublished" title="2023-02-28 03:56">2023-02-28 03:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Does anyone know a good algorithm for perform clustering on both discrete and
continuous attributes? I am working on a problem of identifying a group of
similar customers and each customer has both discrete and continuous
attributes (Think type of customers, amount of revenue generated by this
customer, geographic location and etc..)</p>
<p>Traditionally algorithm like K-means or EM work for continuous attributes,
what if we have a mix of continuous and discrete attributes?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>If I remember correctly, then COBWEB algorithm could work with discrete
attributes.</p>
<p>And you can also do different 'tricks' to the discrete attributes in order to
create meaningful distance metrics.</p>
<p>You could google for clustering of categorical/discrete attributes, one of the
first hits: ROCK: A Robust Clustering Algorithm for Categorical Attributes.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1443.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1441.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
