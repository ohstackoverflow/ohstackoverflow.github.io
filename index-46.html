<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 46) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-46.html">
<link rel="prev" href="index-47.html" type="text/html">
<link rel="next" href="index-45.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-xun-huan-bian-li-huo-mei-ju-javascript-dui-xiang/" class="u-url">如何循环遍历或枚举 JavaScript 对象？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-xun-huan-bian-li-huo-mei-ju-javascript-dui-xiang/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:34:48+08:00" itemprop="datePublished" title="2023-02-16 19:34">2023-02-16 19:34</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我有一个如下所示的 JavaScript 对象：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">"p1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value1"</span><span class="p">,</span>
<span class="w">    </span><span class="s2">"p2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value2"</span><span class="p">,</span>
<span class="w">    </span><span class="s2">"p3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value3"</span>
<span class="p">};</span>
</pre></div>

<p>如何遍历所有的<code>p</code>元素（<code>p1</code>, <code>p2</code>, <code>p3</code>...）并获取它们的键和值？</p>
<p><br><br></p>
<h2>解答</h2>
<p>您可以使用<code>for-in</code>其他人显示的循环。但是，您还必须确保获得的键是对象的实际属性，而不是来自原型。</p>
<p><strong>这是片段：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nf">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="ss">"p1"</span><span class="err">:</span><span class="w"> </span><span class="ss">"value1"</span><span class="p">,</span>
<span class="w">    </span><span class="ss">"p2"</span><span class="err">:</span><span class="w"> </span><span class="ss">"value2"</span><span class="p">,</span>
<span class="w">    </span><span class="ss">"p3"</span><span class="err">:</span><span class="w"> </span><span class="ss">"value3"</span>
<span class="err">}</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="k">key</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">" -&gt; "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p><strong>For-of with Object.keys() 替代：</strong></p>
<div class="code"><pre class="code literal-block"><span class="nf">var</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="ss">"value1"</span><span class="p">,</span>
<span class="w">    </span><span class="ss">"b"</span><span class="err">:</span><span class="w"> </span><span class="ss">"value2"</span><span class="p">,</span>
<span class="w">    </span><span class="k">key</span><span class="err">:</span><span class="w"> </span><span class="ss">"value3"</span>
<span class="err">}</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">" -&gt; "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">)</span>
<span class="err">}</span>
</pre></div>

<p>注意使用<code>for-of</code>instead of <code>for-in</code>，如果不使用，它将在命名属性上返回 undefined
，并<code>Object.keys()</code>确保只使用对象自己的属性，而不使用整个原型链属性</p>
<p><strong>使用新<code>Object.entries()</code>方法：</strong></p>
<p><strong>注意：</strong> Internet Explorer 本身不支持此方法。您可以考虑为旧版浏览器使用 Polyfill。</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">"p1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value1"</span><span class="p">,</span>
<span class="w">    </span><span class="s2">"p2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value2"</span><span class="p">,</span>
<span class="w">    </span><span class="s2">"p3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value3"</span>
<span class="p">};</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">entries</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="err">`</span><span class="o">$</span><span class="p">{</span><span class="n">key</span><span class="p">}:</span><span class="w"> </span><span class="o">$</span><span class="p">{</span><span class="n">value</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>在 ECMAScript 5 下，您可以组合<code>Object.keys()</code>and <code>Array.prototype.forEach()</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nf">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">first</span><span class="err">:</span><span class="w"> </span><span class="ss">"John"</span><span class="p">,</span><span class="w"> </span><span class="k">last</span><span class="err">:</span><span class="w"> </span><span class="ss">"Doe"</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>

<span class="k">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">obj</span><span class="p">).</span><span class="n">forEach</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="k">key</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span><span class="p">);</span>
</pre></div>

<p>ECMAScript 6 添加<code>for...of</code>：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span>
</pre></div>

<p>ECMAScript 8 添加了<code>Object.entries()</code>避免查找原始对象中的每个值的方法：</p>
<div class="code"><pre class="code literal-block">Object.entries(obj).forEach(
    ([key, value]) =&gt; console.log(key, value)
);
</pre></div>

<p>您可以组合<code>for...of</code>、解构和<code>Object.entries</code>：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">entries</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>和<code>Object.keys()</code>都以与循环<code>Object.entries()</code>相同的顺序迭代属性 <em>，但忽略原型链</em>
。仅迭代对象自身的可枚举属性。<code>for...in</code> __</p>
<p><br><br><a href="posts/how-do-i-loop-through-or-enumerate-a-javascript-object/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-hou-zai-java-zhong-shi-yong-linkedlist-er-bu-shi-arraylist/" class="u-url">什么时候在 Java 中使用 LinkedList 而不是 ArrayList？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-hou-zai-java-zhong-shi-yong-linkedlist-er-bu-shi-arraylist/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:34:08+08:00" itemprop="datePublished" title="2023-02-16 19:34">2023-02-16 19:34</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我一直是一个简单使用的人：</p>
<div class="code"><pre class="code literal-block">List&lt;String&gt; names = new ArrayList&lt;&gt;();
</pre></div>

<p>我使用接口作为 <em>可移植性</em> 的类型名称，这样当我提出这样的问题时，我可以重新编写我的代码。</p>
<p>什么时候应该<code>LinkedList</code>结束使用<code>ArrayList</code>，反之亦然？</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>Summary</strong> <code>ArrayList</code> with<code>ArrayDeque</code>在 <em>更多</em> 用例中比<code>LinkedList</code>.
如果你不确定——就从<code>ArrayList</code>.</p>
<hr>
<p>TLDR，<code>ArrayList</code>访问一个元素需要常数时间 [O(1)] 并且添加一个元素需要 O(n) 时间
[最坏情况]。插入<code>LinkedList</code>一个元素需要 O(n) 时间，访问也需要 O(n)
时间，但<code>LinkedList</code>使用的内存比<code>ArrayList</code>.</p>
<p><code>LinkedList</code>并且<code>ArrayList</code>是接口的两个不同实现<code>List</code>。<code>LinkedList</code>用双向链表实现它。<code>ArrayList</code>使用动态调整大小的数组来实现它。</p>
<p>与标准链表和数组操作一样，各种方法将具有不同的算法运行时间。</p>
<p>为了<code>LinkedList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> when <code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>getFirst()</code>and <code>getLast()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>add(int index, E element)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> 时<code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>addFirst()</code>and <code>addLast()</code>/ <code>add()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>remove(int index)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> when <code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>removeFirst()</code>and <code>removeLast()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>Iterator.remove()</code>是 <em>O(1)</em> 。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>ListIterator.add(E element)</code>是 <em>O(1)</em> 。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
</ul>
<p>注意：许多操作平均需要 <em>n/4</em> 步，最佳情况下的步数 <em>不变（例如索引 = 0），最坏情况下的</em> <em>n/2</em> 步（列表中间）</p>
<p>为了<code>ArrayList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code>是 <em>O(1)</em> 。 <strong>的主要好处</strong> <code>ArrayList&lt;E&gt;</code>
</li>
<li>
<code>add(E element)</code>是 <em>O(1)</em> 摊销，但 <em>O(n)</em> 最坏的情况，因为数组必须调整大小和复制</li>
<li>
<code>add(int index, E element)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>remove(int index)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>Iterator.remove()</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>ListIterator.add(E element)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
</ul>
<p>注意：许多操作平均需要 <em>n/2</em> 步，最佳情况下（列表末尾）的步数 <em>不变</em> ，最坏情况下的 <em>n步（列表开始）</em></p>
<p><code>LinkedList&lt;E&gt;</code> <em>允许使用迭代器</em>
进行恒定时间的插入或删除，但只能顺序访问元素。换句话说，您可以向前或向后遍历列表，但在列表中找到一个位置所花费的时间与列表的大小成正比。Javadoc 说
<em>“索引到列表中的操作将从开头或结尾遍历列表，以更接近者为准”</em> ，因此这些方法平均为 <em>O(n)</em> （ <em>n/4步</em> <em>）</em> ，尽管<code>index =
0</code>.</p>
<p><code>ArrayList&lt;E&gt;</code>，另一方面，允许快速随机读取访问，因此您可以在恒定时间内抓取任何元素。但是从除结尾以外的任何地方添加或删除都需要将后面的所有元素移过来，以形成一个开口或填补空白。此外，如果添加的元素多于底层数组的容量，则会分配一个新数组（大小的
1.5 倍），并将旧数组复制到新数组中，因此添加到 an 最坏情况下是 O ( <code>ArrayList</code>n <em>)</em> 情况但平均不变。</p>
<p>因此，根据您打算执行的操作，您应该相应地选择实现。遍历任何一种 List 实际上都同样便宜。（迭代
an<code>ArrayList</code>在技术上更快，但除非你正在做一些真正对性能敏感的事情，否则你不应该担心这一点——它们都是常量。）</p>
<p><code>LinkedList</code>当您重新使用现有的迭代器来插入和删除元素时，使用 a 的主要好处就会出现。然后可以通过仅在本地更改列表来在 <em>O(1)</em>
中完成这些操作。在数组列表中，数组的其余部分需要移动 <em>（</em> 即复制）。另一方面，在最坏的情况<code>LinkedList</code>下，在 <em>O(n)</em> （
<em>n/2步）中寻找一种方法，而在</em> <em>O(1)</em><code>ArrayList</code>中可以通过数学计算和访问所需的位置。 __</p>
<p><code>LinkedList</code>当您从列表的头部添加或删除时，使用 a 的另一个好处是，因为这些操作是 <em>O(1)</em> ，而它们是 <em>O(n)</em> for
<code>ArrayList</code>。请注意，这<code>ArrayDeque</code>可能是<code>LinkedList</code>从头部添加和删除的一个很好的替代方法，但它不是<code>List</code>.</p>
<p>此外，如果您有大列表，请记住内存使用量也不同。a
的每个元素<code>LinkedList</code>都有更多的开销，因为还存储了指向下一个和前一个元素的指针。<code>ArrayLists</code>没有这个开销。但是，<code>ArrayLists</code>无论是否实际添加了元素，都会占用为容量分配的内存。</p>
<p>an 的默认初始容量<code>ArrayList</code>非常小（Java 1.4 - 1.8 为
10）。但是由于底层实现是一个数组，如果你添加了很多元素，就必须调整数组的大小。当您知道要添加大量元素时，为避免调整大小的高成本，请<code>ArrayList</code>使用更高的初始容量构建
。</p>
<p>如果从数据结构的角度来理解这两种结构，LinkedList 基本上是一个包含头节点的顺序数据结构。Node 是两个组件的包装器：一个 T 类型的值
[通过泛型接受] 和另一个对链接到它的 Node
的引用。所以，我们可以断言它是一个递归数据结构（一个节点包含另一个节点，另一个节点有另一个节点等等......）。如上所述，在 LinkedList
中添加元素需要线性时间。</p>
<p>ArrayList 是一个可增长的数组。它就像一个常规数组。在引擎盖下，当添加一个元素并且 ArrayList
已经满载时，它会创建另一个数组，其大小大于以前的大小。然后将元素从先前的数组复制到新的数组，并且要添加的元素也放置在指定的索引处。</p>
<p><br></p>
<h3>更多建议</h3>
<p><code>LinkedList</code>到目前为止，除了 a比 an
“多得多”这一普遍共识之外，似乎没有人解决过这些列表中的每一个的内存占用问题，<code>ArrayList</code>因此我进行了一些数字运算以证明这两个列表究竟占用了多少
N 个空引用。</p>
<p>由于引用在其相关系统上是 32 位或 64 位（即使为空），因此我包含了 4 组 32 位和 64
位数据<code>LinkedLists</code>以及<code>ArrayLists</code>.</p>
<p><strong>注意：</strong> 显示的行大小<code>ArrayList</code>是针对 <em>经过修剪的列表</em> - 实际上，支持数组的容量<code>ArrayList</code>通常大于其当前元素数。</p>
<p><strong>注意 2：（</strong> <em>感谢 BeeOnRope）</em> 由于 CompressedOops 现在是 JDK6 中期及更高版本的默认设置，下面针对 64
位机器的值将基本上匹配它们的 32 位对应值，当然除非您特别将其关闭。</p>
<hr>
<p><img alt="LinkedList 和 ArrayList 图的元素数 x 字节" src="https://i.imgur.com/f83xDyz.png"></p>
<hr>
<p>结果清楚地表明<code>LinkedList</code>比 多很多<code>ArrayList</code>，尤其是在元素数非常高的情况下。如果内存是一个因素，请避开<code>LinkedLists</code>.</p>
<p>我使用的公式如下，如果我做错了什么，请告诉我，我会修复它。对于 32 位或 64 位系统，'b' 是 4 或 8，'n'
是元素的数量。注意mods的原因是因为java中的所有对象无论是否全部使用都会占用8字节空间的倍数。</p>
<p><strong>数组列表：</strong></p>
<p><code>ArrayList object header + size integer + modCount integer + array reference +
(array oject header + b * n) + MOD(array oject, 8) + MOD(ArrayList object, 8)
== 8 + 4 + 4 + b + (12 + b * n) + MOD(12 + b * n, 8) + MOD(8 + 4 + 4 + b + (12
+ b * n) + MOD(12 + b * n, 8), 8)</code></p>
<p><strong>链表：</strong></p>
<p><code>LinkedList object header + size integer + modCount integer + reference to
header + reference to footer + (node object overhead + reference to previous
element + reference to next element + reference to element) * n) + MOD(node
object, 8) * n + MOD(LinkedList object, 8) == 8 + 4 + 4 + 2 * b + (8 + 3 * b)
* n + MOD(8 + 3 * b, 8) * n + MOD(8 + 4 + 4 + 2 * b + (8 + 3 * b) * n + MOD(8
+ 3 * b, 8) * n, 8)</code></p>
<p><br><br><a href="posts/when-to-use-linkedlist-over-arraylist-in-java/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-yi-lai-zhu-ru/" class="u-url">什么是依赖注入？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-yi-lai-zhu-ru/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:33:39+08:00" itemprop="datePublished" title="2023-02-16 19:33">2023-02-16 19:33</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>已经发布了几个关于依赖注入的特定问题的问题，例如何时使用它以及它有哪些框架。然而，</p>
<p><strong>什么是依赖注入以及何时/为什么应该或不应该使用它？</strong></p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>依赖注入</strong> 将依赖传递给其他 <strong>对象</strong> 或 <strong>框架</strong> （依赖注入器）。</p>
<p>依赖注入使测试更容易。注入可以通过 <strong>构造函数</strong> 完成。</p>
<p><code>SomeClass()</code>其构造函数如下：</p>
<div class="code"><pre class="code literal-block">public SomeClass() {
    myObject = Factory.getObject();
}
</pre></div>

<p><strong>问题</strong> ：如果<code>myObject</code>涉及磁盘访问或网络访问等复杂任务，则很难 <strong>对其</strong>
进行单元测试<code>SomeClass()</code>。程序员必须模拟<code>myObject</code>并可能 <strong>拦截</strong> 工厂调用。</p>
<p><strong>替代解决方案</strong> ：</p>
<ul>
<li>
<p>作为参数传入<code>myObject</code>构造函数</p>
<p>public SomeClass (MyClass myObject) {
    this.myObject = myObject;
}</p>
</li>
</ul>
<p><code>myObject</code>可以直接通过，这样测试更容易。</p>
<ul>
<li>一种常见的替代方法是定义一个 <strong>什么都不做的构造函数</strong> 。依赖注入可以通过setter来完成。（h/t @MikeVella）。</li>
<li>Martin Fowler记录了第三种选择 (h/t @MarcDix)，其中 <strong>类显式实现了程序员希望注入的依赖项的接口</strong> 。</li>
</ul>
<p>在没有依赖注入的情况下，很难在单元测试中隔离组件。</p>
<p>2013 年，当我写这个答案时，这是Google
测试博客上的一个主要主题。这对我来说仍然是最大的优势，因为程序员在他们的运行时设计中并不总是需要额外的灵活性（例如，服务定位器或类似模式）。程序员经常需要在测试期间隔离类。</p>
<p><br></p>
<h3>更多建议</h3>
<p><strong>依赖注入</strong> 将依赖传递给其他 <strong>对象</strong> 或 <strong>框架</strong> （依赖注入器）。</p>
<p>依赖注入使测试更容易。注入可以通过 <strong>构造函数</strong> 完成。</p>
<p><code>SomeClass()</code>其构造函数如下：</p>
<div class="code"><pre class="code literal-block">public SomeClass() {
    myObject = Factory.getObject();
}
</pre></div>

<p><strong>问题</strong> ：如果<code>myObject</code>涉及磁盘访问或网络访问等复杂任务，则很难 <strong>对其</strong>
进行单元测试<code>SomeClass()</code>。程序员必须模拟<code>myObject</code>并可能 <strong>拦截</strong> 工厂调用。</p>
<p><strong>替代解决方案</strong> ：</p>
<ul>
<li>
<p>作为参数传入<code>myObject</code>构造函数</p>
<p>public SomeClass (MyClass myObject) {
    this.myObject = myObject;
}</p>
</li>
</ul>
<p><code>myObject</code>可以直接通过，这样测试更容易。</p>
<ul>
<li>一种常见的替代方法是定义一个 <strong>什么都不做的构造函数</strong> 。依赖注入可以通过setter来完成。（h/t @MikeVella）。</li>
<li>Martin Fowler记录了第三种选择 (h/t @MarcDix)，其中 <strong>类显式实现了程序员希望注入的依赖项的接口</strong> 。</li>
</ul>
<p>在没有依赖注入的情况下，很难在单元测试中隔离组件。</p>
<p>2013 年，当我写这个答案时，这是Google
测试博客上的一个主要主题。这对我来说仍然是最大的优势，因为程序员在他们的运行时设计中并不总是需要额外的灵活性（例如，服务定位器或类似模式）。程序员经常需要在测试期间隔离类。</p>
<p><br><br><a href="posts/what-is-dependency-injection/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-47.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-45.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
