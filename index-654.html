<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 654) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-654.html">
<link rel="prev" href="index-655.html" type="text/html">
<link rel="next" href="index-653.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/chuang-jian-yi-ge-kong-de-pandas-dataframe-ran-hou-tian-chong-ta/" class="u-url">创建一个空的 Pandas DataFrame，然后填充它</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/chuang-jian-yi-ge-kong-de-pandas-dataframe-ran-hou-tian-chong-ta/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:33:03+08:00" itemprop="datePublished" title="2023-02-17 12:33">2023-02-17 12:33</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我从这里的 pandas DataFrame 文档开始： <em>Introduction to data structures</em></p>
<p>我想在时间序列类型的计算中用值迭代地填充 DataFrame。所以基本上，我想用列 A、B 和时间戳行初始化 DataFrame，全部为 0 或全部为
NaN。</p>
<p>然后我会添加初始值并检查这些数据，从之前的行计算新行，比如说<code>row[A][t] = row[A][t-1]+1</code>。</p>
<p>我目前正在使用下面的代码，但我觉得它有点难看，必须有一种方法可以直接使用 DataFrame 来执行此操作，或者只是一种更好的方法。</p>
<p>注意：我使用的是 Python 2.7。</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">s</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="p">[</span> <span class="n">base</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
    <span class="n">dates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">valdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">symb</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">valdict</span><span class="p">[</span><span class="n">symb</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span> <span class="n">s</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)),</span> <span class="n">dates</span> <span class="p">)</span>

    <span class="k">for</span> <span class="n">thedate</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">thedate</span> <span class="o">&gt;</span> <span class="n">dates</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">symb</span> <span class="ow">in</span> <span class="n">valdict</span><span class="p">:</span>
                <span class="n">valdict</span><span class="p">[</span><span class="n">symb</span><span class="p">][</span><span class="n">thedate</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">valdict</span><span class="p">[</span><span class="n">symb</span><span class="p">][</span><span class="n">thedate</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

    <span class="nb">print</span> <span class="n">valdict</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>这里有几个建议：</p>
<p>用于<code>date_range</code>索引：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">todays_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">todays_date</span><span class="o">-</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">'D'</span><span class="p">)</span>

<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">]</span>
</pre></div>

<p><em>注意：我们可以创建一个空的 DataFrame（带有<code>NaN</code>s），只需编写：</em></p>
<div class="code"><pre class="code literal-block">df_ = pd.DataFrame(index=index, columns=columns)
df_ = df_.fillna(0) # With 0s rather than NaNs
</pre></div>

<p>要对数据进行这些类型的计算，请使用NumPy数组：</p>
<div class="code"><pre class="code literal-block">data = np.array([np.arange(10)]*3).T
</pre></div>

<p>因此我们可以创建 DataFrame：</p>
<div class="code"><pre class="code literal-block">In [10]: df = pd.DataFrame(data, index=index, columns=columns)

In [11]: df
Out[11]:
            A  B  C
2012-11-29  0  0  0
2012-11-30  1  1  1
2012-12-01  2  2  2
2012-12-02  3  3  3
2012-12-03  4  4  4
2012-12-04  5  5  5
2012-12-05  6  6  6
2012-12-06  7  7  7
2012-12-07  8  8  8
2012-12-08  9  9  9
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>这里有几个建议：</p>
<p>用于<code>date_range</code>索引：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">todays_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">todays_date</span><span class="o">-</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">periods</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">'D'</span><span class="p">)</span>

<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'A'</span><span class="p">,</span><span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">]</span>
</pre></div>

<p><em>注意：我们可以创建一个空的 DataFrame（带有<code>NaN</code>s），只需编写：</em></p>
<div class="code"><pre class="code literal-block">df_ = pd.DataFrame(index=index, columns=columns)
df_ = df_.fillna(0) # With 0s rather than NaNs
</pre></div>

<p>要对数据进行这些类型的计算，请使用NumPy数组：</p>
<div class="code"><pre class="code literal-block">data = np.array([np.arange(10)]*3).T
</pre></div>

<p>因此我们可以创建 DataFrame：</p>
<div class="code"><pre class="code literal-block">In [10]: df = pd.DataFrame(data, index=index, columns=columns)

In [11]: df
Out[11]:
            A  B  C
2012-11-29  0  0  0
2012-11-30  1  1  1
2012-12-01  2  2  2
2012-12-02  3  3  3
2012-12-03  4  4  4
2012-12-04  5  5  5
2012-12-05  6  6  6
2012-12-06  7  7  7
2012-12-07  8  8  8
2012-12-08  9  9  9
</pre></div>

<p><br><br><a href="posts/creating-an-empty-pandas-dataframe-and-then-filling-it/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-shi-yong-jquery-jian-ce-zai-jian-pan-shang-an-xia-enter-jian/" class="u-url">如何使用 jQuery 检测在键盘上按下 Enter 键？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-shi-yong-jquery-jian-ce-zai-jian-pan-shang-an-xia-enter-jian/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:32:37+08:00" itemprop="datePublished" title="2023-02-17 12:32">2023-02-17 12:32</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想检测用户是否按下<code>Enter</code>使用 jQuery。</p>
<p>这怎么可能？它需要一个插件吗？</p>
<p>看起来我需要使用该<code>keypress()</code>方法。</p>
<p>该命令是否存在浏览器问题 - 比如是否存在我应该了解的浏览器兼容性问题？</p>
<p><br><br></p>
<h2>解答</h2>
<p>jQuery 的全部意义在于您不必担心浏览器的差异。我很确定您可以安全地<code>enter</code>在所有浏览器中保持 13 岁。因此，考虑到这一点，您可以这样做：</p>
<div class="code"><pre class="code literal-block">$<span class="ss">(</span><span class="nv">document</span><span class="ss">)</span>.<span class="nv">on</span><span class="ss">(</span><span class="s1">'keypress'</span>,<span class="nv">function</span><span class="ss">(</span><span class="nv">e</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="ss">(</span><span class="nv">e</span>.<span class="nv">which</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">13</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">alert</span><span class="ss">(</span><span class="s1">'You pressed enter!'</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}
}<span class="ss">)</span><span class="c1">;</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>我写了一个小插件来更容易地绑定“按下回车键”事件：</p>
<div class="code"><pre class="code literal-block"><span class="o">$.</span><span class="n">fn</span><span class="o">.</span><span class="n">enterKey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">fnc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">$</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">.</span><span class="n">keypress</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">ev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">var</span><span class="w"> </span><span class="n">keycode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ev</span><span class="o">.</span><span class="n">keyCode</span><span class="w"> </span><span class="err">?</span><span class="w"> </span><span class="n">ev</span><span class="o">.</span><span class="n">keyCode</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ev</span><span class="o">.</span><span class="n">which</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">keycode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">'13'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">fnc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>用法：</p>
<div class="code"><pre class="code literal-block">$("#input").enterKey(function () {
    alert('Enter!');
})
</pre></div>

<p><br><br><a href="posts/how-can-i-detect-pressing-enter-on-the-keyboard-using-jquery/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/so-reuseaddr-he-so-reuseport-you-he-bu-tong/" class="u-url">SO_REUSEADDR 和 SO_REUSEPORT 有何不同？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/so-reuseaddr-he-so-reuseport-you-he-bu-tong/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:32:10+08:00" itemprop="datePublished" title="2023-02-17 12:32">2023-02-17 12:32</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>man
pages</code>套接字选项的文档和程序员文档对于不同的操作系统是不同的并且通常非常混乱<code>SO_REUSEADDR</code>。<code>SO_REUSEPORT</code>有些操作系统甚至没有这个选项<code>SO_REUSEPORT</code>。WWW
上充满了关于这个主题的相互矛盾的信息，并且您经常可以找到仅适用于特定操作系统的一个套接字实现的信息，这些信息甚至可能没有在文本中明确提及。</p>
<p>那么与 到底有何<code>SO_REUSEADDR</code>不同呢<code>SO_REUSEPORT</code>？</p>
<p>系统没有<code>SO_REUSEPORT</code>更多限制吗？</p>
<p>如果我在不同的操作系统上使用其中任何一个，预期的行为到底是什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>欢迎来到便携性的美妙世界……或者更确切地说，是缺乏便携性。在我们开始详细分析这两个选项并深入了解不同操作系统如何处理它们之前，应该注意 BSD
套接字实现是所有套接字实现之母。基本上所有其他系统都在某个时间点（或至少是它的接口）复制了 BSD 套接字实现，然后开始自己发展它。当然，BSD
套接字实现也在同一时间发展，因此后来复制它的系统获得了较早复制它的系统所缺乏的功能。理解 BSD
套接字实现是理解所有其他套接字实现的关键，所以即使您不关心为 BSD 系统编写代码，您也应该阅读它。</p>
<p>在我们查看这两个选项之前，您应该了解一些基础知识。TCP/UDP 连接由五个值的元组标识：</p>
<p><code>{&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;}</code></p>
<p>这些值的任何唯一组合都标识一个连接。因此，任何两个连接都不能有相同的五个值，否则系统将无法再区分这些连接。</p>
<p>套接字的协议是在使用该<code>socket()</code>函数创建套接字时设置的。源地址和端口用函数设置<code>bind()</code>。目的地址和端口用函数设置<code>connect()</code>。由于
UDP 是一种无连接协议，因此可以在不连接它们的情况下使用 UDP
套接字。然而，允许连接它们并且在某些情况下对您的代码和一般应用程序设计非常有利。在无连接模式下，当数据第一次通过它们发送时未明确绑定的 UDP
套接字通常由系统自动绑定，因为未绑定的 UDP 套接字无法接收任何（回复）数据。未绑定的 TCP 套接字也是如此，它会在连接之前自动绑定。</p>
<p>如果您显式绑定套接字，则可以将其绑定到 port
<code>0</code>，这意味着“任何端口”。由于套接字不能真正绑定到所有现有端口，因此在这种情况下系统必须自己选择一个特定端口（通常来自预定义的操作系统特定范围的源端口）。源地址存在类似的通配符，它​​可以是“任何地址”（<code>0.0.0.0</code>对于
IPv4 和<code>::</code>在 IPv6 的情况下）。与端口的情况不同，套接字实际上可以绑定到“任何地址”，这意味着“所有本地接口的所有源 IP
地址”。如果稍后连接套接字，系统必须选择一个特定的源 IP 地址，因为套接字无法连接并同时绑定到任何本地 IP
地址。根据目标地址和路由表的内容，系统将选择一个合适的源地址并将“任何”绑定替换为到所选源 IP 地址的绑定。</p>
<p>默认情况下，没有两个套接字可以绑定到相同的源地址和源端口组合。只要源端口不同，源地址实际上是无关紧要的。如果成立，则始终可以绑定<code>socketA</code>到<code>ipA:portA</code>和<code>socketB</code>到，即使.
例如属于一个FTP服务器程序并且被绑定到并且属于另一个FTP服务器程序并且被绑定到，两个绑定都会成功。但是请记住，套接字可能在本地绑定到“任何地址”。如果套接字绑定到，它同时绑定到所有现有的本地地址，在这种情况下，没有其他套接字可以绑定到端口，无论它尝试绑定到哪个特定
IP 地址，如<code>ipB:portB``ipA != ipB``portA ==
portB``socketA``192.168.0.1:21``socketB``10.0.0.1:21``0.0.0.0:21``21``0.0.0.0</code>与所有现有的本地
IP 地址冲突。</p>
<p>到目前为止所说的任何内容对于所有主要操作系统来说几乎都是一样的。当地址重用发挥作用时，事情开始变得特定于操作系统。我们从 BSD
开始，因为正如我上面所说，它是所有套接字实现之母。</p>
<h2>BSD</h2>
<h3>SO_REUSEADDR</h3>
<p>如果在<code>SO_REUSEADDR</code>绑定之前在套接字上启用，则可以成功绑定套接字，除非与绑定到完全相同的源地址和端口组合的另一个套接字发生 <strong>冲突</strong>
。现在您可能想知道这与以前有什么不同？关键词是“恰好”。<code>SO_REUSEADDR</code>主要改变了在搜索冲突时如何处理通配符地址（“任何 IP 地址”）的方式。</p>
<p>如果没有<code>SO_REUSEADDR</code>，绑定<code>socketA</code>到<code>0.0.0.0:21</code>然后绑定<code>socketB</code>到<code>192.168.0.1:21</code>将失败（错误<code>EADDRINUSE</code>），因为
0.0.0.0 表示“任何本地 IP 地址”，因此所有本地 IP 地址都被认为正在被该套接字使用，这<code>192.168.0.1</code>也包括
。有了<code>SO_REUSEADDR</code>它就会成功，因为<code>0.0.0.0</code>和<code>192.168.0.1</code>不是 <strong>完全相同</strong>
的地址，一个是所有本地地址的通配符，另一个是非常具体的本地地址。<code>socketA</code>请注意，无论以何种顺序绑定，上面的陈述都是正确的<code>socketB</code>；没有<code>SO_REUSEADDR</code>它总会失败，有<code>SO_REUSEADDR</code>它总会成功。</p>
<p>为了给你一个更好的概览，让我们在这里制作一个表格并列出所有可能的组合：</p>
<div class="code"><pre class="code literal-block">SO_REUSEADDR socketA socketB 结果
---------------------------------------------- ------------------
  开/关 192.168.0.1:21 192.168.0.1:21 错误 (EADDRINUSE)
  开/关 192.168.0.1:21 10.0.0.1:21 好
  开/关 10.0.0.1:21 192.168.0.1:21 好
   关闭 0.0.0.0:21 192.168.1.0:21 错误 (EADDRINUSE)
   关闭 192.168.1.0:21 0.0.0.0:21 错误 (EADDRINUSE)
   打开 0.0.0.0:21 192.168.1.0:21 好
   在 192.168.1.0:21 0.0.0.0:21 好
  开/关 0.0.0.0:21 0.0.0.0:21 错误（EADDRINUSE）
</pre></div>

<p>上表假设<code>socketA</code>已经成功绑定到给定的地址<code>socketA</code>，然后<code>socketB</code>创建，设置<code>SO_REUSEADDR</code>或不设置，最后绑定到给定的地址<code>socketB</code>。<code>Result</code>是
的绑定操作的结果<code>socketB</code>。如果第一列显示<code>ON/OFF</code>，则 的值<code>SO_REUSEADDR</code>与结果无关。</p>
<p>好的，<code>SO_REUSEADDR</code>对通配符地址有影响，很高兴知道。然而，这并不是它的唯一作用。<code>SO_REUSEADDR</code>还有一个众所周知的效果，这也是大多数人首先在服务器程序中使用的原因。对于此选项的其他重要用途，我们必须深入了解
TCP 协议的工作原理。</p>
<p>如果 TCP 套接字正在关闭，通常会执行 3 次握手；该序列称为<code>FIN-ACK</code>。这里的问题是，该序列的最后一个 ACK​​
可能已经到达另一端，也可能没有到达，只有到达时，另一端才会认为套接字已完全关闭。为了防止重复使用地址+端口组合，某些远程对等方可能仍将其视为打开，系统不会在发送最后一个套接字后立即将套接字视为已死，而是将套接字置于通常<code>ACK</code>称为<code>TIME_WAIT</code>.
它可以处于该状态数分钟（系统相关设置）。在大多数系统上，您可以通过启用延迟并将延迟时间设置为 zero1
来绕过该状态，但不能保证这总是可能的，系统将始终尊重此请求，即使系统尊重它，这也会导致通过重置 ( )
关闭套接字<code>RST</code>，这并不总是一个好主意。要了解有关逗留时间的更多信息，请查看我对此主题的回答。</p>
<p>问题是，系统如何处理状态中的套接字<code>TIME_WAIT</code>？如果<code>SO_REUSEADDR</code>未设置，处于状态的套接字<code>TIME_WAIT</code>被认为仍然绑定到源地址和端口，任何将新套接字绑定到相同地址和端口的尝试都将失败，直到套接字真正关闭。所以不要指望关闭套接字后可以立即重新绑定源地址。在大多数情况下，这会失败。但是，如果<code>SO_REUSEADDR</code>为您尝试绑定的套接字设置了
，则另一个套接字绑定到状态中的相同地址和端口<code>TIME_WAIT</code>被简单地忽略了，毕竟它已经“半死了”，并且您的套接字可以毫无问题地绑定到完全相同的地址。在那种情况下，另一个套接字可能具有完全相同的地址和端口没有任何作用。请注意，将套接字绑定到与处于<code>TIME_WAIT</code>状态的垂死套接字完全相同的地址和端口可能会产生意想不到的，通常是不希望的副作用，以防另一个套接字仍在“工作”，但这超出了本答案的范围，幸运的是，这些副作用在实践中很少见。</p>
<p>最后一件事你应该知道<code>SO_REUSEADDR</code>。只要您要绑定的套接字启用了地址重用，上面写的所有内容都可以工作。<code>TIME_WAIT</code>另一个套接字，即已经绑定或处于某种状态的套接字，在绑定时也不必设置此标志。决定绑定是成功还是失败的代码只检查<code>SO_REUSEADDR</code>输入调用的套接字的标志<code>bind()</code>，对于所有其他检查的套接字，甚至不看这个标志。</p>
<h3>SO_REUSEPORT</h3>
<p><code>SO_REUSEPORT</code>是大多数人所期望<code>SO_REUSEADDR</code>的。基本上，<code>SO_REUSEPORT</code>允许您将任意数量的套接字绑定到
<strong>完全相同</strong> 的源地址和端口，只要 <strong>所有</strong>
先前绑定的套接字<code>SO_REUSEPORT</code>在绑定之前也已设置。如果绑定到地址和端口的第一个套接字没有<code>SO_REUSEPORT</code>设置，则没有其他套接字可以绑定到完全相同的地址和端口，无论是否设置了其他套接字<code>SO_REUSEPORT</code>，直到第一个套接字再次释放其绑定。<code>SO_REUSEADDR</code>与代码处理的情况不同，它<code>SO_REUSEPORT</code>不仅会验证当前绑定的套接字是否已<code>SO_REUSEPORT</code>设置，还会验证具有冲突地址和端口的套接字<code>SO_REUSEPORT</code>在绑定时是否已设置。</p>
<p><code>SO_REUSEPORT</code>并不暗示<code>SO_REUSEADDR</code>。<code>SO_REUSEPORT</code>这意味着如果一个套接字在绑定时没有设置，而另一个套接字<code>SO_REUSEPORT</code>在绑定到完全相同的地址和端口时设置了，则绑定失败，这是预期的，但如果另一个套接字已经死了，它也会失败并且处于<code>TIME_WAIT</code>状态。为了能够将一个套接字绑定到与处于<code>TIME_WAIT</code>状态的另一个套接字相同的地址和端口，需要<code>SO_REUSEADDR</code>在该套接字上设置或者必须在绑定它们之前
<strong>在两个套接字上</strong><code>SO_REUSEPORT</code>设置。当然，允许在套接字上同时设置和。 ****<code>SO_REUSEPORT``SO_REUSEADDR</code></p>
<p><code>SO_REUSEPORT</code>除了它的添加时间晚于
之外，没有什么可说的了<code>SO_REUSEADDR</code>，这就是为什么在其他系统的许多套接字实现中找不到它的原因，这些系统在添加此选项之前“分叉”了 BSD
代码，并且没有在此选项之前将两个套接字绑定到 BSD 中完全相同的套接字地址的方法。</p>
<h3>Connect() 返回 EADDRINUSE？</h3>
<p>大多数人都知道这<code>bind()</code>可能会因错误而失败<code>EADDRINUSE</code>，但是，当您开始尝试地址重用时，您可能会遇到同样因<code>connect()</code>该错误而失败的奇怪情况。怎么会这样？毕竟连接添加到套接字的远程地址怎么可能已经被使用了呢？将多个套接字连接到完全相同的远程地址以前从来都不是问题，那么这里出了什么问题呢？</p>
<p>正如我在回复的最顶部所说的那样，连接是由五个值的元组定义的，还记得吗？而且我也说过，这五个值必须是唯一的，否则系统就不能区分两个连接了，对吧？那么，通过地址重用，您可以将相同协议的两个套接字绑定到相同的源地址和端口。这意味着这五个值中的三个对于这两个套接字已经相同。如果您现在尝试将这两个套接字也连接到相同的目标地址和端口，您将创建两个连接的套接字，它们的元组完全相同。这行不通，至少对于
TCP 连接不行（UDP 连接无论如何都不是真正的连接）。如果两个连接之一的数据到达，系统无法判断数据属于哪个连接。</p>
<p>因此，如果您将相同协议的两个套接字绑定到相同的源地址和端口，并尝试将它们连接到相同的目标地址和端口，实际上将失败并显示您尝试连接的第二个套接字的错误，<code>connect()</code>这<code>EADDRINUSE</code>意味着具有五个值的相同元组的套接字已连接。</p>
<h3>多播地址</h3>
<p>大多数人忽略了多播地址存在的事实，但它们确实存在。单播地址用于一对一通信，而多播地址用于一对多通信。大多数人在了解 IPv6
时就知道多播地址，但多播地址也存在于 IPv4 中，尽管此功能从未在公共 Internet 上广泛使用。</p>
<p>The meaning of <code>SO_REUSEADDR</code> changes for multicast addresses as it allows
multiple sockets to be bound to exactly the same combination of source
multicast address and port. In other words, for multicast addresses
<code>SO_REUSEADDR</code> behaves exactly as <code>SO_REUSEPORT</code> for unicast addresses.
Actually, the code treats <code>SO_REUSEADDR</code> and <code>SO_REUSEPORT</code> identically for
multicast addresses, that means you could say that <code>SO_REUSEADDR</code> implies
<code>SO_REUSEPORT</code> for all multicast addresses and the other way round.</p>
<h2></h2>
<p>FreeBSD/OpenBSD/NetBSD</p>
<p>All these are rather late forks of the original BSD code, that's why they all
three offer the same options as BSD and they also behave the same way as in
BSD.</p>
<h2></h2>
<p>macOS (MacOS X)</p>
<p>At its core, macOS is simply a BSD-style UNIX named " <em>Darwin</em> ", based on a
rather late fork of the BSD code (BSD 4.3), which was then later on even re-
synchronized with the (at that time current) FreeBSD 5 code base for the Mac
OS 10.3 release, so that Apple could gain full POSIX compliance (macOS is
POSIX certified). Despite having a microkernel at its core (" <em>Mach</em> "), the
rest of the kernel (" <em>XNU</em> ") is basically just a BSD kernel, and that's why
macOS offers the same options as BSD and they also behave the same way as in
BSD.</p>
<h3>iOS / watchOS / tvOS</h3>
<p>iOS is just a macOS fork with a slightly modified and trimmed kernel, somewhat
stripped down user space toolset and a slightly different default framework
set. watchOS and tvOS are iOS forks, that are stripped down even further
(especially watchOS). To my best knowledge they all behave exactly as macOS
does.</p>
<h2></h2>
<p>Linux</p>
<h3>Linux &lt; 3.9</h3>
<p>Prior to Linux 3.9, only the option <code>SO_REUSEADDR</code> existed. This option
behaves generally the same as in BSD with two important exceptions:</p>
<ol>
<li>
<p>As long as a listening (server) TCP socket is bound to a specific port, the <code>SO_REUSEADDR</code> option is entirely ignored for all sockets targeting that port. Binding a second socket to the same port is only possible if it was also possible in BSD without having <code>SO_REUSEADDR</code> set. E.g. you cannot bind to a wildcard address and then to a more specific one or the other way round, both is possible in BSD if you set <code>SO_REUSEADDR</code>. What you can do is you can bind to the same port and two different non-wildcard addresses, as that's always allowed. In this aspect Linux is more restrictive than BSD.</p>
</li>
<li>
<p>The second exception is that for client sockets, this option behaves exactly like <code>SO_REUSEPORT</code> in BSD, as long as both had this flag set before they were bound. The reason for allowing that was simply that it is important to be able to bind multiple sockets to exactly to the same UDP socket address for various protocols and as there used to be no <code>SO_REUSEPORT</code> prior to 3.9, the behavior of <code>SO_REUSEADDR</code> was altered accordingly to fill that gap. In that aspect Linux is less restrictive than BSD.</p>
</li>
</ol>
<h3>Linux &gt;= 3.9</h3>
<p>Linux 3.9 added the option <code>SO_REUSEPORT</code> to Linux as well. This option
behaves exactly like the option in BSD and allows binding to exactly the same
address and port number as long as all sockets have this option set prior to
binding them.</p>
<p>Yet, there are still two differences to <code>SO_REUSEPORT</code> on other systems:</p>
<ol>
<li>
<p>To prevent "port hijacking", there is one special limitation: <strong>All sockets that want to share the same address and port combination must belong to processes that share the same effective user ID!</strong> So one user cannot "steal" ports of another user. This is some special magic to somewhat compensate for the missing <code>SO_EXCLBIND</code>/<code>SO_EXCLUSIVEADDRUSE</code> flags.</p>
</li>
<li>
<p>Additionally the kernel performs some "special magic" for <code>SO_REUSEPORT</code> sockets that isn't found in other operating systems: For UDP sockets, it tries to distribute datagrams evenly, for TCP listening sockets, it tries to distribute incoming connect requests (those accepted by calling <code>accept()</code>) evenly across all the sockets that share the same address and port combination. Thus an application can easily open the same port in multiple child processes and then use <code>SO_REUSEPORT</code> to get a very inexpensive load balancing.</p>
</li>
</ol>
<h3></h3>
<p>Android</p>
<p>Even though the whole Android system is somewhat different from most Linux
distributions, at its core works a slightly modified Linux kernel, thus
everything that applies to Linux should apply to Android as well.</p>
<h2></h2>
<p>Windows</p>
<p>Windows only knows the <code>SO_REUSEADDR</code> option, there is no <code>SO_REUSEPORT</code>.
Setting <code>SO_REUSEADDR</code> on a socket in Windows behaves like setting
<code>SO_REUSEPORT</code> and <code>SO_REUSEADDR</code> on a socket in BSD, with one exception:</p>
<p>Prior to Windows 2003, a socket with <code>SO_REUSEADDR</code> could always been bound to
exactly the same source address and port as an already bound socket, <strong>even if
the other socket did not have this option set when it was bound</strong>. This
behavior allowed an application "to steal" the connected port of another
application. Needless to say that this has major security implications!</p>
<p>Microsoft realized that and added another important socket option:
<code>SO_EXCLUSIVEADDRUSE</code>. Setting <code>SO_EXCLUSIVEADDRUSE</code> on a socket makes sure
that if the binding succeeds, the combination of source address and port is
owned exclusively by this socket and no other socket can bind to them, <strong>not
even</strong> if it has <code>SO_REUSEADDR</code> set.</p>
<p>This default behavior was changed first in Windows 2003, Microsoft calls that
"Enhanced Socket Security" (funny name for a behavior that is default on all
other major operating systems). For more details just visit this page. There
are three tables: The first one shows the classic behavior (still in use when
using compatibility modes!), the second one shows the behavior of Windows 2003
and up when the <code>bind()</code> calls are made by the same user, and the third one
when the <code>bind()</code> calls are made by different users.</p>
<h2></h2>
<p>Solaris</p>
<p>Solaris is the successor of SunOS. SunOS was originally based on a fork of
BSD, SunOS 5 and later was based on a fork of SVR4, however SVR4 is a merge of
BSD, System V, and Xenix, so up to some degree Solaris is also a BSD fork, and
a rather early one. As a result Solaris only knows <code>SO_REUSEADDR</code>, there is no
<code>SO_REUSEPORT</code>. The <code>SO_REUSEADDR</code> behaves pretty much the same as it does in
BSD. As far as I know there is no way to get the same behavior as
<code>SO_REUSEPORT</code> in Solaris, that means it is not possible to bind two sockets
to exactly the same address and port.</p>
<p>Similar to Windows, Solaris has an option to give a socket an exclusive
binding. This option is named <code>SO_EXCLBIND</code>. If this option is set on a socket
prior to binding it, setting <code>SO_REUSEADDR</code> on another socket has no effect if
the two sockets are tested for an address conflict. E.g. if <code>socketA</code> is bound
to a wildcard address and <code>socketB</code> has <code>SO_REUSEADDR</code> enabled and is bound to
a non-wildcard address and the same port as <code>socketA</code>, this bind will normally
succeed, unless <code>socketA</code> had <code>SO_EXCLBIND</code> enabled, in which case it will
fail regardless the <code>SO_REUSEADDR</code> flag of <code>socketB</code>.</p>
<h2></h2>
<p>Other Systems</p>
<p>In case your system is not listed above, I wrote a little test program that
you can use to find out how your system handles these two options. <strong>Also if
you think my results are wrong</strong> , please first run that program before
posting any comments and possibly making false claims.</p>
<p>All that the code requires to build is a bit POSIX API (for the network parts)
and a C99 compiler (actually most non-C99 compiler will work as well as long
as they offer <code>inttypes.h</code> and <code>stdbool.h</code>; e.g. <code>gcc</code> supported both long
before offering full C99 support).</p>
<p>All that the program needs to run is that at least one interface in your
system (other than the local interface) has an IP address assigned and that a
default route is set which uses that interface. The program will gather that
IP address and use it as the second "specific address".</p>
<p>It tests all possible combinations you can think of:</p>
<ul>
<li>TCP and UDP protocol</li>
<li>Normal sockets, listen (server) sockets, multicast sockets</li>
<li>
<code>SO_REUSEADDR</code> set on socket1, socket2, or both sockets</li>
<li>
<code>SO_REUSEPORT</code> set on socket1, socket2, or both sockets</li>
<li>All address combinations you can make out of <code>0.0.0.0</code> (wildcard), <code>127.0.0.1</code> (specific address), and the second specific address found at your primary interface (for multicast it's just <code>224.1.2.3</code> in all tests)</li>
</ul>
<p>and prints the results in a nice table. It will also work on systems that
don't know <code>SO_REUSEPORT</code>, in which case this option is simply not tested.</p>
<p>What the program cannot easily test is how <code>SO_REUSEADDR</code> acts on sockets in
<code>TIME_WAIT</code> state as it's very tricky to force and keep a socket in that
state. Fortunately most operating systems seems to simply behave like BSD here
and most of the time programmers can simply ignore the existence of that
state.</p>
<p>Here's the code (I cannot include it here, answers have a size limit and the
code would push this reply over the limit).</p>
<p><br></p>
<h3>更多建议</h3>
<p>Mecki 的回答绝对完美，但值得补充的是，FreeBSD 还支持<code>SO_REUSEPORT_LB</code>，它模仿 Linux 的<code>SO_REUSEPORT</code>行为
- 它平衡负载；参见setsockopt(2)</p>
<p><br><br><a href="posts/how-do-so-reuseaddr-and-so-reuseport-differ/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-655.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-653.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
