<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2114) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2114.html">
<link rel="prev" href="index-2115.html" type="text/html">
<link rel="next" href="index-2113.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-there-an-r-function-for-finding-the-index-of-an-element-in-a-vector/" class="u-url">Is there an R function for finding the index of an element in a vector?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-there-an-r-function-for-finding-the-index-of-an-element-in-a-vector/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:17:37+08:00" itemprop="datePublished" title="2023-03-03 17:17">2023-03-03 17:17</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In R, I have an element <code>x</code> and a vector <code>v</code>. I want to find the first index
of an element in <code>v</code> that is equal to <code>x</code>. I know that one way to do this is:
<code>which(x == v)[[1]]</code>, but that seems excessively inefficient. Is there a more
direct way to do it?</p>
<p>For bonus points, is there a function that works if <code>x</code> is a vector? That is,
it should return a vector of indices indicating the position of each element
of <code>x</code> in <code>v</code>.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The function <code>match</code> works on vectors:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">)</span>
<span class="n">x</span>
<span class="c1"># [1]  4  5  9  3  8  1  6 10  7  2</span>
<span class="nf">match</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="m">8</span><span class="p">),</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># [1] 1 5</span>
</pre></div>

<p><code>match</code> only returns the first encounter of a match, as you requested. It
returns the position in the second argument of the values in the first
argument.</p>
<p>For multiple matching, <code>%in%</code> is the way to go:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span><span class="m">10</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="n">x</span>
<span class="c1"># [1] 3 4 3 3 2 3 1 1 2 2</span>
<span class="nf">which</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">))</span>
<span class="c1"># [1]  2  5  9 10</span>
</pre></div>

<p><code>%in%</code> returns a logical vector as long as the first argument, with a <code>TRUE</code>
if that value can be found in the second argument and a <code>FALSE</code> otherwise.</p>
<p><br></p>
<h3>Suggest</h3>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/does-http-2-make-websockets-obsolete/" class="u-url">Does HTTP/2 make websockets obsolete?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/does-http-2-make-websockets-obsolete/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:17:12+08:00" itemprop="datePublished" title="2023-03-03 17:17">2023-03-03 17:17</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm learning about HTTP/2 protocol. It's a binary protocol with small message
frames. It allows stream multiplexing over single TCP connection. Conceptually
it seems very similar to WebSockets.</p>
<p>Are there plans to obsolete websockets and replace them with some kind of
headerless HTTP/2 requests and server-initiated push messages? Or will
WebSockets complement HTTP/2?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>From what I understood HTTP/2 is not a replacement for websocket but aims to
standardize SPDY protocol.</p>
<p>In HTTP/2, server-push is used behind the scene to improve resource loading by
the client from the browser. As a developer, you don't really care about it
during your development. However, with Websocket, the developer is allowed to
use API which is able to consume and push message with an unique full-duplex
connection.</p>
<p>These are not the same things, and they should complement each other.</p>
<p><br></p>
<h3>Suggest</h3>
<p>From what I understood HTTP/2 is not a replacement for websocket but aims to
standardize SPDY protocol.</p>
<p>In HTTP/2, server-push is used behind the scene to improve resource loading by
the client from the browser. As a developer, you don't really care about it
during your development. However, with Websocket, the developer is allowed to
use API which is able to consume and push message with an unique full-duplex
connection.</p>
<p>These are not the same things, and they should complement each other.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/difference-between-numpy-array-shape-r-1-and-r/" class="u-url">Difference between numpy.array shape (R, 1) and (R,)</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/difference-between-numpy-array-shape-r-1-and-r/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:16:47+08:00" itemprop="datePublished" title="2023-03-03 17:16">2023-03-03 17:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In <code>numpy</code>, some of the operations return in shape <code>(R, 1)</code> but some return
<code>(R,)</code>. This will make matrix multiplication more tedious since explicit
<code>reshape</code> is required. For example, given a matrix <code>M</code>, if we want to do
<code>numpy.dot(M[:,0], numpy.ones((1, R)))</code> where <code>R</code> is the number of rows (of
course, the same issue also occurs column-wise). We will get <code>matrices are not
aligned</code> error since <code>M[:,0]</code> is in shape <code>(R,)</code> but <code>numpy.ones((1, R))</code> is
in shape <code>(1, R)</code>.</p>
<p>So my questions are:</p>
<ol>
<li>
<p>What's the difference between shape <code>(R, 1)</code> and <code>(R,)</code>. I know literally it's list of numbers and list of lists where all list contains only a number. Just wondering why not design <code>numpy</code> so that it favors shape <code>(R, 1)</code> instead of <code>(R,)</code> for easier matrix multiplication.</p>
</li>
<li>
<p>Are there better ways for the above example? Without explicitly reshape like this: <code>numpy.dot(M[:,0].reshape(R, 1), numpy.ones((1, R)))</code></p>
</li>
</ol>
<p><br><br></p>
<h2>Answer</h2>
<h4>1. The meaning of shapes in NumPy</h4>
<p>You write, "I know literally it's list of numbers and list of lists where all
list contains only a number" but that's a bit of an unhelpful way to think
about it.</p>
<p>The best way to think about NumPy arrays is that they consist of two parts, a
<em>data buffer</em> which is just a block of raw elements, and a <em>view</em> which
describes how to interpret the data buffer.</p>
<p>For example, if we create an array of 12 integers:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; a = numpy.arange(12)
&gt;&gt;&gt; a
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
</pre></div>

<p>Then <code>a</code> consists of a data buffer, arranged something like this:</p>
<div class="code"><pre class="code literal-block">┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>and a view which describes how to interpret the data:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; a.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
&gt;&gt;&gt; a.dtype
dtype('int64')
&gt;&gt;&gt; a.itemsize
8
&gt;&gt;&gt; a.strides
(8,)
&gt;&gt;&gt; a.shape
(12,)
</pre></div>

<p>Here the <em>shape</em> <code>(12,)</code> means the array is indexed by a single index which
runs from 0 to 11. Conceptually, if we label this single index <code>i</code>, the array
<code>a</code> looks like this:</p>
<div class="code"><pre class="code literal-block">i= 0    1    2    3    4    5    6    7    8    9   10   11
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>If we reshape an array, this doesn't change the data buffer. Instead, it
creates a new view that describes a different way to interpret the data. So
after:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; b = a.reshape((3, 4))
</pre></div>

<p>the array <code>b</code> has the same data buffer as <code>a</code>, but now it is indexed by <em>two</em>
indices which run from 0 to 2 and 0 to 3 respectively. If we label the two
indices <code>i</code> and <code>j</code>, the array <code>b</code> looks like this:</p>
<div class="code"><pre class="code literal-block">i= 0    0    0    0    1    1    1    1    2    2    2    2
j= 0    1    2    3    0    1    2    3    0    1    2    3
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>which means that:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; b[2,1]
9
</pre></div>

<p>You can see that the second index changes quickly and the first index changes
slowly. If you prefer this to be the other way round, you can specify the
<code>order</code> parameter:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c = a.reshape((3, 4), order='F')
</pre></div>

<p>which results in an array indexed like this:</p>
<div class="code"><pre class="code literal-block">i= 0    1    2    0    1    2    0    1    2    0    1    2
j= 0    0    0    1    1    1    2    2    2    3    3    3
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>which means that:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c[2,1]
5
</pre></div>

<p>It should now be clear what it means for an array to have a shape with one or
more dimensions of size 1. After:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; d = a.reshape((12, 1))
</pre></div>

<p>the array <code>d</code> is indexed by two indices, the first of which runs from 0 to 11,
and the second index is always 0:</p>
<div class="code"><pre class="code literal-block">i= 0    1    2    3    4    5    6    7    8    9   10   11
j= 0    0    0    0    0    0    0    0    0    0    0    0
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>and so:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; d[10,0]
10
</pre></div>

<p>A dimension of length 1 is "free" (in some sense), so there's nothing stopping
you from going to town:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; e = a.reshape((1, 2, 1, 6, 1))
</pre></div>

<p>giving an array indexed like this:</p>
<div class="code"><pre class="code literal-block">i= 0    0    0    0    0    0    0    0    0    0    0    0
j= 0    0    0    0    0    0    1    1    1    1    1    1
k= 0    0    0    0    0    0    0    0    0    0    0    0
l= 0    1    2    3    4    5    0    1    2    3    4    5
m= 0    0    0    0    0    0    0    0    0    0    0    0
┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│  0 │  1 │  2 │  3 │  4 │  5 │  6 │  7 │  8 │  9 │ 10 │ 11 │
└────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</pre></div>

<p>and so:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; e[0,1,0,0,0]
6
</pre></div>

<p>See the NumPy internals documentation for more details about how arrays are
implemented.</p>
<h4>2. What to do?</h4>
<p>Since <code>numpy.reshape</code> just creates a new view, you shouldn't be scared about
using it whenever necessary. It's the right tool to use when you want to index
an array in a different way.</p>
<p>However, in a long computation it's usually possible to arrange to construct
arrays with the "right" shape in the first place, and so minimize the number
of reshapes and transposes. But without seeing the actual context that led to
the need for a reshape, it's hard to say what should be changed.</p>
<p>The example in your question is:</p>
<div class="code"><pre class="code literal-block">numpy.dot(M[:,0], numpy.ones((1, R)))
</pre></div>

<p>but this is not realistic. First, this expression:</p>
<div class="code"><pre class="code literal-block">M[:,0].sum()
</pre></div>

<p>computes the result more simply. Second, is there really something special
about column 0? Perhaps what you actually need is:</p>
<div class="code"><pre class="code literal-block">M.sum(axis=0)
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>The difference between <code>(R,)</code> and <code>(1,R)</code> is literally the number of indices
that you need to use. <code>ones((1,R))</code> is a 2-D array that happens to have only
one row. <code>ones(R)</code> is a vector. Generally if it doesn't make sense for the
variable to have more than one row/column, you should be using a vector, not a
matrix with a singleton dimension.</p>
<p>For your specific case, there are a couple of options:</p>
<p>1) Just make the second argument a vector. The following works fine:</p>
<div class="code"><pre class="code literal-block">    np.dot(M[:,0], np.ones(R))
</pre></div>

<p>2) If you want matlab like matrix operations, use the class <code>matrix</code> instead
of <code>ndarray</code>. All matricies are forced into being 2-D arrays, and operator <code>*</code>
does matrix multiplication instead of element-wise (so you don't need dot). In
my experience, this is more trouble that it is worth, but it may be nice if
you are used to matlab.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2115.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2113.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
