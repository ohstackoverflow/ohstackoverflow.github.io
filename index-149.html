<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 149) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-149.html">
<link rel="prev" href="index-150.html" type="text/html">
<link rel="next" href="index-148.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-i-pad-a-string-with-zeroes/" class="u-url">How do I pad a string with zeroes?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-i-pad-a-string-with-zeroes/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:04:27+08:00" itemprop="datePublished" title="2023-02-16 23:04">2023-02-16 23:04</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How do I pad a numeric string with zeroes to the left, so that the string has
a specific length?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>To pad strings:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; n = '4'
&gt;&gt;&gt; print(n.zfill(3))
004
</pre></div>

<p>To pad numbers:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; n = 4
&gt;&gt;&gt; print(f'{n:03}') # Preferred method, python &gt;= 3.6
004
&gt;&gt;&gt; print('%03d' % n)
004
&gt;&gt;&gt; print(format(n, '03')) # python &gt;= 2.6
004
&gt;&gt;&gt; print('{0:03d}'.format(n))  # python &gt;= 2.6 + python 3
004
&gt;&gt;&gt; print('{foo:03d}'.format(foo=n))  # python &gt;= 2.6 + python 3
004
&gt;&gt;&gt; print('{:03d}'.format(n))  # python &gt;= 2.7 + python3
004
</pre></div>

<p>String formatting documentation.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Just use the <code>rjust</code> method of the string object.</p>
<p>This example creates a 10-character length string, padding as necessary:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; s = 'test'
&gt;&gt;&gt; s.rjust(10, '0')
&gt;&gt;&gt; '000000test'
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-move-semantics/" class="u-url">What is move semantics?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-move-semantics/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:03:48+08:00" itemprop="datePublished" title="2023-02-16 23:03">2023-02-16 23:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I just finished listening to the Software Engineering radio podcast interview
with Scott Meyers regarding C++0x. Most of the new features made sense to me,
and I am actually excited about C++0x now, with the exception of one. I still
don't get <em>move semantics</em>... What is it exactly?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I find it easiest to understand move semantics with example code. Let's start
with a very simple string class which only holds a pointer to a heap-allocated
block of memory:</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">cstring</span><span class="o">&gt;</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">algorithm</span><span class="o">&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="n">string</span>
<span class="err">{</span>
<span class="w">    </span><span class="nc">char</span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="p">;</span>

<span class="k">public</span><span class="err">:</span>

<span class="w">    </span><span class="n">string</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="nc">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">char</span><span class="o">[</span><span class="n">size</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">memcpy</span><span class="p">(</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">size</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
</pre></div>

<p>Since we chose to manage the memory ourselves, we need to follow the rule of
three. I am going to defer writing the assignment operator and only implement
the destructor and the copy constructor for now:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">~</span><span class="n">string</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="k">data</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="n">string</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">that</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="k">data</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">char</span><span class="o">[</span><span class="n">size</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">memcpy</span><span class="p">(</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="k">size</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
</pre></div>

<p>The copy constructor defines what it means to copy string objects. The
parameter <code>const string&amp; that</code> binds to all expressions of type string which
allows you to make copies in the following examples:</p>
<div class="code"><pre class="code literal-block">string a(x);                                    // Line 1
string b(x + y);                                // Line 2
string c(some_function_returning_a_string());   // Line 3
</pre></div>

<p>Now comes the key insight into move semantics. Note that only in the first
line where we copy <code>x</code> is this deep copy really necessary, because we might
want to inspect <code>x</code> later and would be very surprised if <code>x</code> had changed
somehow. Did you notice how I just said <code>x</code> three times (four times if you
include this sentence) and meant the <em>exact same object</em> every time? We call
expressions such as <code>x</code> "lvalues".</p>
<p>The arguments in lines 2 and 3 are not lvalues, but rvalues, because the
underlying string objects have no names, so the client has no way to inspect
them again at a later point in time. rvalues denote temporary objects which
are destroyed at the next semicolon (to be more precise: at the end of the
full-expression that lexically contains the rvalue). This is important because
during the initialization of <code>b</code> and <code>c</code>, we could do whatever we wanted with
the source string, and <em>the client couldn't tell a difference</em>!</p>
<p>C++0x introduces a new mechanism called "rvalue reference" which, among other
things, allows us to detect rvalue arguments via function overloading. All we
have to do is write a constructor with an rvalue reference parameter. Inside
that constructor we can do <em>anything we want</em> with the source, as long as we
leave it in <em>some</em> valid state:</p>
<div class="code"><pre class="code literal-block">    string(string&amp;&amp; that)   // string&amp;&amp; is an rvalue reference to a string
    {
        data = that.data;
        that.data = nullptr;
    }
</pre></div>

<p>What have we done here? Instead of deeply copying the heap data, we have just
copied the pointer and then set the original pointer to null (to prevent
'delete[]' from source object's destructor from releasing our 'just stolen
data'). In effect, we have "stolen" the data that originally belonged to the
source string. Again, the key insight is that under no circumstance could the
client detect that the source had been modified. Since we don't really do a
copy here, we call this constructor a "move constructor". Its job is to move
resources from one object to another instead of copying them.</p>
<p>Congratulations, you now understand the basics of move semantics! Let's
continue by implementing the assignment operator. If you're unfamiliar with
the copy and swap idiom, learn it and come back, because it's an awesome C++
idiom related to exception safety.</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nt">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">operator</span><span class="o">=(</span><span class="nt">string</span><span class="w"> </span><span class="nt">that</span><span class="o">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="err">.</span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">*this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Huh, that's it? "Where's the rvalue reference?" you might ask. "We don't need
it here!" is my answer :)</p>
<p>Note that we pass the parameter <code>that</code> <em>by value</em> , so <code>that</code> has to be
initialized just like any other string object. Exactly how is <code>that</code> going to
be initialized? In the olden days of C++98, the answer would have been "by the
copy constructor". In C++0x, the compiler chooses between the copy constructor
and the move constructor based on whether the argument to the assignment
operator is an lvalue or an rvalue.</p>
<p>So if you say <code>a = b</code>, the <em>copy constructor</em> will initialize <code>that</code> (because
the expression <code>b</code> is an lvalue), and the assignment operator swaps the
contents with a freshly created, deep copy. That is the very definition of the
copy and swap idiom -- make a copy, swap the contents with the copy, and then
get rid of the copy by leaving the scope. Nothing new here.</p>
<p>But if you say <code>a = x + y</code>, the <em>move constructor</em> will initialize <code>that</code>
(because the expression <code>x + y</code> is an rvalue), so there is no deep copy
involved, only an efficient move. <code>that</code> is still an independent object from
the argument, but its construction was trivial, since the heap data didn't
have to be copied, just moved. It wasn't necessary to copy it because <code>x + y</code>
is an rvalue, and again, it is okay to move from string objects denoted by
rvalues.</p>
<p>To summarize, the copy constructor makes a deep copy, because the source must
remain untouched. The move constructor, on the other hand, can just copy the
pointer and then set the pointer in the source to null. It is okay to
"nullify" the source object in this manner, because the client has no way of
inspecting the object again.</p>
<p>I hope this example got the main point across. There is a lot more to rvalue
references and move semantics which I intentionally left out to keep it
simple. If you want more details please see my supplementary answer.</p>
<p><br></p>
<h3>Suggest</h3>
<p>My first answer was an extremely simplified introduction to move semantics,
and many details were left out on purpose to keep it simple. However, there is
a lot more to move semantics, and I thought it was time for a second answer to
fill the gaps. The first answer is already quite old, and it did not feel
right to simply replace it with a completely different text. I think it still
serves well as a first introduction. But if you want to dig deeper, read on :)</p>
<p>Stephan T. Lavavej took the time to provide valuable feedback. Thank you very
much, Stephan!</p>
<h3>Introduction</h3>
<p>Move semantics allows an object, under certain conditions, to take ownership
of some other object's external resources. This is important in two ways:</p>
<ol>
<li>
<p>Turning expensive copies into cheap moves. See my first answer for an example. Note that if an object does not manage at least one external resource (either directly, or indirectly through its member objects), move semantics will not offer any advantages over copy semantics. In that case, copying an object and moving an object means the exact same thing:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">cannot_benefit_from_move_semantics</span>
</pre></div>

<p>{
    int a;        // moving an int means copying an int
    float b;      // moving a float means copying a float
    double c;     // moving a double means copying a double
    char d[64];   // moving a char array means copying a char array</p>
<div class="code"><pre class="code literal-block"><span class="c1">// ...</span>
</pre></div>

<p>};</p>
</li>
<li>
<p>Implementing safe "move-only" types; that is, types for which copying does not make sense, but moving does. Examples include locks, file handles, and smart pointers with unique ownership semantics. Note: This answer discusses <code>std::auto_ptr</code>, a deprecated C++98 standard library template, which was replaced by <code>std::unique_ptr</code> in C++11. Intermediate C++ programmers are probably at least somewhat familiar with <code>std::auto_ptr</code>, and because of the "move semantics" it displays, it seems like a good starting point for discussing move semantics in C++11. YMMV.</p>
</li>
</ol>
<h3>What is a move?</h3>
<p>The C++98 standard library offers a smart pointer with unique ownership
semantics called <code>std::auto_ptr&lt;T&gt;</code>. In case you are unfamiliar with
<code>auto_ptr</code>, its purpose is to guarantee that a dynamically allocated object is
always released, even in the face of exceptions:</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">arbitrary</span><span class="w"> </span><span class="err">code,</span><span class="w"> </span><span class="err">could</span><span class="w"> </span><span class="err">throw</span><span class="w"> </span><span class="err">exceptions</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="p">}</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">---</span><span class="w"> </span><span class="nt">when</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">goes</span><span class="w"> </span><span class="nt">out</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">scope</span><span class="o">,</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">triangle</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">deleted</span><span class="w"> </span><span class="nt">automatically</span>
</pre></div>

<p>The unusual thing about <code>auto_ptr</code> is its "copying" behavior:</p>
<div class="code"><pre class="code literal-block"><span class="c">auto_ptr</span><span class="nv">&lt;</span><span class="c">Shape</span><span class="nv">&gt;</span><span class="c"> a(new Triangle);</span>

<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">      | triangle data |</span>
<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">        ^</span>
<span class="c">        |</span>
<span class="c">        |</span>
<span class="c">        |</span>
<span class="c">  </span><span class="nb">+-----</span><span class="c">|</span><span class="nb">---+</span>
<span class="c">  |   </span><span class="nb">+-</span><span class="c">|</span><span class="nb">-+</span><span class="c"> |</span>
<span class="c">a | p | | | |</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |</span>
<span class="c">  </span><span class="nb">+---------+</span>

<span class="c">auto_ptr</span><span class="nv">&lt;</span><span class="c">Shape</span><span class="nv">&gt;</span><span class="c"> b(a);</span>

<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">      | triangle data |</span>
<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">        ^</span>
<span class="c">        |</span>
<span class="c">        </span><span class="nb">+----------------------+</span>
<span class="c">                               |</span>
<span class="c">  </span><span class="nb">+---------+</span><span class="c">            </span><span class="nb">+-----</span><span class="c">|</span><span class="nb">---+</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |            |   </span><span class="nb">+-</span><span class="c">|</span><span class="nb">-+</span><span class="c"> |</span>
<span class="c">a | p |   | |          b | p | | | |</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |            |   </span><span class="nb">+---+</span><span class="c"> |</span>
<span class="c">  </span><span class="nb">+---------+</span><span class="c">            </span><span class="nb">+---------+</span>
</pre></div>

<p>Note how the initialization of <code>b</code> with <code>a</code> does <em>not</em> copy the triangle, but
instead transfers the ownership of the triangle from <code>a</code> to <code>b</code>. We also say
"<code>a</code> is <em>moved into</em> <code>b</code>" or "the triangle is <em>moved</em> from <code>a</code> <em>to</em> <code>b</code>". This
may sound confusing because the triangle itself always stays at the same place
in memory.</p>
<blockquote>
<p>To move an object means to transfer ownership of some resource it manages to
another object.</p>
</blockquote>
<p>The copy constructor of <code>auto_ptr</code> probably looks something like this
(somewhat simplified):</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="p">(</span><span class="n">auto_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">missing</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">longer</span><span class="w"> </span><span class="n">owns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">object</span>
<span class="p">}</span>
</pre></div>

<h3>Dangerous and harmless moves</h3>
<p>The dangerous thing about <code>auto_ptr</code> is that what syntactically looks like a
copy is actually a move. Trying to call a member function on a moved-from
<code>auto_ptr</code> will invoke undefined behavior, so you have to be very careful not
to use an <code>auto_ptr</code> after it has been moved from:</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span><span class="w">   </span><span class="c1">// create triangle</span>
<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">              </span><span class="c1">// move a into b</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span><span class="w">           </span><span class="c1">// undefined behavior</span>
</pre></div>

<p>But <code>auto_ptr</code> is not <em>always</em> dangerous. Factory functions are a perfectly
fine use case for <code>auto_ptr</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_triangle</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">make_triangle</span><span class="p">());</span><span class="w">      </span><span class="c1">// move temporary into c</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_triangle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span><span class="w">   </span><span class="c1">// perfectly safe</span>
</pre></div>

<p>Note how both examples follow the same syntactic pattern:</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">variable</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expression</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>
</pre></div>

<p>And yet, one of them invokes undefined behavior, whereas the other one does
not. So what is the difference between the expressions <code>a</code> and
<code>make_triangle()</code>? Aren't they both of the same type? Indeed they are, but
they have different <em>value categories</em>.</p>
<h3>Value categories</h3>
<p>Obviously, there must be some profound difference between the expression <code>a</code>
which denotes an <code>auto_ptr</code> variable, and the expression <code>make_triangle()</code>
which denotes the call of a function that returns an <code>auto_ptr</code> by value, thus
creating a fresh temporary <code>auto_ptr</code> object every time it is called. <code>a</code> is
an example of an <em>lvalue</em> , whereas <code>make_triangle()</code> is an example of an
<em>rvalue</em>.</p>
<p>Moving from lvalues such as <code>a</code> is dangerous, because we could later try to
call a member function via <code>a</code>, invoking undefined behavior. On the other
hand, moving from rvalues such as <code>make_triangle()</code> is perfectly safe, because
after the copy constructor has done its job, we cannot use the temporary
again. There is no expression that denotes said temporary; if we simply write
<code>make_triangle()</code> again, we get a <em>different</em> temporary. In fact, the moved-
from temporary is already gone on the next line:</p>
<div class="code"><pre class="code literal-block">auto_ptr&lt;Shape&gt; c(make_triangle());
                                  ^ the moved-from temporary dies right here
</pre></div>

<p>Note that the letters <code>l</code> and <code>r</code> have a historic origin in the left-hand side
and right-hand side of an assignment. This is no longer true in C++, because
there are lvalues that cannot appear on the left-hand side of an assignment
(like arrays or user-defined types without an assignment operator), and there
are rvalues which can (all rvalues of class types with an assignment
operator).</p>
<blockquote>
<p>An rvalue of class type is an expression whose evaluation creates a
temporary object. Under normal circumstances, no other expression inside the
same scope denotes the same temporary object.</p>
</blockquote>
<h3>Rvalue references</h3>
<p>We now understand that moving from lvalues is potentially dangerous, but
moving from rvalues is harmless. If C++ had language support to distinguish
lvalue arguments from rvalue arguments, we could either completely forbid
moving from lvalues, or at least make moving from lvalues <em>explicit</em> at call
site, so that we no longer move by accident.</p>
<p>C++11's answer to this problem is <em>rvalue references</em>. An rvalue reference is
a new kind of reference that only binds to rvalues, and the syntax is <code>X&amp;&amp;</code>.
The good old reference <code>X&amp;</code> is now known as an <em>lvalue reference</em>. (Note that
<code>X&amp;&amp;</code> is <em>not</em> a reference to a reference; there is no such thing in C++.)</p>
<p>If we throw <code>const</code> into the mix, we already have four different kinds of
references. What kinds of expressions of type <code>X</code> can they bind to?</p>
<div class="code"><pre class="code literal-block"><span class="w">            </span><span class="n">lvalue</span><span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">lvalue</span><span class="w">   </span><span class="n">rvalue</span><span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">rvalue</span>
<span class="o">---------------------------------------------------------</span><span class="w">              </span>
<span class="n">X</span><span class="o">&amp;</span><span class="w">          </span><span class="n">yes</span>
<span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="w">    </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span><span class="w">            </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span>
<span class="n">X</span><span class="o">&amp;&amp;</span><span class="w">                                 </span><span class="n">yes</span>
<span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="w">                           </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span>
</pre></div>

<p>In practice, you can forget about <code>const X&amp;&amp;</code>. Being restricted to read from
rvalues is not very useful.</p>
<blockquote>
<p>An rvalue reference <code>X&amp;&amp;</code> is a new kind of reference that only binds to
rvalues.</p>
</blockquote>
<h3>Implicit conversions</h3>
<p>Rvalue references went through several versions. Since version 2.1, an rvalue
reference <code>X&amp;&amp;</code> also binds to all value categories of a different type <code>Y</code>,
provided there is an implicit conversion from <code>Y</code> to <code>X</code>. In that case, a
temporary of type <code>X</code> is created, and the rvalue reference is bound to that
temporary:</p>
<div class="code"><pre class="code literal-block"><span class="nt">void</span><span class="w"> </span><span class="nt">some_function</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">r</span><span class="o">);</span>

<span class="nt">some_function</span><span class="o">(</span><span class="s2">"hello world"</span><span class="o">);</span>
</pre></div>

<p>In the above example, <code>"hello world"</code> is an lvalue of type <code>const char[12]</code>.
Since there is an implicit conversion from <code>const char[12]</code> through <code>const
char*</code> to <code>std::string</code>, a temporary of type <code>std::string</code> is created, and <code>r</code>
is bound to that temporary. This is one of the cases where the distinction
between rvalues (expressions) and temporaries (objects) is a bit blurry.</p>
<h3>Move constructors</h3>
<p>A useful example of a function with an <code>X&amp;&amp;</code> parameter is the <em>move
constructor</em> <code>X::X(X&amp;&amp; source)</code>. Its purpose is to transfer ownership of the
managed resource from the source into the current object.</p>
<p>In C++11, <code>std::auto_ptr&lt;T&gt;</code> has been replaced by <code>std::unique_ptr&lt;T&gt;</code> which
takes advantage of rvalue references. I will develop and discuss a simplified
version of <code>unique_ptr</code>. First, we encapsulate a raw pointer and overload the
operators <code>-&gt;</code> and <code>*</code>, so our class feels like a pointer:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="n">unique_ptr</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>

<p>The constructor takes ownership of the object, and the destructor deletes it:</p>
<div class="code"><pre class="code literal-block">    explicit unique_ptr(T* p = nullptr)
    {
        ptr = p;
    }

    ~unique_ptr()
    {
        delete ptr;
    }
</pre></div>

<p>Now comes the interesting part, the move constructor:</p>
<div class="code"><pre class="code literal-block">    unique_ptr(unique_ptr&amp;&amp; source)   // note the rvalue reference
    {
        ptr = source.ptr;
        source.ptr = nullptr;
    }
</pre></div>

<p>This move constructor does exactly what the <code>auto_ptr</code> copy constructor did,
but it can only be supplied with rvalues:</p>
<div class="code"><pre class="code literal-block">unique_ptr&lt;Shape&gt; a(new Triangle);
unique_ptr&lt;Shape&gt; b(a);                 // error
unique_ptr&lt;Shape&gt; c(make_triangle());   // okay
</pre></div>

<p>The second line fails to compile, because <code>a</code> is an lvalue, but the parameter
<code>unique_ptr&amp;&amp; source</code> can only be bound to rvalues. This is exactly what we
wanted; dangerous moves should never be implicit. The third line compiles just
fine, because <code>make_triangle()</code> is an rvalue. The move constructor will
transfer ownership from the temporary to <code>c</code>. Again, this is exactly what we
wanted.</p>
<blockquote>
<p>The move constructor transfers ownership of a managed resource into the
current object.</p>
</blockquote>
<h3>Move assignment operators</h3>
<p>The last missing piece is the move assignment operator. Its job is to release
the old resource and acquire the new resource from its argument:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="n">unique_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">   </span><span class="c1">// note the rvalue reference</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">source</span><span class="p">)</span><span class="w">    </span><span class="c1">// beware of self-assignment</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w">         </span><span class="c1">// release the old resource</span>

<span class="w">            </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span><span class="w">   </span><span class="c1">// acquire the new resource</span>
<span class="w">            </span><span class="n">source</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>Note how this implementation of the move assignment operator duplicates logic
of both the destructor and the move constructor. Are you familiar with the
copy-and-swap idiom? It can also be applied to move semantics as the move-and-
swap idiom:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nt">unique_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">operator</span><span class="o">=(</span><span class="nt">unique_ptr</span><span class="w"> </span><span class="nt">source</span><span class="o">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">note</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">missing</span><span class="w"> </span><span class="nt">reference</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">swap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="err">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">*this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Now that <code>source</code> is a variable of type <code>unique_ptr</code>, it will be initialized
by the move constructor; that is, the argument will be moved into the
parameter. The argument is still required to be an rvalue, because the move
constructor itself has an rvalue reference parameter. When control flow
reaches the closing brace of <code>operator=</code>, <code>source</code> goes out of scope,
releasing the old resource automatically.</p>
<blockquote>
<p>The move assignment operator transfers ownership of a managed resource into
the current object, releasing the old resource. The move-and-swap idiom
simplifies the implementation.</p>
</blockquote>
<h3>Moving from lvalues</h3>
<p>Sometimes, we want to move from lvalues. That is, sometimes we want the
compiler to treat an lvalue as if it were an rvalue, so it can invoke the move
constructor, even though it could be potentially unsafe. For this purpose,
C++11 offers a standard library function template called <code>std::move</code> inside
the header <code>&lt;utility&gt;</code>. This name is a bit unfortunate, because <code>std::move</code>
simply casts an lvalue to an rvalue; it does <em>not</em> move anything by itself. It
merely <em>enables</em> moving. Maybe it should have been named <code>std::cast_to_rvalue</code>
or <code>std::enable_move</code>, but we are stuck with the name by now.</p>
<p>Here is how you explicitly move from an lvalue:</p>
<div class="code"><pre class="code literal-block"><span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">a</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Triangle</span><span class="o">);</span>
<span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">b</span><span class="o">(</span><span class="nt">a</span><span class="o">);</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="nt">still</span><span class="w"> </span><span class="nt">an</span><span class="w"> </span><span class="nt">error</span>
<span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">c</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">a</span><span class="o">));</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">okay</span>
</pre></div>

<p>Note that after the third line, <code>a</code> no longer owns a triangle. That's okay,
because by <em>explicitly</em> writing <code>std::move(a)</code>, we made our intentions clear:
"Dear constructor, do whatever you want with <code>a</code> in order to initialize <code>c</code>; I
don't care about <code>a</code> anymore. Feel free to have your way with <code>a</code>."</p>
<blockquote>
<p><code>std::move(some_lvalue)</code> casts an lvalue to an rvalue, thus enabling a
subsequent move.</p>
</blockquote>
<h3>Xvalues</h3>
<p>Note that even though <code>std::move(a)</code> is an rvalue, its evaluation does <em>not</em>
create a temporary object. This conundrum forced the committee to introduce a
third value category. Something that can be bound to an rvalue reference, even
though it is not an rvalue in the traditional sense, is called an <em>xvalue</em>
(eXpiring value). The traditional rvalues were renamed to <em>prvalues</em> (Pure
rvalues).</p>
<p>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both <em>glvalues</em>
(Generalized lvalues). The relationships are easier to grasp with a diagram:</p>
<div class="code"><pre class="code literal-block">        expressions
          /     \
         /       \
        /         \
    glvalues   rvalues
      /  \       /  \
     /    \     /    \
    /      \   /      \
lvalues   xvalues   prvalues
</pre></div>

<p>Note that only xvalues are really new; the rest is just due to renaming and
grouping.</p>
<blockquote>
<p>C++98 rvalues are known as prvalues in C++11. Mentally replace all
occurrences of "rvalue" in the preceding paragraphs with "prvalue".</p>
</blockquote>
<h3>Moving out of functions</h3>
<p>So far, we have seen movement into local variables, and into function
parameters. But moving is also possible in the opposite direction. If a
function returns by value, some object at call site (probably a local variable
or a temporary, but could be any kind of object) is initialized with the
expression after the <code>return</code> statement as an argument to the move
constructor:</p>
<div class="code"><pre class="code literal-block"><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">make_triangle</span><span class="ss">()</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">new</span><span class="w"> </span><span class="nv">Triangle</span><span class="ss">)</span><span class="c1">;</span>
}<span class="w">          </span>\<span class="o">-----------------------------/</span>
<span class="w">                  </span><span class="o">|</span>
<span class="w">                  </span><span class="o">|</span><span class="w"> </span><span class="nv">temporary</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">moved</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">c</span>
<span class="w">                  </span><span class="o">|</span>
<span class="w">                  </span><span class="nv">v</span>
<span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="nv">make_triangle</span><span class="ss">())</span><span class="c1">;</span>
</pre></div>

<p>Perhaps surprisingly, automatic objects (local variables that are not declared
as <code>static</code>) can also be <em>implicitly</em> moved out of functions:</p>
<div class="code"><pre class="code literal-block"><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">make_square</span><span class="ss">()</span>
{
<span class="w">    </span><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">result</span><span class="ss">(</span><span class="nv">new</span><span class="w"> </span><span class="nv">Square</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">result</span><span class="c1">;   // note the missing std::move</span>
}
</pre></div>

<p>How come the move constructor accepts the lvalue <code>result</code> as an argument? The
scope of <code>result</code> is about to end, and it will be destroyed during stack
unwinding. Nobody could possibly complain afterward that <code>result</code> had changed
somehow; when control flow is back at the caller, <code>result</code> does not exist
anymore! For that reason, C++11 has a special rule that allows returning
automatic objects from functions without having to write <code>std::move</code>. In fact,
you should <em>never</em> use <code>std::move</code> to move automatic objects out of functions,
as this inhibits the "named return value optimization" (NRVO).</p>
<blockquote>
<p>Never use <code>std::move</code> to move automatic objects out of functions.</p>
</blockquote>
<p>Note that in both factory functions, the return type is a value, not an rvalue
reference. Rvalue references are still references, and as always, you should
never return a reference to an automatic object; the caller would end up with
a dangling reference if you tricked the compiler into accepting your code,
like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="nt">flawed_attempt</span><span class="o">()</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">DO</span><span class="w"> </span><span class="nt">NOT</span><span class="w"> </span><span class="nt">DO</span><span class="w"> </span><span class="nt">THIS</span><span class="o">!</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">very_bad_idea(new</span><span class="w"> </span><span class="err">Square)</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">very_bad_idea</span><span class="p">);</span><span class="w">   </span><span class="err">//</span><span class="w"> </span><span class="err">WRONG!</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p>Never return automatic objects by rvalue reference. Moving is exclusively
performed by the move constructor, not by <code>std::move</code>, and not by merely
binding an rvalue to an rvalue reference.</p>
</blockquote>
<h3>Moving into members</h3>
<p>Sooner or later, you are going to write code like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Foo</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">member</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="nf">Foo</span><span class="p">(</span><span class="n">unique_ptr</span><span class="err">&lt;</span><span class="n">Shape</span><span class="err">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">parameter</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">error</span>
<span class="w">    </span><span class="err">{</span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Basically, the compiler will complain that <code>parameter</code> is an lvalue. If you
look at its type, you see an rvalue reference, but an rvalue reference simply
means "a reference that is bound to an rvalue"; it does <em>not</em> mean that the
reference itself is an rvalue! Indeed, <code>parameter</code> is just an ordinary
variable with a name. You can use <code>parameter</code> as often as you like inside the
body of the constructor, and it always denotes the same object. Implicitly
moving from it would be dangerous, hence the language forbids it.</p>
<blockquote>
<p>A named rvalue reference is an lvalue, just like any other variable.</p>
</blockquote>
<p>The solution is to manually enable the move:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Foo</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">member</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="nf">Foo</span><span class="p">(</span><span class="n">unique_ptr</span><span class="err">&lt;</span><span class="n">Shape</span><span class="err">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">parameter</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="n">std</span><span class="err">::</span><span class="kc">move</span><span class="err">(</span><span class="n">parameter</span><span class="p">))</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kc">move</span>
<span class="w">    </span><span class="err">{</span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>You could argue that <code>parameter</code> is not used anymore after the initialization
of <code>member</code>. Why is there no special rule to silently insert <code>std::move</code> just
as with return values? Probably because it would be too much burden on the
compiler implementors. For example, what if the constructor body was in
another translation unit? By contrast, the return value rule simply has to
check the symbol tables to determine whether or not the identifier after the
<code>return</code> keyword denotes an automatic object.</p>
<p>You can also pass the <code>parameter</code> by value. For move-only types like
<code>unique_ptr</code>, it seems there is no established idiom yet. Personally, I prefer
to pass by value, as it causes less clutter in the interface.</p>
<h3>Special member functions</h3>
<p>C++98 implicitly declares three special member functions on demand, that is,
when they are needed somewhere: the copy constructor, the copy assignment
operator, and the destructor.</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="p">::</span><span class="n">X</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">constructor</span>
<span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">operator</span>
<span class="n">X</span><span class="p">::</span><span class="o">~</span><span class="n">X</span><span class="p">();</span><span class="w">                     </span><span class="o">//</span><span class="w"> </span><span class="n">destructor</span>
</pre></div>

<p>Rvalue references went through several versions. Since version 3.0, C++11
declares two additional special member functions on demand: the move
constructor and the move assignment operator. Note that neither VC10 nor VC11
conforms to version 3.0 yet, so you will have to implement them yourself.</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="p">::</span><span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w">                   </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">constructor</span>
<span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">operator</span>
</pre></div>

<p>These two new special member functions are only implicitly declared if none of
the special member functions are declared manually. Also, if you declare your
own move constructor or move assignment operator, neither the copy constructor
nor the copy assignment operator will be declared implicitly.</p>
<p>What do these rules mean in practice?</p>
<blockquote>
<p>If you write a class without unmanaged resources, there is no need to
declare any of the five special member functions yourself, and you will get
correct copy semantics and move semantics for free. Otherwise, you will have
to implement the special member functions yourself. Of course, if your class
does not benefit from move semantics, there is no need to implement the
special move operations.</p>
</blockquote>
<p>Note that the copy assignment operator and the move assignment operator can be
fused into a single, unified assignment operator, taking its argument by
value:</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">    </span><span class="c1">// unified assignment operator</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="n">source</span><span class="p">);</span><span class="w">            </span><span class="c1">// see my first answer for an explanation</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>This way, the number of special member functions to implement drops from five
to four. There is a tradeoff between exception-safety and efficiency here, but
I am not an expert on this issue.</p>
<h3>Forwarding references (previously known as <em>Universal references</em> )</h3>
<p>Consider the following function template:</p>
<div class="code"><pre class="code literal-block">template&lt;typename T&gt;
void foo(T&amp;&amp;);
</pre></div>

<p>You might expect <code>T&amp;&amp;</code> to only bind to rvalues, because at first glance, it
looks like an rvalue reference. As it turns out though, <code>T&amp;&amp;</code> also binds to
lvalues:</p>
<div class="code"><pre class="code literal-block">foo(make_triangle());   // T is unique_ptr&lt;Shape&gt;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;&amp;
unique_ptr&lt;Shape&gt; a(new Triangle);
foo(a);                 // T is unique_ptr&lt;Shape&gt;&amp;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;
</pre></div>

<p>If the argument is an rvalue of type <code>X</code>, <code>T</code> is deduced to be <code>X</code>, hence
<code>T&amp;&amp;</code> means <code>X&amp;&amp;</code>. This is what anyone would expect. But if the argument is an
lvalue of type <code>X</code>, due to a special rule, <code>T</code> is deduced to be <code>X&amp;</code>, hence
<code>T&amp;&amp;</code> would mean something like <code>X&amp; &amp;&amp;</code>. But since C++ still has no notion of
references to references, the type <code>X&amp; &amp;&amp;</code> is <em>collapsed</em> into <code>X&amp;</code>. This may
sound confusing and useless at first, but reference collapsing is essential
for <em>perfect forwarding</em> (which will not be discussed here).</p>
<blockquote>
<p>T&amp;&amp; is not an rvalue reference, but a forwarding reference. It also binds to
lvalues, in which case <code>T</code> and <code>T&amp;&amp;</code> are both lvalue references.</p>
</blockquote>
<p>If you want to constrain a function template to rvalues, you can combine
SFINAE with type traits:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kr">void</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>

<h3>Implementation of move</h3>
<p>Now that you understand reference collapsing, here is how <code>std::move</code> is
implemented:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">typename</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">remove_reference</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">type</span><span class="o">&amp;&amp;</span>
<span class="nt">move</span><span class="o">(</span><span class="nt">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">t</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">static_cast&lt;typename</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>As you can see, <code>move</code> accepts any kind of parameter thanks to the forwarding
reference <code>T&amp;&amp;</code>, and it returns an rvalue reference. The
<code>std::remove_reference&lt;T&gt;::type</code> meta-function call is necessary because
otherwise, for lvalues of type <code>X</code>, the return type would be <code>X&amp; &amp;&amp;</code>, which
would collapse into <code>X&amp;</code>. Since <code>t</code> is always an lvalue (remember that a named
rvalue reference is an lvalue), but we want to bind <code>t</code> to an rvalue
reference, we have to explicitly cast <code>t</code> to the correct return type. The call
of a function that returns an rvalue reference is itself an xvalue. Now you
know where xvalues come from ;)</p>
<blockquote>
<p>The call of a function that returns an rvalue reference, such as
<code>std::move</code>, is an xvalue.</p>
</blockquote>
<p>Note that returning by rvalue reference is fine in this example, because <code>t</code>
does not denote an automatic object, but instead an object that was passed in
by the caller.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-does-data-binding-work-in-angularjs/" class="u-url">How does data binding work in AngularJS?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-does-data-binding-work-in-angularjs/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:03:05+08:00" itemprop="datePublished" title="2023-02-16 23:03">2023-02-16 23:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How does data binding work in the <code>AngularJS</code> framework?</p>
<p>I haven't found technical details on their site. It's more or less clear how
it works when data is propagated from view to model. But how does AngularJS
track changes of model properties without setters and getters?</p>
<p>I found that there are JavaScript watchers that may do this work. But they are
not supported in Internet Explorer 6 and Internet Explorer 7. So how does
AngularJS know that I changed for example the following and reflected this
change on a view?</p>
<div class="code"><pre class="code literal-block">myobject.myproperty="new value";
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>AngularJS remembers the value and compares it to a previous value. This is
basic dirty-checking. If there is a change in value, then it fires the change
event.</p>
<p>The <code>$apply()</code> method, which is what you call when you are transitioning from
a non-AngularJS world into an AngularJS world, calls <code>$digest()</code>. A digest is
just plain old dirty-checking. It works on all browsers and is totally
predictable.</p>
<p>To contrast dirty-checking (AngularJS) vs change listeners (KnockoutJS and
Backbone.js): While dirty-checking may seem simple, and even inefficient (I
will address that later), it turns out that it is semantically correct all the
time, while change listeners have lots of weird corner cases and need things
like dependency tracking to make it more semantically correct. KnockoutJS
dependency tracking is a clever feature for a problem which AngularJS does not
have.</p>
<h2>Issues with change listeners:</h2>
<ul>
<li>The syntax is atrocious, since browsers do not support it natively. Yes, there are proxies, but they are not semantically correct in all cases, and of course there are no proxies on old browsers. The bottom line is that dirty-checking allows you to do POJO, whereas KnockoutJS and Backbone.js force you to inherit from their classes, and access your data through accessors.</li>
<li>Change coalescence. Suppose you have an array of items. Say you want to add items into an array, as you are looping to add, each time you add you are firing events on change, which is rendering the UI. This is very bad for performance. What you want is to update the UI only once, at the end. The change events are too fine-grained.</li>
<li>Change listeners fire immediately on a setter, which is a problem, since the change listener can further change data, which fires more change events. This is bad since on your stack you may have several change events happening at once. Suppose you have two arrays which need to be kept in sync for whatever reason. You can only add to one or the other, but each time you add you fire a change event, which now has an inconsistent view of the world. This is a very similar problem to thread locking, which JavaScript avoids since each callback executes exclusively and to completion. Change events break this since setters can have far-reaching consequences which are not intended and non obvious, which creates the thread problem all over again. It turns out that what you want to do is to delay the listener execution, and guarantee, that only one listener runs at a time, hence any code is free to change data, and it knows that no other code runs while it is doing so.</li>
</ul>
<h2>What about performance?</h2>
<p>So it may seem that we are slow, since dirty-checking is inefficient. This is
where we need to look at real numbers rather than just have theoretical
arguments, but first let's define some constraints.</p>
<p>Humans are:</p>
<ul>
<li>
<p><em>Slow</em> — Anything faster than 50 ms is imperceptible to humans and thus can be considered as "instant".</p>
</li>
<li>
<p><em>Limited</em> — You can't really show more than about 2000 pieces of information to a human on a single page. Anything more than that is really bad UI, and humans can't process this anyway.</p>
</li>
</ul>
<p>So the real question is this: How many comparisons can you do on a browser in
50 ms? This is a hard question to answer as many factors come into play, but
here is a test case: http://jsperf.com/angularjs-digest/6 which creates 10,000
watchers. On a modern browser this takes just under 6 ms. On Internet Explorer
8 it takes about 40 ms. As you can see, this is not an issue even on slow
browsers these days. There is a caveat: The comparisons need to be simple to
fit into the time limit... Unfortunately it is way too easy to add a slow
comparison into AngularJS, so it is easy to build slow applications when you
don't know what you are doing. But we hope to have an answer by providing an
instrumentation module, which would show you which are the slow comparisons.</p>
<p>It turns out that video games and GPUs use the dirty-checking approach,
specifically because it is consistent. As long as they get over the monitor
refresh rate (typically 50-60 Hz, or every 16.6-20 ms), any performance over
that is a waste, so you're better off drawing more stuff, than getting FPS
higher.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Misko already gave an excellent description of how the data bindings work, but
I would like to add my view on the performance issue with the data binding.</p>
<p>As Misko stated, around 2000 bindings are where you start to see problems, but
you shouldn't have more than 2000 pieces of information on a page anyway. This
may be true, but not every data-binding is visible to the user. Once you start
building any sort of widget or data grid with two-way binding you can <em>easily</em>
hit 2000 bindings, without having a bad UX.</p>
<p>Consider, for example, a combo box where you can type text to filter the
available options. This sort of control could have ~150 items and still be
highly usable. If it has some extra feature (for example a specific class on
the currently selected option) you start to get 3-5 bindings per option. Put
three of these widgets on a page (e.g. one to select a country, the other to
select a city in the said country, and the third to select a hotel) and you
are somewhere between 1000 and 2000 bindings already.</p>
<p>Or consider a data-grid in a corporate web application. 50 rows per page is
not unreasonable, each of which could have 10-20 columns. If you build this
with ng-repeats, and/or have information in some cells which uses some
bindings, you could be approaching 2000 bindings with this grid alone.</p>
<p>I find this to be a <strong>huge</strong> problem when working with AngularJS, and the only
solution I've been able to find so far is to construct widgets without using
two-way binding, instead of using ngOnce, deregistering watchers and similar
tricks, or construct directives which build the DOM with jQuery and DOM
manipulation. I feel this defeats the purpose of using Angular in the first
place.</p>
<p>I would love to hear suggestions on other ways to handle this, but then maybe
I should write my own question. I wanted to put this in a comment, but it
turned out to be way too long for that...</p>
<p><strong>TL;DR</strong><br>
The data binding can cause performance issues on complex pages.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-150.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-148.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
