<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1436) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1436.html">
<link rel="prev" href="index-1437.html" type="text/html">
<link rel="next" href="index-1435.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-naive-and-semi-naive-evaluation/" class="u-url">What is the difference between naive and semi naive evaluation?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-naive-and-semi-naive-evaluation/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:50:51+08:00" itemprop="datePublished" title="2023-02-28 03:50">2023-02-28 03:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have been trying to implement an algorithm for the semi naive evaluation of
a datalog program but couldn't get a straightforward answer anywhere that
explains the difference in simple words.</p>
<p>According to my understanding naive is a bottom up evaluation technique so is
semi-naive.</p>
<p>In the first iteration both evaluation techniques start with an empty set.</p>
<p>As the iterations proceed further both end up having iterations and producing
tuples until a new tuple is reached.</p>
<p>So the semi-naive starts from head or body of the rule?</p>
<div class="code"><pre class="code literal-block"><span class="nf">path</span> <span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">edge</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>

<span class="nf">path</span> <span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">edge</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Z</span><span class="p">),</span> <span class="nf">path</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>
</pre></div>

<p>Can someone please explain how the EDB and IDB gets updated at the end of each
iteration for the above program. Is the tuples stored under each predicate.
Like a separate column for edge and a separate column for path or they get
stored as a collection.</p>
<p>Also what is the difference between global and local unification?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The difference between the naîve and semi-naîve evaluation in Datalog is that
when you're evaluating using the naïve implementation you take all the initial
dataset (existing EDBs) plus the news ones (inferred EDBs) for each iteration.
For example, if you have the IDBs like this:</p>
<div class="code"><pre class="code literal-block"><span class="nf">reachable</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">link</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>
<span class="nf">reachable</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Y</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">link</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">Z</span><span class="p">),</span> <span class="nf">reachable</span><span class="p">(</span><span class="nv">Z</span><span class="p">,</span><span class="nv">Y</span><span class="p">).</span>
</pre></div>

<p>And a set of EDBs like this: <code>link = {(a,b), (b,c), (c,c), (c,d)}</code> The
procedure to execute the evaluation is:</p>
<ol>
<li>Begin by assuming all IDB relations are empty.</li>
<li>Repeatedly evaluate the rules using the EDB and the previous IDB to get a new IDB.</li>
<li>End when there is no change to IDB.</li>
</ol>
<p>When you're using a naîve approach in every step you'll have the follow data
as input and output:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">Iteration</span><span class="w"> </span><span class="o">|</span><span class="nv">Input</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">current</span><span class="w"> </span><span class="nv">iteration</span><span class="w"> </span><span class="nv">I_</span>{<span class="nv">i</span>}<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">facts</span><span class="w"> </span><span class="nv">inferred</span><span class="w">           </span><span class="o">|</span>
<span class="w"> </span><span class="o">|-----------|-------------------------------------------------|------------------------------|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">1</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{}<span class="w">                                              </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w"> </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">2</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">                    </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">b</span>,<span class="nv">d</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">    </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">3</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">a</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">      </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">                      </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">4</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">a</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">d</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">a</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="o">|</span><span class="w"> </span>{}<span class="w">                           </span><span class="o">|</span>
</pre></div>

<p>At the 4th iteration, you'll stop because the <strong>fixpoint</strong> is reached, and no
new facts could be inferred. However, in the semi-naïve approach, you apply an
optimization, instead of using all derived facts as input to rules at each
iteration, it's possible to send to each iteration only the tuples already
learned in prior iterations, for avoid duplicates tuples.</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">Iteration</span><span class="w"> </span><span class="o">|</span><span class="nv">Input</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">current</span><span class="w"> </span><span class="nv">iteration</span><span class="w"> </span><span class="nv">I_</span>{<span class="nv">i</span>}<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">facts</span><span class="w"> </span><span class="nv">inferred</span><span class="w">           </span><span class="o">|</span>
<span class="w"> </span><span class="o">|-----------|---------------------------------------|------------------------------|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">1</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{}<span class="w">                                    </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w"> </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">2</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">b</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">          </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">b</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">b</span>,<span class="nv">d</span><span class="ss">)</span>,<span class="ss">(</span><span class="nv">c</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">    </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">3</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">c</span><span class="ss">)</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">b</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">                        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">                      </span><span class="o">|</span>
<span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">4</span><span class="w">        </span><span class="o">|</span><span class="w"> </span>{<span class="ss">(</span><span class="nv">a</span>,<span class="nv">d</span><span class="ss">)</span>}<span class="w">                               </span><span class="o">|</span><span class="w"> </span>{}<span class="w">                           </span><span class="o">|</span>
</pre></div>

<p>Source: Datalog and Recursive Query Processing</p>
<p><br></p>
<h3>Suggest</h3>
<p>I am going to tell you about Prolog. I don't know if it applies equally to
Datalog or not, so if I'm wrong, someone will just have to correct me.</p>
<blockquote>
<p>So the semi-naive starts from head or body of the rule?</p>
</blockquote>
<p>According to this handout, you can proceed with a variable-based or a tuple-
based algorithm, but in both cases you start with the body and only after it
succeeds do you add a tuple representing the head:</p>
<blockquote>
<p><strong>Variable-based</strong> : Consider all possible assignments to the variable of
the body. If the assignment makes the body true, add the tuple for the head
to the result.</p>
<p><strong>Tuple-based</strong> : Consider all assignments of tuples from the nonnegated
relational subgoals. If the assignment makes the body true, add the tuple
for the head to the result.</p>
</blockquote>
<p>This jibes well with what I know about Prolog and backward-chaining: you want
to conclude the head, so you must first prove the body.</p>
<p>You seem also to be asking if semi-naive has something to say about whether
you start from the head or the body. Based on what I have reviewed today, it
looks to me like semi-naive is a twist on the naive algorithm rather than a
completely new thing. It's like a tabled version of the naive approach; if
there are multiple naive approaches, you'll have just as many semi-naive
approaches. If there's just one naive, there will be only one semi-naive.</p>
<blockquote>
<p>Can someone please explain how the EDB and IDB gets updated at the end of
each iteration for the above program.</p>
</blockquote>
<p>That's easy: they do not. The EDB is the set of facts in the database. The IDB
is the set of rules in the database. A query is just a query, it doesn't
modify the database. The tuples that the query returns are another matter.</p>
<blockquote>
<p>Are the tuples stored under each predicate?</p>
</blockquote>
<p>The tuples that represent facts in the EDB are already stored in the EDB as
facts. The tuples derived from the rules in the IDB are computed and become
part of the result set and are not stored. In neither case is the store
updated as a result of performing a query.</p>
<p>If we were talking about Prolog here, there would be this stack of recursive
invocations going on. The outermost call might say <code>path(a, z)</code>; inside that
call might be something like <code>edge(a, b), path(b, z)</code>, which will beget a call
<code>edge(b, c), path(c, z)</code>. In Prolog terms, each time you enter another
invocation you wind up with a fresh set of variables, some bound, some yet-to-
be-bound. In your Datalog world, it seems to me that <code>edge(a,b)</code> and
<code>edge(b,c)</code> already exist as tuples in your EDB. During the query they will be
part of the tuples in the stack of tuples that represents your result. The IDB
contained a rule called <code>path/2</code>, and once you satisfy the recursive call, you
will wind up with some new tuples like <code>path(a,z)</code> in your result. But that
result tuple is not a fact stored in your EDB (which only contains facts like
<code>edge/2</code>) nor is it going to replace the rule <code>path/2</code>. It's just part of the
result of your query.</p>
<blockquote>
<p>Also what is the difference between global and local unification?</p>
</blockquote>
<p>I wasn't able to find anything using those terms and I can't imagine what they
would mean.</p>
<p>So, there's my guess. Let's see how wide of the mark I am.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/module-jdk-compiler-does-not-opens-com-sun-tools-javac-processing-to-unnamed-module-4bae33a6/" class="u-url">module jdk.compiler does not "opens com.sun.tools.javac.processing" to unnamed module @4bae33a6</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/module-jdk-compiler-does-not-opens-com-sun-tools-javac-processing-to-unnamed-module-4bae33a6/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:50:30+08:00" itemprop="datePublished" title="2023-02-28 03:50">2023-02-28 03:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I cloned this Project from Github</p>
<p>https://github.com/PacktPublishing/Java-Machine-Learning-for-Computer-
Vision.git</p>
<p>I am going to use the FaceRecognizition from this project. But as soon as I
try to run this in IntelliJ I get this error</p>
<p>java: java.lang.ExceptionInInitializerError Unable to make field private
com.sun.tools.javac.processing.JavacProcessingEnvironment$DiscoveredProcessors
com.sun.tools.javac.processing.JavacProcessingEnvironment.discoveredProcs
accessible: module jdk.compiler does not "opens
com.sun.tools.javac.processing" to unnamed module @4bae33a6</p>
<p>What can I do?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I had same issue first check what Java version is used by maven by using</p>
<blockquote>
<p>mvn -v</p>
</blockquote>
<p>if it is set to Jdk 16 then you will have to update file below</p>
<blockquote>
<p>/usr/local/Cellar/maven/{version}/bin/mvn</p>
</blockquote>
<p>and set</p>
<blockquote>
<p>JAVA_HOME:-$(/usr/libexec/java_home)</p>
</blockquote>
<p>then you can confirm by running mvn -v again</p>
<p>Above steps have resolved the issue for me</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ai-fastest-algorithm-to-find-if-path-exists/" class="u-url">AI: Fastest algorithm to find if path exists?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ai-fastest-algorithm-to-find-if-path-exists/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:50:09+08:00" itemprop="datePublished" title="2023-02-28 03:50">2023-02-28 03:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am looking for a pathfinding algorithm to use for an AI controlling an
entity in a 2D grid that needs to find a path from A to B. It does not have to
be the shortest path but it needs to be calculated very fast. The grid is
static (never changes) and some grid cells are occupied by obstacles.</p>
<p>I'm currently using A<em> but it is too slow for my purposes because it always
tries to calculate the fastest path. The main performance problem occurs when
the path does not exist, in which case A</em> will try to explore too many cells.</p>
<p>Is there a different algorithm I could use that could find a path faster than
A* if the path doesn't have to be the shortest path?</p>
<p>Thanks,</p>
<p>Luminal</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Assuming your grid is static and doesn't change. You can calculate the
connected components of your graph once after building the grid.</p>
<p>Then you can easily check if source and target vertex are within a component
or not. If yes, then execute A*, if not then don't as there can't be a path
between the components.</p>
<p>You can get the connected components of a graph using BFS or DFS.</p>
<p><br></p>
<h3>Suggest</h3>
<p>To find <em>a</em> path instead of the shortest path, use any graph traversal (e.g.
depth-first or best-first). It won't necessarily be faster, in fact it may
check many more nodes than A* on some graphs, so it depends on your data.
However, it will be easier to implement and the constant factors will be
significantly lower.</p>
<p>To avoid search for a path when there is none, you could create disjoint sets
(once after you built the graph) to <em>very</em> quickly check whether two given
points are connected. This takes linear space and linear time to build, and
lookup takes amortized practically-constant time, but you still need to run
your full algorithm at times, as it will only tell you <em>whether</em> there is a
path, not where that path goes.</p>
<p>If you're already building data structures beforehand, and have a bit more
time and space to trade for <em>instant shortest paths</em> at run-time, you can have
your cake and eat it too: The Floyd-Warshall algorithm gives you <em>all</em>
shortest paths in comparatively modest <code>O(|V|^3)</code> time, which is the most bang
for the buck considering there are |V|² (start, destination) pairs. It
computes a <code>|V| * |V|</code> matrix, which could be a bit large, but consider that
this is an integer matrix and you only need <code>|V| * |V| * log_2 |V|</code> bits (for
example, that's 1.25 MiB for 1024 vertices).</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1437.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1435.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
