<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1436) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1436.html">
<link rel="prev" href="index-1437.html" type="text/html">
<link rel="next" href="index-1435.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-is-manhattan-distance-an-admissible-heuristic/" class="u-url">How is Manhattan distance an admissible heuristic?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-is-manhattan-distance-an-admissible-heuristic/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:47:44+08:00" itemprop="datePublished" title="2023-02-28 03:47">2023-02-28 03:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Ain't it true that while counting the moves for 1 tile can lead to other tiles
getting to their goal state? And hence counting for each tile can give us a
count more than the minimum moves required to reach the goal state?</p>
<p>This question is in context of Manhattan distance for 15-Puzzle.</p>
<p>Here is the Question in different words:</p>
<p>Can we use Manhattan distance as an admissible heuristic for N-Puzzle. To
implement A* search we need an admissible heuristic. Is Manhattan heuristic a
candidate? If yes, how do you counter the above argument (the first 3
sentences in the question)?</p>
<p>Definitions: A* is a kind of search algorithm. It uses a heuristic function to
determine the estimated distance to the goal. As long as this heuristic
function never overestimates the distance to the goal, the algorithm will find
the shortest path, probably faster than breadth-first search would. A
heuristic that satisfies that condition is <em>admissible</em>.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Admissable heuristics must not overestimate the number of moves to solve this
problem. Since you can only move the blocks 1 at a time and in only one of 4
directions, the optimal scenario for each block is that it has a clear,
unobstructed path to its goal state. This is a M.D. of 1.</p>
<p>The rest of the states for a pair of blocks is sub-optimal, meaning it <em>will</em>
take more moves than the M.D. to get the block in the right place. Thus, the
heuristic never over-estimate and is admissible.</p>
<p>I will delete when someone posts a correct, formal version of this.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Formal Proof: By definition of h, h(s∗) = 0, if s∗ is the goal state. Assume
for proof by contradiction that C∗ &lt; h(s0) for some initial state s0. Note
that, since each action can move only one tile, performing an action can at
most reduce h by one. Since the goal can be reached in C∗ actions, we have
h(s∗) ≥ h(s0) − C∗ &gt; 0, which brings us to a contradiction since h(s∗) should
be zero. Therefore, we must have h(s0) ≤ C∗ forall s0, and h is admissible. (
<strong>Source</strong> : University of California, Irvine)</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/alternatives-to-the-turing-test/" class="u-url">Alternatives to the Turing Test</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/alternatives-to-the-turing-test/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:47:23+08:00" itemprop="datePublished" title="2023-02-28 03:47">2023-02-28 03:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>So we learned a bit about the Turing Test in my AI class. This got me thinking
about it. I can see a few limitations with it:</p>
<ol>
<li>It's limited to a certain context. What if I'm not designing an AI to converse with humans?</li>
<li>It favors acting humanly over acting rationally. For example, if I'm designing an AI to control nuclear missiles, do I <em>really</em> want it to act human? Granted, this is an extreme example, but you get the idea.</li>
<li>It could be influenced by factors that don't indicate that the computer can think humanly. For example, suppose I ask what 2334 * 321 is. I could tell if the device is a computer because it will probably answer me fairly quickly while a human would have to figure it out. The solution? Make the computer pause.</li>
</ol>
<p>Now, I'm sure that the Turing Test still has its place in determining machine
intelligence. But I see it as being fairly limited in scope. Are there any
alternatives? For that matter, am I wrong as to what I perceive to be its
limitations?</p>
<p><strong>EDIT</strong> : Let me be clear: I'm not suggesting that the Turing Test should be
abandoned. I'm just curious if there are any other tests that overcome its
limitations (probably trading them for other limitations).</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Tell you what: before we answer your question, define "intelligence".</p>
<p>The Turing Test, as originally described, had some other problems too, the
most notable of them being that it's not "effective", which is to say there is
no way to tell when it's over.</p>
<p>Now, look at your (quite reasonable) objections: on one hand, if it gives the
right answer too quickly, it would make you suspicious; on the other, you're
not sure it would be good if it gives wrong answers, even if it would make you
think it might be "intelligent."</p>
<p>But, now, consider our interaction: you don't know that I'm <em>not</em> an
intelligent computer. How about, for a Star Trek reference, Mr Data on ST:TNG?
He's certainly distinguishable from a human and doesn't give human responses
at all times, but mostly passes.</p>
<p>Now, let's for a moment consider a person you meet who, instead of being
intelligent, is completely a mechanism: no "consciousness", no "soul." (This
kind of entity is called a "philosophical zombie" in the literature.) <em>Except</em>
for that missing "consciousness", this person, or simulacrum of a person, acts
like a person in all other ways: expresses pain on an injury, shows pleasure
when eating a good meal, shows affection to kittens <del>and small children</del>.
(Corrected because I want to pass this test myself.)</p>
<p>How could you tell that this philosophical zombie <em>wasn't</em> "intelligent" ?</p>
<p>The point here is that you've got good questions, but there aren't necessarily
well-accepted answers. My own opinion of the Turing Test is that it's a good
valid test, because the point of it, as Turing himself said, is that if you
can't tell the difference between an intelligent or sentient computer, and a
<em>really</em> intelligent entity, then you have to assume there is no difference.</p>
<p>Some other things you could read:</p>
<ul>
<li>Read about John Searle's "Chinese Room"</li>
<li>Read Doug Hofstadter's "Gödel Escher Bach: An Eternal Golden Braid"</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>I think you are missing the point of the Turing Test. It's not meant to be a
judge of the quality of an AI algorithm, but rather the success of an AI
algorithm meant to simulate human intelligence. In that sense it is really
more a test of the state of the art in AI rather than any particular AI
algorithm. That is, if we can design an AI algorithm to pass this test, then
we can say that we are able with AI to develop machines with human
intelligence.</p>
<p>It's reasonable to assume that there are other tests that would be equally
sufficient, but this test is elegant in its simplicity and relative lack of
constraints. There are basically no constraints on the inputs except their
format.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-best-data-structure-to-represent-a-checkers-board-when-speed-is-the-primary-concern/" class="u-url">What is the best data-structure to represent a checkers board when speed is the primary concern?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-best-data-structure-to-represent-a-checkers-board-when-speed-is-the-primary-concern/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:47:02+08:00" itemprop="datePublished" title="2023-02-28 03:47">2023-02-28 03:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am currently implementing something quite similar to checkers. So, I have
this table game and there are both white and black pieces. Where there are
neither white or black pieces, you dno't have pieces.</p>
<p>I'm currently doing the <code>GetValidMoves()</code> method that'll return all the
current moves one can do with the current board.</p>
<p>I am thus wondering what might be the best way to represent the board. The
naive approach would be to have a matrix with 0's 1's and 2's (for no piece,
white piece and black piece).</p>
<p>Other idea would be to instead of a matrix representation of the board, have 2
lists(or any other data-structure): one for black pieces, other for white.</p>
<p>I am implementing this game to test some AI algorithms, so my main concern is
speed. I will basically put 2 AI players playing each other, for each turn
each player should have a list of all his valid moves and then he'll choose
what move to do, this always happening until the game ends(some player wins or
there's a tie).</p>
<p>PS: I am not asking about the AI algorithm, I just want to know what would be
the best data-structure to handle the board, so that it makes it easy to</p>
<ol>
<li>Look for all the valid moves for the current player</li>
<li>Do a move</li>
<li>Verify the game is not over (it is over when one player lost all his pieces or one player reached the other side of the board).</li>
</ol>
<p><br><br></p>
<h2>Answer</h2>
<p>Consider using a bitmap: two 64-bit unsigned ints, one for white and one for
black. Then you can represent moves and board positions as a function from <code>(W
x B) -&gt; (W x B)</code> where <em>W</em> , <em>B</em> represent the set of possible white and
possible black positions respectively.</p>
<p>Then most of the board position stuff can be done with integer arithmetic,
which is about as fast as you can get.</p>
<p><br></p>
<h3>Suggest</h3>
<p>A common way of doing that is with a <code>long</code> type's binary representation for
each player.<br>
(since there are 64 squares on the board).. As <strong>Charlie</strong> already said..<br>
Here's a very good (but reather general) wiki article.</p>
<p>The usage is simple - for example, if you want to check if all pieces can move
say up and right, shift the player's pieces represntation 7 bits to the left,
and check if there are opponent pieces there, then shift them 7 bits left
again, and check if those squares are clear...<br>
I used it in a Reversi competition once, and can say the implementation wasn't
too hard.<br>
HTH.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1437.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1435.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
