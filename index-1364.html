<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1364) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1364.html">
<link rel="prev" href="index-1365.html" type="text/html">
<link rel="next" href="index-1363.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/forward-chaining-vs-backward-chaining/" class="u-url">Forward Chaining vs Backward Chaining</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/forward-chaining-vs-backward-chaining/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:30:11+08:00" itemprop="datePublished" title="2023-02-28 02:30">2023-02-28 02:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What is one good for that the other's not in practice? I understand the theory
of what they do, but what are their limitations and capabilities in practical
use? I'm considering Drools vs a java prolog for a new AI project, but open to
other suggestions. What are some popular approaches for inferencing on a
complicated relational data set or alternatives?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Backward chaining (a la Prolog) is more like finding what initial conditions
form a path to your goal. At a very basic level it is a backward search from
your goal to find conditions that will fulfil it.</p>
<p>Backward chaining is used for interrogative applications (finding items that
fulfil certain criteria) - one commercial example of a backward chaining
application might be finding which insurance policies are covered by a
particular reinsurance contract.</p>
<p>Forward chaining (a la CLIPS) matches conditions and then generates inferences
from those conditions. These conditions can in turn match other rules.
Basically, this takes a set of initial conditions and then draws all
inferences it can from those conditions.</p>
<p>The inferences (if asserted) can also be actions or events that can trigger
external actions. This is useful in event driven systems, as the rule sets can
be configured to (for example) initiate a workflow or some other action. This
type of rule engine is the most commonly used in commercial applications.</p>
<p>Event driven systems are a common application of forward chaining rule
engines. One example of a forward chaining application might be a telecoms
plan provisioning engine (typically used for administering mobile phone
plans). Entering a particular user with a particular plan will trigger a range
of items to be set up in various phone switches, billing systems, financials,
CRM systems etc.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Concerned's answer is very good. When asked to boil the difference down to a
sound bite, I usually say something like:</p>
<p>Lots of Output Hypotheses + Lots of Data Up Front =&gt; Use Forward Chaining</p>
<p>Fewer Output Hypotheses + Must Query for Data =&gt; Use Backward Chaining</p>
<p>But it's just a rule of thumb, not a commandment.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/tracing-and-returning-a-path-in-depth-first-search/" class="u-url">Tracing and Returning a Path in Depth First Search</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/tracing-and-returning-a-path-in-depth-first-search/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:29:50+08:00" itemprop="datePublished" title="2023-02-28 02:29">2023-02-28 02:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>So I have a problem that I want to use depth first search to solve, returning
the first path that DFS finds. Here is my (incomplete) DFS function:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nv">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">problem</span>.<span class="nv">getStartState</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Stack</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">visited</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[]
<span class="w">    </span><span class="nv">stack</span>.<span class="nv">push</span><span class="ss">(</span><span class="nv">start</span><span class="ss">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nv">problem</span>.<span class="nv">isGoalState</span><span class="ss">(</span><span class="nv">problem</span>.<span class="nv">getStartState</span><span class="ss">)</span>:
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">something</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nv">stack</span>:
<span class="w">        </span><span class="nv">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">stack</span>.<span class="nv">pop</span><span class="ss">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">visited</span>:<span class="w"> </span><span class="k">continue</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">problem</span>.<span class="nv">isGoalState</span><span class="ss">(</span><span class="nv">parent</span><span class="ss">)</span>:
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nv">something</span>
<span class="w">        </span><span class="nv">visited</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">parent</span><span class="ss">)</span>
<span class="w">        </span><span class="nv">children</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">problem</span>.<span class="nv">getSuccessors</span><span class="ss">(</span><span class="nv">parent</span><span class="ss">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">children</span>:
<span class="w">            </span><span class="nv">stack</span>.<span class="nv">push</span><span class="ss">(</span><span class="nv">child</span>[<span class="mi">0</span>]<span class="ss">)</span>
</pre></div>

<p>The startState and goalState variables are simply a tuple of x, y coordinates.
problem is a class with a variety of methods. The important ones here are
getSuccessors (which returns the children of a given state in the form of a
list of 3 item tuples. for this part of the problem though, only the first
element of the tuple, (child[0]), which returns the state of the child in x, y
coordinates, is important) and isGoalState (which provides the x, y
coordinates of the goal state).</p>
<p>So I THINK (difficult to test at this point), that this function, given proper
implementation of everything else, will return once it has reached a goal
state. Please let me know if I am missing something. My biggest issue, though,
is WHAT to return. I want it to output a list of all of the states it takes to
get to the goal state, in order from the beginning to the end. It doesn't seem
like simply returning my stack will do the trick, since the stack will include
many unvisited children. Nor will my visited list yield anything useful, since
it is conceivable I could reach dead ends, have to backtrack, but still have
the dead-end tuples in the visited list. How would I go about getting the list
I desire?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You are right - you cannot simply return the stack, it indeed contains a lot
of unvisited nodes.</p>
<p>However, by maintaining a map (dictionary): <code>map:Vertex-&gt;Vertex</code> such that
<code>parentMap[v] = the vertex we used to discover v</code>, you can get your path.</p>
<p>The modification you will need to do is pretty much in the for loop:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">children</span><span class="p">:</span>
<span class="w">        </span><span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">parentMap</span><span class="o">[</span><span class="n">child</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="n">#this</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">added</span>
</pre></div>

<p>Later on, when you found your target, you can get the path from the source to
the target (pseudo code):</p>
<div class="code"><pre class="code literal-block"><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">curr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">None</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="k">print</span><span class="w"> </span><span class="n">curr</span>
<span class="w">  </span><span class="n">curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parentMap</span><span class="o">[</span><span class="n">curr</span><span class="o">]</span>
</pre></div>

<p>Note that the order will be reversed, it can be solved by pushing all elements
to a stack and then print.</p>
<p>I once answered a similar (though not identical IMO) question regarding
finding the actual path in BFS in this thread</p>
<p>Another solution is to use a recursive version of DFS rather then
iterative+stack, and once a target is found, print all <code>current</code> nodes in the
recursion back up - but this solution requires a redesign of the algorithm to
a recursive one.</p>
<hr>
<p>P.S. Note that DFS might fail to find a path to the target (even if
maintaining a <code>visited</code> set) if the graph contains an infinite branch.<br>
If you want a complete (always finds a solution if one exists) and optimal
(finds shortest path) algorithm - you might want to use BFS or Iterative
Deepening DFS or even A* Algorithm if you have some heuristic function</p>
<p><br></p>
<h3>Suggest</h3>
<p>Not specific to your problem, but you can tweak this code and apply it to
different scenarios, in fact, you can make the stack also hold the path.</p>
<p>Example:</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">A</span>
<span class="w">   </span><span class="o">/</span><span class="w">    </span><span class="err">\</span>
<span class="w">  </span><span class="n">C</span><span class="w">      </span><span class="n">B</span>
<span class="w">  </span><span class="err">\</span><span class="w">     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span>
<span class="w">   </span><span class="err">\</span><span class="w">    </span><span class="n">D</span><span class="w"> </span><span class="n">E</span>
<span class="w">    </span><span class="err">\</span><span class="w">    </span><span class="o">/</span>
<span class="w">       </span><span class="n">F</span>




<span class="n">graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="s1">'A'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'B', 'C'</span><span class="o">]</span><span class="p">),</span>
<span class="w">         </span><span class="s1">'B'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'A', 'D', 'E'</span><span class="o">]</span><span class="p">),</span>
<span class="w">         </span><span class="s1">'C'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'A', 'F'</span><span class="o">]</span><span class="p">),</span>
<span class="w">         </span><span class="s1">'D'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'B'</span><span class="o">]</span><span class="p">),</span>
<span class="w">         </span><span class="s1">'E'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'B', 'F'</span><span class="o">]</span><span class="p">),</span>
<span class="w">         </span><span class="s1">'F'</span><span class="err">:</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="o">[</span><span class="n">'C', 'E'</span><span class="o">]</span><span class="p">)</span><span class="err">}</span>

<span class="n">def</span><span class="w"> </span><span class="n">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="k">start</span><span class="p">,</span><span class="w"> </span><span class="n">goal</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">(start, [start</span><span class="o">]</span><span class="p">)</span><span class="err">]</span>
<span class="w">    </span><span class="n">visited</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">set</span><span class="p">()</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nl">stack</span><span class="p">:</span>
<span class="w">        </span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span><span class="w"> </span><span class="k">path</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">visited</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nl">goal</span><span class="p">:</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">path</span>
<span class="w">            </span><span class="n">visited</span><span class="p">.</span><span class="k">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">neighbor</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">graph</span><span class="o">[</span><span class="n">vertex</span><span class="o">]</span><span class="err">:</span>
<span class="w">                </span><span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span><span class="w"> </span><span class="k">path</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span><span class="p">))</span>

<span class="k">print</span><span class="w"> </span><span class="p">(</span><span class="n">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="s1">'A'</span><span class="p">,</span><span class="w"> </span><span class="s1">'F'</span><span class="p">))</span><span class="w">   </span><span class="err">#</span><span class="o">[</span><span class="n">'A', 'B', 'E', 'F'</span><span class="o">]</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/iterative-deepening-vs-depth-first-search/" class="u-url">Iterative deepening vs depth-first search</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/iterative-deepening-vs-depth-first-search/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:29:26+08:00" itemprop="datePublished" title="2023-02-28 02:29">2023-02-28 02:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I keep reading about <em>iterative deepening</em> , but I don't understand how it
differs from <em>depth-first search</em>.</p>
<p>I understood that depth-first search keeps going deeper and deeper.</p>
<p>In iterative deepening you establish a value of a level, if there is no
solution at that level, you increment that value, and start again from scratch
(the root).</p>
<p><strong>Wouldn't this be the same thing as depth-first search?</strong></p>
<p>I mean you would keep incrementing and incrementing, going deeper until you
find a solution. I see this as the same thing! I would be going down the same
branch, because if I start again from scratch I would go down the same branch
as before.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>In a depth-first search, you begin at some node in the graph and continuously
explore deeper and deeper into the graph while you can find new nodes that you
haven't yet reached (or until you find the solution). Any time the DFS runs
out of moves, it backtracks to the latest point where it could make a
different choice, then explores out from there. This can be a serious problem
if your graph is extremely large and there's only one solution, since you
might end up exploring the entire graph along one DFS path only to find the
solution after looking at each node. Worse, if the graph is infinite (perhaps
your graph consists of all the numbers, for example), the search might not
terminate. Moreover, once you find the node you're looking for, you might not
have the optimal path to it (you could have looped all over the graph looking
for the solution even though it was right next to the start node!)</p>
<p>One potential fix to this problem would be to limit the depth of any one path
taken by the DFS. For example, we might do a DFS search, but stop the search
if we ever take a path of length greater than 5. This ensures that we never
explore any node that's of distance greater than five from the start node,
meaning that we never explore out infinitely or (unless the graph is extremely
dense) we don't search the entire graph. However, this does mean that we might
not find the node we're looking for, since we don't necessarily explore the
entire graph.</p>
<p>The idea behind iterative deepening is to use this second approach but to keep
increasing the depth at each level. In other words, we might try exploring
using all paths of length one, then all paths of length two, then length
three, etc. until we end up finding the node in question. This means that we
never end up exploring along infinite dead-end paths, since the length of each
path is capped by some length at each step. It also means that we find the
shortest possible path to the destination node, since if we didn't find the
node at depth d but did find it at depth d + 1, there can't be a path of
length d (or we would have taken it), so the path of length d + 1 is indeed
optimal.</p>
<p>The reason that this is different from a DFS is that it never runs into the
case where it takes an extremely long and circuitous path around the graph
without ever terminating. The lengths of the paths are always capped, so we
never end up exploring unnecessary branches.</p>
<p>The reason that this is different from BFS is that in a BFS, you have to hold
all of the fringe nodes in memory at once. This takes memory O(bd), where b is
the branching factor. Compare this to the O(d) memory usage from iterative
deepening (to hold the state for each of the d nodes in the current path). Of
course, BFS never explores the same path multiple times, while iterative
deepening may explore any path several times as it increases the depth limit.
However, asymptotically the two have the same runtime. BFS terminates in O(bd)
steps after considering all O(bd) nodes at distance d. Iterative deepening
uses O(bd) time per level, which sums up to O(bd) overall, but with a higher
constant factor.</p>
<p>In short:</p>
<ul>
<li>DFS is not guaranteed to find an optimal path; iterative deepening is.</li>
<li>DFS may explore the entire graph before finding the target node; iterative deepening only does this if the distance between the start and end node is the maximum in the graph.</li>
<li>BFS and iterative deepening both run in time O(bd), but iterative deepening likely has a higher constant factor.</li>
<li>BFS uses O(bd) memory, while iterative deepening uses only O(d).</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>There is a decent page on wikipedia about this.</p>
<p>The basic idea I think you missed is that iterative deepening is primarily a
<em>heuristic</em>. When a solution is likely to be found close to the root iterative
deepening is will find it relatively fast while straightfoward depth-first-
search could make a "wrong" decision and spend a lot of time on a fruitless
deep branch.</p>
<p>(This is particularly important when the search tree can be infinite. <strong>In
this case they are even less equivalent</strong> since DFS can get stuck forever
while BFS or iterative deepening are sure to find the answer one day if it
exists)</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1365.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1363.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
