<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2138) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2138.html">
<link rel="prev" href="index-2139.html" type="text/html">
<link rel="next" href="index-2137.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/callback-functions-in-c/" class="u-url">Callback functions in C++</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/callback-functions-in-c/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:50:31+08:00" itemprop="datePublished" title="2023-03-03 17:50">2023-03-03 17:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In C++, when and how do you use a callback function?</p>
<p><strong>EDIT:</strong><br>
I would like to see a simple example to write a callback function.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><em>Note: Most of the answers cover function pointers which is one possibility to
achieve "callback" logic in C++, but as of today not the most favourable one I
think.</em></p>
<h2>What are callbacks(?) and why to use them(!)</h2>
<p>A callback is a <em>callable</em> (see further down) accepted by a class or function,
used to customize the current logic depending on that callback.</p>
<p>One reason to use callbacks is to write <strong>generic</strong> code which is independant
from the logic in the called function and can be reused with different
callbacks.</p>
<p>Many functions of the standard algorithms library <code>&lt;algorithm&gt;</code> use callbacks.
For example the <code>for_each</code> algorithm applies an unary callback to every item
in a range of iterators:</p>
<div class="code"><pre class="code literal-block"><span class="nv">template</span><span class="o">&lt;</span><span class="nv">class</span><span class="w"> </span><span class="nv">InputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">UnaryFunction</span><span class="o">&gt;</span>
<span class="nv">UnaryFunction</span><span class="w"> </span><span class="nv">for_each</span><span class="ss">(</span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">first</span>,<span class="w"> </span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">last</span>,<span class="w"> </span><span class="nv">UnaryFunction</span><span class="w"> </span><span class="nv">f</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="c1">; first != last; ++first) {</span>
<span class="w">    </span><span class="nv">f</span><span class="ss">(</span><span class="o">*</span><span class="nv">first</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span>}
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">f</span><span class="c1">;</span>
}
</pre></div>

<p>which can be used to first increment and then print a vector by passing
appropriate callables for example:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">vector</span><span class="o">&lt;</span><span class="nt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">v</span><span class="p">{</span><span class="w"> </span><span class="err">1.0,</span><span class="w"> </span><span class="err">2.2,</span><span class="w"> </span><span class="err">4.0,</span><span class="w"> </span><span class="err">5.5,</span><span class="w"> </span><span class="err">7.2</span><span class="w"> </span><span class="p">}</span><span class="o">;</span>
<span class="nt">double</span><span class="w"> </span><span class="nt">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">4</span><span class="p">.</span><span class="nc">0</span><span class="o">;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">for_each</span><span class="o">(</span><span class="nt">v</span><span class="p">.</span><span class="nc">begin</span><span class="o">(),</span><span class="w"> </span><span class="nt">v</span><span class="p">.</span><span class="nc">end</span><span class="o">(),</span><span class="w"> </span><span class="cp">[</span><span class="o">&amp;</span><span class="cp">]</span><span class="o">(</span><span class="nt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nt">v</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">v</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">r</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">for_each</span><span class="o">(</span><span class="nt">v</span><span class="p">.</span><span class="nc">begin</span><span class="o">(),</span><span class="w"> </span><span class="nt">v</span><span class="p">.</span><span class="nc">end</span><span class="o">(),</span><span class="w"> </span><span class="cp">[]</span><span class="o">(</span><span class="nt">double</span><span class="w"> </span><span class="nt">v</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">" "</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
</pre></div>

<p>which prints</p>
<div class="code"><pre class="code literal-block"><span class="mf">5</span><span class="w"> </span><span class="mf">6.2</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="mf">9.5</span><span class="w"> </span><span class="mf">11.2</span>
</pre></div>

<p>Another application of callbacks is the notification of callers of certain
events which enables a certain amount of static / compile time flexibility.</p>
<p>Personally, I use a local optimization library that uses two different
callbacks:</p>
<ul>
<li>The first callback is called if a function value and the gradient based on a vector of input values is required (logic callback: function value determination / gradient derivation).</li>
<li>The second callback is called once for each algorithm step and receives certain information about the convergence of the algorithm (notification callback).</li>
</ul>
<p>Thus, the library designer is not in charge of deciding what happens with the
information that is given to the programmer via the notification callback and
he needn't worry about how to actually determine function values because
they're provided by the logic callback. Getting those things right is a task
due to the library user and keeps the library slim and more generic.</p>
<p>Furthermore, callbacks can enable dynamic runtime behaviour.</p>
<p>Imagine some kind of game engine class which has a function that is fired,
each time the users presses a button on his keyboard and a set of functions
that control your game behaviour. With callbacks you can (re)decide at runtime
which action will be taken.</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">player_jump</span><span class="p">();</span>
<span class="n">void</span><span class="w"> </span><span class="n">player_crouch</span><span class="p">();</span>

<span class="k">class</span><span class="w"> </span><span class="n">game_core</span>
<span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">array</span><span class="o">&lt;</span><span class="n">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(),</span><span class="w"> </span><span class="n">total_num_keys</span><span class="o">&gt;</span><span class="w"> </span><span class="n">actions</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span>
<span class="w">    </span><span class="n">void</span><span class="w"> </span><span class="n">key_pressed</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">key_id</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="p">();</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="n">keybind</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">menu</span>
<span class="w">    </span><span class="n">void</span><span class="w"> </span><span class="n">update_keybind</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">key_id</span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="p">(</span><span class="o">*</span><span class="n">new_action</span><span class="p">)())</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_action</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span><span class="p">;</span>
</pre></div>

<p>Here the function <code>key_pressed</code> uses the callbacks stored in <code>actions</code> to
obtain the desired behaviour when a certain key is pressed. If the player
chooses to change the button for jumping, the engine can call</p>
<div class="code"><pre class="code literal-block">game_core_instance.update_keybind(newly_selected_key, &amp;player_jump);
</pre></div>

<p>and thus change the behaviour of a call to <code>key_pressed</code> (which the calls
<code>player_jump</code>) once this button is pressed the next time ingame.</p>
<h2>What are <em>callables</em> in C++(11)?</h2>
<p>See C++ concepts: Callable on cppreference for a more formal description.</p>
<p>Callback functionality can be realized in several ways in C++(11) since
several different things turn out to be <strong>callable</strong>* :</p>
<ul>
<li>Function pointers (including pointers to member functions)</li>
<li>
<code>std::function</code> objects</li>
<li>Lambda expressions</li>
<li>Bind expressions</li>
<li>
<p>Function objects (classes with overloaded function call operator <code>operator()</code>)</p>
</li>
<li>
<p><em>Note: Pointer to data members are callable as well but no function is called at all.</em></p>
</li>
</ul>
<h2>Several important ways to write <em>callbacks</em> in detail</h2>
<ul>
<li>X.1 "Writing" a callback in this post means the syntax to declare and name the callback type.</li>
<li>X.2 "Calling" a callback refers to the syntax to call those objects.</li>
<li>X.3 "Using" a callback means the syntax when passing arguments to a function using a callback.</li>
</ul>
<p><em>Note: As of C++17, a call like<code>f(...)</code> can be written as <code>std::invoke(f,
...)</code> which also handles the pointer to member case.</em></p>
<h3>1. Function pointers</h3>
<p>A function pointer is the 'simplest' (in terms of generality; in terms of
readability arguably the worst) type a callback can have.</p>
<p>Let's have a simple function <code>foo</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="nv">x</span><span class="c1">; }</span>
</pre></div>

<h4>1.1 Writing a function pointer / type notation</h4>
<p>A <strong>function pointer type</strong> has the notation</p>
<div class="code"><pre class="code literal-block">return_type (*)(parameter_type_1, parameter_type_2, parameter_type_3)
// i.e. a pointer to foo has the type:
int (*)(int)
</pre></div>

<p>where a <strong>named function pointer</strong> type will look like</p>
<div class="code"><pre class="code literal-block"><span class="nt">return_type</span><span class="w"> </span><span class="o">(*</span><span class="w"> </span><span class="nt">name</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nt">parameter_type_1</span><span class="o">,</span><span class="w"> </span><span class="nt">parameter_type_2</span><span class="o">,</span><span class="w"> </span><span class="nt">parameter_type_3</span><span class="o">)</span>

<span class="o">//</span><span class="w"> </span><span class="nt">i</span><span class="p">.</span><span class="nc">e</span><span class="o">.</span><span class="w"> </span><span class="nt">f_int_t</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">type</span><span class="o">:</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">one</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">argument</span><span class="o">,</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">typedef</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="o">(*</span><span class="nt">f_int_t</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="o">);</span>

<span class="o">//</span><span class="w"> </span><span class="nt">foo_p</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="o">//</span><span class="w"> </span><span class="nt">initialized</span><span class="w"> </span><span class="nt">by</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">foo</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">int</span><span class="w"> </span><span class="o">(*</span><span class="w"> </span><span class="nt">foo_p</span><span class="o">)(</span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">foo</span><span class="o">;</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="nt">can</span><span class="w"> </span><span class="nt">alternatively</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">written</span><span class="w"> </span><span class="nt">as</span><span class="w"> </span>
<span class="nt">f_int_t</span><span class="w"> </span><span class="nt">foo_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">foo</span><span class="o">;</span>
</pre></div>

<p>The <code>using</code> declaration gives us the option to make things a little bit more
readable, since the <code>typedef</code> for <code>f_int_t</code> can also be written as:</p>
<div class="code"><pre class="code literal-block">using f_int_t = int(*)(int);
</pre></div>

<p>Where (at least for me) it is clearer that <code>f_int_t</code> is the new type alias and
recognition of the function pointer type is also easier</p>
<p>And a declaration of a <strong>function using a callback of function pointer type</strong>
will be:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// foobar having a callback argument named moo of type </span>
<span class="c1">// pointer to function returning int taking int as its argument</span>
<span class="nb">int</span><span class="w"> </span><span class="n">foobar</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb">int</span><span class="p">));</span>
<span class="c1">// if f_int is the function pointer typedef from above we can also write foobar as:</span>
<span class="nb">int</span><span class="w"> </span><span class="n">foobar</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">f_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">);</span>
</pre></div>

<h4>1.2 Callback call notation</h4>
<p>The call notation follows the simple function call syntax:</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">foobar</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="ss">(</span><span class="o">*</span><span class="nv">moo</span><span class="ss">)(</span><span class="nv">int</span><span class="ss">))</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">moo</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="c1">; // function pointer moo called using argument x</span>
}
<span class="o">//</span><span class="w"> </span><span class="nv">analog</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">foobar</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span>,<span class="w"> </span><span class="nv">f_int_t</span><span class="w"> </span><span class="nv">moo</span><span class="ss">)</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">moo</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="c1">; // function pointer moo called using argument x</span>
}
</pre></div>

<h4>1.3 Callback use notation and compatible types</h4>
<p>A callback function taking a function pointer can be called using function
pointers.</p>
<p>Using a function that takes a function pointer callback is rather simple:</p>
<div class="code"><pre class="code literal-block"> int a = 5;
 int b = foobar(a, foo); // call foobar with pointer to foo as callback
 // can also be
 int b = foobar(a, &amp;foo); // call foobar with pointer to foo as callback
</pre></div>

<h4>1.4 Example</h4>
<p>A function ca be written that doesn't rely on how the callback works:</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">tranform_every_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="nc">int</span><span class="p">))</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>where possible callbacks could be</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">double_int</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="nv">x</span><span class="c1">; }</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">square_int</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="o">*</span><span class="nv">x</span><span class="c1">; }</span>
</pre></div>

<p>used like</p>
<div class="code"><pre class="code literal-block">int a[5] = {1, 2, 3, 4, 5};
tranform_every_int(&amp;a[0], 5, double_int);
// now a == {2, 4, 6, 8, 10};
tranform_every_int(&amp;a[0], 5, square_int);
// now a == {4, 16, 36, 64, 100};
</pre></div>

<h3>2. Pointer to member function</h3>
<p>A pointer to member function (of some class <code>C</code>) is a special type of (and
even more complex) function pointer which requires an object of type <code>C</code> to
operate on.</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">C</span>
<span class="p">{</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>

<h4>2.1 Writing pointer to member function / type notation</h4>
<p>A <strong>pointer to member function type</strong> for some class <code>T</code> has the notation</p>
<div class="code"><pre class="code literal-block"><span class="c1">// can have more or less parameters</span>
<span class="n">return_type</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">::</span><span class="o">*</span><span class="p">)(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span>
<span class="c1">// i.e. a pointer to C::foo has the type</span>
<span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>

<p>where a <strong>named pointer to member function</strong> will -in analogy to the function
pointer- look like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">return_type</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="w"> </span><span class="k">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span>

<span class="o">//</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">e</span><span class="p">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n n-Quoted">`f_C_int`</span><span class="w"> </span><span class="n">representing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n n-Quoted">`C`</span>
<span class="o">//</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">returning</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">is</span><span class="o">:</span>
<span class="n">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C_foo_p</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">returning</span><span class="w"> </span><span class="kt">int</span>
<span class="o">//</span><span class="w"> </span><span class="n">Its</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C</span>
<span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="w"> </span><span class="n">C_foo_p</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
<span class="o">//</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">typedef</span><span class="o">:</span>
<span class="n">f_C_int_t</span><span class="w"> </span><span class="n">C_foo_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
</pre></div>

<p>Example: Declaring a function taking a <strong>pointer to member function callback</strong>
as one of its arguments:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="n">having</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">member</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">C</span>
<span class="o">//</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">argument</span>
<span class="o">//</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">needs</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">c</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">));</span>
<span class="o">//</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">equivalently</span><span class="w"> </span><span class="n">declared</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">typedef</span><span class="w"> </span><span class="n">above</span><span class="p">:</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">);</span>
</pre></div>

<h4>2.2 Callback call notation</h4>
<p>The pointer to member function of <code>C</code> can be invoked, with respect to an
object of type <code>C</code> by using member access operations on the dereferenced
pointer. <em>Note: Parenthesis required!</em></p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">.*</span><span class="n">moo</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">analog</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">.*</span><span class="n">moo</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
</pre></div>

<p><em>Note: If a pointer to<code>C</code> is available the syntax is equivalent (where the
pointer to <code>C</code> must be dereferenced as well):</em></p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar_2</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">meow</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">meow</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">.*</span><span class="n">meow</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">equivalent</span><span class="p">:</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar_2</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">meow</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">meow</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;*</span><span class="n">meow</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<h4>2.3 Callback use notation and compatible types</h4>
<p>A callback function taking a member function pointer of class <code>T</code> can be
called using a member function pointer of class <code>T</code>.</p>
<p>Using a function that takes a pointer to member function callback is -in
analogy to function pointers- quite simple as well:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mh">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// aggregate initialization</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">5</span><span class="p">;</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">my_c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// call C_foobar with pointer to foo as its callback</span>
</pre></div>

<h3>3. <code>std::function</code> objects (header <code>&lt;functional&gt;</code>)</h3>
<p>The <code>std::function</code> class is a polymorphic function wrapper to store, copy or
invoke callables.</p>
<h4>3.1 Writing a <code>std::function</code> object / type notation</h4>
<p>The type of a <code>std::function</code> object storing a callable looks like:</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">//</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">declaration</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foo</span><span class="p">:</span>
<span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stdf_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">:</span>
<span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">C</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stdf_C_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">;</span>
</pre></div>

<h4>3.2 Callback call notation</h4>
<p>The class <code>std::function</code> has <code>operator()</code> defined which can be used to invoke
its target.</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">moo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">stdf_C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">moo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
</pre></div>

<h4>3.3 Callback use notation and compatible types</h4>
<p>The <code>std::function</code> callback is more generic than function pointers or pointer
to member function since different types can be passed and implicitly
converted into a <code>std::function</code> object.</p>
<p><strong>3.3.1 Function pointers and pointers to member functions</strong></p>
<p>A function pointer</p>
<div class="code"><pre class="code literal-block">int a = 2;
int b = stdf_foobar(a, &amp;foo);
// b == 6 ( 2 + (2+2) )
</pre></div>

<p>or a pointer to member function</p>
<div class="code"><pre class="code literal-block"><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="n">C</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mh">7</span><span class="p">};</span><span class="w"> </span><span class="c1">// aggregate initialization</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_C_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span>
<span class="c1">// b == 11 == ( 2 + (7+2) )</span>
</pre></div>

<p>can be used.</p>
<p><strong>3.3.2 Lambda expressions</strong></p>
<p>An unnamed closure from a lambda expression can be stored in a <code>std::function</code>
object:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="err">}</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="o">==</span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p><strong>3.3.3<code>std::bind</code> expressions</strong></p>
<p>The result of a <code>std::bind</code> expression can be passed. For example by binding
parameters to a function pointer call:</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">foo_2</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">,</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">y</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">9*x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">using</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">placeholders</span><span class="p">::</span><span class="nd">_1</span><span class="o">;</span>

<span class="nt">int</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">2</span><span class="o">;</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">stdf_foobar</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span><span class="o">));</span>
<span class="o">//</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">23</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nt">9</span><span class="o">*</span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">3</span><span class="w"> </span><span class="o">)</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">stdf_foobar</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">));</span>
<span class="o">//</span><span class="w"> </span><span class="nt">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">49</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nt">9</span><span class="o">*</span><span class="nt">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">)</span>
</pre></div>

<p>Where also objects can be bound as the object for the invocation of pointer to
member functions:</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">aggregate</span><span class="w"> </span><span class="n">initialization</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">my_c</span><span class="p">,</span><span class="w"> </span><span class="n">_1</span><span class="p">));</span>
<span class="o">//</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">)</span>
</pre></div>

<p><strong>3.3.4 Function objects</strong></p>
<p>Objects of classes having a proper <code>operator()</code> overload can be stored inside
a <code>std::function</code> object, as well.</p>
<div class="code"><pre class="code literal-block"><span class="nv">struct</span><span class="w"> </span><span class="nv">Meow</span>
{
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">Meow</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">y_</span><span class="ss">)</span><span class="w"> </span>:<span class="w"> </span><span class="nv">y</span><span class="ss">(</span><span class="nv">y_</span><span class="ss">)</span><span class="w"> </span>{}
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">operator</span><span class="ss">()(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">x</span><span class="c1">; }</span>
}<span class="c1">;</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="c1">;</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">stdf_foobar</span><span class="ss">(</span><span class="nv">a</span>,<span class="w"> </span><span class="nv">Meow</span>{<span class="mi">8</span>}<span class="ss">)</span><span class="c1">;</span>
<span class="o">//</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">(</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="ss">)</span>
</pre></div>

<h4>3.4 Example</h4>
<p>Changing the function pointer example to use <code>std::function</code></p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">function</span><span class="o">&lt;</span><span class="nc">int</span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>gives a whole lot more utility to that function because (see 3.3) we have more
possibilities to use it:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// using function pointer still possible</span>
<span class="nb">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">double_int</span><span class="p">);</span>
<span class="c1">// now a == {2, 4, 6, 8, 10};</span>

<span class="c1">// use it without having to write another function by using a lambda</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="c1">// now a == {1, 2, 3, 4, 5}; again</span>

<span class="c1">// use std::bind :</span>
<span class="nb">int</span><span class="w"> </span><span class="n">nine_x_and_y</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="n">using</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">placeholders</span><span class="p">::</span><span class="n">_1</span><span class="p">;</span>
<span class="c1">// calls nine_x_and_y for every int in a with y being 4 every time</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="n">nine_x_and_y</span><span class="p">,</span><span class="w"> </span><span class="n">_1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span>
<span class="c1">// now a == {13, 22, 31, 40, 49};</span>
</pre></div>

<h3>4. Templated callback type</h3>
<p>Using templates, the code calling the callback can be even more general than
using <code>std::function</code> objects.</p>
<p><em>Note that templates are a compile-time feature and are a design tool for
compile-time polymorphism. If runtime dynamic behaviour is to be achieved
through callbacks, templates will help but they won't induce runtime
dynamics.</em></p>
<h4>4.1 Writing (type notations) and calling templated callbacks</h4>
<p>Generalizing i.e. the <code>std_ftransform_every_int</code> code from above even further
can be achieved by using templates:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">void</span><span class="w"> </span><span class="n">stdf_transform_every_int_templ</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">  </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>with an even more general (as well as easiest) syntax for a callback type
being a plain, to-be-deduced templated argument:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span>
<span class="n">void</span><span class="w"> </span><span class="n">transform_every_int_templ</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"transform_every_int_templ&lt;"</span><span class="w"> </span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nf">type_name</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"&gt;\n"</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p><em>Note: The included output prints the type name deduced for templated type<code>F</code>.
The implementation of <code>type_name</code> is given at the end of this post.</em></p>
<p>The most general implementation for the unary transformation of a range is
part of the standard library, namely <code>std::transform</code>, which is also templated
with respect to the iterated types.</p>
<div class="code"><pre class="code literal-block"><span class="nv">template</span><span class="o">&lt;</span><span class="nv">class</span><span class="w"> </span><span class="nv">InputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">OutputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">UnaryOperation</span><span class="o">&gt;</span>
<span class="nv">OutputIt</span><span class="w"> </span><span class="nv">transform</span><span class="ss">(</span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">first1</span>,<span class="w"> </span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">last1</span>,<span class="w"> </span><span class="nv">OutputIt</span><span class="w"> </span><span class="nv">d_first</span>,
<span class="w">  </span><span class="nv">UnaryOperation</span><span class="w"> </span><span class="nv">unary_op</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">last1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="o">*</span><span class="nv">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unary_op</span><span class="ss">(</span><span class="o">*</span><span class="nv">first1</span><span class="o">++</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span>}
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">d_first</span><span class="c1">;</span>
}
</pre></div>

<h4>4.2 Examples using templated callbacks and compatible types</h4>
<p>The compatible types for the templated <code>std::function</code> callback method
<code>stdf_transform_every_int_templ</code> are identical to the above mentioned types
(see 3.4).</p>
<p>Using the templated version however, the signature of the used callback may
change a little:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Let</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">muh</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">woof</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">}</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">muh</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">woof</span><span class="p">);</span>
</pre></div>

<p><em>Note:<code>std_ftransform_every_int</code> (non templated version; see above) does work
with <code>foo</code> but not using <code>muh</code>.</em></p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Let</span>
<span class="n">void</span><span class="w"> </span><span class="n">print_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="n">bool</span><span class="w"> </span><span class="n">f</span><span class="err">{</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="ss">""</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="ss">" "</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"\n"</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>The plain templated parameter of <code>transform_every_int_templ</code> can be every
possible callable type.</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">a</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">1,</span><span class="w"> </span><span class="err">2,</span><span class="w"> </span><span class="err">3,</span><span class="w"> </span><span class="err">4,</span><span class="w"> </span><span class="err">5</span><span class="w"> </span><span class="p">}</span><span class="o">;</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">foo</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">muh</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">woof</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="cp">[]</span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">Meow</span><span class="p">{</span><span class="w"> </span><span class="err">4</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">using</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">placeholders</span><span class="p">::</span><span class="nd">_1</span><span class="o">;</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span><span class="o">));</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">function</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">(</span><span class="nt">int</span><span class="o">)&gt;</span><span class="p">{</span><span class="err">&amp;foo</span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
</pre></div>

<p>The above code prints:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="mf">5</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">3</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="mf">6</span><span class="w"> </span><span class="mf">7</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="err">&amp;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">6</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="mf">12</span><span class="w"> </span><span class="mf">14</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="err">&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="err">&amp;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">9</span><span class="w"> </span><span class="mf">11</span><span class="w"> </span><span class="mf">13</span><span class="w"> </span><span class="mf">15</span><span class="w"> </span><span class="mf">17</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="p">::</span><span class="err">{</span><span class="n">lambda</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="err">#</span><span class="mf">1</span><span class="err">}</span><span class="w"> </span><span class="o">&gt;</span>
<span class="mf">27</span><span class="w"> </span><span class="mf">33</span><span class="w"> </span><span class="mf">39</span><span class="w"> </span><span class="mf">45</span><span class="w"> </span><span class="mf">51</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Meow</span><span class="o">&gt;</span>
<span class="mf">108</span><span class="w"> </span><span class="mf">132</span><span class="w"> </span><span class="mf">156</span><span class="w"> </span><span class="mf">180</span><span class="w"> </span><span class="mf">204</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">_Bind</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Placeholder</span><span class="o">&lt;</span><span class="mf">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="p">))(</span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;&gt;</span>
<span class="mf">975</span><span class="w"> </span><span class="mf">1191</span><span class="w"> </span><span class="mf">1407</span><span class="w"> </span><span class="mf">1623</span><span class="w"> </span><span class="mf">1839</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;&gt;</span>
<span class="mf">977</span><span class="w"> </span><span class="mf">1193</span><span class="w"> </span><span class="mf">1409</span><span class="w"> </span><span class="mf">1625</span><span class="w"> </span><span class="mf">1841</span>
</pre></div>

<h2>
<code>type_name</code> implementation used above</h2>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;typeinfo&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cxxabi.h&gt;</span>

<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kr">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="w"> </span><span class="n">type_name</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kr">typedef</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">TR</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kr">char</span><span class="p">,</span><span class="w"> </span><span class="kr">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kr">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">own</span>
<span class="w">    </span><span class="p">(</span><span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">TR</span><span class="p">).</span><span class="n">name</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">    </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">own</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="o">?</span><span class="n">own</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span><span class="o">:</span><span class="n">typeid</span><span class="p">(</span><span class="n">TR</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="n">TR</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" const"</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_volatile</span><span class="o">&lt;</span><span class="n">TR</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" volatile"</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" &amp;"</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" &amp;&amp;"</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>There is also the C way of doing callbacks: function pointers</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">signature</span><span class="p">,</span>
<span class="o">//</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">makes</span><span class="w"> </span><span class="n">life</span><span class="w"> </span><span class="n">easier</span>

<span class="o">//</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">CallbackType</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb nb-Type">float</span>
<span class="o">//</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="nb nb-Type">int</span>
<span class="n">typedef</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">CallbackType</span><span class="p">)(</span><span class="nb nb-Type">float</span><span class="p">);</span>

<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">DoWork</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">calculations</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Call</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">retrieve</span><span class="w"> </span><span class="n">the</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">result</span>
<span class="w">  </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">result</span>
<span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">SomeCallback</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">variable</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Interpret</span><span class="w"> </span><span class="n">variable</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">SomeCallback</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">DoWork</span>
<span class="w">  </span><span class="n">DoWork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SomeCallback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>Now, if you want to pass in class methods as callbacks, the declarations to
those function pointers have more complex declarations, for example:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Declaration:</span>
<span class="n">typedef</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="n">ClassName</span><span class="p">::</span><span class="o">*</span><span class="n">CallbackType</span><span class="p">)(</span><span class="n">float</span><span class="p">);</span>

<span class="c1">// This method performs work using an object instance</span>
<span class="n">void</span><span class="w"> </span><span class="n">DoWorkObject</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Class instance to invoke it through</span>
<span class="w">  </span><span class="n">ClassName</span><span class="w"> </span><span class="n">objectInstance</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Invocation</span>
<span class="w">  </span><span class="nb">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">objectInstance</span><span class="o">.*</span><span class="n">callback</span><span class="p">)(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//This method performs work using an object pointer</span>
<span class="n">void</span><span class="w"> </span><span class="n">DoWorkPointer</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Class pointer to invoke it through</span>
<span class="w">  </span><span class="n">ClassName</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pointerInstance</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Invocation</span>
<span class="w">  </span><span class="nb">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">pointerInstance</span><span class="o">-&gt;*</span><span class="n">callback</span><span class="p">)(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Pass in SomeCallback to the DoWork</span>
<span class="w">  </span><span class="n">DoWorkObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ClassName</span><span class="p">::</span><span class="n">Method</span><span class="p">);</span>
<span class="w">  </span><span class="n">DoWorkPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ClassName</span><span class="p">::</span><span class="n">Method</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-remove-last-n-characters-from-a-string-in-bash/" class="u-url">How to remove last n characters from a string in Bash?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-remove-last-n-characters-from-a-string-in-bash/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:49:56+08:00" itemprop="datePublished" title="2023-03-03 17:49">2023-03-03 17:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have a variable <code>var</code> in a Bash script holding a string:</p>
<div class="code"><pre class="code literal-block"><span class="n">echo</span><span class="w"> </span><span class="o">$</span><span class="k">var</span>
<span class="s2">"some string.rtf"</span>
</pre></div>

<p>I want to remove the last four characters of this string and assign the result
to a new variable <code>var2</code>, so that</p>
<div class="code"><pre class="code literal-block"><span class="n">echo</span><span class="w"> </span><span class="o">$</span><span class="n">var2</span>
<span class="s2">"some string"</span>
</pre></div>

<p>How can I do this?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>First, it's usually better to be explicit about your intent. So if you know
the string ends in a <code>.rtf</code> that you want to remove, you can just use
<code>var2=${var%.rtf}</code>. One potentially-useful aspect of this approach is that if
the string <em>doesn't</em> end in <code>.rtf</code>, it is not changed at all; <code>var2</code> will
contain an unmodified copy of <code>var</code>.</p>
<p>If you want to remove a filename suffix but don't know or care exactly what it
is, you can use <code>var2=${var%.*}</code> to remove everything starting with the last
<code>.</code>. Or, if you only want to keep everything up to but not including the
<em>first</em> <code>.</code>, you can use <code>var2=${var%%.*}</code>. Those options have the same result
if there's only one <code>.</code> in the string, but if there might be more than one,
you get to pick which end of the string to work from. On the other hand, if
there's no <code>.</code> in the string at all, <code>var2</code> will again be an unchanged copy of
<code>var</code>.</p>
<p>If you really want to always remove a specific <em>number</em> of characters, here
are some options.</p>
<p>You tagged this <code>bash</code> specifically, so we'll start with bash builtins. The
one which has worked the longest is the same suffix-removal syntax I used
above: to remove four characters, use <code>var2=${var%????}</code>. Or to remove four
characters only if the first one is a dot, use <code>var2=${var%.???}</code>, which is
like <code>var2=${var%.*}</code> but only removes the suffix if the part after the dot is
exactly three characters. As you can see, to count characters this way, you
need one question mark per unknown character removed, so this approach gets
unwieldy for larger substring lengths.</p>
<p>An option in newer shell versions is substring extraction:
<code>var2=${var:0:${#var}-4}</code>. Here you can put any number in place of the <code>4</code> to
remove a different number of characters. The <code>${#var}</code> is replaced by the
length of the string, so this is actually asking to extract and keep (length -
4) characters starting with the first one (at index 0). With this approach,
you lose the option to make the change only if the string matches a pattern.
As long as the string has at least four characters, no matter what its actual
value is, the copy will include all but its last four characters.</p>
<p>You can leave the start index out; it defaults to 0, so you can shorten that
to just <code>var2=${var::${#var}-4}</code>. In fact, newer versions of bash
(specifically 4+, which means the one that ships with MacOS won't work)
recognize negative lengths as the index of the character to stop at, counting
back from the end of the string. So in those versions you can get rid of the
string-length expression, too: <code>var2=${var::-4}</code>. This interpretation is also
triggered if you leave the string length in but the string is shorter than
four characters, since then <code>${#var}-4</code> is negative. For example, if the
string has three characters, <code>${var:0:${#var}-4}</code> becomes <code>${var:0:-1}</code> and
removes only the last character.</p>
<p>If you're not actually using bash but some other POSIX-type shell, the
pattern-based suffix removal with <code>%</code> will still work – even in plain old
dash, where the index-based substring extraction won't. Ksh and zsh do both
support substring extraction, but require the explicit 0 start index; zsh also
supports the negative end index, while ksh requires the length expression.
Note that zsh, which indexes <em>arrays</em> starting at 1, nonetheless indexes
<em>strings</em> starting at 0 <em>if you use this bash-compatible syntax</em>. But zsh also
allows you to treat scalar parameters as if they were arrays of characters, in
which case the substring syntax uses a 1-based count and places the start and
(inclusive) end positions in brackets separated by commas: <code>var2=$var[1,-5]</code>.</p>
<p>Instead of using built-in shell parameter expansion, you can of course run
some utility program to modify the string and capture its output with command
substitution. There are several commands that will work; one is <code>var2=$(sed
's/.\{4\}$//' &lt;&lt;&lt;"$var")</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>To remove four characters from the end of the string use <code>${var%????}</code>.</p>
<p>To remove everything after and including the final <code>.</code> use <code>${var%.*}</code>.</p>
<p>See Bash's documentation on parameter expansion for more.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/jquery-inarray-how-to-use-it-right/" class="u-url">jQuery.inArray(), how to use it right?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/jquery-inarray-how-to-use-it-right/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:48:40+08:00" itemprop="datePublished" title="2023-03-03 17:48">2023-03-03 17:48</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>First time I work with <code>jQuery.inArray()</code> and it acts kinda strange.</p>
<p>If the object is in the array, it will return 0, but 0 is false in Javascript.
So the following will output: <em>"is NOT in array"</em></p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">myarray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="n">myarray</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">"test"</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">jQuery</span><span class="o">.</span><span class="n">inArray</span><span class="p">(</span><span class="s2">"test"</span><span class="p">,</span><span class="w"> </span><span class="n">myarray</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">"is in array"</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">"is NOT in array"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>I will have to change the if statement to:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="ss">(</span><span class="nv">jQuery</span>.<span class="nv">inArray</span><span class="ss">(</span><span class="s2">"test"</span>,<span class="w"> </span><span class="nv">myarray</span><span class="ss">)</span><span class="o">==</span><span class="mi">0</span><span class="ss">)</span>
</pre></div>

<p>But this makes the code unreadable. Especially for someone who doesn't know
this function. They will expect that jQuery.inArray("test", myarray) gives
true when "test" is in the array.</p>
<p>So my question is, why is it done this way? I realy dislike this. But there
must be a good reason to do it like that.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><code>inArray</code> returns the index of the element in the array, not a boolean
indicating if the item exists in the array. If the element was not found, <code>-1</code>
will be returned.</p>
<p>So, to check if an item is in the array, use:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="ss">(</span><span class="nv">jQuery</span>.<span class="nv">inArray</span><span class="ss">(</span><span class="s2">"test"</span>,<span class="w"> </span><span class="nv">myarray</span><span class="ss">)</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p><code>$.inArray</code> returns the <em>index</em> of the element if found or -1 if it isn't --
not a boolean value. So the correct is</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="ss">(</span><span class="nv">jQuery</span>.<span class="nv">inArray</span><span class="ss">(</span><span class="s2">"test"</span>,<span class="w"> </span><span class="nv">myarray</span><span class="ss">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">console</span>.<span class="nv">log</span><span class="ss">(</span><span class="s2">"is in array"</span><span class="ss">)</span><span class="c1">;</span>
}<span class="w"> </span><span class="k">else</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">console</span>.<span class="nv">log</span><span class="ss">(</span><span class="s2">"is NOT in array"</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2139.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2137.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
