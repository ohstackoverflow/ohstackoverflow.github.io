<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 281) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-281.html">
<link rel="prev" href="index-282.html" type="text/html">
<link rel="next" href="index-280.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/in-python-how-do-i-determine-if-an-object-is-iterable/" class="u-url">In Python, how do I determine if an object is iterable?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/in-python-how-do-i-determine-if-an-object-is-iterable/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:54:37+08:00" itemprop="datePublished" title="2023-02-17 02:54">2023-02-17 02:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Is there a method like <code>isiterable</code>? The only solution I have found so far is
to call</p>
<div class="code"><pre class="code literal-block">hasattr(myObj, '__iter__')
</pre></div>

<p>But I am not sure how fool-proof this is.</p>
<p><br><br></p>
<h2>Answer</h2>
<ol>
<li>Checking for <code>__iter__</code> works on sequence types, but it would fail on e.g. strings <strong>in Python 2</strong>. I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):<div class="code"><pre class="code literal-block"> try:
 some_object_iterator = iter(some_object)
</pre></div>

<p>except TypeError as te:
     print(some_object, 'is not iterable')</p>
</li>
</ol>
<p>The <code>iter</code> built-in checks for the <code>__iter__</code> method or in the case of strings
the <code>__getitem__</code> method.</p>
<ol>
<li>Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object. The Python glossary:</li>
</ol>
<blockquote>
<p>Pythonic programming style that determines an object's type by inspection of
its method or attribute signature rather than by explicit relationship to
some type object ("If it looks like a <strong>duck</strong> and quacks like a <strong>duck</strong> ,
it must be a <strong>duck</strong>.") By emphasizing interfaces rather than specific
types, well-designed code improves its flexibility by allowing polymorphic
substitution. Duck-typing avoids tests using type() or isinstance().
<strong>Instead, it typically employs the EAFP (Easier to Ask Forgiveness than
Permission) style of programming.</strong></p>
<p>...</p>
<div class="code"><pre class="code literal-block"><span class="k">try</span><span class="o">:</span>
<span class="w">   </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">e</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">my_object</span><span class="o">)</span>
<span class="n">except</span><span class="w"> </span><span class="n">TypeError</span><span class="o">:</span>
<span class="w">   </span><span class="n">print</span><span class="w"> </span><span class="n">my_object</span><span class="o">,</span><span class="w"> </span><span class="s1">'is not iterable'</span>
</pre></div>

</blockquote>
<ol>
<li>
<p>The <code>collections</code> module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:</p>
<div class="code"><pre class="code literal-block"> <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
</pre></div>

<p>if isinstance(e, Iterable):
     # e is iterable</p>
</li>
</ol>
<p>However, this does not check for classes that are iterable through
<code>__getitem__</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<h3>Duck typing</h3>
<div class="code"><pre class="code literal-block"><span class="k">try</span><span class="o">:</span>
<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">(</span><span class="n">the_element</span><span class="o">)</span>
<span class="n">except</span><span class="w"> </span><span class="n">TypeError</span><span class="o">:</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">iterable</span>
<span class="k">else</span><span class="o">:</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">iterable</span>

<span class="err">#</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iterator</span><span class="o">:</span>
<span class="err">#</span><span class="w">     </span><span class="n">pass</span>
</pre></div>

<h3>Type checking</h3>
<p>Use the Abstract Base Classes. They need at least Python 2.6 and work only for
new-style classes.</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>   <span class="c1"># import directly from collections for Python &lt; 3.3</span>

<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_element</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="c1"># iterable</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># not iterable</span>
</pre></div>

<p>However, <code>iter()</code> is a bit more reliable as described by the documentation:</p>
<blockquote>
<p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as
Iterable or that have an <code>__iter__()</code> method, but it does not detect classes
that iterate with the <code>__getitem__()</code> method. The only reliable way to
determine whether an object is iterable is to call <code>iter(obj)</code>.</p>
</blockquote>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping-commands-in-vim/" class="u-url">What is the difference between the remap, noremap, nnoremap and vnoremap mapping commands in Vim?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-the-remap-noremap-nnoremap-and-vnoremap-mapping-commands-in-vim/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:54:13+08:00" itemprop="datePublished" title="2023-02-17 02:54">2023-02-17 02:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What is the difference between the <code>remap</code>, <code>noremap</code>, <code>nnoremap</code> and
<code>vnoremap</code> mapping commands in Vim?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><code>remap</code> is an <strong>option</strong> that makes mappings work recursively. By default it
is on and I'd recommend you leave it that way. The rest are <strong>mapping
commands</strong> , described below:</p>
<p><code>:map</code> and <code>:noremap</code> are <strong>recursive</strong> and <strong>non-recursive</strong> versions of the
various mapping commands. For example, if we run:</p>
<div class="code"><pre class="code literal-block">:map j gg           (moves cursor to first line)
:map Q j            (moves cursor to first line)
:noremap W j        (moves cursor down one line)
</pre></div>

<p>Then:</p>
<ul>
<li>
<code>j</code> will be mapped to <code>gg</code>.</li>
<li>
<code>Q</code> will <em>also</em> be mapped to <code>gg</code>, because <code>j</code> will be expanded for the recursive mapping.</li>
<li>
<code>W</code> will be mapped to <code>j</code> (and not to <code>gg</code>) because <code>j</code> will not be expanded for the non-recursive mapping.</li>
</ul>
<p>Now remember that Vim is a <strong>modal editor</strong>. It has a <strong>normal</strong> mode,
<strong>visual</strong> mode and other modes.</p>
<p>For each of these sets of mappings, there is a mapping that works in normal,
visual, select and operator modes (<code>:map</code> and <code>:noremap</code>), one that works in
normal mode (<code>:nmap</code> and <code>:nnoremap</code>), one in visual mode (<code>:vmap</code> and
<code>:vnoremap</code>) and so on.</p>
<p>For more guidance on this, see:</p>
<div class="code"><pre class="code literal-block">:help :map
:help :noremap
:help recursive_mapping
:help :map-modes
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>I think the Vim documentation should've explained the meaning behind the
naming of these commands. Just telling you what they do doesn't help you
remember the names.</p>
<p><code>map</code> is the "root" of all recursive mapping commands. The root form applies
to "normal", "visual+select", and "operator-pending" modes. (I'm using the
term "root" as in linguistics.)</p>
<p><code>noremap</code> is the "root" of all non-recursive mapping commands. The root form
applies to the same modes as <code>map</code>. (Think of the <code>nore</code> prefix to mean "non-
recursive".)</p>
<p>(Note that there are also the <code>!</code> modes like <code>map!</code> that apply to insert &amp;
command-line.)</p>
<p>See below for what "recursive" means in this context.</p>
<p>Prepending a mode letter like <code>n</code> modify the modes the mapping works in. It
can choose a subset of the list of applicable modes (e.g. only "visual"), or
choose other modes that <code>map</code> wouldn't apply to (e.g. "insert").</p>
<p>Use <code>help map-modes</code> will show you a few tables that explain how to control
which modes the mapping applies to.</p>
<p>Mode letters:</p>
<ul>
<li>
<code>n</code>: normal only</li>
<li>
<code>v</code>: visual and select</li>
<li>
<code>o</code>: operator-pending</li>
<li>
<code>x</code>: visual only</li>
<li>
<code>s</code>: select only</li>
<li>
<code>i</code>: insert</li>
<li>
<code>c</code>: command-line</li>
<li>
<code>l</code>: insert, command-line, regexp-search (and others. Collectively called "Lang-Arg" pseudo-mode)</li>
</ul>
<p>" <strong>Recursive</strong> " means that the mapping is expanded to a result, then the
result is expanded to another result, and so on.</p>
<p>The expansion stops when one of these is true:</p>
<ol>
<li>the result is no longer mapped to anything else.</li>
<li>a non-recursive mapping has been applied (i.e. the "noremap" [or one of its ilk] is the final expansion).</li>
</ol>
<p>At that point, Vim's default "meaning" of the final result is
applied/executed.</p>
<p>" <strong>Non-recursive</strong> " means the mapping is only expanded once, and that result
is applied/executed.</p>
<p>Example:</p>
<div class="code"><pre class="code literal-block"> nmap K H
 nnoremap H G
 nnoremap G gg
</pre></div>

<p>The above causes <code>K</code> to expand to <code>H</code>, then <code>H</code> to expand to <code>G</code> and stop. It
stops because of the <code>nnoremap</code>, which expands and stops immediately. The
meaning of <code>G</code> will be executed (i.e. "jump to last line"). At most one non-
recursive mapping will ever be applied in an expansion chain (it would be the
last expansion to happen).</p>
<p>The mapping of <code>G</code> to <code>gg</code> only applies if you press <code>G</code>, but not if you press
<code>K</code>. This mapping doesn't affect pressing <code>K</code> regardless of whether <code>G</code> was
mapped recursively or not, since it's line 2 that causes the expansion of <code>K</code>
to stop, so line 3 wouldn't be used.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-are-the-differences-between-np-np-complete-and-np-hard/" class="u-url">What are the differences between NP, NP-Complete and NP-Hard?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-are-the-differences-between-np-np-complete-and-np-hard/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:53:48+08:00" itemprop="datePublished" title="2023-02-17 02:53">2023-02-17 02:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What are the differences between <strong>NP</strong> , <strong>NP-Complete</strong> and <strong>NP-Hard</strong>?</p>
<p>I am aware of many resources all over the web. I'd like to read your
explanations, and the reason is they might be different from what's out there,
or there is something that I'm not aware of.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I assume that you are looking for intuitive definitions, since the technical
definitions require quite some time to understand. First of all, let's
remember a preliminary needed concept to understand those definitions.</p>
<ul>
<li>
<strong>Decision problem</strong> : A problem with a <strong>yes</strong> or <strong>no</strong> answer.</li>
</ul>
<hr>
<p>Now, let us define those <em>complexity classes</em>.</p>
<h2>P</h2>
<p><em>P is a complexity class that represents the set of all decision problems that
can be solved in polynomial time</em>.</p>
<p>That is, given an instance of the problem, the answer yes or no can be decided
in polynomial time.</p>
<p><strong>Example</strong></p>
<p>Given a connected graph <code>G</code>, can its vertices be coloured using two colours so
that no edge is monochromatic?</p>
<p>Algorithm: start with an arbitrary vertex, color it red and all of its
neighbours blue and continue. Stop when you run out of vertices or you are
forced to make an edge have both of its endpoints be the same color.</p>
<hr>
<h2>NP</h2>
<p><em>NP is a complexity class that represents the set of all decision problems for
which the instances where the answer is "yes" have proofs that can be verified
in polynomial time.</em></p>
<p>This means that if someone gives us an instance of the problem and a
certificate (sometimes called a witness) to the answer being yes, we can check
that it is correct in polynomial time.</p>
<p><strong>Example</strong></p>
<p><em>Integer factorisation</em> is in NP. This is the problem that given integers <code>n</code>
and <code>m</code>, is there an integer <code>f</code> with <code>1 &lt; f &lt; m</code>, such that <code>f</code> divides <code>n</code>
(<code>f</code> is a small factor of <code>n</code>)?</p>
<p>This is a decision problem because the answers are yes or no. If someone hands
us an instance of the problem (so they hand us integers <code>n</code> and <code>m</code>) and an
integer <code>f</code> with <code>1 &lt; f &lt; m</code>, and claim that <code>f</code> is a factor of <code>n</code> (the
certificate), we can check the answer in <em>polynomial time</em> by performing the
division <code>n / f</code>.</p>
<hr>
<h2>NP-Complete</h2>
<p><em>NP-Complete is a complexity class which represents the set of all problems<code>X</code>
in NP for which it is possible to reduce any other NP problem <code>Y</code> to <code>X</code> in
polynomial time.</em></p>
<p>Intuitively this means that we can solve <code>Y</code> quickly if we know how to solve
<code>X</code> quickly. Precisely, <code>Y</code> is reducible to <code>X</code>, if there is a polynomial time
algorithm <code>f</code> to transform instances <code>y</code> of <code>Y</code> to instances <code>x = f(y)</code> of <code>X</code>
in polynomial time, with the property that the answer to <code>y</code> is yes, if and
only if the answer to <code>f(y)</code> is yes.</p>
<p><strong>Example</strong></p>
<p><code>3-SAT</code>. This is the problem wherein we are given a conjunction (ANDs) of
3-clause disjunctions (ORs), statements of the form</p>
<div class="code"><pre class="code literal-block">(x_v11 OR x_v21 OR x_v31) AND 
(x_v12 OR x_v22 OR x_v32) AND 
...                       AND 
(x_v1n OR x_v2n OR x_v3n)
</pre></div>

<p>where each <code>x_vij</code> is a boolean variable or the negation of a variable from a
finite predefined list <code>(x_1, x_2, ... x_n)</code>.</p>
<p>It can be shown that <em>every NP problem can be reduced to 3-SAT</em>. The proof of
this is technical and requires use of the technical definition of NP ( <em>based
on non-deterministic Turing machines</em> ). This is known as <em>Cook's theorem</em>.</p>
<p>What makes NP-complete problems important is that if a deterministic
polynomial time algorithm can be found to solve one of them, every NP problem
is solvable in polynomial time (one problem to rule them all).</p>
<hr>
<h2>NP-hard</h2>
<p>Intuitively, these are the problems that are <em>at least as hard as the NP-
complete problems</em>. Note that NP-hard problems <em>do not have to be in NP</em> , and
<em>they do not have to be decision problems</em>.</p>
<p>The precise definition here is that <em>a problem<code>X</code> is NP-hard, if there is an
NP-complete problem <code>Y</code>, such that <code>Y</code> is reducible to <code>X</code> in polynomial
time</em>.</p>
<p>But since any NP-complete problem can be reduced to any other NP-complete
problem in polynomial time, all NP-complete problems can be reduced to any NP-
hard problem in polynomial time. Then, if there is a solution to one NP-hard
problem in polynomial time, there is a solution to all NP problems in
polynomial time.</p>
<p><strong>Example</strong></p>
<p>The halting problem is an NP-hard problem. This is the problem that given a
program <code>P</code> and input <code>I</code>, will it halt? This is a decision problem but it is
not in NP. It is clear that any NP-complete problem can be reduced to this
one. As another example, any NP-complete problem is NP-hard.</p>
<p>My favorite NP-complete problem is the Minesweeper problem.</p>
<hr>
<h2>P = NP</h2>
<p>This one is the most famous problem in computer science, and one of the most
important outstanding questions in the mathematical sciences. In fact, the
Clay Institute is offering one million dollars for a solution to the problem
(Stephen Cook's writeup on the Clay website is quite good).</p>
<p>It's clear that P is a subset of NP. The open question is whether or not NP
problems have deterministic polynomial time solutions. It is largely believed
that they do not. Here is an outstanding recent article on the latest (and the
importance) of the P = NP problem: The Status of the P versus NP problem.</p>
<p>The best book on the subject is Computers and Intractability by Garey and
Johnson.</p>
<p><br></p>
<h3>Suggest</h3>
<p>I've been looking around and seeing many long explanations. Here is a small
chart that may be useful to summarise:</p>
<p>Notice how difficulty increases top to bottom: any <em>NP can be reduced to NP-
Complete</em> , and any <em>NP-Complete can be reduced to NP-Hard</em> , all in P
(polynomial) time.</p>
<p>If you can solve a more difficult class of problem in P time, that will mean
you found how to solve all easier problems in P time (for example, proving P =
NP, if you figure out how to solve any NP-Complete problem in P time).</p>
<div class="code"><pre class="code literal-block">____________________________________________________________
| Problem Type | Verifiable in P time | Solvable in P time | Increasing Difficulty
___________________________________________________________|           |
| P            |        Yes           |        Yes         |           |
| NP           |        Yes           |     Yes or No *    |           |
| NP-Complete  |        Yes           |      Unknown       |           |
| NP-Hard      |     Yes or No **     |      Unknown ***   |           |
____________________________________________________________           V
</pre></div>

<p>Notes on <code>Yes</code> or <code>No</code> entries:</p>
<ul>
<li>
<ul>
<li>An NP problem that is also P is solvable in P time.</li>
</ul>
</li>
<li>** An NP-Hard problem that is also NP-Complete is verifiable in P time.</li>
<li>*** NP-Complete problems (all of which form a subset of NP-hard) might be. The rest of NP hard is not.</li>
</ul>
<p>I also found this diagram quite useful in seeing how all these types
correspond to each other (pay more attention to the left half of the diagram).</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-282.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-280.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
