<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 571) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-571.html">
<link rel="prev" href="index-572.html" type="text/html">
<link rel="next" href="index-570.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/jiang-wai-bu-jar-lib-jar-tian-jia-dao-intellij-idea-xiang-mu-de-zheng-que-fang-fa/" class="u-url">将外部 jar (lib/*.jar) 添加到 IntelliJ IDEA 项目的正确方法</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/jiang-wai-bu-jar-lib-jar-tian-jia-dao-intellij-idea-xiang-mu-de-zheng-que-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:24:35+08:00" itemprop="datePublished" title="2023-02-17 10:24">2023-02-17 10:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在 IntelliJ IDEA 中新建 Java 项目时，会创建如下目录和文件：</p>
<div class="code"><pre class="code literal-block">./projectname.iml
./projectname.ipr
./projectname.iws
./src/
</pre></div>

<p>我想配置 IntelliJ IDEA 以将我的依赖项 JAR 包含到<code>./lib/*.jar</code>项目中。在 IntelliJ IDEA
中实现此目的的正确方法是什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p><img alt="Intellij 20.3 中的对话" src="images/ZlENo.png"></p>
<p><strong>在IntelliJ IDEA</strong> 中添加外部 jar 的步骤：</p>
<ol>
<li>单击工具栏中的 <strong>文件</strong>
</li>
<li>选择 <strong>项目结构</strong> 选项（在 Windows/Linux 上为<code>CTRL</code>+ <code>SHIFT</code>+ <code>ALT</code>+ ，在 Mac OS X 上为+ ）<code>S``⌘``;</code>
</li>
<li>在左侧面板中选择 <strong>模块</strong>
</li>
<li>选择 <strong>依赖</strong> 选项卡</li>
<li>选择 <strong>+</strong> 图标</li>
<li>选择 <strong>1 个 JAR 或目录</strong> 选项</li>
</ol>
<p><br></p>
<h3>更多建议</h3>
<h4>IntelliJ IDEA 15 和 2016</h4>
<ol>
<li>
<strong>文件</strong> &gt; <strong>项目结构...</strong>
</li>
</ol>
<p><img alt="文件 &gt; 项目结构" src="images/eJqMW.png"></p>
<p>或按<code>Ctrl</code>+ <code>Alt</code>+ <code>Shift</code>+<code>S</code></p>
<ol>
<li>
<strong>项目设置</strong> &gt; <strong>模块</strong> &gt; <strong>依赖项</strong> &gt; “ <strong>+</strong> ” 符号 &gt; <strong>JAR 或目录...</strong>
</li>
</ol>
<p><img alt="模块 &gt; 依赖项 &gt; JAR 或目录" src="images/Nj5dC.png"></p>
<ol>
<li>选择 jar 文件并单击确定，然后单击另一个确定按钮进行确认</li>
</ol>
<p><img alt="在此处输入图像描述" src="images/hyld1.png"></p>
<p><img alt="在此处输入图像描述" src="images/wnEcT.png"></p>
<ol>
<li>可以在“External Libraries”文件夹中查看jar文件</li>
</ol>
<p><img alt="在此处输入图像描述" src="images/2IEoQ.png"></p>
<p><br><br><a href="posts/correct-way-to-add-external-jars-lib-jar-to-an-intellij-idea-project/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-tong-guo-gou-zao-lai-chu-shi-hua-hashsetzhi/" class="u-url">如何通过构造来初始化HashSet值？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-tong-guo-gou-zao-lai-chu-shi-hua-hashsetzhi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:24:04+08:00" itemprop="datePublished" title="2023-02-17 10:24">2023-02-17 10:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我需要创建一个<code>Set</code>具有初始值的。</p>
<div class="code"><pre class="code literal-block">Set&lt;String&gt; h = new HashSet&lt;String&gt;();
h.add("a");
h.add("b");
</pre></div>

<p>有没有办法在一行代码中做到这一点？例如，它对最终静态字段很有用。</p>
<p><br><br></p>
<h2>解答</h2>
<p>我使用的速记不是很省时，但适合一行：</p>
<div class="code"><pre class="code literal-block">Set&lt;String&gt; h = new HashSet&lt;&gt;(Arrays.asList("a", "b"));
</pre></div>

<p>同样，这不是时间效率，因为您正在构造一个数组，转换为一个列表并使用该列表创建一个集合。</p>
<p>在初始化静态最终集时，我通常这样写：</p>
<div class="code"><pre class="code literal-block">public static final String[] SET_VALUES = new String[] { "a", "b" };
public static final Set&lt;String&gt; MY_SET = new HashSet&lt;&gt;(Arrays.asList(SET_VALUES));
</pre></div>

<p>对于静态初始化来说，稍微不那么丑陋和效率无关紧要。</p>
<p><br></p>
<h3>更多建议</h3>
<p>Collection literals 计划用于 Java 7，但没有加入。所以还没有自动的。</p>
<p>你可以使用番石榴的<code>Sets</code>：</p>
<div class="code"><pre class="code literal-block">Sets.newHashSet("a", "b", "c")
</pre></div>

<p>或者您可以使用以下语法，这将创建一个匿名类，但它很老套：</p>
<div class="code"><pre class="code literal-block">Set&lt;String&gt; h = new HashSet&lt;String&gt;() {{
    add("a");
    add("b");
}};
</pre></div>

<p><br><br><a href="posts/how-to-initialize-hashset-values-by-construction/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-bash-zhong-jiang-zi-fu-chuan-chai-fen-wei-shu-zu/" class="u-url">如何在 Bash 中将字符串拆分为数组？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-bash-zhong-jiang-zi-fu-chuan-chai-fen-wei-shu-zu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:23:36+08:00" itemprop="datePublished" title="2023-02-17 10:23">2023-02-17 10:23</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在 Bash 脚本中，我想将一行分成几部分并将它们存储在一个数组中。</p>
<p>例如，给定行：</p>
<div class="code"><pre class="code literal-block">Paris, France, Europe
</pre></div>

<p>我想让结果数组看起来像这样：</p>
<div class="code"><pre class="code literal-block">array[0] = Paris
array[1] = France
array[2] = Europe
</pre></div>

<p>一个简单的实现是可取的；速度无所谓。我该怎么做？</p>
<p><br><br></p>
<h2>解答</h2>
<div class="code"><pre class="code literal-block">IFS=', ' read -r -a array &lt;&lt;&lt; "$string"
</pre></div>

<p>请注意，中的字符<code>$IFS</code>被单独视为分隔符，因此在这种情况下，字段可以用逗号或空格分隔， <em>而</em>
不是两个字符的顺序。有趣的是，当逗号空格出现在输入中时，不会创建空字段，因为该空格被特殊处理。</p>
<p>要访问单个元素：</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="cp">}</span>"
</pre></div>

<p>遍历元素：</p>
<div class="code"><pre class="code literal-block">for<span class="w"> </span>element<span class="w"> </span>in<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">@</span><span class="p">]</span><span class="cp">}</span>"
do
<span class="w">    </span>echo<span class="w"> </span>"<span class="nv">$element</span>"
done
</pre></div>

<p>要同时获取索引和值：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="ss">"${!array[@]}"</span>
<span class="n">do</span>
<span class="w">    </span><span class="n">echo</span><span class="w"> </span><span class="ss">"$index ${array[index]}"</span>
<span class="n">done</span>
</pre></div>

<p>最后一个示例很有用，因为 Bash 数组是稀疏的。换句话说，您可以删除一个元素或添加一个元素，然后索引不连续。</p>
<div class="code"><pre class="code literal-block">unset "array[1]"
array[42]=Earth
</pre></div>

<p>获取数组中元素的数量：</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="c1">#array[@]</span><span class="cp">}</span>"
</pre></div>

<p>如上所述，数组可以是稀疏的，因此您不应使用长度来获取最后一个元素。在 Bash 4.2 及更高版本中，您可以这样做：</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="cp">}</span>"
</pre></div>

<p>在任何版本的 Bash 中（从 2.05b 之后的某个地方）：</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">@</span><span class="p">]:</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="cp">}</span>"
</pre></div>

<p>较大的负偏移会选择距离数组末尾更远的​​位置。注意旧形式中减号前的空格。这是必需的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>这个问题的所有答案在某种程度上都是错误的。</p>
<hr>
<p><strong><em>错误答案 #1</em></strong></p>
<div class="code"><pre class="code literal-block">IFS=', ' read -r -a array &lt;&lt;&lt; "$string"
</pre></div>

<p><strong>1：</strong> 这是对<code>$IFS</code>. <code>$IFS</code>变量的值 <strong>不</strong> 被视为 <em>单个可变长度</em> 字符串分隔符，而是被视为一组 <em>单</em> <em>字符</em>
字符串分隔符，其中<code>read</code>从输入行拆分的每个字段都可以由集合中的 <em>任何</em> 字符终止（在此示例中为逗号 <strong>或</strong> 空格）。</p>
<p>实际上，对于那里真正的坚持者来说，完整的含义<code>$IFS</code>稍微复杂一些。来自bash 手册：</p>
<blockquote>
<p>shell 将 <strong>IFS</strong> 的每个字符视为定界符，并将其他扩展的结果拆分为使用这些字符作为字段终止符的单词。如果 <strong>IFS</strong>
未设置，或者它的值恰好是 <strong>&lt; space&gt;<tab><newline></newline></tab></strong>，默认值，则 <strong>&lt; space&gt;</strong>， <strong>&lt; tab&gt;</strong>和 <strong>&lt;
newline&gt;</strong>序列位于先前扩展结果的开头和结尾被忽略，任何不在开头或结尾的 <strong>IFS</strong> 字符序列都用于分隔单词。如果 <strong>IFS</strong>
具有默认值以外的值，则空白字符序列 <strong>&lt; space&gt;</strong>、 <strong>&lt; tab&gt;</strong>和 <strong>&lt;</strong> 只要空白字符在 <strong>IFS</strong> 的值中（一个
<strong>IFS</strong> 空白字符），在单词的开头和结尾都会被忽略。 <strong>IFS</strong> 中任何不是 <strong>IFS</strong> 空白字符的字符，以及任何相邻的 <strong>IFS</strong>
空白字符，都会对字段进行定界。 <strong>IFS</strong> 空白字符序列也被视为定界符。 <strong>如果IFS</strong> 的值为null，则不会发生分词。</p>
</blockquote>
<p>基本上，对于 的非默认非空值<code>$IFS</code>，字段可以用 (1) 一个或多个字符序列分隔，这些字符全部来自“IFS 空白字符”集（即 <space> 中的任何
<strong>一个</strong> ， <strong>&lt; tab&gt;</strong>和 <strong>&lt; newline&gt;</strong>（“换行符”表示换行符 (LF)）出现在 中的任何位置<code>$IFS</code>，或 (2)
中出现的任何非“IFS 空白字符”及其周围的<code>$IFS</code>任何“IFS 空白字符”在输入行中。</space></p>
<p>对于
OP，我在上一段中描述的第二种分离模式可能正是他想要的输入字符串，但我们可以非常确信我描述的第一种分离模式根本不正确。例如，如果他的输入字符串是<code>'Los
Angeles, United States, North America'</code>？</p>
<div class="code"><pre class="code literal-block">IFS=', ' read -ra a &lt;&lt;&lt;'Los Angeles, United States, North America'; declare -p a;
## declare -a a=([0]="Los" [1]="Angeles" [2]="United" [3]="States" [4]="North" [5]="America")
</pre></div>

<p><strong>2：</strong> 即使您将此解决方案与单字符分隔符（例如逗号本身，即没有后续空格或其他包袱）一起使用，如果变量的值恰好包含任何 LF
<code>$string</code>，<code>read</code>则将一旦遇到第一个 LF 就停止处理。内置<code>read</code>函数每次调用只处理一行。 <em>即使您仅</em>
将输入通过管道或重定向到语句，也是如此<code>read</code>，正如我们在本例中使用here-
string机制所做的那样，因此未处理的输入肯定会丢失。为内置命令提供支持的代码<code>read</code>不知道其包含的命令结构中的数据流。</p>
<p>您可能会争辩说这不太可能导致问题，但仍然是一个微妙的危险，应该尽可能避免。这是由于<code>read</code>内置函数实际上进行了两级输入拆分：首先是行，然后是字段。由于
OP 只想要一级拆分，因此<code>read</code>内置函数的这种用法是不合适的，我们应该避免它。</p>
<p><strong>3：</strong> 此解决方案的一个不明显的潜在问题是，<code>read</code>如果尾随字段为空，则始终删除它，尽管它会保留空字段。这是一个演示：</p>
<div class="code"><pre class="code literal-block">string=', , a, , b, c, , , '; IFS=', ' read -ra a &lt;&lt;&lt;"$string"; declare -p a;
## declare -a a=([0]="" [1]="" [2]="a" [3]="" [4]="b" [5]="c" [6]="" [7]="")
</pre></div>

<p>也许 OP 不会关心这个，但这仍然是一个值得了解的限制。它降低了解决方案的稳健性和通用性。</p>
<p>这个问题可以通过在输入字符串之前附加一个虚拟的尾随分隔符来解决<code>read</code>，我将在后面演示。</p>
<hr>
<p><strong><em>错误答案 #2</em></strong></p>
<div class="code"><pre class="code literal-block">string="1:2:3:4:5"
set<span class="w"> </span>-f<span class="w">                     </span>#<span class="w"> </span>avoid<span class="w"> </span>globbing<span class="w"> </span>(expansion<span class="w"> </span>of<span class="w"> </span>*).
array=(<span class="cp">${</span><span class="n">string</span><span class="o">//</span><span class="p">:</span><span class="o">/</span> <span class="cp">}</span>)
</pre></div>

<p>类似的想法：</p>
<div class="code"><pre class="code literal-block">t="one,two,three"
a=($(echo $t | tr ',' "\n"))
</pre></div>

<p>（注意：我在回答者似乎省略的命令替换周围添加了缺少的括号。）</p>
<p>类似的想法：</p>
<div class="code"><pre class="code literal-block">string="1,2,3,4"
array=(`echo $string | sed 's/,/\n/g'`)
</pre></div>

<p>这些解决方案利用数组分配中的单词拆分将字符串拆分为字段。有趣的是，就像
一样<code>read</code>，一般分词也使用<code>$IFS</code>特殊变量，尽管在这种情况下暗示它被设置为其默认值 <strong>&lt;
space&gt;<tab><newline></newline></tab></strong>，因此一个或多个 IFS 的任何序列字符（现在都是空白字符）被认为是字段定界符。</p>
<p>这解决了
的两级拆分问题<code>read</code>，因为单词拆分本身只构成一级拆分。但是和之前一样，这里的问题是输入字符串中的各个字段已经可以包含<code>$IFS</code>字符，因此在分词操作时它们会被不正确地分割。这些回答者提供的任何示例输入字符串都不是这种情况（多么方便......），但当然这不会改变这样一个事实，即任何使用此习语的代码库都会冒着以下风险如果在某个时候违反了这个假设，它就会爆炸。再次考虑我的<code>'Los
Angeles, United States, North America'</code>(or <code>'Los Angeles:United States:North
America'</code>) 的反例。</p>
<p>此外，分词通常后跟文件名扩展（ <em>又名</em> 路径名扩展 <em>又名</em>
通配符），如果这样做，可能会损坏包含字符<code>*</code>,<code>?</code>或<code>[</code>后跟<code>]</code>（并且，如果<code>extglob</code>已设置，括号内的片段前面有<code>?</code>, <code>*</code>, <code>+</code>,
<code>@</code>,或<code>!</code>) 通过将它们与文件系统对象匹配并相应地扩展单词（“globs”）。这三个回答者中的第一个通过<code>set -f</code>预先运行以禁用
globbing 巧妙地削弱了这个问题。从技术上讲这是可行的（尽管您可能应该添加<code>set +f</code>之后为可能依赖于它的后续代码重新启用
globbing），但是为了在本地代码中破解基本的字符串到数组解析操作而不得不弄乱全局 shell 设置是不可取的。</p>
<p>这个答案的另一个问题是所有空字段都将丢失。这可能是问题，也可能不是问题，具体取决于应用程序。</p>
<p>注意：如果您要使用此解决方案，最好使用参数扩展<code>${string//:/ }</code>的“模式替换”形式，而不是麻烦地调用命令替换（它会分叉
shell）、启动管道，以及运行外部可执行文件（或），因为参数扩展纯粹是 shell
内部操作。（此外，对于和解决方案，输入变量应在命令替换内用双引号引起来；否则分词会在命令中生效，并可能弄乱字段值。此外，命令替换的形式比旧的更可取`tr<code>sed</code>tr<code>sed</code>echo<code>$(...)```...</code>形式，因为它简化了命令替换的嵌套，并允许文本编辑器更好地突出显示语法。）</p>
<hr>
<p><strong><em>错误答案 #3</em></strong></p>
<div class="code"><pre class="code literal-block">str="a,<span class="w"> </span>b,<span class="w"> </span>c,<span class="w"> </span>d"<span class="w">  </span>#<span class="w"> </span>assuming<span class="w"> </span>there<span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span>space<span class="w"> </span>after<span class="w"> </span>','<span class="w"> </span>as<span class="w"> </span>in<span class="w"> </span>Q
arr=(<span class="cp">${</span><span class="nb">str</span><span class="o">//</span><span class="p">,</span><span class="o">/</span><span class="cp">}</span>)<span class="w">  </span>#<span class="w"> </span>delete<span class="w"> </span>all<span class="w"> </span>occurrences<span class="w"> </span>of<span class="w"> </span>','
</pre></div>

<p><strong>这个答案几乎与#2</strong> 相同。不同之处在于，回答者假设字段由两个字符分隔，其中一个字符在 default
中表示<code>$IFS</code>，另一个则不是。他通过使用模式替换扩展删除非 IFS 表示的字符，然后使用单词拆分来拆分幸存的 IFS
表示的定界符上的字段，从而解决了这个相当特殊的情况。</p>
<p>这不是一个非常通用的解决方案。此外，可以说逗号实际上是这里的“主要”分隔符，剥离它然后根据空格字符进行字段拆分是完全错误的。再次考虑我的反例：<code>'Los
Angeles, United States, North America'</code>。</p>
<p>同样，文件名扩展可能会破坏扩展的单词，但这可以通过暂时禁用分配的 globbing 和<code>set -f</code>then来防止<code>set +f</code>。</p>
<p>同样，所有空字段都将丢失，这可能会或可能不会成为问题，具体取决于应用程序。</p>
<hr>
<p><strong><em>错误答案 #4</em></strong></p>
<div class="code"><pre class="code literal-block">string='first<span class="w"> </span>line
second<span class="w"> </span>line
third<span class="w"> </span>line'

oldIFS="<span class="nv">$IFS</span>"
IFS='
'
IFS=<span class="cp">${</span><span class="n">IFS</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="cp">}</span><span class="w"> </span>#<span class="w"> </span>this<span class="w"> </span>is<span class="w"> </span>useful<span class="w"> </span>to<span class="w"> </span>format<span class="w"> </span>your<span class="w"> </span>code<span class="w"> </span>with<span class="w"> </span>tabs
lines=(<span class="w"> </span><span class="nv">$string</span><span class="w"> </span>)
IFS="<span class="nv">$oldIFS</span>"
</pre></div>

<p>这与 <strong>#2</strong> 和 <strong>#3</strong>
相似，因为它使用分词来完成工作，只是现在代码明确设置<code>$IFS</code>为仅包含输入字符串中存在的单字符字段定界符。应该重复的是，这不适用于多字符字段定界符，例如
OP 的逗号空格定界符。但是对于像本例中使用的 LF
这样的单字符定界符，它实际上接近于完美。字段不能像我们在前面的错误答案中看到的那样在中间无意地分裂，并且根据需要只有一层分裂。</p>
<p>一个问题是文件名扩展会破坏受影响的单词，如前所述，尽管这可以通过将关键语句包装在<code>set -f</code>and中来解决<code>set +f</code>。</p>
<p>另一个潜在的问题是，由于 LF 符合前面定义的“IFS 空白字符”，所有空字段都将丢失，就像 <strong>#2</strong> 和 <strong>#3</strong>
中一样。如果定界符恰好是非“IFS 空白字符”，这当然不是问题，并且根据应用程序的不同，这可能无关紧要，但它确实破坏了解决方案的通用性。</p>
<p>因此，总而言之，假设您有一个单字符定界符，并且它是非“IFS 空白字符”或者您不关心空字段，并且将关键语句包装在 and 中，那么此解决<code>set
-f</code>方案<code>set +f</code>有效，但除此之外不是。</p>
<p>（此外，为了提供信息，使用语法可以更轻松地在 bash 中将 LF 分配给变量<code>$'...'</code>，例如<code>IFS=$'\n';</code>.）</p>
<hr>
<p><strong><em>错误答案 #5</em></strong></p>
<div class="code"><pre class="code literal-block">countries='Paris, France, Europe'
OIFS="$IFS"
IFS=', ' array=($countries)
IFS="$OIFS"
</pre></div>

<p>类似的想法：</p>
<div class="code"><pre class="code literal-block">IFS=', ' eval 'array=($string)'
</pre></div>

<p><strong>这个解决方案实际上是#1</strong> （因为它设置<code>$IFS</code>为逗号空间）和 <strong>#2-4</strong>
（因为它使用单词拆分将字符串拆分为字段）之间的交叉。正因为如此，它遭受了困扰上述所有错误答案的大部分问题，有点像世界上最糟糕的问题。</p>
<p>此外，关于第二个变体，调用似乎<code>eval</code>完全没有必要，因为它的参数是单引号字符串文字，因此是静态已知的。<code>eval</code>但实际上以这种方式使用有一个非常不明显的好处。通常，当您运行一个
<em>仅</em> 由变量赋值组成的简单命令时，这意味着它后面没有实际的命令词，赋值在 shell 环境中生效：</p>
<div class="code"><pre class="code literal-block">IFS=', '; ## changes $IFS in the shell environment
</pre></div>

<p><em>即使简单命令涉及多个</em> 变量赋值也是如此；同样，只要没有命令字，所有变量赋值都会影响 shell 环境：</p>
<div class="code"><pre class="code literal-block">IFS=', ' array=($countries); ## changes both $IFS and $array in the shell environment
</pre></div>

<p>但是，如果变量赋值附加到命令名称（我喜欢称之为“前缀赋值”），那么它不会 <em>影响</em> shell 环境，而只会影响执行命令的环境，无论它是否是内置命令或外部：</p>
<div class="code"><pre class="code literal-block"><span class="n">IFS</span><span class="o">=</span><span class="p">',</span><span class="w"> </span><span class="p">'</span><span class="w"> </span><span class="o">:</span><span class="p">;</span><span class="w"> </span><span class="p">##</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">builtin</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">$IFS</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">it</span>
<span class="n">IFS</span><span class="o">=</span><span class="p">',</span><span class="w"> </span><span class="p">'</span><span class="w"> </span><span class="n">env</span><span class="p">;</span><span class="w"> </span><span class="p">##</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">external</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">$IFS</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">it</span>
</pre></div>

<p>bash 手册中的相关引述：</p>
<blockquote>
<p>如果没有命令名称结果，则变量赋值会影响当前的 shell 环境。否则，变量将添加到执行命令的环境中，并且不会影响当前的 shell 环境。</p>
</blockquote>
<p>可以利用变量赋值的这个特性来<code>$IFS</code>临时改变，这使我们能够避免像<code>$OIFS</code>第一个变量中的变量那样的整个保存和恢复策略。但我们在这里面临的挑战是，我们需要运行的命令本身只是一个变量赋值，因此它不会涉及一个命令词来使赋值成为<code>$IFS</code>临时的。你可能会想，为什么不在像
the 这样的语句中添加一个空操作命令词来<code>: builtin</code>使<code>$IFS</code>赋值成为临时的呢？这是行不通的，因为它也会使<code>$array</code>分配成为临时的：</p>
<div class="code"><pre class="code literal-block">IFS=', ' array=($countries) :; ## fails; new $array value never escapes the : command
</pre></div>

<p>所以，我们实际上陷入了僵局，有点像第 22 条军规。但是，当<code>eval</code>运行它的代码时，它在 shell
环境中运行它，就好像它是正常的静态源代码一样，因此我们可以在参数<code>$array</code>内部运行赋值<code>eval</code>，使其在 shell
环境中生效，而<code>$IFS</code>前缀赋值以<code>eval</code>命令为前缀将不会超过命令<code>eval</code>。这正是此解决方案的第二个变体中使用的技巧：</p>
<div class="code"><pre class="code literal-block">IFS=', ' eval 'array=($string)'; ## $IFS does not outlive the eval command, but $array does
</pre></div>

<p>So, as you can see, it's actually quite a clever trick, and accomplishes
exactly what is required (at least with respect to assignment effectation) in
a rather non-obvious way. I'm actually not against this trick in general,
despite the involvement of <code>eval</code>; just be careful to single-quote the
argument string to guard against security threats.</p>
<p>But again, because of the "worst of all worlds" agglomeration of problems,
this is still a wrong answer to the OP's requirement.</p>
<hr>
<p><strong><em>Wrong answer #6</em></strong></p>
<div class="code"><pre class="code literal-block">IFS=', '; array=(Paris, France, Europe)

IFS=' ';declare -a array=(Paris France Europe)
</pre></div>

<p>Um... what? The OP has a string variable that needs to be parsed into an
array. This "answer" starts with the verbatim contents of the input string
pasted into an array literal. I guess that's one way to do it.</p>
<p>It looks like the answerer may have assumed that the <code>$IFS</code> variable affects
all bash parsing in all contexts, which is not true. From the bash manual:</p>
<blockquote>
<p><strong>IFS</strong> The Internal Field Separator that is used for word splitting after
expansion and to split lines into words with the <strong>read</strong> builtin command.
The default value is <strong>&lt; space&gt;<tab><newline></newline></tab></strong>.</p>
</blockquote>
<p>So the <code>$IFS</code> special variable is actually only used in two contexts: (1) word
splitting that is performed <em>after expansion</em> (meaning <em>not</em> when parsing bash
source code) and (2) for splitting input lines into words by the <code>read</code>
builtin.</p>
<p>Let me try to make this clearer. I think it might be good to draw a
distinction between <em>parsing</em> and <em>execution</em>. Bash must first <em>parse</em> the
source code, which obviously is a <em>parsing</em> event, and then later it
<em>executes</em> the code, which is when expansion comes into the picture. Expansion
is really an <em>execution</em> event. Furthermore, I take issue with the description
of the <code>$IFS</code> variable that I just quoted above; rather than saying that word
splitting is performed <em>after expansion</em> , I would say that word splitting is
performed <em>during</em> expansion, or, perhaps even more precisely, word splitting
is <em>part of</em> the expansion process. The phrase "word splitting" refers only to
this step of expansion; it should never be used to refer to the parsing of
bash source code, although unfortunately the docs do seem to throw around the
words "split" and "words" a lot. Here's a relevant excerpt from the
linux.die.net version of the bash manual:</p>
<blockquote>
<p>Expansion is performed on the command line after it has been split into
words. There are seven kinds of expansion performed: <em>brace expansion</em> ,
<em>tilde expansion</em> , <em>parameter and variable expansion</em> , <em>command
substitution</em> , <em>arithmetic expansion</em> , <em>word splitting</em> , and <em>pathname
expansion</em>.</p>
<p>The order of expansions is: brace expansion; tilde expansion, parameter and
variable expansion, arithmetic expansion, and command substitution (done in
a left-to-right fashion); word splitting; and pathname expansion.</p>
</blockquote>
<p>You could argue the GNU version of the manual does slightly better, since it
opts for the word "tokens" instead of "words" in the first sentence of the
Expansion section:</p>
<blockquote>
<p>Expansion is performed on the command line after it has been split into
tokens.</p>
</blockquote>
<p>The important point is, <code>$IFS</code> does not change the way bash parses source
code. Parsing of bash source code is actually a very complex process that
involves recognition of the various elements of shell grammar, such as command
sequences, command lists, pipelines, parameter expansions, arithmetic
substitutions, and command substitutions. For the most part, the bash parsing
process cannot be altered by user-level actions like variable assignments
(actually, there are some minor exceptions to this rule; for example, see the
various <code>compatxx</code> shell settings, which can change certain aspects of parsing
behavior on-the-fly). The upstream "words"/"tokens" that result from this
complex parsing process are then expanded according to the general process of
"expansion" as broken down in the above documentation excerpts, where word
splitting of the expanded (expanding?) text into downstream words is simply
one step of that process. Word splitting only touches text that has been spit
out of a preceding expansion step; it does not affect literal text that was
parsed right off the source bytestream.</p>
<hr>
<p><strong><em>Wrong answer #7</em></strong></p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span><span class="err">'first line</span>
<span class="err">        second line</span>
<span class="w">        </span><span class="nv">third</span><span class="w"> </span><span class="nv">line</span><span class="err">'</span>

<span class="err">while read -r line; do lines+=("$line"); done &lt;&lt;&lt;"$string"</span>
</pre></div>

<p>This is one of the best solutions. Notice that we're back to using <code>read</code>.
Didn't I say earlier that <code>read</code> is inappropriate because it performs two
levels of splitting, when we only need one? The trick here is that you can
call <code>read</code> in such a way that it effectively only does one level of
splitting, specifically by splitting off only one field per invocation, which
necessitates the cost of having to call it repeatedly in a loop. It's a bit of
a sleight of hand, but it works.</p>
<p>But there are problems. First: When you provide at least one <em>NAME</em> argument
to <code>read</code>, it automatically ignores leading and trailing whitespace in each
field that is split off from the input string. This occurs whether <code>$IFS</code> is
set to its default value or not, as described earlier in this post. Now, the
OP may not care about this for his specific use-case, and in fact, it may be a
desirable feature of the parsing behavior. But not everyone who wants to parse
a string into fields will want this. There is a solution, however: A somewhat
non-obvious usage of <code>read</code> is to pass zero <em>NAME</em> arguments. In this case,
<code>read</code> will store the entire input line that it gets from the input stream in
a variable named <code>$REPLY</code>, and, as a bonus, it does <em>not</em> strip leading and
trailing whitespace from the value. This is a very robust usage of <code>read</code>
which I've exploited frequently in my shell programming career. Here's a
demonstration of the difference in behavior:</p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span>$<span class="s1">'  a  b  \n  c  d  \n  e  f  '</span><span class="c1">; ## input string</span>

<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -r line; do a+=("$line"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"a  b"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">"c  d"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">"e  f"</span><span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">read</span><span class="w"> </span><span class="nv">trimmed</span><span class="w"> </span><span class="nv">surrounding</span><span class="w"> </span><span class="nv">whitespace</span>

<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -r; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"  a  b  "</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">"  c  d  "</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">"  e  f  "</span><span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">no</span><span class="w"> </span><span class="nv">trimming</span>
</pre></div>

<p>The second issue with this solution is that it does not actually address the
case of a custom field separator, such as the OP's comma-space. As before,
multicharacter separators are not supported, which is an unfortunate
limitation of this solution. We could try to at least split on comma by
specifying the separator to the <code>-d</code> option, but look what happens:</p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span><span class="s1">'Paris, France, Europe'</span><span class="c1">;</span>
<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="ss">)</span>
</pre></div>

<p>Predictably, the unaccounted surrounding whitespace got pulled into the field
values, and hence this would have to be corrected subsequently through
trimming operations (this could also be done directly in the while-loop). But
there's another obvious error: Europe is missing! What happened to it? The
answer is that <code>read</code> returns a failing return code if it hits end-of-file (in
this case we can call it end-of-string) without encountering a final field
terminator on the final field. This causes the while-loop to break prematurely
and we lose the final field.</p>
<p>Technically this same error afflicted the previous examples as well; the
difference there is that the field separator was taken to be LF, which is the
default when you don't specify the <code>-d</code> option, and the <code>&lt;&lt;&lt;</code> ("here-string")
mechanism automatically appends a LF to the string just before it feeds it as
input to the command. Hence, in those cases, we sort of <em>accidentally</em> solved
the problem of a dropped final field by unwittingly appending an additional
dummy terminator to the input. Let's call this solution the "dummy-terminator"
solution. We can apply the dummy-terminator solution manually for any custom
delimiter by concatenating it against the input string ourselves when
instantiating it in the here-string:</p>
<div class="code"><pre class="code literal-block"><span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,; do a+=("$REPLY"); done &lt;&lt;&lt;"$string,"; declare -p a;</span>
<span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">" Europe"</span><span class="ss">)</span>
</pre></div>

<p>There, problem solved. Another solution is to only break the while-loop if
both (1) <code>read</code> returned failure and (2) <code>$REPLY</code> is empty, meaning <code>read</code> was
not able to read any characters prior to hitting end-of-file. Demo:</p>
<div class="code"><pre class="code literal-block"><span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,|| [[ -n "$REPLY" ]]; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span>$<span class="s1">' Europe\n'</span><span class="ss">)</span>
</pre></div>

<p>This approach also reveals the secretive LF that automatically gets appended
to the here-string by the <code>&lt;&lt;&lt;</code> redirection operator. It could of course be
stripped off separately through an explicit trimming operation as described a
moment ago, but obviously the manual dummy-terminator approach solves it
directly, so we could just go with that. The manual dummy-terminator solution
is actually quite convenient in that it solves both of these two problems (the
dropped-final-field problem and the appended-LF problem) in one go.</p>
<p>So, overall, this is quite a powerful solution. It's only remaining weakness
is a lack of support for multicharacter delimiters, which I will address
later.</p>
<hr>
<p><strong><em>Wrong answer #8</em></strong></p>
<div class="code"><pre class="code literal-block">string='first line
        second line
        third line'

readarray -t lines &lt;&lt;&lt;"$string"
</pre></div>

<p>(This is actually from the same post as <strong>#7</strong> ; the answerer provided two
solutions in the same post.)</p>
<p>The <code>readarray</code> builtin, which is a synonym for <code>mapfile</code>, is ideal. It's a
builtin command which parses a bytestream into an array variable in one shot;
no messing with loops, conditionals, substitutions, or anything else. And it
doesn't surreptitiously strip any whitespace from the input string. And (if
<code>-O</code> is not given) it conveniently clears the target array before assigning to
it. But it's still not perfect, hence my criticism of it as a "wrong answer".</p>
<p>First, just to get this out of the way, note that, just like the behavior of
<code>read</code> when doing field-parsing, <code>readarray</code> drops the trailing field if it is
empty. Again, this is probably not a concern for the OP, but it could be for
some use-cases. I'll come back to this in a moment.</p>
<p>Second, as before, it does not support multicharacter delimiters. I'll give a
fix for this in a moment as well.</p>
<p>Third, the solution as written does not parse the OP's input string, and in
fact, it cannot be used as-is to parse it. I'll expand on this momentarily as
well.</p>
<p>For the above reasons, I still consider this to be a "wrong answer" to the
OP's question. Below I'll give what I consider to be the right answer.</p>
<hr>
<p><strong>Right answer</strong></p>
<p>Here's a naïve attempt to make <strong>#8</strong> work by just specifying the <code>-d</code> option:</p>
<div class="code"><pre class="code literal-block">string='Paris, France, Europe';
readarray -td, a &lt;&lt;&lt;"$string"; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=$' Europe\n')
</pre></div>

<p>We see the result is identical to the result we got from the double-
conditional approach of the looping <code>read</code> solution discussed in <strong>#7</strong>. We
can <em>almost</em> solve this with the manual dummy-terminator trick:</p>
<div class="code"><pre class="code literal-block">readarray -td, a &lt;&lt;&lt;"$string,"; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=" Europe" [3]=$'\n')
</pre></div>

<p>The problem here is that <code>readarray</code> preserved the trailing field, since the
<code>&lt;&lt;&lt;</code> redirection operator appended the LF to the input string, and therefore
the trailing field was <em>not</em> empty (otherwise it would've been dropped). We
can take care of this by explicitly unsetting the final array element after-
the-fact:</p>
<div class="code"><pre class="code literal-block">readarray -td, a &lt;&lt;&lt;"$string,"; unset 'a[-1]'; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=" Europe")
</pre></div>

<p>The only two problems that remain, which are actually related, are (1) the
extraneous whitespace that needs to be trimmed, and (2) the lack of support
for multicharacter delimiters.</p>
<p>The whitespace could of course be trimmed afterward (for example, see How to
trim whitespace from a Bash variable?). But if we can hack a multicharacter
delimiter, then that would solve both problems in one shot.</p>
<p>Unfortunately, there's no <em>direct</em> way to get a multicharacter delimiter to
work. The best solution I've thought of is to preprocess the input string to
replace the multicharacter delimiter with a single-character delimiter that
will be guaranteed not to collide with the contents of the input string. The
only character that has this guarantee is the NUL byte. This is because, in
bash (though not in zsh, incidentally), variables cannot contain the NUL byte.
This preprocessing step can be done inline in a process substitution. Here's
how to do it using awk:</p>
<div class="code"><pre class="code literal-block">readarray -td '' a &lt; &lt;(awk '{ gsub(/, /,"\0"); print; }' &lt;&lt;&lt;"$string, "); unset 'a[-1]';
declare -p a;
## declare -a a=([0]="Paris" [1]="France" [2]="Europe")
</pre></div>

<p>There, finally! This solution will not erroneously split fields in the middle,
will not cut out prematurely, will not drop empty fields, will not corrupt
itself on filename expansions, will not automatically strip leading and
trailing whitespace, will not leave a stowaway LF on the end, does not require
loops, and does not settle for a single-character delimiter.</p>
<hr>
<p><strong>Trimming solution</strong></p>
<p>Lastly, I wanted to demonstrate my own fairly intricate trimming solution
using the obscure <code>-C callback</code> option of <code>readarray</code>. Unfortunately, I've run
out of room against Stack Overflow's draconian 30,000 character post limit, so
I won't be able to explain it. I'll leave that as an exercise for the reader.</p>
<div class="code"><pre class="code literal-block">function<span class="w"> </span>mfcb<span class="w"> </span>{<span class="w"> </span>local<span class="w"> </span>val="$4";<span class="w"> </span>"$1";<span class="w"> </span>eval<span class="w"> </span>"$2[$3]=\<span class="nv">$val</span>;";<span class="w"> </span>};
function<span class="w"> </span>val_ltrim<span class="w"> </span>{<span class="w"> </span>if<span class="w"> </span>[[<span class="w"> </span>"<span class="nv">$val</span>"<span class="w"> </span>=~<span class="w"> </span>^[[:space:]]+<span class="w"> </span>]];<span class="w"> </span>then<span class="w"> </span>val="<span class="cp">${</span><span class="n">val</span><span class="p">:</span><span class="err">$</span><span class="p">{</span><span class="c1">#BASH_REMATCH[0]</span><span class="cp">}</span>}";<span class="w"> </span>fi;<span class="w"> </span>};
function<span class="w"> </span>val_rtrim<span class="w"> </span>{<span class="w"> </span>if<span class="w"> </span>[[<span class="w"> </span>"<span class="nv">$val</span>"<span class="w"> </span>=~<span class="w"> </span>[[:space:]]+$<span class="w"> </span>]];<span class="w"> </span>then<span class="w"> </span>val="<span class="cp">${</span><span class="n">val</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="err">$</span><span class="p">{</span><span class="c1">#val</span><span class="cp">}</span>-<span class="cp">${</span><span class="c1">#BASH_REMATCH[0]</span><span class="cp">}</span>}";<span class="w"> </span>fi;<span class="w"> </span>};
function<span class="w"> </span>val_trim<span class="w"> </span>{<span class="w"> </span>val_ltrim;<span class="w"> </span>val_rtrim;<span class="w"> </span>};
readarray<span class="w"> </span>-c1<span class="w"> </span>-C<span class="w"> </span>'mfcb<span class="w"> </span>val_trim<span class="w"> </span>a'<span class="w"> </span>-td,<span class="w"> </span><span class="err">&lt;&lt;&lt;</span>"<span class="nv">$string</span>,";<span class="w"> </span>unset<span class="w"> </span>'a[-1]';<span class="w"> </span>declare<span class="w"> </span>-p<span class="w"> </span>a;
##<span class="w"> </span>declare<span class="w"> </span>-a<span class="w"> </span>a=([0]="Paris"<span class="w"> </span>[1]="France"<span class="w"> </span>[2]="Europe")
</pre></div>

<p><br><br><a href="posts/how-to-split-a-string-into-an-array-in-bash/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-572.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-570.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
