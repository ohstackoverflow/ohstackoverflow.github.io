<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 765) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-765.html">
<link rel="prev" href="index-766.html" type="text/html">
<link rel="next" href="index-764.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-ru-he-zhi-dao-bash-jiao-ben-zhong-de-jiao-ben-wen-jian-ming/" class="u-url">我如何知道 Bash 脚本中的脚本文件名？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-ru-he-zhi-dao-bash-jiao-ben-zhong-de-jiao-ben-wen-jian-ming/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:32:58+08:00" itemprop="datePublished" title="2023-02-17 15:32">2023-02-17 15:32</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何确定脚本本身内的 Bash 脚本文件的名称？</p>
<p>就像我的脚本在文件中一样<code>runme.sh</code>，那么我将如何在不对其进行硬编码的情况下显示“您正在运行 runme.sh”消息？</p>
<p><br><br></p>
<h2>解答</h2>
<div class="code"><pre class="code literal-block"><span class="nv">me</span><span class="o">=</span>`<span class="k">basename</span><span class="w"> </span><span class="s2">"$0"</span>`
</pre></div>

<p>要通过符号链接1阅读，这通常不是您想要的（您通常不想以这种方式混淆用户），请尝试：</p>
<div class="code"><pre class="code literal-block"><span class="nv">me</span><span class="o">=</span><span class="s2">"$(basename "</span>$<span class="ss">(</span><span class="nv">test</span><span class="w"> </span><span class="o">-</span><span class="nv">L</span><span class="w"> </span><span class="s2">"$0"</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">readlink</span><span class="w"> </span><span class="s2">"$0"</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$0"</span><span class="ss">)</span><span class="s2">")"</span>
</pre></div>

<p>IMO，这会产生令人困惑的输出。“我运行了 foo.sh，但它说我正在运行 bar.sh！？一定是一个错误！”
此外，使用不同名称的符号链接的目的之一是根据其名称提供不同的功能（想想某些平台上的 gzip 和 gunzip）。</p>
<hr>
<p>1也就是说，要解析符号链接，以便当用户执行<code>foo.sh</code>实际上是指向
的符号链接时<code>bar.sh</code>，您希望使用解析后的名称<code>bar.sh</code>而不是<code>foo.sh</code>。</p>
<p><br></p>
<h3>更多建议</h3>
<div class="code"><pre class="code literal-block"><span class="c">＃  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> 脚本  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> ＃</span>

<span class="c">#!/bin/bash</span>

<span class="c">echo</span>
<span class="c">echo "# arguments called with </span><span class="nb">----</span><span class="nv">&gt;</span><span class="c">  ${@}     "</span>
<span class="c">echo "# \$1 </span><span class="nb">----------------------</span><span class="nv">&gt;</span><span class="c">  $1       "</span>
<span class="c">echo "# \$2 </span><span class="nb">----------------------</span><span class="nv">&gt;</span><span class="c">  $2       "</span>
<span class="c">echo "# path to me </span><span class="nb">---------------</span><span class="nv">&gt;</span><span class="c">  ${0}     "</span>
<span class="c">echo "# parent path </span><span class="nb">--------------</span><span class="nv">&gt;</span><span class="c">  ${0%/*}  "</span>
<span class="c">echo "# my name </span><span class="nb">------------------</span><span class="nv">&gt;</span><span class="c">  ${0##*/} "</span>
<span class="c">echo</span>
<span class="c">exit</span>

<span class="c"># </span><span class="nb">--------------</span><span class="c"> 调用 </span><span class="nb">--------------</span><span class="c"> #</span>

<span class="c"># 注意下一行，第一个参数在 double 中被调用，</span>
<span class="c"># 和单引号，因为它包含两个词</span>

<span class="c">**$ /misc/shell_scripts/check_root/show_parms</span><span class="nt">.</span><span class="c">sh “‘你好’” “‘威廉’”**</span>

<span class="c">＃  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> 结果  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> ＃</span>

<span class="c"># 调用参数 </span><span class="nb">---</span><span class="nv">&gt;</span><span class="c"> 'hello there' 'william'</span>
<span class="c"># $1 </span><span class="nb">----------------------</span><span class="nv">&gt;</span><span class="c"> '你好'</span>
<span class="c"># $2 </span><span class="nb">----------------------</span><span class="nv">&gt;</span><span class="c"> '威廉'</span>
<span class="c"># 我的路径 </span><span class="nb">--------------</span><span class="nv">&gt;</span><span class="c"> /misc/shell_scripts/check_root/show_parms</span><span class="nt">.</span><span class="c">sh</span>
<span class="c"># 父路径</span><span class="nb">------------</span><span class="nv">&gt;</span><span class="c"> /misc/shell_scripts/check_root</span>
<span class="c"># 我的名字 </span><span class="nb">------------------</span><span class="nv">&gt;</span><span class="c"> show_parms</span><span class="nt">.</span><span class="c">sh</span>

<span class="c">＃  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> 结尾  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c">  </span><span class="nb">-</span><span class="c"> </span><span class="nb">-</span><span class="c"> ＃</span>
</pre></div>

<p><br><br><a href="posts/how-do-i-know-the-script-file-name-in-a-bash-script/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-linuxming-ling-xing-zhong-ti-huan-duo-ge-wen-jian-zhong-de-zi-fu-chuan/" class="u-url">如何在linux命令行中替换多个文件中的字符串</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-linuxming-ling-xing-zhong-ti-huan-duo-ge-wen-jian-zhong-de-zi-fu-chuan/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:31:47+08:00" itemprop="datePublished" title="2023-02-17 15:31">2023-02-17 15:31</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我需要替换文件夹中很多文件中的字符串，只能<code>ssh</code>访问服务器。我怎样才能做到这一点？</p>
<p><br><br></p>
<h2>解答</h2>
<div class="code"><pre class="code literal-block">cd /path/to/your/folder
sed -i 's/foo/bar/g' *
</pre></div>

<p>出现的“foo”将被替换为“bar”。</p>
<p>在像 macOS 这样的 BSD 系统上，您需要提供一个备份扩展，<code>-i '.bak'</code>或者按照联机帮助页提供“风险损坏或部分内容”。</p>
<div class="code"><pre class="code literal-block">cd /path/to/your/folder
sed -i '.bak' 's/foo/bar/g' *
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>类似于 Kaspar 的回答，但使用 g 标志替换一行中所有出现的地方。</p>
<div class="code"><pre class="code literal-block"><span class="nv">find</span><span class="w"> </span>.<span class="o">/</span><span class="w"> </span><span class="o">-</span><span class="nv">type</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">-</span><span class="k">exec</span><span class="w"> </span><span class="nv">sed</span><span class="w"> </span><span class="o">-</span><span class="nv">i</span><span class="w"> </span><span class="s1">'s/old_string/new_string/g'</span><span class="w"> </span>{}<span class="w"> </span>\<span class="c1">;</span>
</pre></div>

<p>对于不区分大小写的全局：</p>
<div class="code"><pre class="code literal-block"><span class="nv">find</span><span class="w"> </span>.<span class="o">/</span><span class="w"> </span><span class="o">-</span><span class="nv">type</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">-</span><span class="k">exec</span><span class="w"> </span><span class="nv">sed</span><span class="w"> </span><span class="o">-</span><span class="nv">i</span><span class="w"> </span><span class="s1">'s/old_string/new_string/gI'</span><span class="w"> </span>{}<span class="w"> </span>\<span class="c1">;</span>
</pre></div>

<p><br><br><a href="posts/how-to-replace-a-string-in-multiple-files-in-linux-command-line/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-ying-yong-cheng-xu-er-jin-zhi-jie-kou-abi/" class="u-url">什么是应用程序二进制接口 (ABI)？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-ying-yong-cheng-xu-er-jin-zhi-jie-kou-abi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:31:18+08:00" itemprop="datePublished" title="2023-02-17 15:31">2023-02-17 15:31</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我一直不清楚什么是 ABI。请不要将我指向维基百科文章。如果我能看懂，我就不会在这里发这么长的帖子了。</p>
<p>这是我对不同接口的看法：</p>
<p>电视遥控器是用户和电视之间的接口。它是一个现有实体，但本身无用（不提供任何功能）。遥控器上每个按钮的所有功能都在电视机中实现。</p>
<blockquote>
<p><strong>接口：</strong><code>functionality</code>它是该功能和该功能之间的“现有实体”层<code>consumer</code>。接口本身不做任何事情。它只是调用隐藏在后面的功能。</p>
<p>现在根据用户是谁，有不同类型的界面。</p>
<p><strong>命令行界面 (CLI)</strong> 命令是现有实体，消费者是用户，功能位于后面。</p>
<p><code>functionality:</code>我的软件功能解决了我们描述此界面的某些目的。</p>
<p><code>existing entities:</code>命令</p>
<p><code>consumer:</code>用户</p>
<p><strong>图形用户界面 (GUI)</strong> 窗口、按钮等是现有实体，而消费者又是用户，功能在后面。</p>
<p><code>functionality:</code>我的软件功能解决了我们描述此界面的一些问题。</p>
<p><code>existing entities:</code>窗口，按钮等。</p>
<p><code>consumer:</code>用户</p>
<p><strong>应用程序编程接口（API）</strong> 功能（或更正确）接口（在基于接口的编程中）是现有实体，这里的消费者是另一个程序而不是用户，功能再次位于这一层之后。</p>
<p><code>functionality:</code>我的软件功能解决了我们描述此界面的一些问题。</p>
<p><code>existing entities:</code>函数，接口（函数数组）。</p>
<p><code>consumer:</code>另一个程序/应用程序。</p>
<p><strong>应用程序二进制接口 (ABI)</strong> 这是我的问题开始的地方。</p>
<p><code>functionality:</code>？？？</p>
<p><code>existing entities:</code>？？？</p>
<p><code>consumer:</code>？？？</p>
</blockquote>
<ul>
<li>我用不同的语言编写过软件并提供了不同类型的接口（CLI、GUI 和 API），但我不确定我是否提供过任何 ABI。</li>
</ul>
<p>维基百科说：</p>
<blockquote>
<p>ABI 涵盖细节，例如</p>
<ul>
<li>数据类型、大小和对齐方式；</li>
<li>调用约定，它控制函数参数的传递方式和返回值的检索方式；</li>
<li>系统调用号以及应用程序应如何对操作系统进行系统调用；
</li>
</ul>
<p>其他 ABI 标准化细节，例如</p>
<ul>
<li>C++ 名称修改，</li>
<li>异常传播，和</li>
<li>同一平台上编译器之间的调用约定，但不需要跨平台兼容性。
</li>
</ul>
</blockquote>
<ul>
<li>
<p>谁需要这些细节？请不要说操作系统。我知道汇编编程。我知道链接和加载是如何工作的。我很清楚里面发生了什么。</p>
</li>
<li>
<p>为什么会出现 C++ 名称修改？我以为我们正在谈论二进制级别。为什么会出现语言？</p>
</li>
</ul>
<p>不管怎样，我已经下载了[PDF] System V Application Binary Interface <em>Edition 4.1
(1997-03-18)</em> 看看它到底包含什么。好吧，其中大部分没有任何意义。</p>
<ul>
<li>
<p>为什么它包含两章（第 4 和第 5 章）来描述ELF文件格式？事实上，这些是该规范中仅有的两个重要章节。其余章节是“特定于处理器的”。无论如何，我认为这是一个完全不同的话题。请不要说 ELF 文件格式规范 <em>就是</em> ABI。根据定义，它没有资格成为 <em>接口。</em></p>
</li>
<li>
<p>我知道，既然我们是在这么低的层面上谈论它，那一定是非常具体的。但我不确定“指令集架构（ISA）”具体如何？</p>
</li>
<li>
<p>在哪里可以找到 Microsoft Windows 的 ABI？</p>
</li>
</ul>
<p>所以，这些是困扰我的主要问题。</p>
<p><br><br></p>
<h2>解答</h2>
<p>理解“ABI”的一种简单方法是将其与“API”进行比较。</p>
<p>您已经熟悉 API 的概念。如果您想使用某些库或您的操作系统的功能，您将针对 API 进行编程。API
由数据类型/结构、常量、函数等组成，您可以在代码中使用它们来访问该外部组件的功能。</p>
<p>ABI 非常相似。将其视为 API 的编译版本（或机器语言级别的 API）。当您编写源代码时，您可以通过 API 访问该库。编译代码后，您的应用程序将通过
ABI 访问库中的二进制数据。ABI 定义了编译后的应用程序将用于访问外部库的结构和方法（就像 API 所做的那样），只是在较低级别上。您的 API
定义了将参数传递给函数的顺序。 <em>您的 ABI 定义了如何</em> 传递这些参数的机制（寄存器、堆栈等）。您的 API 定义了哪些函数是您的库的一部分。您的
ABI 定义了您的代码如何存储在库文件中，以便使用您的库的任何程序都可以找到所需的函数并执行它。</p>
<p>当涉及到使用外部库的应用程序时，ABI 很重要。库中充满了代码和其他资源，但您的程序必须知道如何在库文件中找到它需要的内容。您的 ABI
定义了库的内容如何存储在文件中，您的程序使用 ABI 来搜索文件并找到它需要的内容。如果系统中的所有内容都符合相同的
ABI，那么任何程序都可以使用任何库文件，无论它们是谁创建的。Linux 和 Windows 使用不同的 ABI，因此 Windows 程序不知道如何访问为
Linux 编译的库。</p>
<p>有时，ABI 更改是不可避免的。发生这种情况时，任何使用该库的程序都将无法运行，除非重新编译它们以使用该库的新版本。如果 ABI 改变但 API
没有改变，那么新旧库版本有时被称为“源代码兼容”。这意味着虽然为一个库版本编译的程序不能与另一个版本一起使用，但如果重新编译，为一个版本编写的源代码将适用于另一个版本。</p>
<p>出于这个原因，开发人员倾向于尝试保持他们的 ABI 稳定（以尽量减少中断）。保持 ABI
稳定意味着不更改函数接口（返回类型和数字、类型和参数顺序）、数据类型或数据结构的定义、定义的常量等。可以添加新的函数和数据类型，但必须保留现有的相同。例如，如果您的库使用
32 位整数来指示函数的偏移量，而您切换到 64 位整数，那么使用该库的已编译代码将无法正确访问该字段（或其后的任何字段） .
访问数据结构成员在编译期间被转换为内存地址和偏移量，如果数据结构发生变化，那么这些偏移量将不会指向代码期望它们指向的位置，结果充其量是不可预测的。</p>
<p>ABI 不一定是您明确提供的东西，除非您正在进行非常低级的系统设计工作。它也不是特定于语言的，因为（例如）C 应用程序和 Pascal
应用程序在编译后可以使用相同的 ABI。</p>
<p><strong>编辑：</strong> 关于 SysV ABI 文档中有关 ELF 文件格式的章节的问题：包含此信息的原因是因为 ELF
格式定义了操作系统和应用程序之间的接口。当您告诉操作系统运行一个程序时，它希望程序以某种方式格式化，并且（例如）希望二进制文件的第一部分是一个 ELF
标头，其中包含特定内存偏移处的某些信息。这就是应用程序将有关自身的重要信息传递给操作系统的方式。如果您以非 ELF 二进制格式（例如 a.out 或
PE）构建程序，则需要 ELF 格式应用程序的操作系统将无法解释二进制文件或运行该应用程序。</p>
<p>IIRC，Windows 当前使用可移植可执行文件（或 PE）格式。该维基百科页面的“外部链接”部分中有链接，其中包含有关 PE 格式的更多信息。</p>
<p>另外，关于您关于 C++ 名称修改的注释：在库文件中定位函数时，通常按名称查找函数。C++ 允许您重载函数名称，因此名称本身不足以识别函数。C++
编译器有自己的内部处理方式，称为 <em>name mangling</em> 。ABI
可以定义一种对函数名称进行编码的标准方式，以便使用不同语言或编译器构建的程序可以找到它们需要的内容。当您<code>extern "c"</code>在 C++
程序中使用时，您是在指示编译器使用一种标准化的方式来记录其他软件可以理解的名称。</p>
<p><br></p>
<h3>更多建议</h3>
<p>如果您了解汇编以及操作系统级别的工作原理，那么您就符合某个 ABI。ABI 管理诸如参数传递方式、返回值放置位置等事情。对于许多平台来说，只有一个 ABI
可供选择，在那些情况下，ABI 就是“事物如何工作”。</p>
<p>但是，ABI 还管理诸如类/对象在 C++
中的布局方式之类的事情。如果您希望能够跨模块边界传递对象引用，或者如果您希望混合使用不同编译器编译的代码，那么这是必需的。</p>
<p>此外，如果你有一个可以执行 32 位二进制文​​件的 64 位操作系统，你将有不同的 ABI 用于 32 位和 64 位代码。</p>
<p>通常，您链接到同一可执行文件的任何代码都必须符合同一 ABI。如果要在使用不同 ABI 的代码之间进行通信，则必须使用某种形式的 RPC 或序列化协议。</p>
<p>我认为您太过努力地将不同类型的界面挤入一组固定的特征中。例如，接口不一定必须分为消费者和生产者。接口只是两个实体交互的约定。</p>
<p>ABI 可以（部分）与 ISA 无关。某些方面（例如调用约定）取决于 ISA，而其他方面（例如 C++ 类布局）则不依赖。</p>
<p>定义良好的 ABI 对于编写编译器的人来说非常重要。如果没有定义良好的 ABI，就不可能生成可互操作的代码。</p>
<p>编辑：一些说明要澄清：</p>
<ul>
<li>ABI 中的“二进制”不排除使用字符串或文本。如果要链接导出 C++ 类的 DLL，则必须在其中的某处对方法和类型签名进行编码。这就是 C++ 名称修改的用武之地。</li>
<li>您从未提供 ABI 的原因是绝大多数程序员永远不会这样做。ABI 由设计平台（即操作系统）的同一个人提供，很少有程序员有幸设计出广泛使用的 ABI。</li>
</ul>
<p><br><br><a href="posts/what-is-an-application-binary-interface-abi/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-766.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-764.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
