<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1382) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1382.html">
<link rel="prev" href="index-1383.html" type="text/html">
<link rel="next" href="index-1381.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/store-orientation-to-an-array-and-compare/" class="u-url">Store orientation to an array - and compare</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/store-orientation-to-an-array-and-compare/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:50:19+08:00" itemprop="datePublished" title="2023-02-28 02:50">2023-02-28 02:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I want to achieve the following:</p>
<p>I want the user to be able to "record" the movement of the iPhone using the
gyroscope. And after that, the user should be able to replicate the same
movement. I extract the pitch, roll and yaw using:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">motionManager</span><span class="w"> </span><span class="n">startDeviceMotionUpdatesToQueue</span><span class="o">:</span><span class="p">[</span><span class="bp">NSOperationQueue</span><span class="w"> </span><span class="n">currentQueue</span><span class="p">]</span>
<span class="w">                                       </span><span class="nl">withHandler</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="p">(</span><span class="bp">CMDeviceMotion</span><span class="w"> </span><span class="o">*</span><span class="n">motion</span><span class="p">,</span><span class="w"> </span><span class="bp">NSError</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="p">)</span>
<span class="w">     </span><span class="p">{</span>
<span class="w">         </span><span class="bp">CMAttitude</span><span class="w"> </span><span class="o">*</span><span class="n">attitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">motion</span><span class="p">.</span><span class="n">attitude</span><span class="p">;</span>
<span class="w">         </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@"pitch: %f, roll: %f, yaw: %f]"</span><span class="p">,</span><span class="w"> </span><span class="n">attitude</span><span class="p">.</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="n">attitude</span><span class="p">.</span><span class="n">roll</span><span class="p">,</span><span class="w"> </span><span class="n">attitude</span><span class="p">.</span><span class="n">yaw</span><span class="p">);</span>
<span class="w">     </span><span class="p">}];</span>
</pre></div>

<p>I'm thinking that I could store these values into an array, if the user is in
record mode. And when the user tries to replicate that movement, I'm could
compare the replicated movement array to the recorded one. <strong>The thing is, how
can I compare the two arrays in a smart way?</strong> They will never have exactly
the same values, but they can be somewhat the same.</p>
<p>Am I at all on the right track here?</p>
<p><strong>UPDATE:</strong> I think that maybe Alis answer about using DTW could be the right
way for me here. But I'm not that smart (apparently), so if anyone could help
me out with the first steps with comparing to arrays I would be a happy man!</p>
<p>Thanks!</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Try <strong>dynamic time warping</strong>. Here is an illustrative example with 1D arrays.
In the database we already have the following 2 arrays:</p>
<p>Array 1: <code>[5, 3, 1]</code><br>
Array 2: <code>[1, 3, 5, 8, 8]</code></p>
<p>We measured <code>[2, 4, 6, 7]</code>. Which array is the most similar to the newly
measured? Obviously, the second array is similar to the newly measured and the
first is not.</p>
<p>Let's compute the cost matrices according to this paper, subsection 2.1:</p>
<div class="code"><pre class="code literal-block">D(i,j)=Dist(i,j)+MIN(D(i-1,j),D(i,j-1),D(i-1,j-1))
</pre></div>

<p>Here <code>D(i,j)</code> is the <code>(i,j)</code> element of the cost matrix, see below. Check
Figure 3 of that paper to see this recurrence relation is applied. In short:
columns are computed first, starting from <code>D(1,1)</code>; <code>D(0,*)</code> and <code>D(*,0)</code> are
left out in the MIN. If we are comparing arrays <code>A</code> and <code>B</code> then <code>Dist(i,j)</code>
is the distance between <code>A[i]</code> and <code>B[j]</code>. I simply used <code>ABS(A[i]-B[j])</code>. The
cost matrices for this example:</p>
<p><img alt="Dynamic Time Warping, cost matrices" src="images/ccBaz.png"></p>
<p>For Array 1 we have 13 as score, for Array 2 we have 5. The lower score wins,
so the most similar array is Array 2. The best warping path is marked gray.</p>
<p><strong>This is only a sketch of DTW.</strong> There are a number of issues you have to
address in a real-world application. For example using offset instead of fixed
ending points, or defining measures of fit: see this paper, page 363, 5.
boundary conditions and page 364. The above linked paper has further details
too.</p>
<p><strong>I just noticed you are using yaw, pitch and roll.</strong> Simply put: don't and
another reason not to. Can you use the accelerometer data instead? "An
accelerometer is a direct measurement of orientation" (from the DCM
manuscript) and that is what you need. And as for tc's question, does the
orientation relative to North matter? I guess not.</p>
<p>It is far easier to compare the acceleration vectors than orientations (Euler
angles, rotation matrices, quaternions) as tc pointed that out. If you are
using acceleration data, you have 3 dimensional vectors at each time point,
the (x,y,z) coordinates. I would simply compute</p>
<p><code>Dist(i,j)=SQRT((A[i][X]-B[j][X])^2+(A[i][Y]-B[j][Y])^2+(A[i][Z]-B[j][Z])^2)</code>,</p>
<p>that is the Eucledian distance between the two points.</p>
<p><br></p>
<h3>Suggest</h3>
<p>I think Ali's approach is in general a good way to go, but there is a general
problem called gimbal lock (or SO discussions on this topic) when using Euler
angles i.e. pitch, roll and yaw. You will run into it when you record a more
complex movement lasting longer than a few ticks and thus leading to large
angle deltas in different angular directions.</p>
<p>In a nutshell that means, that you will have more than one mathematical
representation for the same position just depending on the order of movements
you made to get there - and a loss of information on the other side. Consider
an airplane flying up in the air from left to right. X axis is from left to
right, Y axis points up to the air. The following two movement sequences will
lead to the same end position although you will get there on totally different
ways:</p>
<p><strong>Sequence A:</strong></p>
<ol>
<li>Rotation around yaw +90°</li>
<li>Rotation around pitch +90°</li>
</ol>
<p><strong>Sequence B:</strong></p>
<ol>
<li>Rotation around pitch +90°</li>
<li>Rotation around roll +90°</li>
</ol>
<p>In both cases your airplane points down to the ground and you can see its
bottom from your position.</p>
<p>The only solution to this is to avoid Euler angles and thus make things more
complicated. Quaternions are the best way to deal with this but it took a
while (for me) to get an idea of this pretty abstract representation. OK, this
answer doesn't take you any step further regarding your original problem, but
it might help you avoiding waste of time. Maybe you can do some conceptual
changes to set up your idea.</p>
<p>Kay</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/completeness-of-depth-first-search/" class="u-url">Completeness of depth-first search</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/completeness-of-depth-first-search/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:49:58+08:00" itemprop="datePublished" title="2023-02-28 02:49">2023-02-28 02:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I quote from Artificial Intelligence: A Modern Approach:</p>
<blockquote>
<p>The properties of depth-first search depend strongly on whether the graph-
search or tree-search version is used. The graph-search version, which
avoids repeated states and redundant paths, is complete in finite state
spaces because it will eventually expand every node. The tree-search
version, on the other hand, is <em>not</em> complete [...]. Depth-first tree search
can be modified at no extra memory cost so that it checks new states against
those on the path from the root to the current node; this avoids infinite
loops in finite state spaces but does not avoid the proliferation of
redundant paths.</p>
</blockquote>
<p>I don't understand how can graph-search be complete and tree-search be not,
being a tree a particular graph.</p>
<p>Besides, I don't clearly get the difference between "infinite loops" and
"redundant paths"...</p>
<p>May someone explain this to me?</p>
<p>ps. For those who have the book it's page 86 (3rd edition).</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Depth-first tree search can get stuck in an infinite loop, which is why it is
not "complete". Graph search keeps track of the nodes it has already searched,
so it can avoid following infinite loops.</p>
<p>"Redundant paths" are different paths which lead from the same start node to
the same end node. Graph search will still explore all these redundant paths,
but once it reaches a node which it has visited before, it will not go any
further, but will back up and look for more paths which it hasn't tried yet.</p>
<p>This is different from an "infinite loop" which is a path which leads from a
node back to itself.</p>
<p>In response to your comment, look at the quote which you just posted:</p>
<p><code>Depth-first tree search can be modified at no extra memory cost so that it
checks new states against those on the path from the root to the current
node.</code></p>
<p>So while depth-first tree search does keep track of the path from the root to
the current node, to avoid infinite loops, it needs to do a linear search over
that path each time it visits a new node. If you wrote an implementation of
depth-first tree search which didn't do that check, it could get into an
infinite loop.</p>
<p>You are right, what the book said about the "proliferation of redundant paths"
doesn't relate to completeness. It is just pointing out a difference between
graph and tree search. Because tree search just keeps track of the <em>current
path</em> , it can run over the same path more than once in the same search (even
if doing the check I just mentioned).</p>
<p>Say your root node has 2 branches. Each of those branches leads to the same
single node, which has a long path leading out from it. Tree search will
follow that long path <em>twice</em> , once for each of the 2 branches which leads to
it. That is what the author is pointing out.</p>
<p><br></p>
<h3>Suggest</h3>
<p>DFS is incomplete(in tree-search). However, if you keep track of visited
nodes, it turns to be complete(in graph search).</p>
<ol>
<li>let's be clear about what <em><strong>completeness</strong></em> means.</li>
</ol>
<blockquote>
<p>If an algorithm is complete, it means that if at least one solution exists
then the algorithm is <strong>guaranteed to find a solution in a finite amount of
time.</strong></p>
</blockquote>
<ol>
<li>
<p>We need to distinguish between tree-search and graph-search. As shown in section 3.3 or page 77 in Artificial Intelligence: A Modern Approach, <strong>the only difference is that graph-search has a set to store the explored nodes.</strong></p>
</li>
<li>
<p>Finally, we can figure out the answer.</p>
</li>
<li>
<p>In tree-search(not store explored nodes), since we don't know whether the current node is explored or not, DFS may explore it again(and again...), which will loop forever. -&gt; Infinite time, not complete</p>
</li>
<li>In graph-search(store explored nodes), any search algorithms will end. -&gt; Finite time, complete</li>
</ol>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/a-admissible-heuristics-on-a-grid-with-teleporters/" class="u-url">A* admissible heuristics on a grid with teleporters?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/a-admissible-heuristics-on-a-grid-with-teleporters/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:49:38+08:00" itemprop="datePublished" title="2023-02-28 02:49">2023-02-28 02:49</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Suppose that you have a 2D grid of cells, some of which are filled in with
walls. Characters can take a step from one square to any square that is one
step horizontal or vertical from it, but cannot cross walls.</p>
<p>Given a start position and an end position, we can find the shortest path from
the start position to the end position by using the A* algorithm with an
admissible heuristic. In this current setup, the Manhattan distance would be
admissible, since it never overestimates the distance to the destination.</p>
<p>Now suppose that in addition to walls, the world has pairs of teleporters.
Stepping onto a teleporter immediately transports a character to the linked
teleporter. The existence of teleporters breaks the admissible heuristic given
above, since it might be possible to get to the destination faster than taking
the optimal Manhattan distance walk by using a teleporter to cut down on the
distance. For example, consider this linear world with teleporters marked T,
start position marked S, and end position marked E:</p>
<div class="code"><pre class="code literal-block">T . S . . . . . . . . . . . . . E . T
</pre></div>

<p>Here, the best route is to walk to the teleporter on the left, then take two
steps to the left.</p>
<p>My question is this: <strong>what is a good admissible heuristic for A* in a grid
world with teleporters?</strong></p>
<p>Thanks!</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Form a graph of the teleporters:</p>
<ul>
<li>You have a node for each teleporter and a node for the end position.</li>
<li>You have an edge connecting each node to each other node, forming a fully connected graph.</li>
<li>For the edge weights, use the Manhattan distance between each node's destination cell (the one you go to when you enter the teleporter) and all the other nodes.</li>
</ul>
<p>Use Dijkstra's algorithm to calculate the shortest distance from each node to
the end.</p>
<p>You can now use the minimum of the distance between a particular position and
all the nodes plus the pre-calculated distance from the node to the end as a
heuristic function. Dijkstra's algorithm only has to be run once as a pre-
processing step. However, if the number of teleporters is a large perecentage
of the number of cells, you may not get any benefit over using a simpler
heuristic function.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Form a graph of the teleporters:</p>
<ul>
<li>You have a node for each teleporter and a node for the end position.</li>
<li>You have an edge connecting each node to each other node, forming a fully connected graph.</li>
<li>For the edge weights, use the Manhattan distance between each node's destination cell (the one you go to when you enter the teleporter) and all the other nodes.</li>
</ul>
<p>Use Dijkstra's algorithm to calculate the shortest distance from each node to
the end.</p>
<p>You can now use the minimum of the distance between a particular position and
all the nodes plus the pre-calculated distance from the node to the end as a
heuristic function. Dijkstra's algorithm only has to be run once as a pre-
processing step. However, if the number of teleporters is a large perecentage
of the number of cells, you may not get any benefit over using a simpler
heuristic function.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1383.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1381.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
