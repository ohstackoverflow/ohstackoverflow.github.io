<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 450) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-450.html">
<link rel="prev" href="index-451.html" type="text/html">
<link rel="next" href="index-449.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/t-shuang-fu-hao-zai-c-11-zhong-shi-shi-yao-yi-si/" class="u-url">T&amp;&amp;（双符号）在 C++11 中是什么意思？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/t-shuang-fu-hao-zai-c-11-zhong-shi-shi-yao-yi-si/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:13:56+08:00" itemprop="datePublished" title="2023-02-17 07:13">2023-02-17 07:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我一直在研究 C++11 的一些新特性，我注意到的一个是在声明变量时使用双符号，比如<code>T&amp;&amp; var</code>.</p>
<p>首先，这只野兽叫什么？我希望谷歌允许我们搜索这样的标点符号。</p>
<p>这到底是什么 <em>意思？</em></p>
<p>乍一看，它似乎是一个双重引用（就像 C 风格的双重指针<code>T** var</code>），但我很难想出一个用例。</p>
<p><br><br></p>
<h2>解答</h2>
<p>它声明了一个右值引用（标准提案文档）。</p>
<p>下面介绍一下右值引用。</p>
<p>这是 Microsoft 标准库开发人员之一对右值引用的深入了解。</p>
<blockquote>
<p><em><strong>注意：</strong> MSDN 上的链接文章（“右值引用：VC10 中的 C++0x 功能，第 2 部分”）非常清楚地介绍了右值引用，但对右值引用的陈述在
C++11 草案中曾经是正确的标准，但对于最后一个不是真的！具体来说，它在各个方面表示右值引用可以绑定到左值，这曾经是正确的，但已更改。（例如 int
x; int &amp;&amp;rrx = x; 不再在 GCC 中编译） – drewbarbs 2014 年 7 月 13 日 16:12</em></p>
</blockquote>
<p>C++03 引用（现在在 C++11 中称为左值引用）之间的最大区别是它可以像临时一样绑定到右值，而不必是 const。因此，这种语法现在是合法的：</p>
<div class="code"><pre class="code literal-block">T&amp;&amp; r = T();
</pre></div>

<p>右值引用主要提供以下内容：</p>
<p><strong>移动语义</strong> 。现在可以定义一个移动构造函数和移动赋值运算符，它采用右值引用而不是通常的 const-lvalue
引用。移动的功能类似于复制，只是它没有义务保持源不变；事实上，它通常会修改源，使其不再拥有移动的资源。这对于消除无关副本非常有用，尤其是在标准库实现中。</p>
<p>例如，复制构造函数可能如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">];</span>
<span class="w">    </span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>如果这个构造函数被传递给一个临时的，那么副本将是不必要的，因为我们知道临时的将被销毁；为什么不利用临时已经分配的资源？在 C++03
中，没有办法阻止复制，因为我们无法确定我们是否被临时传递。在 C++11 中，我们可以重载移动构造函数：</p>
<div class="code"><pre class="code literal-block"><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">this</span><span class="o">-&gt;</span><span class="nf">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="nf">length</span><span class="p">;</span>
<span class="w">   </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">   </span><span class="n">other</span><span class="p">.</span><span class="nf">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>注意这里的巨大差异：移动构造函数实际上修改了它的参数。这将有效地将临时对象“移动”到正在构造的对象中，从而消除不必要的副本。</p>
<p>移动构造函数将用于临时对象和使用函数显式转换为右值引用的非 const 左值引用<code>std::move</code>（它只是执行转换）。以下代码都调用了<code>f1</code>和
的移动构造函数<code>f2</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nt">foo</span><span class="w"> </span><span class="nt">f1</span><span class="o">((</span><span class="nt">foo</span><span class="o">()));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Move</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">temporary</span><span class="w"> </span><span class="nt">into</span><span class="w"> </span><span class="nt">f1</span><span class="o">;</span><span class="w"> </span><span class="nt">temporary</span><span class="w"> </span><span class="nt">becomes</span><span class="w"> </span><span class="s2">"empty"</span>
<span class="nt">foo</span><span class="w"> </span><span class="nt">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">f1</span><span class="o">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Move</span><span class="w"> </span><span class="nt">f1</span><span class="w"> </span><span class="nt">into</span><span class="w"> </span><span class="nt">f2</span><span class="o">;</span><span class="w"> </span><span class="nt">f1</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">now</span><span class="w"> </span><span class="s2">"empty"</span>
</pre></div>

<p><strong>完美转发</strong> 。右值引用允许我们正确地转发模板函数的参数。以这个工厂函数为例：</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">A1</span><span class="o">&gt;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">factory</span><span class="o">(</span><span class="nt">A1</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">a1</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">a1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>如果我们调用<code>factory&lt;foo&gt;(5)</code>，参数将被推断为<code>int&amp;</code>，它不会绑定到文字 5，即使<code>foo</code>的构造函数采用<code>int</code>.
好吧，我们可以改用，但是如果通过非常量引用获取构造函数参数<code>A1
const&amp;</code>怎么办？<code>foo</code>要创建一个真正通用的工厂函数，我们必须不断地重载<code>A1&amp;</code>工厂<code>A1 const&amp;</code>。如果工厂采用 1
种参数类型，那可能没问题，但每个额外的参数类型都会将必要的重载集乘以 2。这很快就无法维护了。</p>
<p>右值引用通过允许标准库定义一个<code>std::forward</code>可以正确转发左值/右值引用的函数来解决这个问题。有关<code>std::forward</code>工作原理的更多信息，请参阅这个出色的答案。</p>
<p>这使我们能够像这样定义工厂函数：</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">A1</span><span class="o">&gt;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">factory</span><span class="o">(</span><span class="nt">A1</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">a1</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a1</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>

<p>现在，当传递给 的构造函数时，参数的右值/左值特性将被保留<code>T</code>。这意味着如果用右值调用工厂，则<code>T</code>用右值调用 的构造函数。如果使用左值调用
factory，<code>T</code>则使用左值调用 的构造函数。改进后的工厂函数之所以起作用，是因为一个特殊的规则：</p>
<blockquote>
<p>当函数参数类型的形式为<code>T&amp;&amp;</code>where<code>T</code>是模板参数，并且函数参数是 type 的左值时<code>A</code>，该类型<code>A&amp;</code>用于模板参数推导。</p>
</blockquote>
<p>因此，我们可以像这样使用工厂：</p>
<div class="code"><pre class="code literal-block"><span class="n">auto</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="o">&amp;&amp;</span><span class="p">)</span>
<span class="n">auto</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">);</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>
</pre></div>

<p><strong>重要的右值引用属性</strong> ：</p>
<ul>
<li>对于重载决议， <strong>左值更喜欢绑定到左值引用，而右值更喜欢绑定到右值引用</strong> 。因此，为什么临时工更喜欢调用移动构造函数/移动赋值运算符而不是复制构造函数/赋值运算符。</li>
<li>
<strong>右值引用将隐式绑定到右值和作为隐式转换结果的临时值</strong> 。ie<code>float f = 0f; int&amp;&amp; i = f;</code>格式正确，因为 float 可以隐式转换为 int；引用将是一个临时的，即转换的结果。</li>
<li>
<strong>命名的右值引用是左值。 未命名的右值引用是右值。</strong>这对于理解为什么<code>std::move</code>在以下情况下需要调用很重要：<code>foo&amp;&amp; r = foo(); foo f = std::move(r);</code>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>它表示右值引用。右值引用只会绑定到临时对象，除非以其他方式显式生成。它们用于使对象在某些情况下更加高效，并提供称为完美转发的功能，从而大大简化模板代码。</p>
<p>在 C++03 中，您无法区分非可变左值和右值的副本。</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">another</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">more</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>

<p>在 C++0x 中，情况并非如此。</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">another</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">more</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>

<p>考虑这些构造函数背后的实现。在第一种情况下，字符串必须执行复制以保留值语义，这涉及到新的堆分配。然而，在第二种情况下，我们事先知道传递给构造函数的对象将立即销毁，它不必保持原样。在这种情况下，我们可以有效地只交换内部指针而不执行任何复制，这样效率要高得多。移动语义有利于任何具有昂贵或禁止复制内部引用资源的类。考虑以下情况<code>std::unique_ptr</code>-
现在我们的类可以区分临时和非临时，我们可以使移动语义正确工作，以便不能<code>unique_ptr</code>复制但可以移动，这意味着<code>std::unique_ptr</code>可以合法地存储在标准容器中、排序等，而
C++03<code>std::auto_ptr</code>不能。</p>
<p>现在我们考虑右值引用的另一种用途——完美转发。考虑将引用绑定到引用的问题。</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="w"> </span><span class="nt">s</span><span class="o">;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">s</span><span class="o">;</span>
<span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;)&amp;</span><span class="w"> </span><span class="nt">anotherref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">ref</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">usually</span><span class="w"> </span><span class="nt">expressed</span><span class="w"> </span><span class="nt">via</span><span class="w"> </span><span class="nt">template</span>
</pre></div>

<p>不记得 C++03 对此有何评论，但在 C++0x 中，处理右值引用时的结果类型至关重要。对类型 T 的右值引用（其中 T 是引用类型）成为类型 T
的引用。</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span>
<span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span>
<span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span>
</pre></div>

<p>考虑最简单的模板函数——最小值和最大值。在 C++03 中，您必须手动重载 const 和非常量的所有四种组合。在 C++0x
中，它只是一个重载。结合可变参数模板，可以实现完美的转发。</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">aref</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="k">pass</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">argument</span><span class="p">,</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">extension</span><span class="p">,</span><span class="w"> </span><span class="n">aref</span><span class="w"> </span><span class="n">becomes</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">completely</span><span class="w"> </span><span class="n">maintaining</span><span class="w"> </span><span class="n">it</span><span class="s1">'s type information.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aref</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bref</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aref</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bref</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>我没有进行返回类型推导，因为我不记得它是如何临时完成的，但是 min 可以接受左值、右值、const 左值的任意组合。</p>
<p><br><br><a href="posts/what-does-t-double-ampersand-mean-in-c-11/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-css-flexbox-zhong-wei-shi-yao-mei-you-justify-items-he-justify-self-shu-xing/" class="u-url">在 CSS Flexbox 中，为什么没有“justify-items”和“justify-self”属性？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-css-flexbox-zhong-wei-shi-yao-mei-you-justify-items-he-justify-self-shu-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:13:31+08:00" itemprop="datePublished" title="2023-02-17 07:13">2023-02-17 07:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>考虑一个弹性容器的主轴和交叉轴：</p>
<p><img alt="应用于 row flex 容器的各种方向和大小术语的图示" src="images/9Oxw7.png"> 资料来源：W3C</p>
<p>要沿主轴对齐弹性项目，有一个属性：</p>
<ul>
<li><code>justify-content</code></li>
</ul>
<p>要沿交叉轴对齐弹性项目，需要三个属性：</p>
<ul>
<li><code>align-content</code></li>
<li><code>align-items</code></li>
<li><code>align-self</code></li>
</ul>
<p>在上图中，主轴是水平的，交叉轴是垂直的。这些是弹性容器的默认方向。</p>
<p>但是，这些方向可以很容易地与<code>flex-direction</code>酒店互换。</p>
<div class="code"><pre class="code literal-block"><span class="o">/*</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">horizontal</span><span class="p">,</span><span class="w"> </span><span class="nb">cross</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">vertical</span><span class="w"> </span><span class="o">*/</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">row</span><span class="p">;</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">row</span><span class="o">-</span><span class="n">reverse</span><span class="p">;</span>

<span class="o">/*</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">vertical</span><span class="p">,</span><span class="w"> </span><span class="nb">cross</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">horizontal</span><span class="w"> </span><span class="o">*/</span><span class="w">    </span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">column</span><span class="p">;</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">column</span><span class="o">-</span><span class="n">reverse</span><span class="p">;</span>
</pre></div>

<p>（横轴始终垂直于主轴。）</p>
<p>我在描述轴如何工作时的观点是，这两个方向似乎都没有什么特别之处。主轴，横轴，两者的重要性相当，<code>flex-direction</code>来回切换也很方便。</p>
<p><em>那么为什么横轴会获得两个额外的对齐属性呢？</em></p>
<p><em>为什么 和<code>align-content</code>合并<code>align-items</code>为主轴的一个属性？</em></p>
<p><em>为什么主轴没有得到属性<code>justify-self</code>？</em></p>
<hr>
<p>这些属性有用的场景：</p>
<ul>
<li>
<p>将弹性项目放在弹性容器的角落<br><code>#box3 { align-self: flex-end; justify-self: flex-end; }</code></p>
</li>
<li>
<p>使一组弹性项目右对齐（<code>justify-content: flex-end</code>）但第一个项目左对齐（<code>justify-self: flex-start</code>）</p>
</li>
</ul>
<p><em>考虑带有一组导航项和徽标的标题部分。 徽标<code>justify-
self</code>可以左对齐，而导航项保持在最右边，并且整个事物可以平滑地调整（“弯曲”）以适应不同的屏幕尺寸。</em></p>
<ul>
<li>在一排三个弹性项目中，将中间项目固定到容器的中心 ( <code>justify-content: center</code>) 并将相邻项目与容器边缘对齐 (<code>justify-self: flex-start</code>和<code>justify-self: flex-end</code>)。</li>
</ul>
<p><em>请注意，如果相邻项的宽度不同， values<code>space-around</code>和<code>space-
between</code>on属性将不会使中间项以容器为中心。<code>justify-content</code></em></p>
<p>显示代码片段</p>
<div class="code"><pre class="code literal-block">#container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>space-between;
<span class="w">  </span>background-color:<span class="w"> </span>lightyellow;
}
.box<span class="w"> </span>{
<span class="w">  </span>height:<span class="w"> </span>50px;
<span class="w">  </span>width:<span class="w"> </span>75px;
<span class="w">  </span>background-color:<span class="w"> </span>springgreen;
}
.box1<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>100px;
}
.box3<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>200px;
}
#center<span class="w"> </span>{
<span class="w">  </span>text-align:<span class="w"> </span>center;
<span class="w">  </span>margin-bottom:<span class="w"> </span>5px;
}
#center<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{
<span class="w">  </span>background-color:<span class="w"> </span>aqua;
<span class="w">  </span>padding:<span class="w"> </span>2px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"center"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>TRUE<span class="w"> </span>CENTER<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box1"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box2"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box3"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;p&gt;</span>note<span class="w"> </span>that<span class="w"> </span>the<span class="w"> </span>middlebox<span class="w"> </span>will<span class="w"> </span>only<span class="w"> </span>be<span class="w"> </span>truly<span class="w"> </span>centered<span class="w"> </span>if<span class="w"> </span>adjacent<span class="w"> </span>boxes<span class="w"> </span>are<span class="w"> </span>equal<span class="w"> </span>width<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p>jsFiddle版本</p>
<hr>
<p>在撰写本文时， flexbox 规范中没有提到<code>justify-self</code>or 。<code>justify-items</code></p>
<p>然而，在CSS Box Alignment Module中，这是 W3C 未完成的提议，旨在建立一组通用的对齐属性以供所有盒子模型使用，其中有：</p>
<p><img alt="在此处输入图像描述" src="images/uu2tP.png"> 资料来源：W3C</p>
<p>你会注意到<code>justify-self</code>和<code>justify-items</code>正在被考虑...... <em>但不是 flexbox</em> 。</p>
<hr>
<p>最后，我将重申主要问题：</p>
<blockquote>
<p>为什么没有“justify-items”和“justify-self”属性？</p>
</blockquote>
<p><br><br></p>
<h2>解答</h2>
<h3>沿主轴对齐 Flex 项目的方法</h3>
<p>如问题所述：</p>
<blockquote>
<p>要沿主轴对齐弹性项目，有一个属性：<code>justify-content</code></p>
<p>要沿交叉轴对齐弹性项目，需要三个属性：<code>align-content</code>,<code>align-items</code>和<code>align-self</code>。</p>
</blockquote>
<p>问题接着问：</p>
<blockquote>
<p>为什么没有<code>justify-items</code>and<code>justify-self</code>属性？</p>
</blockquote>
<p>一个答案可能是： <em>因为它们不是必需的。</em></p>
<p>flexbox规范提供了 <em>两种</em> 沿主轴对齐弹性项目的方法：</p>
<ol>
<li>关键字<code>justify-content</code>属性，以及</li>
<li>
<code>auto</code>边距</li>
</ol>
<hr>
<p>__</p>
<h3><em>证明内容</em></h3>
<p>该<code>justify-content</code>属性沿弹性容器的主轴对齐弹性项目。</p>
<p>它应用于 flex 容器，但只影响 flex 项目。</p>
<p>有五个对齐选项：</p>
<ul>
<li>
<strong><code>flex-start</code></strong> ~ Flex 项目被打包到行的开头。</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/YOzeU.png"></p>
<ul>
<li>
<strong><code>flex-end</code></strong> ~ Flex 项目被打包到生产线的末尾。</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/13Z1u.png"></p>
<ul>
<li>
<strong><code>center</code></strong> ~ Flex 项目被包装到线的中心。</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/oKi7M.png"></p>
<ul>
<li>
<strong><code>space-between</code></strong> ~ 弹性项目均匀分布，第一个项目与容器的一个边缘对齐，最后一个项目与相对的边缘对齐。第一项和最后一项使用的边缘取决于<code>flex-direction</code>书写模式（<code>ltr</code>或<code>rtl</code>）。</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/0mQqd.png"></p>
<ul>
<li>
<strong><code>space-around</code></strong> ~<code>space-between</code>除了两端有一半大小的空间外，其他都一样。</li>
</ul>
<p><img alt="在此处输入图像描述" src="images/u4BH6.png"></p>
<hr>
<h3>自动保证金</h3>
<p>有了<code>auto</code>margins，弹性项目可以居中，间隔开或打包成子组。</p>
<p><code>justify-content</code>与适用于 flex 容器的不同， <code>auto</code>margins 用于 flex 项目。</p>
<p>它们通过消耗指定方向上的所有可用空间来工作。</p>
<hr>
<h4>将一组弹性项目向右对齐，但第一个项目向左对齐</h4>
<p>问题场景：</p>
<blockquote>
<ul>
<li>使一组弹性项目右对齐（<code>justify-content: flex-end</code>）但第一个项目左对齐（<code>justify-self: flex-
start</code>）</li>
</ul>
<p><em>考虑带有一组导航项和徽标的标题部分。 徽标<code>justify-
self</code>可以左对齐，而导航项保持在最右边，并且整个事物可以平滑地调整（“弯曲”）以适应不同的屏幕尺寸。</em></p>
</blockquote>
<p><img alt="在此处输入图像描述" src="images/D3Vnv.png"></p>
<p><img alt="在此处输入图像描述" src="images/Um8DM.png"></p>
<hr>
<p><strong><em>其他有用的场景：</em></strong></p>
<p><img alt="在此处输入图像描述" src="images/qLzgU.png"></p>
<p><img alt="在此处输入图像描述" src="images/HtaOc.png"></p>
<p><img alt="在此处输入图像描述" src="images/M2WkZ.png"></p>
<hr>
<h4>在角落放置一个弹性项目</h4>
<p>问题场景：</p>
<blockquote>
<ul>
<li>将弹性项目放在角落<code>.box { align-self: flex-end; justify-self: flex-end; }</code>
</li>
</ul>
</blockquote>
<p><img alt="在此处输入图像描述" src="images/BtbfK.png"></p>
<hr>
<h4>垂直和水平居中弹性项目</h4>
<p><img alt="在此处输入图像描述" src="images/lV9a0.png"></p>
<p><code>margin: auto``justify-content: center</code>是and的替代品<code>align-items: center</code>。</p>
<p>而不是 flex 容器上的这段代码：</p>
<div class="code"><pre class="code literal-block"><span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">justify-content:</span><span class="w"> </span><span class="nf">center</span><span class="c1">;</span>
<span class="w">    </span><span class="nl">align-items:</span><span class="w"> </span><span class="nf">center</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>您可以在弹性项目上使用它：</p>
<div class="code"><pre class="code literal-block"><span class="na">.box56</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">margin:</span><span class="w"> </span><span class="nf">auto</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p><strong>当将溢出容器的弹性项目居中时，</strong> 此替代方案很有用。</p>
<hr>
<h4>居中弹性项目，并在第一个和边缘之间居中第二个弹性项目</h4>
<p>A flex container aligns flex items by distributing free space.</p>
<p>Hence, in order to create <em>equal balance</em> , so that a middle item can be
centered in the container with a single item alongside, a counterbalance must
be introduced.</p>
<p>In the examples below, invisible third flex items (boxes 61 &amp; 68) are
introduced to balance out the "real" items (box 63 &amp; 66).</p>
<p><img alt="在此处输入图像描述" src="images/3IeTy.png"></p>
<p><img alt="在此处输入图像描述" src="images/BmtRt.png"></p>
<p>Of course, this method is nothing great in terms of semantics.</p>
<p>Alternatively, you can use a pseudo-element instead of an actual DOM element.
Or you can use absolute positioning. All three methods are covered here:
<strong>Center and bottom-align flex items</strong></p>
<p><em>NOTE: The examples above will only work – in terms of true centering – when
the outermost items are equal height/width. When flex items are different
lengths, see next example.</em></p>
<hr>
<h4>Center a flex item when adjacent items vary in size</h4>
<p>Scenario from the question:</p>
<blockquote>
<ul>
<li>in a row of three flex items, affix the middle item to the center of the
container (<code>justify-content: center</code>) and align the adjacent items to the
container edges (<code>justify-self: flex-start</code> and <code>justify-self: flex-end</code>).</li>
</ul>
<p><em>Note that values<code>space-around</code> and <code>space-between</code> on <code>justify-content</code>
property will not keep the middle item centered in relation to the container
if the adjacent items have different widths (see demo).</em></p>
</blockquote>
<p>As noted, unless all flex items are of equal width or height (depending on
<code>flex-direction</code>), the middle item cannot be truly centered. This problem
makes a strong case for a <code>justify-self</code> property (designed to handle the
task, of course).</p>
<p>显示代码片段</p>
<div class="code"><pre class="code literal-block">#container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>space-between;
<span class="w">  </span>background-color:<span class="w"> </span>lightyellow;
}
.box<span class="w"> </span>{
<span class="w">  </span>height:<span class="w"> </span>50px;
<span class="w">  </span>width:<span class="w"> </span>75px;
<span class="w">  </span>background-color:<span class="w"> </span>springgreen;
}
.box1<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>100px;
}
.box3<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>200px;
}
#center<span class="w"> </span>{
<span class="w">  </span>text-align:<span class="w"> </span>center;
<span class="w">  </span>margin-bottom:<span class="w"> </span>5px;
}
#center<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{
<span class="w">  </span>background-color:<span class="w"> </span>aqua;
<span class="w">  </span>padding:<span class="w"> </span>2px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"center"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>TRUE<span class="w"> </span>CENTER<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box1"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box2"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box3"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;p&gt;</span>The<span class="w"> </span>middle<span class="w"> </span>box<span class="w"> </span>will<span class="w"> </span>be<span class="w"> </span>truly<span class="w"> </span>centered<span class="w"> </span>only<span class="w"> </span>if<span class="w"> </span>adjacent<span class="w"> </span>boxes<span class="w"> </span>are<span class="w"> </span>equal<span class="w"> </span>width.<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p><em>Here are two methods for solving this problem:</em></p>
<p><strong><em>Solution #1: Absolute Positioning</em></strong></p>
<p>The flexbox spec allows for absolute positioning of flex items. This allows
for the middle item to be perfectly centered regardless of the size of its
siblings.</p>
<p>Just keep in mind that, like all absolutely positioned elements, the items are
removed from the document flow. This means they don't take up space in the
container and can overlap their siblings.</p>
<p>In the examples below, the middle item is centered with absolute positioning
and the outer items remain in-flow. But the same layout can be achieved in
reverse fashion: Center the middle item with <code>justify-content: center</code> and
absolutely position the outer items.</p>
<p><img alt="在此处输入图像描述" src="images/U1eLb.png"></p>
<p><strong><em>Solution #2: Nested Flex Containers (no absolute positioning)</em></strong></p>
<div class="code"><pre class="code literal-block">.container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
}
.box<span class="w"> </span>{
<span class="w">  </span>flex:<span class="w"> </span>1;
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>center;
}
.box71<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{<span class="w"> </span>margin-right:<span class="w"> </span>auto;<span class="w"> </span>}
.box73<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{<span class="w"> </span>margin-left:<span class="w"> </span>auto;<span class="w">  </span>}

/*<span class="w"> </span>non-essential<span class="w"> </span>*/
.box<span class="w"> </span>{
<span class="w">  </span>align-items:<span class="w"> </span>center;
<span class="w">  </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>#ccc;
<span class="w">  </span>background-color:<span class="w"> </span>lightgreen;
<span class="w">  </span>height:<span class="w"> </span>40px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box71"</span><span class="nt">&gt;&lt;span&gt;</span>71<span class="w"> </span>short<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box72"</span><span class="nt">&gt;&lt;span&gt;</span>72<span class="w"> </span>centered<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box73"</span><span class="nt">&gt;&lt;span&gt;</span>73<span class="w"> </span>loooooooooooooooong<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>运行代码片段隐藏结果</p>
<p>Here's how it works:</p>
<ul>
<li>The top-level div (<code>.container</code>) is a flex container.</li>
<li>Each child div (<code>.box</code>) is now a flex item.</li>
<li>Each <code>.box</code> item is given <code>flex: 1</code> in order to distribute container space equally.</li>
<li>Now the items are consuming all space in the row and are equal width.</li>
<li>Make each item a (nested) flex container and add <code>justify-content: center</code>.</li>
<li>Now each <code>span</code> element is a centered flex item.</li>
<li>Use flex <code>auto</code> margins to shift the outer <code>span</code>s left and right.</li>
</ul>
<p>You could also forgo <code>justify-content</code> and use <code>auto</code> margins exclusively.</p>
<p>But <code>justify-content</code> can work here because <code>auto</code> margins always have
priority. From the spec:</p>
<blockquote>
<p><strong>8.1. Aligning with<code>auto</code> margins</strong></p>
<p>Prior to alignment via <code>justify-content</code> and <code>align-self</code>, any positive free
space is distributed to auto margins in that dimension.</p>
</blockquote>
<hr>
<p>__</p>
<h4><em>justify-content: space-same (concept)</em></h4>
<p>Going back to <code>justify-content</code> for a minute, here's an idea for one more
option.</p>
<ul>
<li>
<strong><code>space-same</code></strong> ~ A hybrid of <code>space-between</code> and <code>space-around</code>. Flex items are evenly spaced (like <code>space-between</code>), except instead of half-size spaces on both ends (like <code>space-around</code>), there are full-size spaces on both ends.</li>
</ul>
<p>This layout can be achieved with <code>::before</code> and <code>::after</code> pseudo-elements on
the flex container.</p>
<p><img alt="在此处输入图像描述" src="images/Jjw9w.png"></p>
<p><em>(credit: @oriol for the code, and @crl for the label)</em></p>
<p><strong>UPDATE:</strong> Browsers have begun implementing <strong><code>space-evenly</code></strong> , which
accomplishes the above. See this post for details: Equal space between flex
items</p>
<hr>
<p><strong>PLAYGROUND</strong> (includes code for all examples above)</p>
<p><br></p>
<h3>更多建议</h3>
<p>我知道这不是一个答案，但我愿意为这件事的价值做出贡献。<code>justify-self</code>如果他们可以发布flexbox 使其真正灵活，那就太好了。</p>
<p>我相信当轴上有多个项目时，最合乎逻辑的<code>justify-self</code>行为方式是将自己与其最近的邻居（或边缘）对齐，如下所示。</p>
<p>我真的希望 W3C 注意到这一点并且至少会考虑它。=)</p>
<p><img alt="在此处输入图像描述" src="images/wpSsJ.jpg"></p>
<p>这样你就可以拥有一个真正居中的项目，而不管左右框的大小。当其中一个盒子到达中心盒子的点时，它会简单地推动它，直到没有更多的空间可以分配。</p>
<p><img alt="在此处输入图像描述" src="images/NgobL.gif"></p>
<p>制作很棒的布局的便利是无穷无尽的，看看这个“复杂”的例子。</p>
<p><img alt="在此处输入图像描述" src="images/U2ELF.png"></p>
<p><br><br><a href="posts/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-cong-grep-r-zhong-pai-chu-mu-lu/" class="u-url">如何从 grep -R 中排除目录？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-cong-grep-r-zhong-pai-chu-mu-lu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:13:03+08:00" itemprop="datePublished" title="2023-02-17 07:13">2023-02-17 07:13</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想遍历所有子目录，除了“node_modules”目录。</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>解决方案 1（结合<code>find</code>和<code>grep</code>）</strong></p>
<p>该解决方案的目的不是处理<code>grep</code>性能，而是展示一个可移植的解决方案：也应该适用于 busybox 或早于 2.5 的 GNU 版本。</p>
<p>使用 <strong><code>find</code></strong> , 排除目录 foo 和 bar ：</p>
<div class="code"><pre class="code literal-block">find /dir \( -name foo -prune \) -o \( -name bar -prune \) -o -name "*.sh" -print
</pre></div>

<p>然后结合 <strong><code>find</code></strong> 和非递归使用 <strong><code>grep</code></strong> , 作为一个可移植的解决方案：</p>
<div class="code"><pre class="code literal-block"><span class="nv">find</span><span class="w"> </span><span class="o">/</span><span class="nv">dir</span><span class="w"> </span>\<span class="ss">(</span><span class="w"> </span><span class="o">-</span><span class="nv">name</span><span class="w"> </span><span class="nv">node_modules</span><span class="w"> </span><span class="o">-</span><span class="nv">prune</span><span class="w"> </span>\<span class="ss">)</span><span class="w"> </span><span class="o">-</span><span class="nv">o</span><span class="w"> </span><span class="o">-</span><span class="nv">name</span><span class="w"> </span><span class="s2">"*.sh"</span><span class="w"> </span><span class="o">-</span><span class="k">exec</span><span class="w"> </span><span class="nv">grep</span><span class="w"> </span><span class="o">--</span><span class="nv">color</span><span class="w"> </span><span class="o">-</span><span class="nv">Hn</span><span class="w"> </span><span class="s2">"your text to find"</span><span class="w"> </span>{}<span class="w"> </span><span class="mi">2</span><span class="o">&gt;/</span><span class="nv">dev</span><span class="o">/</span><span class="nv">null</span><span class="w"> </span>\<span class="c1">;</span>
</pre></div>

<p><strong>解决方案 2（使用 的<code>--exclude-dir</code>选项<code>grep</code>）：</strong></p>
<p>您已经知道这个解决方案，但我添加它是因为它是最新且最有效的解决方案。请注意，这是一种不太便携但更易于阅读的解决方案。</p>
<div class="code"><pre class="code literal-block">grep -R --exclude-dir=node_modules 'some pattern' /path/to/search
</pre></div>

<p>要排除多个目录，请使用<code>--exclude-dir</code>as：</p>
<p><code>--exclude-dir={node_modules,dir1,dir2,dir3}</code></p>
<p><strong>溶液 3（银）</strong></p>
<p>如果您经常搜索代码，Ag (The Silver Searcher)是 grep 的一个更快的替代品，它是为搜索代码而定制的。例如，它会自动忽略
中列出的文件和目录<code>.gitignore</code>，因此您不必继续将同样繁琐的排除选项传递给<code>grep</code>或<code>find</code>。</p>
<p><br></p>
<h3>更多建议</h3>
<p><strong>解决方案 1（结合<code>find</code>和<code>grep</code>）</strong></p>
<p>该解决方案的目的不是处理<code>grep</code>性能，而是展示一个可移植的解决方案：也应该适用于 busybox 或早于 2.5 的 GNU 版本。</p>
<p>使用 <strong><code>find</code></strong> , 排除目录 foo 和 bar ：</p>
<div class="code"><pre class="code literal-block">find /dir \( -name foo -prune \) -o \( -name bar -prune \) -o -name "*.sh" -print
</pre></div>

<p>然后结合 <strong><code>find</code></strong> 和非递归使用 <strong><code>grep</code></strong> , 作为一个可移植的解决方案：</p>
<div class="code"><pre class="code literal-block"><span class="nv">find</span><span class="w"> </span><span class="o">/</span><span class="nv">dir</span><span class="w"> </span>\<span class="ss">(</span><span class="w"> </span><span class="o">-</span><span class="nv">name</span><span class="w"> </span><span class="nv">node_modules</span><span class="w"> </span><span class="o">-</span><span class="nv">prune</span><span class="w"> </span>\<span class="ss">)</span><span class="w"> </span><span class="o">-</span><span class="nv">o</span><span class="w"> </span><span class="o">-</span><span class="nv">name</span><span class="w"> </span><span class="s2">"*.sh"</span><span class="w"> </span><span class="o">-</span><span class="k">exec</span><span class="w"> </span><span class="nv">grep</span><span class="w"> </span><span class="o">--</span><span class="nv">color</span><span class="w"> </span><span class="o">-</span><span class="nv">Hn</span><span class="w"> </span><span class="s2">"your text to find"</span><span class="w"> </span>{}<span class="w"> </span><span class="mi">2</span><span class="o">&gt;/</span><span class="nv">dev</span><span class="o">/</span><span class="nv">null</span><span class="w"> </span>\<span class="c1">;</span>
</pre></div>

<p><strong>解决方案 2（使用 的<code>--exclude-dir</code>选项<code>grep</code>）：</strong></p>
<p>您已经知道这个解决方案，但我添加它是因为它是最新且最有效的解决方案。请注意，这是一种不太便携但更易于阅读的解决方案。</p>
<div class="code"><pre class="code literal-block">grep -R --exclude-dir=node_modules 'some pattern' /path/to/search
</pre></div>

<p>要排除多个目录，请使用<code>--exclude-dir</code>as：</p>
<p><code>--exclude-dir={node_modules,dir1,dir2,dir3}</code></p>
<p><strong>溶液 3（银）</strong></p>
<p>如果您经常搜索代码，Ag (The Silver Searcher)是 grep 的一个更快的替代品，它是为搜索代码而定制的。例如，它会自动忽略
中列出的文件和目录<code>.gitignore</code>，因此您不必继续将同样繁琐的排除选项传递给<code>grep</code>或<code>find</code>。</p>
<p><br><br><a href="posts/how-can-i-exclude-directories-from-grep-r/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-451.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-449.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
