<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1225) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1225.html">
<link rel="prev" href="index-1226.html" type="text/html">
<link rel="next" href="index-1224.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/typedefhan-shu-zhi-zhen/" class="u-url">typedef函数指针？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/typedefhan-shu-zhi-zhen/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T04:29:11+08:00" itemprop="datePublished" title="2023-02-18 04:29">2023-02-18 04:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在学习如何动态加载 DLL，但我不明白这一行</p>
<div class="code"><pre class="code literal-block">typedef void (*FunctionFunc)();
</pre></div>

<p>我有几个问题。如果有人能够回答他们，我将不胜感激。</p>
<ol>
<li>为什么<code>typedef</code>使用？</li>
<li>语法看起来很奇怪；之后<code>void</code>不应该有函数名之类的吗？它看起来像一个匿名函数。</li>
<li>创建函数指针是为了存放函数的内存地址吗？</li>
</ol>
<p>所以我现在很困惑；你能帮我澄清一下吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>typedef</code>是一种将名称与类型相关联的语言结构。<br>
您可以像使用原始类型一样使用它，例如</p>
<div class="code"><pre class="code literal-block">typedef int myinteger;
typedef char *mystring;
typedef void (*myfunc)();
</pre></div>

<p>像使用它们</p>
<div class="code"><pre class="code literal-block"><span class="n">myinteger</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">equivalent</span><span class="w"> </span><span class="n">to</span><span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="n">mystring</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="k">as</span><span class="w">      </span><span class="nb">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="n">myfunc</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w">      </span><span class="o">//</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="n">equally</span><span class="w"> </span><span class="k">as</span><span class="w">  </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)();</span>
</pre></div>

<p>如您所见，您可以用上面给出的定义替换 <em>类型定义的名称。</em>  </p>
<p>难点在于 C 和 C++
中指向函数的语法和可读性，可以<code>typedef</code>提高此类声明的可读性。然而，语法是合适的，因为函数——不像其他更简单的类型——可能有一个返回值和参数，因此函数指针的声明有时冗长而复杂。</p>
<p>使用指向函数数组的指针和其他一些更间接的风格，可读性可能开始变得非常棘手。</p>
<p>回答你的三个问题</p>
<ul>
<li>
<p><strong>为什么使用typedef？</strong> 为了简化代码的阅读——尤其是指向函数或结构名称的指针。</p>
</li>
<li>
<p><strong>语法看起来很奇怪（在指向函数声明的指针中）</strong> 该语法读起来并不明显，至少在开始时是这样。使用<code>typedef</code>声明而不是简化阅读</p>
</li>
<li>
<p><strong>创建函数指针是为了存放函数的内存地址吗？</strong> 是的，函数指针存储函数的地址。<code>typedef</code>这与只简化程序的编写/阅读的构造无关；编译器只是在编译实际代码之前扩展 typedef 定义。</p>
</li>
</ul>
<p>例子：</p>
<div class="code"><pre class="code literal-block"><span class="n">typedef</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">t_somefunc</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="nb nb-Type">int</span><span class="p">);</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">product</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">t_somefunc</span><span class="w"> </span><span class="n">afunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">product</span><span class="p">;</span>
<span class="o">...</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">afunc</span><span class="p">)(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">456</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">product</span><span class="p">()</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">calculate</span><span class="w"> </span><span class="mi">123</span><span class="o">*</span><span class="mi">456</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<ol>
<li>
<p><code>typedef</code>用于别名类型；在这种情况下，您别名<code>FunctionFunc</code>为<code>void(*)()</code>.</p>
</li>
<li>
<p>确实语法看起来很奇怪，看看这个：</p>
<div class="code"><pre class="code literal-block">typedef   void      (*FunctionFunc)  ( );
</pre></div>

<p>//         ^                ^         ^
//     return type      type name  arguments</p>
</li>
<li>
<p>不，这只是告诉编译器该<code>FunctionFunc</code>类型将是一个函数指针，它没有 <em>定义</em> 一个，如下所示：</p>
<div class="code"><pre class="code literal-block">FunctionFunc x;
</pre></div>

<p>void doSomething() { printf("Hello there\n"); }
x = &amp;doSomething;</p>
<p>x(); //prints "Hello there"</p>
</li>
</ol>
<p><br><br><a href="posts/typedef-function-pointer/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/gcc-fpic-xuan-xiang/" class="u-url">GCC -fPIC 选项</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/gcc-fpic-xuan-xiang/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T04:28:48+08:00" itemprop="datePublished" title="2023-02-18 04:28">2023-02-18 04:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我已经阅读了GCC 的 Options for Code Generation Conventions，但无法理解“生成位置无关代码
(PIC)”的作用。请举个例子来解释一下这是什么意思。</p>
<p><br><br></p>
<h2>解答</h2>
<p>位置无关代码意味着生成的机器代码不依赖于位于特定地址才能工作。</p>
<p>例如，跳跃将生成为相对的而不是绝对的。</p>
<p>伪装配：</p>
<p>PIC：无论代码位于地址 100 还是 1000，这都有效</p>
<div class="code"><pre class="code literal-block"><span class="mi">100</span><span class="o">:</span><span class="w"> </span><span class="n">COMPARE</span><span class="w"> </span><span class="n">REG1</span><span class="o">,</span><span class="w"> </span><span class="n">REG2</span>
<span class="mi">101</span><span class="o">:</span><span class="w"> </span><span class="n">JUMP_IF_EQUAL</span><span class="w"> </span><span class="n">CURRENT</span><span class="o">+</span><span class="mi">10</span>
<span class="o">...</span>
<span class="mi">111</span><span class="o">:</span><span class="w"> </span><span class="n">NOP</span>
</pre></div>

<p>非 PIC：这仅在代码位于地址 100 时有效</p>
<div class="code"><pre class="code literal-block"><span class="mi">100</span><span class="o">:</span><span class="w"> </span><span class="n">COMPARE</span><span class="w"> </span><span class="n">REG1</span><span class="o">,</span><span class="w"> </span><span class="n">REG2</span>
<span class="mi">101</span><span class="o">:</span><span class="w"> </span><span class="n">JUMP_IF_EQUAL</span><span class="w"> </span><span class="mi">111</span>
<span class="o">...</span>
<span class="mi">111</span><span class="o">:</span><span class="w"> </span><span class="n">NOP</span>
</pre></div>

<p>编辑：回应评论。</p>
<p>如果您的代码是使用 -fPIC 编译的，则它适合包含在库中 -
该库必须能够从其在内存中的首选位置重新定位到另一个地址，在您的库喜欢的地址可能有另一个已经加载的库。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我将尝试以更简单的方式解释已经说过的内容。</p>
<p>每当加载共享库时，加载程序（操作系统上加载您运行的任何程序的代码）都会根据对象加载到的位置更改代码中的某些地址。</p>
<p>在上面的例子中，non-PIC代码中的“111”是loader在第一次加载时写入的。</p>
<p>对于非共享对象，您可能希望它是那样的，因为编译器可以对该代码进行一些优化。</p>
<p>对于共享对象，如果另一个进程想要“链接”到该代码，则它必须将其读取到相同的虚拟地址，否则“111”将毫无意义。但是该虚拟空间可能已经在第二个进程中使用。</p>
<p><br><br><a href="posts/gcc-fpic-option/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/eval-exec-he-compile-zhi-jian-you-shi-yao-qu-bie/" class="u-url">eval、exec 和 compile 之间有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/eval-exec-he-compile-zhi-jian-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T04:28:23+08:00" itemprop="datePublished" title="2023-02-18 04:28">2023-02-18 04:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我一直在研究 Python 代码的动态评估，并遇到了函数和<code>eval()</code>语句。<code>compile()``exec</code></p>
<p><code>eval</code>有人可以解释一下和之间的区别<code>exec</code>，以及不同的模式如何<code>compile()</code>适应吗？</p>
<p><br><br></p>
<h2>解答</h2>
<h2>简短的回答，或 TL;DR</h2>
<p>基本上，<code>eval</code>它用于 <strong>评估</strong> 单个动态生成的 Python 表达式，并且仅<code>exec</code>用于 <strong>执行</strong> 动态生成的 Python
代码以获得其副作用。</p>
<p><code>eval</code>并<code>exec</code>有以下两个区别：</p>
<ol>
<li>
<code>eval</code>仅接受 <strong>单个表达式</strong> ，<code>exec</code>可以采用具有 Python 语句的代码块：循环、<code>try: except:</code>函数<code>class</code>/方法<code>def</code>初始化等。</li>
</ol>
<p>Python 中的表达式是您在变量赋值中可以拥有的任何值：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="n">a_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">anything</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">within</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">parentheses</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">expression</span><span class="p">)</span>
</pre></div>

<ol>
<li>
<code>eval</code> <strong><em>*返回给定表达式的 </em>*值</strong><code>exec</code>，而忽略其代码的返回值，并始终返回<code>None</code>（在 Python 2 中，它是一个语句，不能用作表达式，因此它实际上不返回任何内容）。</li>
</ol>
<p>在 1.0 - 2.7 版本中，<code>exec</code>是一个语句，因为 CPython 需要为函数生成一种不同类型的代码对象，用于<code>exec</code>函数内部的副作用。</p>
<p>在 Python 3 中，<code>exec</code>是一个函数；它的使用对使用它的函数的编译字节码没有影响。</p>
<hr>
<p>因此基本上：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="s1">'37 + a'</span><span class="p">)</span><span class="w">   </span><span class="c1"># it is an expression</span>
<span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">exec</span><span class="p">(</span><span class="s1">'37 + a'</span><span class="p">)</span><span class="w">   </span><span class="c1"># it is an expression statement; value is ignored (None is returned)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">exec</span><span class="p">(</span><span class="s1">'a = 47'</span><span class="p">)</span><span class="w">   </span><span class="c1"># modify a global variable as a side effect</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="mi">47</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="s1">'a = 47'</span><span class="p">)</span><span class="w">  </span><span class="c1"># you cannot evaluate a statement</span>
<span class="n">Traceback</span><span class="w"> </span><span class="p">(</span><span class="n">most</span><span class="w"> </span><span class="n">recent</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">last</span><span class="p">):</span>
<span class="w">  </span><span class="n">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">47</span>
<span class="w">      </span><span class="o">^</span>
<span class="n">SyntaxError</span><span class="p">:</span><span class="w"> </span><span class="n">invalid</span><span class="w"> </span><span class="n">syntax</span>
</pre></div>

<hr>
<p>in模式将任意数量的语句编译成字节码，隐式总是返回，而 in模式将单个表达式编译<code>compile</code>成 <em>返回</em> 该 <em>表达式</em>
值的字节码。<code>'exec'``None``'eval'</code> <strong> </strong></p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'42'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'exec'</span><span class="ss">))</span><span class="w">  </span>#<span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="nv">returns</span><span class="w"> </span><span class="nv">None</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'42'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'eval'</span><span class="ss">))</span><span class="w">  </span>#<span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="nv">returns</span><span class="w"> </span><span class="mi">42</span>
<span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'42'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'eval'</span><span class="ss">))</span><span class="w">  </span>#<span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="nv">returns</span><span class="w"> </span><span class="mi">42</span>,
<span class="o">&gt;&gt;&gt;</span><span class="w">                                          </span>#<span class="w"> </span><span class="nv">but</span><span class="w"> </span><span class="nv">ignored</span><span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="k">exec</span>
</pre></div>

<p>在<code>'eval'</code>模式中（<code>eval</code>如果传入字符串，则使用函数），<code>compile</code>如果源代码包含语句或超出单个表达式的任何其他内容，则会引发异常：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'for i in range(3): print(i)'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'eval'</span><span class="ss">)</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">3</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">print</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span>
<span class="w">      </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<hr>
<p><em>实际上， “eval 只接受一个表达式”</em> 语句仅适用于将字符串（包含 Python <em>源代码</em> ）传递给<code>eval</code>.
然后使用它在内部编译为字节码<code>compile(source, '&lt;string&gt;', 'eval')</code>这就是真正的区别所在。</p>
<p>如果一个<code>code</code>对象（包含 Python <em>字节码</em> ）被传递给<code>exec</code>or <code>eval</code>， <em>它们的行为是相同的</em>
，除了<code>exec</code>忽略返回值的事实，仍然<code>None</code>总是返回。<code>eval</code>因此，如果您<code>compile</code>之前只是将其转换为字节码而不是将其作为字符串传递，则可以执行具有语句的内容：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'if 1: print("Hello")'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'exec'</span><span class="ss">))</span>
<span class="nv">Hello</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>

<p>即使编译后的代码包含语句，也可以正常工作。它仍然返回<code>None</code>，因为那是从 返回的代码对象的返回值<code>compile</code>。</p>
<p>在<code>'eval'</code>模式中（<code>eval</code>如果传入字符串，则使用函数），<code>compile</code>如果源代码包含语句或超出单个表达式的任何其他内容，则会引发异常：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'for i in range(3): print(i)'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>.<span class="w"> </span><span class="s1">'eval'</span><span class="ss">)</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">3</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">print</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span>
<span class="w">      </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<h2>更长的答案，也就是血淋淋的细节</h2>
<h3>
<code>exec</code>和<code>eval</code>
</h3>
<p>该<code>exec</code>函数（在 Python 2 中是一条语句）用于执行动态创建的语句或程序：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">''</span><span class="err">'</span>
<span class="err">for i in range(3):</span>
<span class="err">    print("Python is cool")</span>
<span class="s1">''</span><span class="err">'</span>
<span class="err">&gt;&gt;&gt; exec(program)</span>
<span class="err">Python is cool</span>
<span class="err">Python is cool</span>
<span class="err">Python is cool</span>
<span class="err">&gt;&gt;&gt;</span>
</pre></div>

<p>该函数对单个表达式<code>eval</code>执行相同的操作， <em>并</em> 返回表达式的值： __</p>
<div class="code"><pre class="code literal-block"> &gt;&gt;&gt; a = 2
&gt;&gt;&gt; my_calculation = '42 * a'
&gt;&gt;&gt; result = eval(my_calculation)
&gt;&gt;&gt; result
84
</pre></div>

<p><code>exec</code>并且都接受程序/表达式作为包含源代码的,或对象<code>eval</code>运行，或者作为包含 Python 字节码的
<em>对象运行。</em><code>str``unicode``bytes</code> <em><code>code</code></em></p>
<p>如果将包含源代码的<code>str</code>//传递给，它的行为等效于：<code>unicode``bytes``exec</code></p>
<div class="code"><pre class="code literal-block"><span class="k">exec</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="nv">source</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'exec'</span><span class="ss">))</span>
</pre></div>

<p>并且<code>eval</code>类似地表现等同于：</p>
<div class="code"><pre class="code literal-block">eval(compile(source, '&lt;string&gt;', 'eval'))
</pre></div>

<hr>
<p>Since all expressions can be used as statements in Python (these are called
the <code>Expr</code> nodes in the Python abstract grammar; the opposite is not true),
you can always use <code>exec</code> if you do not need the return value. That is to say,
you can use either <code>eval('my_func(42)')</code> or <code>exec('my_func(42)')</code>, the
difference being that <code>eval</code> returns the value returned by <code>my_func</code>, and
<code>exec</code> discards it:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">def</span><span class="w"> </span><span class="nv">my_func</span><span class="ss">(</span><span class="nv">arg</span><span class="ss">)</span>:
...<span class="w">     </span><span class="nv">print</span><span class="ss">(</span><span class="s2">"Called with %d"</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nv">arg</span><span class="ss">)</span>
...<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
...<span class="w"> </span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'my_func(42)'</span><span class="ss">)</span>
<span class="nv">Called</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="s1">'my_func(42)'</span><span class="ss">)</span>
<span class="nv">Called</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="mi">42</span>
<span class="mi">84</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>

<p>Of the 2, only <code>exec</code> accepts source code that contains statements, like
<code>def</code>, <code>for</code>, <code>while</code>, <code>import</code>, or <code>class</code>, the assignment statement (a.k.a
<code>a = 42</code>), or entire programs:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'for i in range(3): print(i)'</span><span class="ss">)</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="s1">'for i in range(3): print(i)'</span><span class="ss">)</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">3</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">print</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span>
<span class="w">      </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<hr>
<p>Both <code>exec</code> and <code>eval</code> accept 2 additional positional arguments - <code>globals</code>
and <code>locals</code> - which are the global and local variable scopes that the code
sees. These default to the <code>globals()</code> and <code>locals()</code> within the scope that
called <code>exec</code> or <code>eval</code>, but any dictionary can be used for <code>globals</code> and any
<code>mapping</code> for <code>locals</code> (including <code>dict</code> of course). These can be used not
only to restrict/modify the variables that the code sees, but are often also
used for capturing the variables that the <code>exec</code>uted code creates:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">dict</span><span class="ss">()</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">dict</span><span class="ss">()</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'global a; a, b = 123, 42'</span>,<span class="w"> </span><span class="nv">g</span>,<span class="w"> </span><span class="nv">l</span><span class="ss">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">g</span>[<span class="s1">'a'</span>]
<span class="mi">123</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">l</span>
{<span class="s1">'b'</span>:<span class="w"> </span><span class="mi">42</span>}
</pre></div>

<p>(If you display the value of the entire <code>g</code>, it would be much longer, because
<code>exec</code> and <code>eval</code> add the built-ins module as <code>__builtins__</code> to the globals
automatically if it is missing).</p>
<p>In Python 2, the official syntax for the <code>exec</code> statement is actually <code>exec
code in globals, locals</code>, as in</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="w"> </span><span class="s1">'global a; a, b = 123, 42'</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">g</span>,<span class="w"> </span><span class="nv">l</span>
</pre></div>

<p>However the alternate syntax <code>exec(code, globals, locals)</code> has always been
accepted too (see below).</p>
<h3><code>compile</code></h3>
<p>The <code>compile(source, filename, mode, flags=0, dont_inherit=False,
optimize=-1)</code> built-in can be used to speed up repeated invocations of the
same code with <code>exec</code> or <code>eval</code> by compiling the source into a <code>code</code> object
beforehand. The <code>mode</code> parameter controls the kind of code fragment the
<code>compile</code> function accepts and the kind of bytecode it produces. The choices
are <code>'eval'</code>, <code>'exec'</code> and <code>'single'</code>:</p>
<ul>
<li>
<p><code>'eval'</code> mode expects a single expression, and will produce bytecode that when run will return the value of <strong>that expression</strong> :</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; dis.dis(compile('a + b', '&lt;string&gt;', 'eval'))
</pre></div>

<p>1           0 LOAD_NAME                0 (a)
              3 LOAD_NAME                1 (b)
              6 BINARY_ADD
              7 RETURN_VALUE</p>
</li>
<li>
<p><code>'exec'</code> accepts any kinds of python constructs from single expressions to whole modules of code, and executes them as if they were module top-level statements. The code object returns <code>None</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">dis</span>.<span class="nv">dis</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'a + b'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'exec'</span><span class="ss">))</span>
</pre></div>

<p>1           0 LOAD_NAME                0 (a)
              3 LOAD_NAME                1 (b)
              6 BINARY_ADD
              7 POP_TOP                             &lt;- discard result
              8 LOAD_CONST               0 (None)   &lt;- load None on stack
             11 RETURN_VALUE                        &lt;- return top of stack</p>
</li>
<li>
<p><code>'single'</code> is a limited form of <code>'exec'</code> which accepts a source code containing a <strong>single</strong> statement (or multiple statements separated by <code>;</code>) if the last statement is an expression statement, the resulting bytecode also <em>prints the<code>repr</code> of the value of that expression to the standard output(!)</em>.</p>
</li>
</ul>
<p>An <code>if</code>-<code>elif</code>-<code>else</code> chain, a loop with <code>else</code>, and <code>try</code> with its <code>except</code>,
<code>else</code> and <code>finally</code> blocks is considered a single statement.</p>
<p>A source fragment containing 2 top-level statements is an error for the
<code>'single'</code>, except in Python 2 there is <em>a bug</em> that sometimes allows multiple
toplevel statements in the code; only the first is compiled; the rest are
ignored:</p>
<p>In Python 2.7.8:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'a = 5\na = 6'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'single'</span><span class="ss">))</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">a</span>
<span class="mi">5</span>
</pre></div>

<p>And in Python 3.4.2:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'a = 5\na = 6'</span>,<span class="w"> </span><span class="s1">'&lt;string&gt;'</span>,<span class="w"> </span><span class="s1">'single'</span><span class="ss">))</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">        </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">multiple</span><span class="w"> </span><span class="nv">statements</span><span class="w"> </span><span class="nv">found</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nv">compiling</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">single</span><span class="w"> </span><span class="nv">statement</span>
</pre></div>

<p>This is very useful for making interactive Python shells. However, the value
of the expression is <em>not returned</em> , even if you <code>eval</code> the resulting code.</p>
<p>Thus greatest distinction of <code>exec</code> and <code>eval</code> actually comes from the
<code>compile</code> function and its modes.</p>
<hr>
<p>In addition to compiling source code to bytecode, <code>compile</code> supports compiling
<em>abstract syntax trees</em> (parse trees of Python code) into <code>code</code> objects; and
source code into abstract syntax trees (the <code>ast.parse</code> is written in Python
and just calls <code>compile(source, filename, mode, PyCF_ONLY_AST)</code>); these are
used for example for modifying source code on the fly, and also for dynamic
code creation, as it is often easier to handle the code as a tree of nodes
instead of lines of text in complex cases.</p>
<hr>
<p>While <code>eval</code> only allows you to evaluate a string that contains a single
expression, you can <code>eval</code> a whole statement, or even a whole module that has
been <code>compile</code>d into bytecode; that is, with Python 2, <code>print</code> is a statement,
and cannot be <code>eval</code>led directly:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="s1">'for i in range(3): print("Python is cool")'</span><span class="ss">)</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;string&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">3</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">print</span><span class="ss">(</span><span class="s2">"Python is cool"</span><span class="ss">)</span>
<span class="w">      </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<p><code>compile</code> it with <code>'exec'</code> mode into a <code>code</code> object and you can <strong><code>eval</code>
it</strong>; the <code>eval</code> function will return <code>None</code>.</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">compile</span><span class="ss">(</span><span class="s1">'for i in range(3): print("Python is cool")'</span>,
<span class="w">                   </span><span class="s1">'foo.py'</span>,<span class="w"> </span><span class="s1">'exec'</span><span class="ss">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">eval</span><span class="ss">(</span><span class="nv">code</span><span class="ss">)</span>
<span class="nv">Python</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">cool</span>
<span class="nv">Python</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">cool</span>
<span class="nv">Python</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">cool</span>
</pre></div>

<p>If one looks into <code>eval</code> and <code>exec</code> source code in CPython 3, this is very
evident; they both call <code>PyEval_EvalCode</code> with same arguments, the only
difference being that <code>exec</code> explicitly returns <code>None</code>.</p>
<h3>Syntax differences of <code>exec</code> between Python 2 and Python 3</h3>
<p>One of the major differences in Python <strong>2</strong> is that <code>exec</code> is a statement and
<code>eval</code> is a built-in function (both are built-in functions in Python 3). It is
a well-known fact that the official syntax of <code>exec</code> in Python 2 is <code>exec code
[in globals[, locals]]</code>.</p>
<p>Unlike majority of the Python 2-to-3 porting guides seem to suggest, the
<code>exec</code> statement in CPython 2 can be also used with syntax that <em>looks</em>
<strong>exactly</strong> like the <code>exec</code> function invocation in Python 3. The reason is
that Python 0.9.9 had the <code>exec(code, globals, locals)</code> built-in function! And
that built-in function was replaced with <code>exec</code> statement somewhere before
Python 1.0 release.</p>
<p>Since it was desirable to not break backwards compatibility with Python 0.9.9,
Guido van Rossum added a compatibility hack in 1993: if the <code>code</code> was a tuple
of length 2 or 3, and <code>globals</code> and <code>locals</code> were not passed into the <code>exec</code>
statement otherwise, the <code>code</code> would be interpreted as if the 2nd and 3rd
element of the tuple were the <code>globals</code> and <code>locals</code> respectively. The
compatibility hack was not mentioned even in Python 1.4 documentation (the
earliest available version online); and thus was not known to many writers of
the porting guides and tools, until it was documented again in November 2012:</p>
<blockquote>
<p>The first expression may also be a tuple of length 2 or 3. In this case, the
optional parts must be omitted. The form <code>exec(expr, globals)</code> is equivalent
to <code>exec expr in globals</code>, while the form <code>exec(expr, globals, locals)</code> is
equivalent to <code>exec expr in globals, locals</code>. The tuple form of <code>exec</code>
provides compatibility with Python 3, where <code>exec</code> is a function rather than
a statement.</p>
</blockquote>
<p>Yes, in CPython 2.7 that it is handily referred to as being a forward-
compatibility option (why confuse people over that there is a backward
compatibility option at all), when it actually had been there for <em>backward-
compatibility for two decades</em>.</p>
<p>Thus while <code>exec</code> is a statement in Python 1 and Python 2, and a built-in
function in Python 3 and Python 0.9.9,</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s2">"print(a)"</span>,<span class="w"> </span><span class="nv">globals</span><span class="ss">()</span>,<span class="w"> </span>{<span class="s1">'a'</span>:<span class="w"> </span><span class="mi">42</span>}<span class="ss">)</span>
<span class="mi">42</span>
</pre></div>

<p>has had identical behaviour in possibly every widely released Python version
ever; and works in Jython 2.5.2, PyPy 2.3.1 (Python 2.7.6) and IronPython
2.6.1 too (kudos to them following the undocumented behaviour of CPython
closely).</p>
<p>What you cannot do in Pythons 1.0 - 2.7 with its compatibility hack, is to
store the return value of <code>exec</code> into a variable:</p>
<div class="code"><pre class="code literal-block"><span class="nv">Python</span><span class="w"> </span><span class="mi">2</span>.<span class="mi">7</span>.<span class="mi">11</span><span class="o">+</span><span class="w"> </span><span class="ss">(</span><span class="nv">default</span>,<span class="w"> </span><span class="nv">Apr</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="mi">2016</span>,<span class="w"> </span><span class="mi">14</span>:<span class="mi">00</span>:<span class="mi">29</span><span class="ss">)</span><span class="w"> </span>
[<span class="nv">GCC</span><span class="w"> </span><span class="mi">5</span>.<span class="mi">3</span>.<span class="mi">1</span><span class="w"> </span><span class="mi">20160413</span>]<span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">linux2</span>
<span class="nv">Type</span><span class="w"> </span><span class="s2">"help"</span>,<span class="w"> </span><span class="s2">"copyright"</span>,<span class="w"> </span><span class="s2">"credits"</span><span class="w"> </span><span class="nv">or</span><span class="w"> </span><span class="s2">"license"</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">more</span><span class="w"> </span><span class="nv">information</span>.
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'print(42)'</span><span class="ss">)</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'print(42)'</span><span class="ss">)</span>
<span class="w">           </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<p>(which wouldn't be useful in Python 3 either, as <code>exec</code> always returns
<code>None</code>), or pass a reference to <code>exec</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">call_later</span><span class="ss">(</span><span class="k">exec</span>,<span class="w"> </span><span class="s1">'print(42)'</span>,<span class="w"> </span><span class="nv">delay</span><span class="o">=</span><span class="mi">1000</span><span class="ss">)</span>
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nv">call_later</span><span class="ss">(</span><span class="k">exec</span>,<span class="w"> </span><span class="s1">'print(42)'</span>,<span class="w"> </span><span class="nv">delay</span><span class="o">=</span><span class="mi">1000</span><span class="ss">)</span>
<span class="w">                  </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<p>Which a pattern that someone might actually have used, though unlikely;</p>
<p>Or use it in a list comprehension:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span>[<span class="k">exec</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span>[<span class="s1">'print(42)'</span>,<span class="w"> </span><span class="s1">'print(foo)'</span>]
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span>[<span class="k">exec</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span>[<span class="s1">'print(42)'</span>,<span class="w"> </span><span class="s1">'print(foo)'</span>]
<span class="w">        </span><span class="o">^</span>
<span class="nv">SyntaxError</span>:<span class="w"> </span><span class="nv">invalid</span><span class="w"> </span><span class="nv">syntax</span>
</pre></div>

<p>which is abuse of list comprehensions (use a <code>for</code> loop instead!).</p>
<p><br></p>
<h3>更多建议</h3>
<ol>
<li>
<p><code>exec</code>不是表达式：在 Python 2.x 中是语句，在 Python 3.x 中是函数。它编译并立即评估字符串中包含的一条语句或一组语句。例子：</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="k">exec</span><span class="ss">(</span><span class="s1">'print(5)'</span><span class="ss">)</span><span class="w">           </span>#<span class="w"> </span><span class="nv">prints</span><span class="w"> </span><span class="mi">5</span>.
</pre></div>

<p># exec 'print 5'     if you use Python 2.x, nor the exec neither the print is a function there
 exec('print(5)\nprint(6)')  # prints 5{newline}6.
 exec('if True: print(6)')  # prints 6.
 exec('5')                 # does nothing and returns nothing.</p>
</li>
<li>
<p><code>eval</code>是一个内置函数（ <strong>不是</strong> 语句），它计算表达式并返回表达式产生的值。例子：</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">eval</span><span class="p">(</span><span class="s">'5'</span><span class="p">)</span><span class="w">              </span><span class="c1"># x &lt;- 5</span>
</pre></div>

<p>x = eval('%d + 6' % x)     # x &lt;- 11
 x = eval('abs(%d)' % -100) # x &lt;- 100
 x = eval('x = 5')          # INVALID; assignment is not an expression.
 x = eval('if 1: x = 4')    # INVALID; if is a statement, not an expression.</p>
</li>
<li>
<p><code>compile``exec</code>是and的较低级别版本<code>eval</code>。它不执行或评估您的语句或表达式，而是返回一个可以执行此操作的代码对象。模式如下：</p>
</li>
<li>
<p><code>compile(string, '', 'eval')</code>返回完成后将执行的代码对象<code>eval(string)</code>。请注意，您 <em>不能</em> 在此模式下使用语句；只有一个（单个）表达式是有效的。</p>
</li>
<li>
<p><code>compile(string, '', 'exec')</code>返回完成后将执行的代码对象<code>exec(string)</code>。您可以在此处使用任意数量的语句。</p>
</li>
<li>
<p><code>compile(string, '', 'single')</code>类似于<code>exec</code>模式，但只需要一个表达式/语句，例如<code>compile('a=1 if 1 else 3', 'myf', mode='single')</code></p>
</li>
</ol>
<p><br><br><a href="posts/what-s-the-difference-between-eval-exec-and-compile/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1226.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1224.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
