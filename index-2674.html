<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2674) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2674.html">
<link rel="prev" href="index-2675.html" type="text/html">
<link rel="next" href="index-2673.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-get-subarray-from-array/" class="u-url">How to get subarray from array?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-get-subarray-from-array/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T09:27:59+08:00" itemprop="datePublished" title="2023-03-05 09:27">2023-03-05 09:27</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have <code>var ar = [1, 2, 3, 4, 5]</code> and want some function <code>getSubarray(array,
fromIndex, toIndex)</code>, that result of call <code>getSubarray(ar, 1, 3)</code> is new array
<code>[2, 3, 4]</code>.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Take a look at <code>Array.slice(begin, end)</code></p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">ar</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>

<span class="o">//</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mf">1.</span><span class="o">.</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">included</span>

<span class="k">const</span><span class="w"> </span><span class="n">ar2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ar</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ar2</span><span class="p">);</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>For a simple use of <code>slice</code>, use my extension to Array Class:</p>
<div class="code"><pre class="code literal-block"><span class="nv">Array</span>.<span class="nv">prototype</span>.<span class="nv">subarray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">function</span><span class="ss">(</span><span class="nv">start</span>,<span class="w"> </span><span class="k">end</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="o">!</span><span class="k">end</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="c1">; } </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">this</span>.<span class="nv">slice</span><span class="ss">(</span><span class="nv">start</span>,<span class="w"> </span><span class="nv">this</span>.<span class="nv">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="ss">(</span><span class="k">end</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="ss">))</span><span class="c1">;</span>
}<span class="c1">;</span>
</pre></div>

<p>Then:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">bigArr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">"a"</span><span class="p">,</span><span class="w"> </span><span class="s2">"b"</span><span class="p">,</span><span class="w"> </span><span class="s2">"c"</span><span class="p">,</span><span class="w"> </span><span class="s2">"fd"</span><span class="p">,</span><span class="w"> </span><span class="s2">"ze"</span><span class="p">];</span>
</pre></div>

<p><strong>Test1</strong> :</p>
<div class="code"><pre class="code literal-block">bigArr.subarray(1, -1);
</pre></div>

<p>&lt; ["b", "c", "fd", "ze"]</p>
<p><strong>Test2:</strong></p>
<div class="code"><pre class="code literal-block">bigArr.subarray(2, -2);
</pre></div>

<p>&lt; ["c", "fd"]</p>
<p><strong>Test3:</strong></p>
<div class="code"><pre class="code literal-block">bigArr.subarray(2);
</pre></div>

<p>&lt; ["c", "fd","ze"]</p>
<p>Might be easier for developers coming from another language (i.e. Groovy).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-does-coalgebra-mean-in-the-context-of-programming/" class="u-url">What does "coalgebra" mean in the context of programming?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-does-coalgebra-mean-in-the-context-of-programming/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T09:26:00+08:00" itemprop="datePublished" title="2023-03-05 09:26">2023-03-05 09:26</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have heard the term "coalgebras" several times in functional programming and
PLT circles, especially when the discussion is about objects, comonads,
lenses, and such. Googling this term gives pages that give mathematical
description of these structures which is pretty much incomprehensible to me.
Can anyone please explain what coalgebras mean in the context of programming,
what is their significance, and how they relate to objects and comonads?</p>
<p><br><br></p>
<h2>Answer</h2>
<h2>Algebras</h2>
<p>I think the place to start would be to understand the idea of an <strong>algebra</strong>.
This is just a generalization of algebraic structures like groups, rings,
monoids and so on. Most of the time, these things are introduced in terms of
sets, but since we're among friends, I'll talk about Haskell types instead. (I
can't resist using some Greek letters though—they make everything look
cooler!)</p>
<p>An algebra, then, is just a type <code>τ</code> with some functions and identities. These
functions take differing numbers of arguments of type <code>τ</code> and produce a <code>τ</code>:
uncurried, they all look like <code>(τ, τ,…, τ) → τ</code>. They can also have
"identities"—elements of <code>τ</code> that have special behavior with some of the
functions.</p>
<p>The simplest example of this is the monoid. A monoid is any type <code>τ</code> with a
function <code>mappend ∷ (τ, τ) → τ</code> and an identity <code>mzero ∷ τ</code>. Other examples
include things like groups (which are just like monoids except with an extra
<code>invert ∷ τ → τ</code> function), rings, lattices and so on.</p>
<p>All the functions operate on <code>τ</code> but can have different arities. We can write
these out as <code>τⁿ → τ</code>, where <code>τⁿ</code> maps to a tuple of <code>n</code> <code>τ</code>. This way, it
makes sense to think of identities as <code>τ⁰ → τ</code> where <code>τ⁰</code> is just the empty
tuple <code>()</code>. So we can actually simplify the idea of an algebra now: it's just
some type with some number of functions on it.</p>
<p>An algebra is just a common pattern in mathematics that's been "factored out",
just like we do with code. People noticed that a whole bunch of interesting
things—the aforementioned monoids, groups, lattices and so on—all follow a
similar pattern, so they abstracted it out. The advantage of doing this is the
same as in programming: it creates reusable proofs and makes certain kinds of
reasoning easier.</p>
<h3>F-Algebras</h3>
<p>However, we're not quite done with factoring. So far, we have a bunch of
functions <code>τⁿ → τ</code>. We can actually do a neat trick to combine them all into
one function. In particular, let's look at monoids: we have <code>mappend ∷ (τ, τ)
→ τ</code> and <code>mempty ∷ () → τ</code>. We can turn these into a single function using a
sum type—<code>Either</code>. It would look like this:</p>
<div class="code"><pre class="code literal-block">op ∷ Monoid τ ⇒ Either (τ, τ) () → τ
op (Left (a, b)) = mappend (a, b)
op (Right ())    = mempty
</pre></div>

<p>We can actually use this transformation repeatedly to combine <em>all</em> the <code>τⁿ →
τ</code> functions into a single one, for <em>any</em> algebra. (In fact, we can do this
for any number of functions <code>a → τ</code>, <code>b → τ</code> and so on for <em>any</em> <code>a, b,…</code>.)</p>
<p>This lets us talk about algebras as a type <code>τ</code> with a <em>single</em> function from
some mess of <code>Either</code>s to a single <code>τ</code>. For monoids, this mess is: <code>Either (τ,
τ) ()</code>; for groups (which have an extra <code>τ → τ</code> operation), it's: <code>Either
(Either (τ, τ) τ) ()</code>. It's a different type for every different structure. So
what do all these types have in common? The most obvious thing is that they
are all just sums of products—algebraic data types. For example, for monoids,
we could create a monoid argument type that works for <em>any</em> monoid τ:</p>
<div class="code"><pre class="code literal-block">data MonoidArgument τ = Mappend τ τ -- here τ τ is the same as (τ, τ)
                      | Mempty      -- here we can just leave the () out
</pre></div>

<p>We can do the same thing for groups and rings and lattices and all the other
possible structures.</p>
<p>What else is special about all these types? Well, they're all <code>Functors</code>!
E.g.:</p>
<div class="code"><pre class="code literal-block">instance Functor MonoidArgument where
  fmap f (Mappend τ τ) = Mappend (f τ) (f τ)
  fmap f Mempty        = Mempty
</pre></div>

<p>So we can generalize our idea of an algebra even more. It's just some type <code>τ</code>
with a function <code>f τ → τ</code> for some functor <code>f</code>. In fact, we could write this
out as a typeclass:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Functor</span> <span class="nb">f</span> ⇒ <span class="n">Algebra</span> <span class="nb">f</span> <span class="n">τ</span> <span class="n">where</span>
  <span class="n">op</span> ∷ <span class="nb">f</span> <span class="n">τ</span> → <span class="n">τ</span>
</pre></div>

<p>This is often called an "F-algebra" because it's determined by the functor
<code>F</code>. If we could partially apply typeclasses, we could define something like
<code>class Monoid = Algebra MonoidArgument</code>.</p>
<h2>Coalgebras</h2>
<p>Now, hopefully you have a good grasp of what an algebra is and how it's just a
generalization of normal algebraic structures. So what is an F-coalgebra?
Well, the co implies that it's the "dual" of an algebra—that is, we take an
algebra and flip some arrows. I only see one arrow in the above definition, so
I'll just flip that:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Functor</span> <span class="nb">f</span> ⇒ <span class="n">CoAlgebra</span> <span class="nb">f</span> <span class="n">τ</span> <span class="n">where</span>
  <span class="n">coop</span> ∷ <span class="n">τ</span> → <span class="nb">f</span> <span class="n">τ</span>
</pre></div>

<p>And that's all it is! Now, this conclusion may seem a little flippant (heh).
It tells you <em>what</em> a coalgebra is, but does not really give any insight on
how it's useful or why we care. I'll get to that in a bit, once I find or come
up with a good example or two :P.</p>
<h3>Classes and Objects</h3>
<p>After reading around a bit, I think I have a good idea of how to use
coalgebras to represent classes and objects. We have a type <code>C</code> that contains
all the possible internal states of objects in the class; the class itself is
a coalgebra over <code>C</code> which specifies the methods and properties of the
objects.</p>
<p>As shown in the algebra example, if we have a bunch of functions like <code>a → τ</code>
and <code>b → τ</code> for any <code>a, b,…</code>, we can combine them all into a single function
using <code>Either</code>, a sum type. The dual "notion" would be combining a bunch of
functions of type <code>τ → a</code>, <code>τ → b</code> and so on. We can do this using the dual of
a sum type—a product type. So given the two functions above (called <code>f</code> and
<code>g</code>), we can create a single one like so:</p>
<div class="code"><pre class="code literal-block">both ∷ τ → (a, b)
both x = (f x, g x)
</pre></div>

<p>The type <code>(a, a)</code> is a functor in the straightforward way, so it certainly
fits with our notion of an F-coalgebra. This particular trick lets us package
up a bunch of different functions—or, for OOP, methods—into a single function
of type <code>τ → f τ</code>.</p>
<p>The elements of our type <code>C</code> represent the <em>internal</em> state of the object. If
the object has some readable properties, they have to be able to depend on the
state. The most obvious way to do this is to make them a function of <code>C</code>. So
if we want a length property (e.g. <code>object.length</code>), we would have a function
<code>C → Int</code>.</p>
<p>We want methods that can take an argument and modify state. To do this, we
need to take all the arguments and produce a new <code>C</code>. Let's imagine a
<code>setPosition</code> method which takes an <code>x</code> and a <code>y</code> coordinate:
<code>object.setPosition(1, 2)</code>. It would look like this: <code>C → ((Int, Int) → C)</code>.</p>
<p>The important pattern here is that the "methods" and "properties" of the
object take the object itself as their first argument. This is just like the
<code>self</code> parameter in Python and like the implicit <code>this</code> of many other
languages. A coalgebra essentially just encapsulates the behavior of taking a
<code>self</code> parameter: that's what the first <code>C</code> in <code>C → F C</code> is.</p>
<p>So let's put it all together. Let's imagine a class with a <code>position</code>
property, a <code>name</code> property and <code>setPosition</code> function:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">C</span>
  <span class="nb">private</span>
    <span class="nb">x</span>, <span class="n">y</span>  : <span class="nb">Int</span>
    <span class="n">_name</span> : <span class="n">String</span>
  <span class="n">public</span>
    <span class="nb">name</span>        : <span class="n">String</span>
    <span class="n">position</span>    : (<span class="nb">Int</span>, <span class="nb">Int</span>)
    <span class="n">setPosition</span> : (<span class="nb">Int</span>, <span class="nb">Int</span>) → <span class="n">C</span>
</pre></div>

<p>We need two parts to represent this class. First, we need to represent the
internal state of the object; in this case it just holds two <code>Int</code>s and a
<code>String</code>. (This is our type <code>C</code>.) Then we need to come up with the coalgebra
representing the class.</p>
<div class="code"><pre class="code literal-block">data C = Obj { x, y  ∷ Int
             , _name ∷ String }
</pre></div>

<p>We have two properties to write. They're pretty trivial:</p>
<div class="code"><pre class="code literal-block">position ∷ C → (Int, Int)
position self = (x self, y self)

name ∷ C → String
name self = _name self
</pre></div>

<p>Now we just need to be able to update the position:</p>
<div class="code"><pre class="code literal-block">setPosition ∷ C → (Int, Int) → C
setPosition self (newX, newY) = self { x = newX, y = newY }
</pre></div>

<p>This is just like a Python class with its explicit <code>self</code> variables. Now that
we have a bunch of <code>self →</code> functions, we need to combine them into a single
function for the coalgebra. We can do this with a simple tuple:</p>
<div class="code"><pre class="code literal-block">coop ∷ C → ((Int, Int), String, (Int, Int) → C)
coop self = (position self, name self, setPosition self)
</pre></div>

<p>The type <code>((Int, Int), String, (Int, Int) → c)</code>—for <em>any</em> <code>c</code>—is a functor, so
<code>coop</code> does have the form we want: <code>Functor f ⇒ C → f C</code>.</p>
<p>Given this, <code>C</code> along with <code>coop</code> form a coalgebra which specifies the class I
gave above. You can see how we can use this same technique to specify any
number of methods and properties for our objects to have.</p>
<p>This lets us use coalgebraic reasoning to deal with classes. For example, we
can bring in the notion of an "F-coalgebra homomorphism" to represent
transformations between classes. This is a scary sounding term that just means
a transformation between coalgebras that preserves structure. This makes it
much easier to think about mapping classes onto other classes.</p>
<p>In short, an F-coalgebra represents a class by having a bunch of properties
and methods that all depend on a <code>self</code> parameter containing each object's
internal state.</p>
<h2>Other Categories</h2>
<p>So far, we've talked about algebras and coalgebras as Haskell types. An
algebra is just a type <code>τ</code> with a function <code>f τ → τ</code> and a coalgebra is just a
type <code>τ</code> with a function <code>τ → f τ</code>.</p>
<p>However, nothing really ties these ideas to Haskell <em>per se</em>. In fact, they're
usually introduced in terms of sets and mathematical functions rather than
types and Haskell functions. Indeed,we can generalize these concepts to <em>any</em>
categories!</p>
<dl>
<dt>We can define an F-algebra for some category <code>C</code>. First, we need a functor `F</dt>
<dd>C → C<code>—that is, an _endofunctor_. (All Haskell</code>Functor<code>s are actually
endofunctors from</code>Hask → Hask<code>.) Then, an algebra is just an object</code>A<code>from</code>C<code>with a morphism</code>F A → A<code>. A coalgebra is the same except with</code>A → F A`.</dd>
</dl>
<p>What do we gain by considering other categories? Well, we can use the same
ideas in different contexts. Like monads. In Haskell, a monad is some type <code>M
∷ ★ → ★</code> with three operations:</p>
<div class="code"><pre class="code literal-block"><span class="nv">map</span><span class="w">      </span>∷<span class="w"> </span><span class="ss">(</span>α<span class="w"> </span>→<span class="w"> </span>β<span class="ss">)</span><span class="w"> </span>→<span class="w"> </span><span class="ss">(</span><span class="nv">M</span><span class="w"> </span>α<span class="w"> </span>→<span class="w"> </span><span class="nv">M</span><span class="w"> </span>β<span class="ss">)</span>
<span class="k">return</span><span class="w">   </span>∷<span class="w"> </span>α<span class="w"> </span>→<span class="w"> </span><span class="nv">M</span><span class="w"> </span>α
<span class="nv">join</span><span class="w">     </span>∷<span class="w"> </span><span class="nv">M</span><span class="w"> </span><span class="ss">(</span><span class="nv">M</span><span class="w"> </span>α<span class="ss">)</span><span class="w"> </span>→<span class="w"> </span><span class="nv">M</span><span class="w"> </span>α
</pre></div>

<p>The <code>map</code> function is just a proof of the fact that <code>M</code> is a <code>Functor</code>. So we
can say that a monad is just a functor with <em>two</em> operations: <code>return</code> and
<code>join</code>.</p>
<p>Functors form a category themselves, with morphisms between them being so-
called "natural transformations". A natural transformation is just a way to
transform one functor into another while preserving its structure. Here's a
nice article helping explain the idea. It talks about <code>concat</code>, which is just
<code>join</code> for lists.</p>
<p>With Haskell functors, the composition of two functors is a functor itself. In
pseudocode, we could write this:</p>
<div class="code"><pre class="code literal-block">instance (Functor f, Functor g) ⇒ Functor (f ∘ g) where
  fmap fun x = fmap (fmap fun) x
</pre></div>

<p>This helps us think about <code>join</code> as a mapping from <code>f ∘ f → f</code>. The type of
<code>join</code> is <code>∀α. f (f α) → f α</code>. Intuitively, we can see how a function valid
for <em>all</em> types <code>α</code> can be thought of as a transformation of <code>f</code>.</p>
<p><code>return</code> is a similar transformation. Its type is <code>∀α. α → f α</code>. This looks
different—the first <code>α</code> is not "in" a functor! Happily, we can fix this by
adding an identity functor there: <code>∀α. Identity α → f α</code>. So <code>return</code> is a
transformation <code>Identity → f</code>.</p>
<p>Now we can think about a monad as just an algebra based around some functor
<code>f</code> with operations <code>f ∘ f → f</code> and <code>Identity → f</code>. Doesn't this look
familiar? It's very similar to a monoid, which was just some type <code>τ</code> with
operations <code>τ × τ → τ</code> and <code>() → τ</code>.</p>
<p>So a monad is just like a monoid, except instead of having a type we have a
functor. It's the same sort of algebra, just in a different category. (This is
where the phrase "A monad is just a monoid in the category of endofunctors"
comes from as far as I know.)</p>
<p>Now, we have these two operations: <code>f ∘ f → f</code> and <code>Identity → f</code>. To get the
corresponding coalgebra, we just flip the arrows. This gives us two new
operations: <code>f → f ∘ f</code> and <code>f → Identity</code>. We can turn them into Haskell
types by adding type variables as above, giving us <code>∀α. f α → f (f α)</code> and
<code>∀α. f α → α</code>. This looks just like the definition of a comonad:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Functor</span> <span class="nb">f</span> ⇒ <span class="n">Comonad</span> <span class="nb">f</span> <span class="n">where</span>
  <span class="n">coreturn</span> ∷ <span class="nb">f</span> <span class="n">α</span> → <span class="n">α</span>
  <span class="n">cojoin</span>   ∷ <span class="nb">f</span> <span class="n">α</span> → <span class="nb">f</span> (<span class="nb">f</span> <span class="n">α</span>)
</pre></div>

<p>So a comonad is then a <em>coalgebra</em> in a category of endofunctors.</p>
<p><br></p>
<h3>Suggest</h3>
<p>F-algebras and F-coalgebras are mathematical structures which are instrumental
in reasoning about <em>inductive types</em> (or <em>recursive types</em> ).</p>
<h2>F-algebras</h2>
<p>We'll start first with F-algebras. I will try to be as simple as possible.</p>
<p>I guess you know what is a recursive type. For example, this is a type for a
list of integers:</p>
<div class="code"><pre class="code literal-block">data IntList = Nil | Cons (Int, IntList)
</pre></div>

<p>It is obvious that it is recursive - indeed, its definition refers to itself.
Its definition consists of two data constructors, which have the following
types:</p>
<div class="code"><pre class="code literal-block"><span class="n">Nil</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
<span class="n">Cons</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">IntList</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
</pre></div>

<p>Note that I have written type of <code>Nil</code> as <code>() -&gt; IntList</code>, not simply
<code>IntList</code>. These are in fact equivalent types from the theoretical point of
view, because <code>()</code> type has only one inhabitant.</p>
<p>If we write signatures of these functions in a more set-theoretical way, we
will get</p>
<div class="code"><pre class="code literal-block"><span class="n">Nil</span><span class="w">  </span><span class="o">::</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
<span class="n">Cons</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntList</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
</pre></div>

<p>where <code>1</code> is a unit set (set with one element) and <code>A × B</code> operation is a
cross product of two sets <code>A</code> and <code>B</code> (that is, set of pairs <code>(a, b)</code> where
<code>a</code> goes through all elements of <code>A</code> and <code>b</code> goes through all elements of
<code>B</code>).</p>
<p>Disjoint union of two sets <code>A</code> and <code>B</code> is a set <code>A | B</code> which is a union of
sets <code>{(a, 1) : a in A}</code> and <code>{(b, 2) : b in B}</code>. Essentially it is a set of
all elements from both <code>A</code> and <code>B</code>, but with each of this elements 'marked' as
belonging to either <code>A</code> or <code>B</code>, so when we pick any element from <code>A | B</code> we
will immediately know whether this element came from <code>A</code> or from <code>B</code>.</p>
<p>We can 'join' <code>Nil</code> and <code>Cons</code> functions, so they will form a single function
working on a set <code>1 | (Int × IntList)</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">Nil</span><span class="o">|</span><span class="n">Cons</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntList</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
</pre></div>

<p>Indeed, if <code>Nil|Cons</code> function is applied to <code>()</code> value (which, obviously,
belongs to <code>1 | (Int × IntList)</code> set), then it behaves as if it was <code>Nil</code>; if
<code>Nil|Cons</code> is applied to any value of type <code>(Int, IntList)</code> (such values are
also in the set <code>1 | (Int × IntList)</code>, it behaves as <code>Cons</code>.</p>
<p>Now consider another datatype:</p>
<div class="code"><pre class="code literal-block">data IntTree = Leaf Int | Branch (IntTree, IntTree)
</pre></div>

<p>It has the following constructors:</p>
<div class="code"><pre class="code literal-block"><span class="n">Leaf</span><span class="w">   </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntTree</span>
<span class="n">Branch</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">IntTree</span><span class="p">,</span><span class="w"> </span><span class="n">IntTree</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntTree</span>
</pre></div>

<p>which also can be joined into one function:</p>
<div class="code"><pre class="code literal-block"><span class="n">Leaf</span><span class="o">|</span><span class="n">Branch</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">IntTree</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntTree</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntTree</span>
</pre></div>

<p>It can be seen that both of this <code>joined</code> functions have similar type: they
both look like</p>
<div class="code"><pre class="code literal-block"><span class="n">f</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span>
</pre></div>

<p>where <code>F</code> is a kind of transformation which takes our type and gives more
complex type, which consists of <code>x</code> and <code>|</code> operations, usages of <code>T</code> and
possibly other types. For example, for <code>IntList</code> and <code>IntTree</code> <code>F</code> looks as
follows:</p>
<div class="code"><pre class="code literal-block">F1 T = 1 | (Int × T)
F2 T = Int | (T × T)
</pre></div>

<p>We can immediately notice that any algebraic type can be written in this way.
Indeed, that is why they are called 'algebraic': they consist of a number of
'sums' (unions) and 'products' (cross products) of other types.</p>
<p>Now we can define F-algebra. <em>F-algebra</em> is just a pair <code>(T, f)</code>, where <code>T</code> is
some type and <code>f</code> is a function of type <code>f :: F T -&gt; T</code>. In our examples
F-algebras are <code>(IntList, Nil|Cons)</code> and <code>(IntTree, Leaf|Branch)</code>. Note,
however, that despite that type of <code>f</code> function is the same for each F, <code>T</code>
and <code>f</code> themselves can be arbitrary. For example, <code>(String, g :: 1 | (Int x
String) -&gt; String)</code> or <code>(Double, h :: Int | (Double, Double) -&gt; Double)</code> for
some <code>g</code> and <code>h</code> are also F-algebras for corresponding F.</p>
<p>Afterwards we can introduce <em>F-algebra homomorphisms</em> and then <em>initial
F-algebras</em> , which have very useful properties. In fact, <code>(IntList,
Nil|Cons)</code> is an initial F1-algebra, and <code>(IntTree, Leaf|Branch)</code> is an
initial F2-algebra. I will not present exact definitions of these terms and
properties since they are more complex and abstract than needed.</p>
<p>Nonetheless, the fact that, say, <code>(IntList, Nil|Cons)</code> is F-algebra allows us
to define <code>fold</code>-like function on this type. As you know, fold is a kind of
operation which transforms some recursive datatype in one finite value. For
example, we can fold a list of integer into a single value which is a sum of
all elements in the list:</p>
<div class="code"><pre class="code literal-block"><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
</pre></div>

<p>It is possible to generalize such operation on any recursive datatype.</p>
<p>The following is a signature of <code>foldr</code> function:</p>
<div class="code"><pre class="code literal-block"><span class="n">foldr</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span>
</pre></div>

<p>Note that I have used braces to separate first two arguments from the last
one. This is not real <code>foldr</code> function, but it is isomorphic to it (that is,
you can easily get one from the other and vice versa). Partially applied
<code>foldr</code> will have the following signature:</p>
<div class="code"><pre class="code literal-block"><span class="n">foldr</span><span class="w"> </span><span class="p">((</span><span class="o">+</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="o">[</span><span class="n">Int</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Int</span>
</pre></div>

<p>We can see that this is a function which takes a list of integers and returns
a single integer. Let's define such function in terms of our <code>IntList</code> type.</p>
<div class="code"><pre class="code literal-block"><span class="n">sumFold</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntList</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span>
<span class="n">sumFold</span><span class="w"> </span><span class="n">Nil</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">sumFold</span><span class="w"> </span><span class="p">(</span><span class="n">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sumFold</span><span class="w"> </span><span class="n">xs</span>
</pre></div>

<p>We see that this function consists of two parts: first part defines this
function's behavior on <code>Nil</code> part of <code>IntList</code>, and second part defines
function's behavior on <code>Cons</code> part.</p>
<p>Now suppose that we are programming not in Haskell but in some language which
allows usage of algebraic types directly in type signatures (well, technically
Haskell allows usage of algebraic types via tuples and <code>Either a b</code> datatype,
but this will lead to unnecessary verbosity). Consider a function:</p>
<div class="code"><pre class="code literal-block"><span class="n">reductor</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span>
<span class="n">reductor</span><span class="w"> </span><span class="p">()</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">reductor</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span>
</pre></div>

<p>It can be seen that <code>reductor</code> is a function of type <code>F1 Int -&gt; Int</code>, just as
in definition of F-algebra! Indeed, the pair <code>(Int, reductor)</code> is an
F1-algebra.</p>
<p>Because <code>IntList</code> is an initial F1-algebra, for each type <code>T</code> and for each
function <code>r :: F1 T -&gt; T</code> there exist a function, called <em>catamorphism</em> for
<code>r</code>, which converts <code>IntList</code> to <code>T</code>, and such function is unique. Indeed, in
our example a catamorphism for <code>reductor</code> is <code>sumFold</code>. Note how <code>reductor</code>
and <code>sumFold</code> are similar: they have almost the same structure! In <code>reductor</code>
definition <code>s</code> parameter usage (type of which corresponds to <code>T</code>) corresponds
to usage of the result of computation of <code>sumFold xs</code> in <code>sumFold</code> definition.</p>
<p>Just to make it more clear and help you see the pattern, here is another
example, and we again begin from the resulting folding function. Consider
<code>append</code> function which appends its first argument to second one:</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="n">append</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">])</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">])</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span>
</pre></div>

<p>This how it looks on our <code>IntList</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">appendFold</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntList</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
<span class="n">appendFold</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="p">()</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">ys</span>
<span class="n">appendFold</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="p">(</span><span class="n">Cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">appendFold</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="n">xs</span>
</pre></div>

<p>Again, let's try to write out the reductor:</p>
<div class="code"><pre class="code literal-block"><span class="n">appendReductor</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntList</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntList</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntList</span>
<span class="n">appendReductor</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="p">()</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ys</span>
<span class="n">appendReductor</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">rs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">rs</span>
</pre></div>

<p><code>appendFold</code> is a catamorphism for <code>appendReductor</code> which transforms <code>IntList</code>
into <code>IntList</code>.</p>
<p>So, essentially, F-algebras allow us to define 'folds' on recursive
datastructures, that is, operations which reduce our structures to some value.</p>
<h2>F-coalgebras</h2>
<p>F-coalgebras are so-called 'dual' term for F-algebras. They allow us to define
<code>unfolds</code> for recursive datatypes, that is, a way to construct recursive
structures from some value.</p>
<p>Suppose you have the following type:</p>
<div class="code"><pre class="code literal-block">data IntStream = Cons (Int, IntStream)
</pre></div>

<p>This is an infinite stream of integers. Its only constructor has the following
type:</p>
<div class="code"><pre class="code literal-block"><span class="n">Cons</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="p">,</span><span class="w"> </span><span class="n">IntStream</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntStream</span>
</pre></div>

<p>Or, in terms of sets</p>
<div class="code"><pre class="code literal-block"><span class="n">Cons</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntStream</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntStream</span>
</pre></div>

<p>Haskell allows you to pattern match on data constructors, so you can define
the following functions working on <code>IntStream</code>s:</p>
<div class="code"><pre class="code literal-block"><span class="n">head</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntStream</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span>
<span class="n">head</span><span class="w"> </span><span class="p">(</span><span class="n">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>

<span class="n">tail</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntStream</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntStream</span>
<span class="n">tail</span><span class="w"> </span><span class="p">(</span><span class="n">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span>
</pre></div>

<p>You can naturally 'join' these functions into single function of type
<code>IntStream -&gt; Int × IntStream</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">head</span><span class="o">&amp;</span><span class="n">tail</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">IntStream</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">IntStream</span>
<span class="n">head</span><span class="o">&amp;</span><span class="n">tail</span><span class="w"> </span><span class="p">(</span><span class="n">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre></div>

<p>Notice how the result of the function coincides with algebraic representation
of our <code>IntStream</code> type. Similar thing can also be done for other recursive
data types. Maybe you already have noticed the pattern. I'm referring to a
family of functions of type</p>
<div class="code"><pre class="code literal-block"><span class="n">g</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">T</span>
</pre></div>

<p>where <code>T</code> is some type. From now on we will define</p>
<div class="code"><pre class="code literal-block">F1 T = Int × T
</pre></div>

<p>Now, <em>F-coalgebra</em> is a pair <code>(T, g)</code>, where <code>T</code> is a type and <code>g</code> is a
function of type <code>g :: T -&gt; F T</code>. For example, <code>(IntStream, head&amp;tail)</code> is an
F1-coalgebra. Again, just as in F-algebras, <code>g</code> and <code>T</code> can be arbitrary, for
example,<code>(String, h :: String -&gt; Int x String)</code> is also an F1-coalgebra for
some h.</p>
<p>Among all F-coalgebras there are so-called <em>terminal F-coalgebras</em> , which are
dual to initial F-algebras. For example, <code>IntStream</code> is a terminal
F-coalgebra. This means that for every type <code>T</code> and for every function <code>p :: T
-&gt; F1 T</code> there exist a function, called <em>anamorphism</em> , which converts <code>T</code> to
<code>IntStream</code>, and such function is unique.</p>
<p>Consider the following function, which generates a stream of successive
integers starting from the given one:</p>
<div class="code"><pre class="code literal-block"><span class="n">nats</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntStream</span>
<span class="n">nats</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">nats</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>Now let's inspect a function <code>natsBuilder :: Int -&gt; F1 Int</code>, that is,
<code>natsBuilder :: Int -&gt; Int × Int</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">natsBuilder</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">Int</span>
<span class="n">natsBuilder</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>Again, we can see some similarity between <code>nats</code> and <code>natsBuilder</code>. It is very
similar to the connection we have observed with reductors and folds earlier.
<code>nats</code> is an anamorphism for <code>natsBuilder</code>.</p>
<p>Another example, a function which takes a value and a function and returns a
stream of successive applications of the function to the value:</p>
<div class="code"><pre class="code literal-block"><span class="nf">iterate</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">IntStream</span>
<span class="nf">iterate</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nf">iterate</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>
</pre></div>

<p>Its builder function is the following one:</p>
<div class="code"><pre class="code literal-block"><span class="n">iterateBuilder</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Int</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">Int</span>
<span class="n">iterateBuilder</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
</pre></div>

<p>Then <code>iterate</code> is an anamorphism for <code>iterateBuilder</code>.</p>
<h2>Conclusion</h2>
<p>So, in short, F-algebras allow to define folds, that is, operations which
reduce recursive structure down into a single value, and F-coalgebras allow to
do the opposite: construct a [potentially] infinite structure from a single
value.</p>
<p>In fact in Haskell F-algebras and F-coalgebras coincide. This is a very nice
property which is a consequence of presence of 'bottom' value in each type. So
in Haskell both folds and unfolds can be created for every recursive type.
However, theoretical model behind this is more complex than the one I have
presented above, so I deliberately have avoided it.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-list-all-versions-of-an-npm-module/" class="u-url">How to list all versions of an npm module?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-list-all-versions-of-an-npm-module/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T09:24:34+08:00" itemprop="datePublished" title="2023-03-05 09:24">2023-03-05 09:24</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In order to see all the versions of a node module [webpack], I have executed
below command in windows command prompt</p>
<div class="code"><pre class="code literal-block">npm view webpack versions
</pre></div>

<p>This command only displays first 100 versions and later displays "331 more"
text.</p>
<p>How will I be able to list all versions?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Usually I do this if I want to see all versions</p>
<div class="code"><pre class="code literal-block">npm view webpack versions --json
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>This is pretty much the same but won't list alpha or beta releases</p>
<div class="code"><pre class="code literal-block"><span class="nv">npm</span><span class="w"> </span><span class="k">show</span><span class="w"> </span><span class="nv">webpack</span>@<span class="o">*</span><span class="w"> </span><span class="nv">version</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2675.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2673.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
