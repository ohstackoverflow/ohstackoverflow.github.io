<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 637) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-637.html">
<link rel="prev" href="index-638.html" type="text/html">
<link rel="next" href="index-636.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-ru-he-zai-android-zhong-fa-xian-wo-de-ying-yong-cheng-xu-de-nei-cun-shi-yong-qing-kuang/" class="u-url">我如何在 Android 中发现我的应用程序的内存使用情况？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-ru-he-zai-android-zhong-fa-xian-wo-de-ying-yong-cheng-xu-de-nei-cun-shi-yong-qing-kuang/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:07:15+08:00" itemprop="datePublished" title="2023-02-17 12:07">2023-02-17 12:07</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何以编程方式找到我的 Android 应用程序上使用的内存？</p>
<p>我希望有办法做到这一点。另外，我如何获得手机的免费内存？</p>
<p><br><br></p>
<h2>解答</h2>
<p>请注意，现代操作系统（如 Linux）上的内存使用是一个 <em>极其</em>
复杂且难以理解的领域。事实上，你真正正确地解释你得到的任何数字的机会是极低的。（几乎每次我与其他工程师一起查看内存使用数据时，总是会就它们的实际含义进行长时间的讨论，结果只会得出一个模糊的结论。）</p>
<p><strong>注意：我们现在有更多关于 管理您的应用程序内存的文档，其中涵盖了此处的大部分材料，并且与 Android 的状态保持同步。</strong></p>
<p>第一件事可能是阅读本文的最后一部分，其中讨论了如何在 Android 上管理内存：</p>
<p>服务 API 从 Android 2.0 开始发生变化</p>
<p>Now<code>ActivityManager.getMemoryInfo()</code>是我们查看整体内存使用情况的最高级别
API。这主要是为了帮助应用程序衡量系统离后台进程没有更多内存有多近，因此需要开始终止所需的进程，如服务。对于纯 Java 应用程序，这应该没什么用，因为
Java 堆限制部分是为了避免一个应用程序能够对系统施加压力到这一点。</p>
<p>在较低级别，您可以使用调试 API 获取有关内存使用情况的原始内核级信息：android.os.Debug.MemoryInfo</p>
<p>请注意，从 2.0 开始，还有一个
API，<code>ActivityManager.getProcessMemoryInfo</code>用于获取有关另一个进程的信息：ActivityManager.getProcessMemoryInfo(int[])</p>
<p>这将返回一个包含所有这些数据的低级 MemoryInfo 结构：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">proportional</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="nb">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dalvik</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">dalvikPss</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">dalvik</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">dalvikPrivateDirty</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">dalvik</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">dalvikSharedDirty</span><span class="p">;</span>

<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">proportional</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="nb">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">native</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">nativePss</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">native</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">nativePrivateDirty</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">native</span><span class="w"> </span><span class="n">heap</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">nativeSharedDirty</span><span class="p">;</span>

<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">proportional</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="nb">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">everything</span><span class="w"> </span><span class="k">else</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">otherPss</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">everything</span><span class="w"> </span><span class="k">else</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">otherPrivateDirty</span><span class="p">;</span>
<span class="w">    </span><span class="o">/**</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="n">pages</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">everything</span><span class="w"> </span><span class="k">else</span><span class="p">.</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">otherSharedDirty</span><span class="p">;</span>
</pre></div>

<p>但是至于<code>Pss</code>, <code>PrivateDirty</code>, 和<code>SharedDirty</code>... 之间的区别是什么，好吧，现在有趣的事情开始了。</p>
<p>Android（以及一般的 Linux 系统）中的大量内存实际上是跨多个进程共享的。所以一个进程使用多少内存真的不清楚。再加上分页到磁盘（更不用说我们在
Android 上不使用的交换），它就更不清楚了。</p>
<p>因此，如果您要获取实际映射到每个进程的所有物理 RAM，并将所有进程加起来，您最终可能会得到比实际总 RAM 大得多的数字。</p>
<p>这个<code>Pss</code>数字是内核计算的一个指标，它考虑了内存共享——基本上，一个进程中的每一页 RAM
都是根据也使用该页的其他进程的数量的比例来缩放的。通过这种方式，您可以（理论上）将所有进程的 pss 相加以查看它们使用的总 RAM，并比较进程之间的
pss 以大致了解它们的相对权重。</p>
<p>这里另一个有趣的指标是<code>PrivateDirty</code>，它基本上是进程内不能分页到磁盘的 RAM
量（它没有由磁盘上的相同数据支持），并且不与任何其他进程共享。另一种看待这个问题的方法是当该进程消失时系统将可用的
RAM（并且可能很快被纳入缓存和它的其他用途）。</p>
<p>这几乎就是用于此的 SDK API。但是，作为开发人员，您可以使用您的设备做更多事情。</p>
<p>使用<code>adb</code>，您可以获得有关正在运行的系统的内存使用情况的大量信息。一个常见的命令是<code>adb shell dumpsys
meminfo</code>会吐出一堆关于每个 Java
进程的内存使用信息的命令，其中包含上述信息以及各种其他信息。你也可以加上单个进程的名称或pid来查看，比如<code>adb shell dumpsys
meminfo system</code>给我系统进程：</p>
<div class="code"><pre class="code literal-block">** pid 890 [系统] 中的 MEMINFO **
                    native dalvik 其他合计
            尺寸：10940 7047 不适用 17987
       分配：8943 5516 N/A 14459
            免费：336 1531 不适用 1867
           (PSS): 4585 9282 11916 25783
  （共享脏）：2184 3596 916 6696
    （私人脏）：4504 5956 7456 17916

 对象
           意见：149 ViewRoots：4
     AppContexts：13 活动：0
          资产：4 资产管理者：4
   本地活页夹：141 代理活页夹：158
死亡接受者：49
 OpenSSL 套接字：0

 数据库
            堆：205 dbFiles：0
       numPagers：0 inactivePageKB：0
    活动页面KB：0
</pre></div>

<p>顶部是主要部分，其中<code>size</code>是特定堆地址空间的总大小，<code>allocated</code>是堆认为它拥有的实际分配的 kb，<code>free</code>是堆剩余的可用 kb
用于额外分配，并且<code>pss</code>是<code>priv dirty</code>相同的如前所述，特定于与每个堆关联的页面。</p>
<p>如果你只想查看所有进程的内存使用情况，你可以使用命令<code>adb shell procrank</code>。在同一系统上的输出如下所示：</p>
<div class="code"><pre class="code literal-block">  PID Vss Rss Pss Uss cmdline
  890 84456K 48668K 25850K 21284K 系统服务器
 1231 50748K 39088K 17587K 13792K com.android.launcher2
  947 34488K 28528K 10834K 9308K com.android.wallpaper
  987 26964K 26956K 8751K 7308K com.google.process.gapps
  954 24300K 24296K 6249K 4824K com.android.phone
  948 23020K 23016K 5864K 4748K com.android.inputmethod.latin
  888 25728K 25724K 5774K 3668K 合子
  977 24100K 24096K 5667K 4340K android.process.acore
...
   59 336K 332K 99K 92K /system/bin/installd
   60 396K 392K 93K 84K /系统/bin/密钥库
   51 280K 276K 74K 68K /system/bin/servicemanager
   54 256K 252K 69K 64K /system/bin/debuggerd
</pre></div>

<p>这里的<code>Vss</code>和<code>Rss</code>列基本上是噪音（这些是一个进程的直接地址空间和 RAM 使用情况，如果你将跨进程的 RAM
使用情况加起来，你会得到一个大得离谱的数字）。</p>
<p><code>Pss</code>就像我们之前看到的那样，并且<code>Uss</code>是<code>Priv Dirty</code>。</p>
<p>这里需要注意的一件有趣的事：<code>Pss</code>与<code>Uss</code>我们在<code>meminfo</code>. 这是为什么？那么 procrank
使用不同的内核机制来收集其数据<code>meminfo</code>，并且它们给出的结果略有不同。这是为什么？老实说，我一点头绪都没有。我相信<code>procrank</code>这可能是更准确的……但实际上，这只是要点：“把你用一粒盐得到的任何记忆信息都拿走；通常是一粒非常大的盐。”</p>
<p><code>adb shell cat
/proc/meminfo</code>最后是给出系统整体内存使用情况摘要的命令。这里有很多数据，值得讨论的只有前几个数字（其余的很少有人理解，而且我对那几个人的问题经常导致相互矛盾的解释）：</p>
<div class="code"><pre class="code literal-block">内存总数：395144 kB
MemFree：184936 kB
缓冲区：880 kB
缓存：84104 kB
交换缓存：0 kB
</pre></div>

<p><code>MemTotal</code>是内核和用户空间可用的内存总量（通常小于设备的实际物理 RAM，因为无线电、DMA 缓冲区等需要一些 RAM）。</p>
<p><code>MemFree</code>是根本未使用的 RAM 量。你在这里看到的数字非常高；通常在 Android 系统上这将只有几
MB，因为我们尝试使用可用内存来保持进程运行</p>
<p><code>Cached</code>是用于文件系统缓存和其他类似事物的 RAM。典型的系统需要有 20MB 左右的空间来避免进入错误的分页状态；Android
内存不足杀手针对特定系统进行了调整，以确保后台进程在缓存 RAM 被消耗过多以导致此类分页之前被杀死。</p>
<p><br></p>
<h3>更多建议</h3>
<p>是的，您可以通过编程方式获取内存信息并决定是否进行内存密集型工作。</p>
<p>通过调用获取 VM 堆大小：</p>
<div class="code"><pre class="code literal-block">Runtime.getRuntime().totalMemory();
</pre></div>

<p>通过调用获取分配的 VM 内存：</p>
<div class="code"><pre class="code literal-block">Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
</pre></div>

<p>通过调用获取 VM 堆大小限制：</p>
<div class="code"><pre class="code literal-block">Runtime.getRuntime().maxMemory()
</pre></div>

<p>通过调用获取本机分配的内存：</p>
<div class="code"><pre class="code literal-block">Debug.getNativeHeapAllocatedSize();
</pre></div>

<p>我制作了一个应用程序来找出 OutOfMemoryError 行为并监控内存使用情况。</p>
<p>https://play.google.com/store/apps/details?id=net.coocood.oomresearch</p>
<p>您可以在https://github.com/coocood/oom-research获取源代码</p>
<p><br><br><a href="posts/how-do-i-discover-memory-usage-of-my-application-in-android/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/huo-qu-zi-fu-chuan-de-chang-du/" class="u-url">获取字符串的长度</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/huo-qu-zi-fu-chuan-de-chang-du/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:06:45+08:00" itemprop="datePublished" title="2023-02-17 12:06">2023-02-17 12:06</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>你如何获得 a 的长度<code>String</code>？例如，我有一个定义如下的变量：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">test1</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Scott"</span>
</pre></div>

<p>但是，我似乎无法在字符串上找到长度方法。</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>从 Swift 4+ 开始</strong></p>
<p>只是：</p>
<div class="code"><pre class="code literal-block">test1.count
</pre></div>

<p>出于某些原因。</p>
<p>（感谢马丁 R）</p>
<p><strong>从斯威夫特 2 开始：</strong></p>
<p>在 Swift 2 中，Apple 将全局函数更改为协议扩展，即匹配任何符合协议的类型的扩展。因此新的语法是：</p>
<div class="code"><pre class="code literal-block">test1.characters.count
</pre></div>

<p>（感谢 JohnDifool 的提醒）</p>
<p><strong>从斯威夫特 1 开始</strong></p>
<p>使用计数字符方法：</p>
<div class="code"><pre class="code literal-block">let unusualMenagerie = "Koala &amp;#128040;, Snail &amp;#128012;, Penguin &amp;#128039;, Dromedary &amp;#128042;"
println("unusualMenagerie has \(count(unusualMenagerie)) characters")
// prints "unusualMenagerie has 40 characters"
</pre></div>

<p>直接来自 Apple Swift 指南</p>
<p>（注意，对于 1.2 之前的 Swift 版本，这将是<code>countElements(unusualMenagerie)</code>替代的）</p>
<p>对于您的变量，它将是</p>
<div class="code"><pre class="code literal-block">length = count(test1) // was countElements in earlier versions of Swift
</pre></div>

<p>或者你可以使用 test1.utf16count</p>
<p><br></p>
<h3>更多建议</h3>
<h2>TLDR：</h2>
<p>对于 <strong>Swift 2.0 和 3.0，</strong> 使用<code>test1.characters.count</code>. 但是，有几件事你应该知道。所以，请继续阅读。</p>
<h2>在 Swift 中计算字符</h2>
<p>在 Swift 2.0 之前，<code>count</code>是一个全局函数。从 Swift 2.0 开始，它可以作为成员函数调用。</p>
<div class="code"><pre class="code literal-block">test1.characters.count
</pre></div>

<p>它将返回 a 中 Unicode 字符的实际数量<code>String</code>，因此它是最正确的选择，因为如果您手动打印字符串并计算字符数，您会得到相同的结果。</p>
<p>然而，由于<code>Strings</code>Swift 中的实现方式，字符并不总是占用相同数量的内存，因此请注意，这与其他语言中常用的字符计数方法的行为有很大不同。</p>
<p>例如，您还可以使用<code>test1.utf16.count</code></p>
<p><code>count</code>但是，如下所述，不能保证返回值与调用的值相同<code>characters</code>。</p>
<p>从语言参考：</p>
<blockquote>
<p>扩展字素簇可以由一个或多个 Unicode
标量组成。这意味着不同的字符——以及同一字符的不同表示——可能需要不同数量的内存来存储。正因为如此，Swift
中的字符在字符串表示中不会占用相同数量的内存。因此，如果不遍历字符串以确定其扩展的字素簇边界，则无法计算字符串中的字符数。如果您正在处理特别长的字符串值，请注意字符属性必须遍历整个字符串中的
Unicode 标量以确定该字符串的字符。</p>
<p>characters 属性返回的字符数并不总是与包含相同字符的 NSString 的 length 属性相同。NSString 的长度基于字符串的
UTF-16 表示中 16 位代码单元的数量，而不是字符串中 Unicode 扩展字形簇的数量。</p>
</blockquote>
<p>一个完美说明上述情况的示例是检查包含单个表情符号字符的字符串的长度，正如评论中的n00neimp0rtant所指出的那样。</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">emoji</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"👍"</span>
<span class="n">emoji</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="w">             </span><span class="o">//</span><span class="n">returns</span><span class="w"> </span><span class="mi">1</span>
<span class="n">emoji</span><span class="o">.</span><span class="n">utf16</span><span class="o">.</span><span class="n">count</span><span class="w">                  </span><span class="o">//</span><span class="n">returns</span><span class="w"> </span><span class="mi">2</span>
</pre></div>

<p><br><br><a href="posts/get-the-length-of-a-string/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/python-2-x-zhong-de-range-he-xrange-han-shu-you-shi-yao-qu-bie/" class="u-url">Python 2.X 中的 range 和 xrange 函数有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/python-2-x-zhong-de-range-he-xrange-han-shu-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:06:12+08:00" itemprop="datePublished" title="2023-02-17 12:06">2023-02-17 12:06</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>显然 xrange 更快，但我不知道为什么它更快（除了目前的轶事之外没有证据表明它更快）或者除此之外还有什么不同</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">0</span>,<span class="w"> </span><span class="mi">20</span><span class="ss">)</span>:
<span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">xrange</span><span class="ss">(</span><span class="mi">0</span>,<span class="w"> </span><span class="mi">20</span><span class="ss">)</span>:
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p><strong>在 Python 2.x 中：</strong></p>
<ul>
<li>
<p><code>range</code>创建一个列表，所以如果你<code>range(1, 10000000)</code>这样做，它会在内存中创建一个包含元素的列表<code>9999999</code>。</p>
</li>
<li>
<p><code>xrange</code>是延迟计算的序列对象。</p>
</li>
</ul>
<p><strong>在 Python 3 中：</strong></p>
<ul>
<li>
<code>range</code>相当于 Python 2 的<code>xrange</code>. 要获取列表，您必须显式使用<code>list(range(...))</code>.</li>
<li>
<code>xrange</code>不复存在。</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<blockquote>
<p>range 创建一个列表，所以如果你<code>range(1, 10000000)</code>这样做，它会在内存中创建一个包含元素的列表<code>9999999</code>。</p>
<p><code>xrange</code> <del>是一个生成器，所以它</del> 是一个序列对象 <del>是一个</del> 惰性评估的。</p>
</blockquote>
<p>这是事实，但在 Python 3 中，<code>range()</code>将由 Python 2 实现<code>xrange()</code>。如果您需要实际生成列表，则需要执行以下操作：</p>
<div class="code"><pre class="code literal-block">list(range(1,100))
</pre></div>

<p><br><br><a href="posts/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-638.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-636.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
