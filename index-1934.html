<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1934) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1934.html">
<link rel="prev" href="index-1935.html" type="text/html">
<link rel="next" href="index-1933.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-do-many-examples-use-fig-ax-plt-subplots-in-matplotlib-pyplot-python/" class="u-url">Why do many examples use `fig, ax = plt.subplots()` in Matplotlib/pyplot/python</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-do-many-examples-use-fig-ax-plt-subplots-in-matplotlib-pyplot-python/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T12:52:43+08:00" itemprop="datePublished" title="2023-03-03 12:52">2023-03-03 12:52</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm learning to use <code>matplotlib</code> by studying examples, and a lot of examples
seem to include a line like the following before creating a single plot...</p>
<div class="code"><pre class="code literal-block">fig, ax = plt.subplots()
</pre></div>

<p>Here are some examples...</p>
<ul>
<li>Modify tick label text</li>
<li>http://matplotlib.org/examples/pylab_examples/boxplot_demo2.html</li>
</ul>
<p>I see this function used a lot, even though the example is only attempting to
create a single chart. Is there some other advantage? The official demo for
<code>subplots()</code> also uses <code>f, ax = subplots</code> when creating a single chart, and it
only ever references ax after that. This is the code they use.</p>
<div class="code"><pre class="code literal-block"># Just a figure and one subplot
f, ax = plt.subplots()
ax.plot(x, y)
ax.set_title('Simple plot')
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p><code>plt.subplots()</code> is a function that returns a tuple containing a figure and
axes object(s). Thus when using <code>fig, ax = plt.subplots()</code> you unpack this
tuple into the variables <code>fig</code> and <code>ax</code>. Having <code>fig</code> is useful if you want to
change figure-level attributes or save the figure as an image file later (e.g.
with <code>fig.savefig('yourfilename.png')</code>). You certainly don't have to use the
returned figure object but many people do use it later so it's common to see.
Also, all axes objects (the objects that have plotting methods), have a parent
figure object anyway, thus:</p>
<div class="code"><pre class="code literal-block">fig, ax = plt.subplots()
</pre></div>

<p>is more concise than this:</p>
<div class="code"><pre class="code literal-block">fig = plt.figure()
ax = fig.add_subplot(111)
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>Just a supplement here.</p>
<p>The following question is that what if I want more subplots in the figure?</p>
<p>As mentioned in the Doc, we can use <code>fig = plt.subplots(nrows=2, ncols=2)</code> to
set a group of subplots with grid(2,2) in one figure object.</p>
<p>Then as we know, the <code>fig, ax = plt.subplots()</code> returns a tuple, let's try
<code>fig, ax1, ax2, ax3, ax4 = plt.subplots(nrows=2, ncols=2)</code> firstly.</p>
<div class="code"><pre class="code literal-block"><span class="n">ValueError</span><span class="o">:</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">unpack</span><span class="w"> </span><span class="o">(</span><span class="n">expected</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
</pre></div>

<p>It raises a error, but no worry, because we now see that <code>plt.subplots()</code>
actually returns a tuple with two elements. The 1st one must be a figure
object, and the other one should be a group of subplots objects.</p>
<p>So let's try this again:</p>
<div class="code"><pre class="code literal-block">fig, [[ax1, ax2], [ax3, ax4]] = plt.subplots(nrows=2, ncols=2)
</pre></div>

<p>and check the type:</p>
<div class="code"><pre class="code literal-block">type(fig) #&lt;class 'matplotlib.figure.Figure'&gt;
type(ax1) #&lt;class 'matplotlib.axes._subplots.AxesSubplot'&gt;
</pre></div>

<p>Of course, if you use parameters as (nrows=1, ncols=4), then the format should
be:</p>
<div class="code"><pre class="code literal-block">fig, [ax1, ax2, ax3, ax4] = plt.subplots(nrows=1, ncols=4)
</pre></div>

<p>So just remember to keep the construction of the list as the same as the
subplots grid we set in the figure.</p>
<p>Hope this would be helpful for you.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/image-comparison-fast-algorithm/" class="u-url">Image comparison - fast algorithm</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/image-comparison-fast-algorithm/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T12:52:19+08:00" itemprop="datePublished" title="2023-03-03 12:52">2023-03-03 12:52</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm looking to create a base table of images and then compare any new images
against that to determine if the new image is an exact (or close) duplicate of
the base.</p>
<p>For example: if you want to reduce storage of the same image 100's of times,
you could store one copy of it and provide reference links to it. When a new
image is entered you want to compare to an existing image to make sure it's
not a duplicate ... ideas?</p>
<p>One idea of mine was to reduce to a small thumbnail and then randomly pick 100
pixel locations and compare.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Below are three approaches to solving this problem (and there are many
others).</p>
<ul>
<li>
<p>The first is a standard approach in computer vision, keypoint matching. This may require some background knowledge to implement, and can be slow.</p>
</li>
<li>
<p>The second method uses only elementary image processing, and is potentially faster than the first approach, and is straightforward to implement. However, what it gains in understandability, it lacks in robustness -- matching fails on scaled, rotated, or discolored images.</p>
</li>
<li>
<p>The third method is both fast and robust, but is potentially the hardest to implement.</p>
</li>
</ul>
<p><strong>Keypoint Matching</strong></p>
<p>Better than picking 100 random points is picking 100 <em>important</em> points.
Certain parts of an image have more information than others (particularly at
edges and corners), and these are the ones you'll want to use for smart image
matching. Google "keypoint extraction" and "keypoint matching" and you'll find
quite a few academic papers on the subject. These days, SIFT keypoints are
arguably the most popular, since they can match images under different scales,
rotations, and lighting. Some SIFT implementations can be found here.</p>
<p>One downside to keypoint matching is the running time of a naive
implementation: O(n^2m), where n is the number of keypoints in each image, and
m is the number of images in the database. Some clever algorithms might find
the closest match faster, like quadtrees or binary space partitioning.</p>
<hr>
<p><strong>Alternative solution: Histogram method</strong></p>
<p>Another less robust but potentially faster solution is to build feature
histograms for each image, and choose the image with the histogram closest to
the input image's histogram. I implemented this as an undergrad, and we used 3
color histograms (red, green, and blue), and two texture histograms, direction
and scale. I'll give the details below, but I should note that this only
worked well for matching images VERY similar to the database images. Re-
scaled, rotated, or discolored images can fail with this method, but small
changes like cropping won't break the algorithm</p>
<p>Computing the color histograms is straightforward -- just pick the range for
your histogram buckets, and for each range, tally the number of pixels with a
color in that range. For example, consider the "green" histogram, and suppose
we choose 4 buckets for our histogram: 0-63, 64-127, 128-191, and 192-255.
Then for each pixel, we look at the green value, and add a tally to the
appropriate bucket. When we're done tallying, we divide each bucket total by
the number of pixels in the entire image to get a normalized histogram for the
green channel.</p>
<p>For the texture direction histogram, we started by performing edge detection
on the image. Each edge point has a normal vector pointing in the direction
perpendicular to the edge. We quantized the normal vector's angle into one of
6 buckets between 0 and PI (since edges have 180-degree symmetry, we converted
angles between -PI and 0 to be between 0 and PI). After tallying up the number
of edge points in each direction, we have an un-normalized histogram
representing texture direction, which we normalized by dividing each bucket by
the total number of edge points in the image.</p>
<p>To compute the texture scale histogram, for each edge point, we measured the
distance to the next-closest edge point with the same direction. For example,
if edge point A has a direction of 45 degrees, the algorithm walks in that
direction until it finds another edge point with a direction of 45 degrees (or
within a reasonable deviation). After computing this distance for each edge
point, we dump those values into a histogram and normalize it by dividing by
the total number of edge points.</p>
<p>Now you have 5 histograms for each image. To compare two images, you take the
absolute value of the difference between each histogram bucket, and then sum
these values. For example, to compare images A and B, we would compute</p>
<div class="code"><pre class="code literal-block">|A.green_histogram.bucket_1 - B.green_histogram.bucket_1|
</pre></div>

<p>for each bucket in the green histogram, and repeat for the other histograms,
and then sum up all the results. The smaller the result, the better the match.
Repeat for all images in the database, and the match with the smallest result
wins. You'd probably want to have a threshold, above which the algorithm
concludes that no match was found.</p>
<hr>
<p><strong>Third Choice - Keypoints + Decision Trees</strong></p>
<p>A third approach that is probably much faster than the other two is using
semantic texton forests (PDF). This involves extracting simple keypoints and
using a collection decision trees to classify the image. This is faster than
simple SIFT keypoint matching, because it avoids the costly matching process,
and keypoints are much simpler than SIFT, so keypoint extraction is much
faster. However, it preserves the SIFT method's invariance to rotation, scale,
and lighting, an important feature that the histogram method lacked.</p>
<p><strong>Update</strong> :</p>
<p>My mistake -- the Semantic Texton Forests paper isn't specifically about image
matching, but rather region labeling. The original paper that does matching is
this one: Keypoint Recognition using Randomized Trees. Also, the papers below
continue to develop the ideas and represent the state of the art (c. 2010):</p>
<ul>
<li>Fast Keypoint Recognition using Random Ferns - faster and more scalable than Lepetit 06</li>
<li>
<del>BRIEF: Binary Robust Independent Elementary Features</del> - less robust but very fast -- I think the goal here is real-time matching on smart phones and other handhelds</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>The best method I know of is to use a Perceptual Hash. There appears to be a
good open source implementation of such a hash available at:</p>
<p>http://phash.org/</p>
<p>The main idea is that each image is reduced down to a small hash code or
'fingerprint' by identifying salient features in the original image file and
hashing a compact representation of those features (rather than hashing the
image data directly). This means that the false positives rate is much reduced
over a simplistic approach such as reducing images down to a tiny thumbprint
sized image and comparing thumbprints.</p>
<p>phash offers several types of hash and can be used for images, audio or video.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/way-to-go-from-recursion-to-iteration/" class="u-url">Way to go from recursion to iteration</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/way-to-go-from-recursion-to-iteration/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T12:51:52+08:00" itemprop="datePublished" title="2023-03-03 12:51">2023-03-03 12:51</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I've used recursion quite a lot on my many years of programming to solve
simple problems, but I'm fully aware that sometimes you need iteration due to
memory/speed problems.</p>
<p>So, sometime in the very far past I went to try and find if there existed any
"pattern" or text-book way of transforming a common recursion approach to
iteration and found nothing. Or at least nothing that I can remember it would
help.</p>
<ul>
<li>Are there general rules?</li>
<li>Is there a "pattern"?</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p>Usually, I replace a recursive algorithm by an iterative algorithm by pushing
the parameters that would normally be passed to the recursive function onto a
stack. In fact, you are replacing the program stack by one of your own.</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">firstObject</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span><span class="o">.</span>
<span class="w">    </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">stuff</span><span class="o">.</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Push</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">needed</span><span class="o">.</span>
<span class="w">    </span><span class="o">...</span>

<span class="p">}</span>
</pre></div>

<p>Note: if you have more than one recursive call inside and you want to preserve
the order of the calls, you have to add them in the reverse order to the
stack:</p>
<div class="code"><pre class="code literal-block">foo(first);
foo(second);
</pre></div>

<p>has to be replaced by</p>
<div class="code"><pre class="code literal-block">stack.push(second);
stack.push(first);
</pre></div>

<p>Edit: The article Stacks and Recursion Elimination (or Article Backup link)
goes into more details on this subject.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Really, the most common way to do it is to keep your own stack. Here's a
recursive quicksort function in C:</p>
<div class="code"><pre class="code literal-block"><span class="nv">void</span><span class="w"> </span><span class="nv">quicksort</span><span class="ss">(</span><span class="nv">int</span><span class="o">*</span><span class="w"> </span><span class="nv">array</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">left</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">right</span><span class="ss">)</span>
{
<span class="w">    </span><span class="k">if</span><span class="ss">(</span><span class="nv">left</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nv">right</span><span class="ss">)</span>
<span class="w">        </span><span class="k">return</span><span class="c1">;</span>

<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">partition</span><span class="ss">(</span><span class="nv">array</span>,<span class="w"> </span><span class="nv">left</span>,<span class="w"> </span><span class="nv">right</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">quicksort</span><span class="ss">(</span><span class="nv">array</span>,<span class="w"> </span><span class="nv">left</span>,<span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">quicksort</span><span class="ss">(</span><span class="nv">array</span>,<span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">right</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>Here's how we could make it iterative by keeping our own stack:</p>
<div class="code"><pre class="code literal-block"><span class="nv">void</span><span class="w"> </span><span class="nv">quicksort</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="o">*</span><span class="nv">array</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">left</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">right</span><span class="ss">)</span>
{
<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">stack</span>[<span class="mi">1024</span>]<span class="c1">;</span>
<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">i</span><span class="o">=</span><span class="mi">0</span><span class="c1">;</span>

<span class="w">    </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">left</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">right</span><span class="c1">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">    </span>{
<span class="w">        </span><span class="nv">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">stack</span>[<span class="o">--</span><span class="nv">i</span>]<span class="c1">;</span>
<span class="w">        </span><span class="nv">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">stack</span>[<span class="o">--</span><span class="nv">i</span>]<span class="c1">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">left</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nv">right</span><span class="ss">)</span>
<span class="w">             </span><span class="k">continue</span><span class="c1">;</span>

<span class="w">        </span><span class="nv">int</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">partition</span><span class="ss">(</span><span class="nv">array</span>,<span class="w"> </span><span class="nv">left</span>,<span class="w"> </span><span class="nv">right</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">left</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">stack</span>[<span class="nv">i</span><span class="o">++</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">right</span><span class="c1">;</span>
<span class="w">    </span>}
}
</pre></div>

<p>Obviously, this example doesn't check stack boundaries... and really you could
size the stack based on the worst case given left and and right values. But
you get the idea.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1935.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1933.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
