<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 143) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-143.html">
<link rel="prev" href="index-144.html" type="text/html">
<link rel="next" href="index-142.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-jian-cha-bian-liang-shi-fou-shi-javascript-zhong-de-shu-zu/" class="u-url">如何检查变量是否是 JavaScript 中的数组？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-jian-cha-bian-liang-shi-fou-shi-javascript-zhong-de-shu-zu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:57:23+08:00" itemprop="datePublished" title="2023-02-16 22:57">2023-02-16 22:57</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何检查变量是否是 JavaScript 中的数组？</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">constructor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb nb-Type">Array</span><span class="p">)</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>有几种方法可以检查变量是否为数组。最好的解决方案是您选择的那个。</p>
<div class="code"><pre class="code literal-block"><span class="n">variable</span><span class="o">.</span><span class="n">constructor</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nb nb-Type">Array</span>
</pre></div>

<p>这是 Chrome 上最快的方法，很可能是所有其他浏览器。所有数组都是对象，因此检查构造函数属性对于 JavaScript 引擎来说是一个快速的过程。</p>
<p>如果您在确定对象属性是否为数组时遇到问题，则必须首先检查该属性是否存在。</p>
<div class="code"><pre class="code literal-block"><span class="n">variable</span><span class="o">.</span><span class="n">prop</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">variable</span><span class="o">.</span><span class="n">prop</span><span class="o">.</span><span class="n">constructor</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nb nb-Type">Array</span>
</pre></div>

<p>其他一些方式是：</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">Array</span><span class="o">.</span><span class="n">isArray</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</pre></div>

<p><strong>2019 年 5 月 23 日更新，使用 Chrome 75，向@AnduAndrici 大喊让我用他的问题重新审视这个问题，</strong>
在我看来，最后一个是最丑陋的，也是最 <del>慢的</del> 最快之一。 <del>以第一个示例的速度运行大约 1/5。</del> 这家伙大约慢了
2-5%，但这很难说。稳固好用！对结果印象深刻。Array.prototype，其实就是一个数组。你可以在这里阅读更多相关信息https://developer.mozilla.org/en-
US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray</p>
<div class="code"><pre class="code literal-block"><span class="n">variable</span><span class="w"> </span><span class="n">instanceof</span><span class="w"> </span><span class="nb nb-Type">Array</span>
</pre></div>

<p>此方法的运行 <del>速度</del> 约为第一个示例的 1/3。仍然非常坚固，看起来更干净，如果你只关心漂亮的代码而不是性能。请注意，检查数字并不<code>variable
instanceof Number</code>总是返回<code>false</code>。 <strong>更新：<code>instanceof</code>现在速度提高了 2/3！</strong></p>
<p><strong>所以又一次更新</strong></p>
<div class="code"><pre class="code literal-block"><span class="n">Object</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">toString</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="err">'</span><span class="p">[</span><span class="n">object</span><span class="w"> </span><span class="n">Array</span><span class="p">]</span><span class="err">'</span><span class="p">;</span>
</pre></div>

<p>这家伙在尝试检查数组方面是最慢的。但是，这是您正在寻找的任何类型的一站式商店。但是，由于您正在寻找一个数组，因此只需使用上面最快的方法即可。</p>
<p>另外，我进行了一些测试：http://jsperf.com/instanceof-array-vs-array-isarray/35所以玩得开心并检查一下。</p>
<p>注意：@EscapeNetscape 已创建另一个测试，因为 jsperf.com 已关闭。http://jsben.ch/#/QgYAV我想确保原始链接在
jsperf 重新上线时保留。</p>
<p><br></p>
<h3>更多建议</h3>
<p>您还可以使用：</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">value</span><span class="w"> </span><span class="nv">instanceof</span><span class="w"> </span><span class="nv">Array</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">alert</span><span class="ss">(</span><span class="s1">'value is Array!'</span><span class="ss">)</span><span class="c1">;</span>
}<span class="w"> </span><span class="k">else</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">alert</span><span class="ss">(</span><span class="s1">'Not an array'</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>在我看来，这似乎是一个非常优雅的解决方案，但对每个人来说都是如此。</p>
<p>编辑：</p>
<p>从 ES5 开始，现在还有：</p>
<div class="code"><pre class="code literal-block">Array.isArray(value);
</pre></div>

<p>但这会在旧版浏览器上中断，除非您使用的是 polyfill（基本上... IE8 或类似浏览器）。</p>
<p><br><br><a href="posts/how-do-i-check-if-a-variable-is-an-array-in-javascript/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2048-you-xi-de-zui-jia-suan-fa-shi-shi-yao/" class="u-url">2048 游戏的最佳算法是什么？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/2048-you-xi-de-zui-jia-suan-fa-shi-shi-yao/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:56:23+08:00" itemprop="datePublished" title="2023-02-16 22:56">2023-02-16 22:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我最近偶然发现了游戏2048。您可以通过在四个方向中的任何一个方向上移动它们来合并相似的图块，以制作“更大”的图块。每次移动后，一个新的方块出现在随机的空白位置，其值为<code>2</code>或<code>4</code>。当所有的方块都被填满并且没有可以合并方块的移动时，游戏终止，或者您创建了一个值为
的方块<code>2048</code>。</p>
<p>第一，我需要遵循明确的策略来实现目标。于是，我想到了为它写一个程序。</p>
<p>我目前的算法：</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="o">!</span><span class="nv">game_over</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">possible</span><span class="w"> </span><span class="nv">move</span>:
<span class="w">        </span><span class="nv">count_no_of_merges_for_2</span><span class="o">-</span><span class="nv">tiles</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mi">4</span><span class="o">-</span><span class="nv">tiles</span>
<span class="w">    </span><span class="nv">choose</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">move</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">large</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">merges</span>
}
</pre></div>

<p>我正在做的是在任何时候，我都会尝试将瓷砖与值合并<code>2</code>，也就是说，我尝试尽可能少地<code>4</code>拥有<code>2</code>和瓷砖。<code>4</code>如果我以这种方式尝试，所有其他图块都会自动合并，并且该策略看起来不错。</p>
<p>但是，当我实际使用这个算法时，在游戏结束前我只得到了大约 4000 分。最高分 AFAIK 略高于 20,000
分，这比我目前的分数要高得多。有没有比上面更好的算法？</p>
<p><br><br></p>
<h2>解答</h2>
<p>我使用 <em>expectimax</em> 优化开发了一个 2048 AI，而不是 @ovolve 算法使用的 minimax 搜索。AI
简单地对所有可能的移动执行最大化，然后是对所有可能的瓦片生成的期望（由瓦片的概率加权，即 4 为 10%，2 为 90%）。据我所知，修剪
expectimax 优化是不可能的（除了删除极不可能的分支），因此使用的算法是经过仔细优化的强力搜索。</p>
<h3>表现</h3>
<p>AI 在其默认配置（最大搜索深度为 8）下执行一次移动需要 10 毫秒到 200 毫秒，具体取决于棋盘位置的复杂性。在测试中，AI
在整个游戏过程中的平均移动速度为每秒 5-10 步。如果搜索深度限制在 6 个动作，AI 可以轻松地每秒执行 20+ 个动作，这会引起一些有趣的观看。</p>
<p>为了评估 AI 的得分表现，我运行了 AI 100 次（通过远程控制连接到浏览器游戏）。对于每个板块，以下是至少获得该板块一次的游戏比例：</p>
<div class="code"><pre class="code literal-block"><span class="mi">2048</span><span class="o">:</span><span class="w"> </span><span class="mi">100</span><span class="o">%</span>
<span class="mi">4096</span><span class="o">:</span><span class="w"> </span><span class="mi">100</span><span class="o">%</span>
<span class="mi">8192</span><span class="o">:</span><span class="w"> </span><span class="mi">100</span><span class="o">%</span>
<span class="mi">16384</span><span class="o">:</span><span class="w"> </span><span class="mi">94</span><span class="o">%</span>
<span class="mi">32768</span><span class="o">:</span><span class="w"> </span><span class="mi">36</span><span class="o">%</span>
</pre></div>

<p>所有运行的最低分数是 124024；最高得分为 794076。中位数得分为 387222。AI 从未失败过获得 2048 块（因此它在 100
场比赛中从未输过比赛）；事实上，它在每次运行中至少获得了一次 <strong>8192块！</strong></p>
<p>这是最佳运行的屏幕截图：</p>
<p><img alt="32768 块瓷砖，分数 794076" src="images/jG2CL.png"></p>
<p>这场比赛在 96 分钟内进行了 27830 步，平均每秒 4.8 步。</p>
<h3>执行</h3>
<p>我的方法将整个板（16 个条目）编码为单个 64 位整数（其中图块是 nybbles，即 4 位块）。在 64
位机器上，这使得整个板可以在单个机器寄存器中传递。</p>
<p>位移位操作用于提取单独的行和列。单个行或列是一个 16 位数量，因此大小为 65536
的表可以编码对单个行或列进行操作的转换。例如，移动被实现为对预先计算的“移动效果表”进行 4
次查找，该表描述了每个移动如何影响单个行或列（例如，“向右移动”表包含条目“1122 -&gt; 0023”，描述了如何行 [2,2,4,4] 向右移动时变为行
[0,0,4,8]）。</p>
<p>评分也是使用表查找完成的。这些表包含在所有可能的行/列上计算的启发式分数，并且板的结果分数只是每行和每列的表值的总和。</p>
<p>这种棋盘表示，连同用于移动和计分的表格查找方法，允许 AI 在短时间内搜索大量游戏状态（在我 2011 年年中的笔记本电脑的一个内核上每秒搜索超过
10,000,000 个游戏状态）。</p>
<p>expectimax
搜索本身被编码为递归搜索，它在“期望”步骤（测试所有可能的瓦片生成位置和值，并根据每种可能性的概率加权它们的优化分数）和“最大化”步骤（测试所有可能的移动）之间交替并选择得分最高的那个）。树搜索在看到先前看到的位置（使用换位表）、达到预定义的深度限制或达到极不可能的棋盘状态时终止（例如，通过获得
6 个“4”方块达到）从起始位置连续排列）。典型的搜索深度是 4-8 步。</p>
<h3>启发式</h3>
<p>几种启发式方法用于将优化算法导向有利的位置。启发式的精确选择对算法的性能有巨大的影响。各种启发法被加权并组合成一个位置分数，它决定了给定棋盘位置的“好”程度。然后，优化搜索的目标是最大化所有可能棋盘位置的平均得分。游戏中显示的实际分数不
<em>用于</em> 计算棋盘分数，因为它对合并图块的权重太大（当延迟合并可以产生很大的好处时）。</p>
<p>最初，我使用了两个非常简单的启发式方法，为空心方块和边上的大值授予“奖励”。这些启发式算法表现非常好，经常达到 16384 但从未达到 32768。</p>
<p>Petr Morávek (@xificurk) 使用我的 AI
并添加了两个新的启发式算法。第一个启发式是对非单调行和列的惩罚，随着等级的增加而增加，确保小数字的非单调行不会强烈影响分数，但大数字的非单调行会大大损害分数。第二个启发式计算除了开放空间之外的潜在合并数（相邻的相等值）。这两种启发式方法用于将算法推向单调板（更容易合并），并推向具有大量合并的板位置（鼓励它在可能的情况下对齐合并以获得更大的效果）。</p>
<p>此外，Petr 还使用“元优化”策略（使用称为CMA-ES 的算法）优化启发式权重，调整权重本身以获得可能的最高平均分。</p>
<p>这些变化的效果是极其显着的。该算法从大约 13% 的时间达到 16384 瓦片到达到它超过 90% 的时间，算法开始在 1/3 的时间内达到
32768（而旧的启发式从未产生过 32768 瓦片） .</p>
<p>我相信启发式方法仍有改进的余地。这个算法肯定还不是“最优”的，但我觉得它已经非常接近了。</p>
<hr>
<p>AI 在超过三分之一的游戏中达到 32768 块是一个巨大的里程碑；听到是否有任何人类玩家在官方游戏中达到
32768（即不使用保存状态或撤消等工具），我会感到惊讶。我认为65536瓦片是触手可及的！</p>
<p>您可以亲自试用 AI。该代码可在https://github.com/nneonneo/2048-ai获得。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我是其他人在此线程中提到的 AI 程序的作者。您可以查看运行中的 AI或阅读源代码。</p>
<p>目前，该程序在我笔记本电脑浏览器的 javascript 中运行大约 90% 的胜率，每步思考时间大约为 100
毫秒，因此虽然还不完美（但！），但它的表现相当不错。</p>
<p>由于该游戏是一个离散状态空间、完美信息、回合制游戏，如国际象棋和西洋跳棋，我使用了已被证明适用于这些游戏的相同方法，即带有 alpha-
beta剪枝的minimax
搜索。由于已经有很多关于该算法的信息，我将只讨论我在静态评估函数中使用的两个主要启发式方法，它们将其他人在这里表达的许多直觉形式化。</p>
<h4>单调性</h4>
<p>这种试探法试图确保瓦片的值都沿着左/右和上/下方向增加或减少。这种启发法本身就捕捉到了许多其他人提到的直觉，即价值更高的图块应该聚集在一个角落里。它通常会防止价值较小的瓷砖成为孤立的，并且会使棋盘保持井井有条，较小的瓷砖层叠并填充到较大的瓷砖中。</p>
<p>这是一个完美单调网格的屏幕截图。我通过使用 eval 函数集运行算法来忽略其他启发式算法并仅考虑单调性来获得此结果。</p>
<p><img alt="完美单调的 2048 板" src="images/Oce4N.png"></p>
<h4>平滑度</h4>
<p>仅上述启发式方法就倾向于创建其中相邻图块的值递减的结构，但当然为了合并，相邻图块需要具有相同的值。因此，平滑启发式只是测量相邻图块之间的值差异，试图最小化此计数。</p>
<p>Hacker News 上的一位评论员根据图论对这个想法进行了有趣的形式化。</p>
<p>这是一个完美平滑的网格的屏幕截图。</p>
<p><img alt="完美平滑的 2048 板" src="images/wxgDV.png"></p>
<h4>免费瓷砖</h4>
<p>最后，免费板块太少会受到惩罚，因为当游戏板太狭窄时，选项很快就会用完。</p>
<p>就是这样！在优化这些标准的同时搜索游戏空间会产生非常好的性能。使用像这样的通用方法而不是明确编码的移动策略的一个优点是算法通常可以找到有趣和意想不到的解决方案。如果你观察它奔跑，它通常会做出令人惊讶但有效的动作，比如突然切换它靠着哪堵墙或哪个角落建造。</p>
<h3><em>编辑：</em></h3>
<p>这是这种方法的强大功能的演示。我取消了图块值的上限（因此它在达到 2048 后继续运行），这是八次试验后的最佳结果。</p>
<p><img alt="4096" src="images/x69jZ.png"></p>
<p>是的，这是一个 4096 和一个 2048。=) 这意味着它在同一块板上三次实现了难以捉摸的 2048 块。</p>
<p><br><br><a href="posts/what-is-the-optimal-algorithm-for-the-game-2048/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-chrome-zhong-jin-yong-tong-yuan-ce-lue/" class="u-url">在 Chrome 中禁用同源策略</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-chrome-zhong-jin-yong-tong-yuan-ce-lue/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:54:16+08:00" itemprop="datePublished" title="2023-02-16 22:54">2023-02-16 22:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>有什么办法可以禁用谷歌Chrome浏览器的同源策略吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>关闭 chrome（或 chromium）并使用<code>--disable-web-security</code>参数重新启动。我刚刚对此进行了测试，并验证了我可以访问
iframe 的内容，其中 src="http://google.com" 嵌入在“localhost”提供的页面中（在 chromium 5 /
ubuntu 下测试）。对我来说，确切的命令是：</p>
<p><strong>注意：在运行命令之前杀死所有 chrome 实例</strong></p>
<div class="code"><pre class="code literal-block">chromium-browser --disable-web-security --user-data-dir="[some directory here]"
</pre></div>

<p>浏览器在第一次打开时会警告你“你正在使用不受支持的命令行”，你可以忽略。</p>
<p>来自铬源：</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Don</span><span class="s1">'t enforce the same-origin policy. (Used by people testing their sites.)</span>
<span class="k">const</span><span class="w"> </span><span class="n">wchar_t</span><span class="w"> </span><span class="n">kDisableWebSecurity</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="s2">"disable-web-security"</span><span class="p">;</span>
</pre></div>

<hr>
<p>在 Chrome 48 之前，你可以使用：</p>
<div class="code"><pre class="code literal-block">chromium-browser --disable-web-security
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>是的。对于 OSX，打开终端并运行：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>open<span class="w"> </span>-a<span class="w"> </span>Google<span class="se">\ </span>Chrome<span class="w"> </span>--args<span class="w"> </span>--disable-web-security<span class="w"> </span>--user-data-dir
</pre></div>

<p>--user-data-dir 在 OSX 上的 Chrome 49+ 上需要</p>
<p>对于 Linux 运行：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>google-chrome<span class="w"> </span>--disable-web-security
</pre></div>

<p>此外，如果您出于 AJAX 或 JSON 之类的开发目的而尝试访问本地文件，您也可以使用此标志。</p>
<div class="code"><pre class="code literal-block">--allow-file-access-from-files
</pre></div>

<p>对于 Windows，进入命令提示符并进入 Chrome.exe 所在的文件夹并键入</p>
<div class="code"><pre class="code literal-block">chrome.exe --disable-web-security
</pre></div>

<p>那应该禁用同源策略并允许您访问本地文件。</p>
<p><strong>更新：</strong> 对于 Chrome 22+，您将看到一条错误消息：</p>
<blockquote>
<p>您正在使用不受支持的命令行标志：--disable-web-security。稳定性和安全性将受到影响。</p>
</blockquote>
<p>但是，您可以在开发时忽略该消息。</p>
<p><br><br><a href="posts/disable-same-origin-policy-in-chrome/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-144.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-142.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
