<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 18) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-18.html">
<link rel="prev" href="index-19.html" type="text/html">
<link rel="next" href="index-17.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-a-plain-english-explanation-of-big-o-notation/" class="u-url">What is a plain English explanation of "Big O" notation?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-a-plain-english-explanation-of-big-o-notation/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:42:20+08:00" itemprop="datePublished" title="2023-02-16 18:42">2023-02-16 18:42</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'd prefer as little formal definition as possible and simple mathematics.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Quick note, my answer is almost certainly confusing Big Oh notation (which is
an upper bound) with Big Theta notation "Θ" (which is a two-side bound). But
in my experience, this is actually typical of discussions in non-academic
settings. Apologies for any confusion caused.</p>
<hr>
<p>BigOh complexity can be visualized with this graph:</p>
<p><img alt="Big Oh Analysis" src="images/WcBRI.png"></p>
<p>The simplest definition I can give for Big Oh notation is this:</p>
<p><strong>Big Oh notation is a relative representation of the complexity of an
algorithm.</strong></p>
<p>There are some important and deliberately chosen words in that sentence:</p>
<blockquote>
<ul>
<li>
<strong>relative:</strong> you can only compare apples to apples. You can't compare
an algorithm that does arithmetic multiplication to an algorithm that sorts
a list of integers. But a comparison of two algorithms to do arithmetic
operations (one multiplication, one addition) will tell you something
meaningful;</li>
<li>
<strong>representation:</strong> BigOh (in its simplest form) reduces the comparison
between algorithms to a single variable. That variable is chosen based on
observations or assumptions. For example, sorting algorithms are typically
compared based on comparison operations (comparing two nodes to determine
their relative ordering). This assumes that comparison is expensive. But
what if the comparison is cheap but swapping is expensive? It changes the
comparison; and</li>
<li>
<strong>complexity:</strong> if it takes me one second to sort 10,000 elements, how
long will it take me to sort one million? Complexity in this instance is a
relative measure to something else.
</li>
</ul>
</blockquote>
<p>Come back and reread the above when you've read the rest.</p>
<p>The best example of BigOh I can think of is doing arithmetic. Take two numbers
(123456 and 789012). The basic arithmetic operations we learned in school
were:</p>
<blockquote>
<ul>
<li>addition;</li>
<li>subtraction;</li>
<li>multiplication; and</li>
<li>division.
</li>
</ul>
</blockquote>
<p>Each of these is an operation or a problem. A method of solving these is
called an <strong>algorithm</strong>.</p>
<p>The addition is the simplest. You line the numbers up (to the right) and add
the digits in a column writing the last number of that addition in the result.
The 'tens' part of that number is carried over to the next column.</p>
<p>Let's assume that the addition of these numbers is the most expensive
operation in this algorithm. It stands to reason that to add these two numbers
together we have to add together 6 digits (and possibly carry a 7th). If we
add two 100 digit numbers together we have to do 100 additions. If we add
<strong>two</strong> 10,000 digit numbers we have to do 10,000 additions.</p>
<p>See the pattern? The <strong>complexity</strong> (being the number of operations) is
directly proportional to the number of digits <em>n</em> in the larger number. We
call this <strong>O(n)</strong> or <strong>linear complexity</strong>.</p>
<p>Subtraction is similar (except you may need to borrow instead of carry).</p>
<p>Multiplication is different. You line the numbers up, take the first digit in
the bottom number and multiply it in turn against each digit in the top number
and so on through each digit. So to multiply our two 6 digit numbers we must
do 36 multiplications. We may need to do as many as 10 or 11 column adds to
get the end result too.</p>
<p>If we have two 100-digit numbers we need to do 10,000 multiplications and 200
adds. For two one million digit numbers we need to do one trillion (1012)
multiplications and two million adds.</p>
<p>As the algorithm scales with n- <em>squared</em> , this is <strong>O(n 2)</strong> or <strong>quadratic
complexity</strong>. This is a good time to introduce another important concept:</p>
<p><strong>We only care about the most significant portion of complexity.</strong></p>
<p>The astute may have realized that we could express the number of operations
as: n2 + 2n. But as you saw from our example with two numbers of a million
digits apiece, the second term (2n) becomes insignificant (accounting for
0.0002% of the total operations by that stage).</p>
<p>One can notice that we've assumed the worst case scenario here. While
multiplying 6 digit numbers, if one of them has 4 digits and the other one has
6 digits, then we only have 24 multiplications. Still, we calculate the worst
case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big Oh
notation is about the Worst-case scenario of an algorithm.</p>
<h2>The Telephone Book</h2>
<p>The next best example I can think of is the telephone book, normally called
the White Pages or similar but it varies from country to country. But I'm
talking about the one that lists people by surname and then initials or first
name, possibly address and then telephone numbers.</p>
<p>Now if you were instructing a computer to look up the phone number for "John
Smith" in a telephone book that contains 1,000,000 names, what would you do?
Ignoring the fact that you could guess how far in the S's started (let's
assume you can't), what would you do?</p>
<p>A typical implementation might be to open up to the middle, take the 500,000th
and compare it to "Smith". If it happens to be "Smith, John", we just got
really lucky. Far more likely is that "John Smith" will be before or after
that name. If it's after we then divide the last half of the phone book in
half and repeat. If it's before then we divide the first half of the phone
book in half and repeat. And so on.</p>
<p>This is called a <strong>binary search</strong> and is used every day in programming
whether you realize it or not.</p>
<p>So if you want to find a name in a phone book of a million names you can
actually find any name by doing this at most 20 times. In comparing search
algorithms we decide that this comparison is our 'n'.</p>
<blockquote>
<ul>
<li>For a phone book of 3 names it takes 2 comparisons (at most).</li>
<li>For 7 it takes at most 3.</li>
<li>For 15 it takes 4.</li>
<li>…</li>
<li>For 1,000,000 it takes 20.
</li>
</ul>
</blockquote>
<p>That is staggeringly good, isn't it?</p>
<p>In BigOh terms this is <strong>O(log n)</strong> or <strong>logarithmic complexity</strong>. Now the
logarithm in question could be ln (base e), log10, log2 or some other base. It
doesn't matter it's still O(log n) just like O(2n2) and O(100n2) are still
both O(n2).</p>
<p>It's worthwhile at this point to explain that BigOh can be used to determine
three cases with an algorithm:</p>
<blockquote>
<ul>
<li>
<strong>Best Case:</strong> In the telephone book search, the best case is that we
find the name in one comparison. This is <strong>O(1)</strong> or <strong>constant complexity</strong>
;</li>
<li>
<strong>Expected Case:</strong> As discussed above this is O(log n); and</li>
<li>
<strong>Worst Case:</strong> This is also O(log n).
</li>
</ul>
</blockquote>
<p>Normally we don't care about the best case. We're interested in the expected
and worst case. Sometimes one or the other of these will be more important.</p>
<p>Back to the telephone book.</p>
<p>What if you have a phone number and want to find a name? The police have a
reverse phone book but such look-ups are denied to the general public. Or are
they? Technically you can reverse look-up a number in an ordinary phone book.
How?</p>
<p>You start at the first name and compare the number. If it's a match, great, if
not, you move on to the next. You have to do it this way because the phone
book is <strong>unordered</strong> (by phone number anyway).</p>
<p>So to find a name given the phone number (reverse lookup):</p>
<blockquote>
<ul>
<li>
<strong>Best Case:</strong> O(1);</li>
<li>
<strong>Expected Case:</strong> O(n) (for 500,000); and</li>
<li>
<strong>Worst Case:</strong> O(n) (for 1,000,000).
</li>
</ul>
</blockquote>
<h2>The Traveling Salesman</h2>
<p>This is quite a famous problem in computer science and deserves a mention. In
this problem, you have N towns. Each of those towns is linked to 1 or more
other towns by a road of a certain distance. The Traveling Salesman problem is
to find the shortest tour that visits every town.</p>
<p>Sounds simple? Think again.</p>
<p>If you have 3 towns A, B, and C with roads between all pairs then you could
go:</p>
<blockquote>
<ul>
<li>A → B → C</li>
<li>A → C → B</li>
<li>B → C → A</li>
<li>B → A → C</li>
<li>C → A → B</li>
<li>C → B → A
</li>
</ul>
</blockquote>
<p>Well, actually there's less than that because some of these are equivalent (A
→ B → C and C → B → A are equivalent, for example, because they use the same
roads, just in reverse).</p>
<p>In actuality, there are 3 possibilities.</p>
<blockquote>
<ul>
<li>Take this to 4 towns and you have (iirc) 12 possibilities.</li>
<li>With 5 it's 60.</li>
<li>6 becomes 360.
</li>
</ul>
</blockquote>
<p>This is a function of a mathematical operation called a <strong>factorial</strong>.
Basically:</p>
<blockquote>
<ul>
<li>5! = 5 × 4 × 3 × 2 × 1 = 120</li>
<li>6! = 6 × 5 × 4 × 3 × 2 × 1 = 720</li>
<li>7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040</li>
<li>…</li>
<li>25! = 25 × 24 × … × 2 × 1 = 15,511,210,043,330,985,984,000,000</li>
<li>…</li>
<li>50! = 50 × 49 × … × 2 × 1 = 3.04140932 × 1064
</li>
</ul>
</blockquote>
<p>So the BigOh of the Traveling Salesman problem is <strong>O(n!)</strong> or <strong>factorial or
combinatorial complexity</strong>.</p>
<p><strong>By the time you get to 200 towns there isn't enough time left in the
universe to solve the problem with traditional computers.</strong></p>
<p>Something to think about.</p>
<h2>Polynomial Time</h2>
<p>Another point I wanted to make a quick mention of is that any algorithm that
has a complexity of <strong>O(n a)</strong> is said to have <strong>polynomial complexity</strong> or is
solvable in <strong>polynomial time</strong>.</p>
<p>O(n), O(n2) etc. are all polynomial time. Some problems cannot be solved in
polynomial time. Certain things are used in the world because of this. Public
Key Cryptography is a prime example. It is computationally hard to find two
prime factors of a very large number. If it wasn't, we couldn't use the public
key systems we use.</p>
<p>Anyway, that's it for my (hopefully plain English) explanation of BigOh
(revised).</p>
<p><br></p>
<h3>Suggest</h3>
<p>It shows how an algorithm scales based on input size.</p>
<p><strong>O(n 2)</strong>: known as <strong>Quadratic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 100 operations</li>
<li>100 items: 10,000 operations</li>
</ul>
<p>Notice that the number of items increases by a factor of 10, but the time
increases by a factor of 102. Basically, n=10 and so O(n2) gives us the
scaling factor n2 which is 102.</p>
<p><strong>O(n)</strong> : known as <strong>Linear complexity</strong></p>
<ul>
<li>1 item: 1 operation</li>
<li>10 items: 10 operations</li>
<li>100 items: 100 operations</li>
</ul>
<p>This time the number of items increases by a factor of 10, and so does the
time. n=10 and so O(n)'s scaling factor is 10.</p>
<p><strong>O(1)</strong> : known as <strong>Constant complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 1 operations</li>
<li>100 items: 1 operations</li>
</ul>
<p>The number of items is still increasing by a factor of 10, but the scaling
factor of O(1) is always 1.</p>
<p><strong>O(log n)</strong> : known as <strong>Logarithmic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 2 operations</li>
<li>100 items: 3 operations</li>
<li>1000 items: 4 operations</li>
<li>10,000 items: 5 operations</li>
</ul>
<p>The number of computations is only increased by a log of the input value. So
in this case, assuming each computation takes 1 second, the log of the input
<code>n</code> is the time required, hence <code>log n</code>.</p>
<p>That's the gist of it. They reduce the maths down so it might not be exactly
n2 or whatever they say it is, but that'll be the dominating factor in the
scaling.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/reset-local-repository-branch-to-be-just-like-remote-repository-head/" class="u-url">Reset local repository branch to be just like remote repository HEAD</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/reset-local-repository-branch-to-be-just-like-remote-repository-head/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:41:31+08:00" itemprop="datePublished" title="2023-02-16 18:41">2023-02-16 18:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How do I reset my local branch to be just like the branch on the remote
repository?</p>
<p>I tried:</p>
<div class="code"><pre class="code literal-block">git reset --hard HEAD
</pre></div>

<p>But <code>git status</code> claims I have modified files:</p>
<div class="code"><pre class="code literal-block">On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)
      modified:   java/com/mycompany/TestContacts.java
      modified:   java/com/mycompany/TestParser.java
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Setting your branch to exactly match the remote branch can be done in two
steps:</p>
<div class="code"><pre class="code literal-block">git fetch origin
git reset --hard origin/master
</pre></div>

<p>If you want to save your current branch's state before doing this (just in
case), you can do:</p>
<div class="code"><pre class="code literal-block">git commit -a -m "Saving my work, just in case"
git branch my-saved-work
</pre></div>

<p>Now your work is saved on the branch "my-saved-work" in case you decide you
want it back (or want to look at it later or diff it against your updated
branch).</p>
<p>Note that the first example assumes that the remote repo's name is "origin"
and that the branch named "master" in the remote repo matches the currently
checked-out branch in your local repo.</p>
<p>BTW, this situation that you're in looks an awful lot like a common case where
a push has been done into the currently checked out branch of a non-bare
repository. Did you recently push into your local repo? If not, then no
worries -- something else must have caused these files to unexpectedly end up
modified. Otherwise, you should be aware that it's not recommended to push
into a non-bare repository (and not into the currently checked-out branch, in
particular).</p>
<p><br></p>
<h3>Suggest</h3>
<p>I needed to do (the solution in the accepted answer):</p>
<div class="code"><pre class="code literal-block">git fetch origin
git reset --hard origin/master
</pre></div>

<p>Followed by:</p>
<div class="code"><pre class="code literal-block">git clean -f
</pre></div>

<p>to remove local files</p>
<p>To see what files will be removed (without actually removing them):</p>
<div class="code"><pre class="code literal-block">git clean -n -f
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-do-i-replace-all-occurrences-of-a-string-in-javascript/" class="u-url">How do I replace all occurrences of a string in JavaScript?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-do-i-replace-all-occurrences-of-a-string-in-javascript/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:41:03+08:00" itemprop="datePublished" title="2023-02-16 18:41">2023-02-16 18:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Given a string:</p>
<div class="code"><pre class="code literal-block">s = "Test abc test test abc test test test abc test test abc";
</pre></div>

<p>This seems to only remove the first occurrence of <code>abc</code> in the string above:</p>
<div class="code"><pre class="code literal-block">s = s.replace('abc', '');
</pre></div>

<p>How do I replace <em>all</em> occurrences of it?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>In the latest versions of most popular browsers, you can use <code>replaceAll</code> as
shown here:</p>
<div class="code"><pre class="code literal-block"><span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"1 abc 2 abc 3"</span><span class="p">.</span><span class="n">replaceAll</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">,</span><span class="w"> </span><span class="s2">"xyz"</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`result`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="s2">"1 xyz 2 xyz 3"</span>
</pre></div>

<p>But check Can I use or another compatibility table first to make sure the
browsers you're targeting have added support for it first.</p>
<hr>
<p>For Node.js and compatibility with older/non-current browsers:</p>
<p><strong>Note: Don't use the following solution in performance critical code.</strong></p>
<p>As an alternative to regular expressions for a simple literal string, you
could use</p>
<div class="code"><pre class="code literal-block">str = "Test abc test test abc test...".split("abc").join("");
</pre></div>

<p>The general pattern is</p>
<div class="code"><pre class="code literal-block">str.split(search).join(replacement)
</pre></div>

<p>This used to be faster in some cases than using <code>replaceAll</code> and a regular
expression, but that doesn't seem to be the case anymore in modern browsers.</p>
<p>Benchmark: https://jsben.ch/TZYzj</p>
<h4>Conclusion:</h4>
<p>If you have a performance-critical use case (e.g., processing hundreds of
strings), use the regular expression method. But for most typical use cases,
this is well worth not having to worry about special characters.</p>
<p><br></p>
<h3>Suggest</h3>
<p>For the sake of completeness, I got to thinking about which method I should
use to do this. There are basically two ways to do this as suggested by the
other answers on this page.</p>
<p><strong>Note:</strong> In general, extending the built-in prototypes in JavaScript is
generally not recommended. I am providing as extensions on the String
prototype simply for purposes of illustration, showing different
implementations of a hypothetical standard method on the <code>String</code> built-in
prototype.</p>
<hr>
<h4>Regular Expression Based Implementation</h4>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">String</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">replaceAll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">search</span><span class="p">,</span><span class="w"> </span><span class="n">replacement</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">RegExp</span><span class="p">(</span><span class="n">search</span><span class="p">,</span><span class="w"> </span><span class="s1">'g'</span><span class="p">),</span><span class="w"> </span><span class="n">replacement</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>

<h4>Split and Join (Functional) Implementation</h4>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">String</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">replaceAll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">search</span><span class="p">,</span><span class="w"> </span><span class="n">replacement</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">search</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">replacement</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>

<hr>
<p>Not knowing too much about how regular expressions work behind the scenes in
terms of efficiency, I tended to lean toward the split and join implementation
in the past without thinking about performance. When I did wonder which was
more efficient, and by what margin, I used it as an excuse to find out.</p>
<p>On my Chrome Windows 8 machine, <strong>the regular expression based implementation
is the fastest</strong> , with the <strong>split and join implementation being 53%
slower</strong>. Meaning the regular expressions are twice as fast for the lorem
ipsum input I used.</p>
<p>Check out this <strong>benchmark</strong> running these two implementations against each
other.</p>
<hr>
<p>As noted in the comment below by @ThomasLeduc and others, there could be an
issue with the regular expression-based implementation if <code>search</code> contains
certain characters which are reserved as special characters in regular
expressions. The implementation assumes that the caller will escape the string
beforehand or will only pass strings that are without the characters in the
table in <em>Regular Expressions</em> (MDN).</p>
<p>MDN also provides an implementation to escape our strings. It would be nice if
this was also standardized as <code>RegExp.escape(str)</code>, but alas, it does not
exist:</p>
<div class="code"><pre class="code literal-block">function<span class="w"> </span>escapeRegExp(str)<span class="w"> </span>{
<span class="w">  </span>return<span class="w"> </span>str.replace(/[.*+?^<span class="cp">${</span><span class="p">}()</span><span class="o">|</span><span class="p">[</span>\<span class="p">]</span>\\<span class="p">]</span><span class="o">/</span><span class="n">g</span><span class="p">,</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">$&amp;"</span><span class="p">);</span> <span class="o">//</span> <span class="err">$</span><span class="o">&amp;</span> <span class="n">means</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">matched</span> <span class="n">string</span>
<span class="cp">}</span>
</pre></div>

<p>We could call <code>escapeRegExp</code> within our <code>String.prototype.replaceAll</code>
implementation, however, I'm not sure how much this will affect the
performance (potentially even for strings for which the escape is not needed,
like all alphanumeric strings).</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-19.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-17.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
