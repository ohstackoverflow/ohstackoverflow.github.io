<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2500) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2500.html">
<link rel="prev" href="index-2501.html" type="text/html">
<link rel="next" href="index-2499.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/mysql-vs-mongodb-1000-reads/" class="u-url">MySQL vs MongoDB 1000 reads</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/mysql-vs-mongodb-1000-reads/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T20:47:51+08:00" itemprop="datePublished" title="2023-03-04 20:47">2023-03-04 20:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have been very excited about MongoDb and have been testing it lately. I had
a table called posts in MySQL with about 20 million records indexed only on a
field called 'id'.</p>
<p>I wanted to compare speed with MongoDB and I ran a test which would get and
print 15 records randomly from our huge databases. I ran the query about 1,000
times each for mysql and MongoDB and I am suprised that I do not notice a lot
of difference in speed. Maybe MongoDB is 1.1 times faster. That's very
disappointing. Is there something I am doing wrong? I know that my tests are
not perfect but is MySQL on par with MongoDb when it comes to read intensive
chores.</p>
<p>Note:</p>
<ul>
<li>I have dual core + ( 2 threads ) i7 cpu and 4GB ram</li>
<li>I have 20 partitions on MySQL each of 1 million records</li>
</ul>
<p><strong>Sample Code Used For Testing MongoDB</strong></p>
<div class="code"><pre class="code literal-block"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">microtime_float</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">list</span><span class="p">(</span><span class="nv">$usec</span><span class="p">,</span> <span class="nv">$sec</span><span class="p">)</span> <span class="o">=</span> <span class="nb">explode</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="nb">microtime</span><span class="p">());</span>
    <span class="k">return</span> <span class="p">((</span><span class="nx">float</span><span class="p">)</span><span class="nv">$usec</span> <span class="o">+</span> <span class="p">(</span><span class="nx">float</span><span class="p">)</span><span class="nv">$sec</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$time_taken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$tries</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="c1">// connect</span>
<span class="nv">$time_start</span> <span class="o">=</span> <span class="nx">microtime_float</span><span class="p">();</span>

<span class="k">for</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nv">$i</span><span class="o">&lt;=</span><span class="nv">$tries</span><span class="p">;</span><span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Mongo</span><span class="p">();</span>
    <span class="nv">$db</span> <span class="o">=</span> <span class="nv">$m</span><span class="o">-&gt;</span><span class="na">swalif</span><span class="p">;</span>
    <span class="nv">$cursor</span> <span class="o">=</span> <span class="nv">$db</span><span class="o">-&gt;</span><span class="na">posts</span><span class="o">-&gt;</span><span class="na">find</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">'$in'</span> <span class="o">=&gt;</span> <span class="nx">get_15_random_numbers</span><span class="p">())));</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$cursor</span> <span class="k">as</span> <span class="nv">$obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//echo $obj["thread_title"] . "&lt;br&gt;&lt;Br&gt;";</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nv">$time_end</span> <span class="o">=</span> <span class="nx">microtime_float</span><span class="p">();</span>
<span class="nv">$time_taken</span> <span class="o">=</span> <span class="nv">$time_taken</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$time_end</span> <span class="o">-</span> <span class="nv">$time_start</span><span class="p">);</span>
<span class="k">echo</span> <span class="nv">$time_taken</span><span class="p">;</span>

<span class="k">function</span> <span class="nf">get_15_random_numbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$numbers</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nv">$i</span><span class="o">&lt;=</span><span class="mi">15</span><span class="p">;</span><span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="nb">mt_rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20000000</span><span class="p">)</span> <span class="p">;</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$numbers</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">?&gt;</span>
</pre></div>

<p><strong>Sample Code For Testing MySQL</strong></p>
<div class="code"><pre class="code literal-block"><span class="cp">&lt;?php</span>
<span class="k">function</span> <span class="nf">microtime_float</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">list</span><span class="p">(</span><span class="nv">$usec</span><span class="p">,</span> <span class="nv">$sec</span><span class="p">)</span> <span class="o">=</span> <span class="nb">explode</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="nb">microtime</span><span class="p">());</span>
    <span class="k">return</span> <span class="p">((</span><span class="nx">float</span><span class="p">)</span><span class="nv">$usec</span> <span class="o">+</span> <span class="p">(</span><span class="nx">float</span><span class="p">)</span><span class="nv">$sec</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$BASE_PATH</span> <span class="o">=</span> <span class="s2">"../src/"</span><span class="p">;</span>
<span class="k">include_once</span><span class="p">(</span><span class="nv">$BASE_PATH</span>  <span class="o">.</span> <span class="s2">"classes/forumdb.php"</span><span class="p">);</span>

<span class="nv">$time_taken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$tries</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nv">$time_start</span> <span class="o">=</span> <span class="nx">microtime_float</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nv">$i</span><span class="o">&lt;=</span><span class="nv">$tries</span><span class="p">;</span><span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$db</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AQLDatabase</span><span class="p">();</span>
    <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">"select * from posts_really_big where id in ("</span><span class="o">.</span><span class="nb">implode</span><span class="p">(</span><span class="s1">','</span><span class="p">,</span><span class="nx">get_15_random_numbers</span><span class="p">())</span><span class="o">.</span><span class="s2">")"</span><span class="p">;</span>
    <span class="nv">$result</span> <span class="o">=</span> <span class="nv">$db</span><span class="o">-&gt;</span><span class="na">executeSQL</span><span class="p">(</span><span class="nv">$sql</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nv">$row</span> <span class="o">=</span> <span class="nb">mysql_fetch_array</span><span class="p">(</span><span class="nv">$result</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//echo $row["thread_title"] . "&lt;br&gt;&lt;Br&gt;";</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nv">$time_end</span> <span class="o">=</span> <span class="nx">microtime_float</span><span class="p">();</span>
<span class="nv">$time_taken</span> <span class="o">=</span> <span class="nv">$time_taken</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$time_end</span> <span class="o">-</span> <span class="nv">$time_start</span><span class="p">);</span>
<span class="k">echo</span> <span class="nv">$time_taken</span><span class="p">;</span>

<span class="k">function</span> <span class="nf">get_15_random_numbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$numbers</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nv">$i</span><span class="o">&lt;=</span><span class="mi">15</span><span class="p">;</span><span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="nb">mt_rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20000000</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$numbers</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>MongoDB is not magically faster. If you store the same data, organised in
basically the same fashion, and access it exactly the same way, then you
really shouldn't expect your results to be wildly different. After all, MySQL
and MongoDB are both GPL, so if Mongo had some magically better IO code in it,
then the MySQL team could just incorporate it into their codebase.</p>
<p>People are seeing real world MongoDB performance largely because MongoDB
allows you to query in a different manner that is more sensible to your
workload.</p>
<p>For example, consider a design that persisted a lot of information about a
complicated entity in a normalised fashion. This could easily use dozens of
tables in MySQL (or any relational db) to store the data in normal form, with
many indexes needed to ensure relational integrity between tables.</p>
<p>Now consider the same design with a document store. If all of those related
tables are subordinate to the main table (and they often are), then you might
be able to model the data such that the entire entity is stored in a single
document. In MongoDB you can store this as a single document, in a single
collection. This is where MongoDB starts enabling superior performance.</p>
<p>In MongoDB, to retrieve the whole entity, you have to perform:</p>
<ul>
<li>One index lookup on the collection (assuming the entity is fetched by id)</li>
<li>Retrieve the contents of one database page (the actual binary json document)</li>
</ul>
<p>So a b-tree lookup, and a binary page read. Log(n) + 1 IOs. If the indexes can
reside entirely in memory, then 1 IO.</p>
<p>In MySQL with 20 tables, you have to perform:</p>
<ul>
<li>One index lookup on the root table (again, assuming the entity is fetched by id)</li>
<li>With a clustered index, we can assume that the values for the root row are in the index</li>
<li>20+ range lookups (hopefully on an index) for the entity's pk value</li>
<li>These probably aren't clustered indexes, so the same 20+ data lookups once we figure out what the appropriate child rows are.</li>
</ul>
<p>So the total for mysql, even assuming that all indexes are in memory (which is
harder since there are 20 times more of them) is about 20 range lookups.</p>
<p>These range lookups are likely comprised of random IO — different tables will
definitely reside in different spots on disk, and it's possible that different
rows in the same range in the same table for an entity might not be contiguous
(depending on how the entity has been updated, etc).</p>
<p>So for this example, the final tally is about <em>20 times</em> more IO with MySQL
per logical access, compared to MongoDB.</p>
<p>This is how MongoDB can boost performance <em>in some use cases</em>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Do you have concurrency, i.e simultaneous users ? If you just run 1000 times
the query straight, with just one thread, there will be almost no difference.
Too easy for these engines :)</p>
<p>BUT I strongly suggest that you build a true load testing session, which means
using an injector such as JMeter with 10, 20 or 50 users AT THE SAME TIME so
you can really see a difference (try to embed this code inside a web page
JMeter could query).</p>
<p>I just did it today on a single server (and a simple collection / table) and
the results are quite interesting and surprising (MongoDb was really faster on
writes &amp; reads, compared to MyISAM engine and InnoDb engine).</p>
<p>This really should be part of your test : concurrency &amp; MySQL engine. Then,
data/schema design &amp; application needs are of course huge requirements, beyond
response times. Let me know when you get results, I'm also in need of inputs
about this!</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/convert-a-number-range-to-another-range-maintaining-ratio/" class="u-url">Convert a number range to another range, maintaining ratio</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/convert-a-number-range-to-another-range-maintaining-ratio/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T20:46:24+08:00" itemprop="datePublished" title="2023-03-04 20:46">2023-03-04 20:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm trying to convert one range of numbers to another, maintaining ratio.
Maths is not my strong point.</p>
<p>I have an image file where point values may range from -16000.00 to 16000.00
though the typical range may be much less. What I want to do is compress these
values into the integer range 0-100, where 0 is the value of the smallest
point, and 100 is the value of the largest. All points in between should keep
a relative ratio even though some precision is being lost I'd like to do this
in python but even a general algorithm should suffice. I'd prefer an algorithm
where the min/max or either range can be adjusted (ie, the second range could
be -50 to 800 instead of 0 to 100).</p>
<p><br><br></p>
<h2>Answer</h2>
<div class="code"><pre class="code literal-block">NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
</pre></div>

<p>Or a little more readable:</p>
<div class="code"><pre class="code literal-block">OldRange = (OldMax - OldMin)  
NewRange = (NewMax - NewMin)  
NewValue = (((OldValue - OldMin) * NewRange) / OldRange) + NewMin
</pre></div>

<p>Or if you want to protect for the case where the old range is 0 ( <em>OldMin =
OldMax</em> ):</p>
<div class="code"><pre class="code literal-block"><span class="nv">OldRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">OldMax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">OldMin</span><span class="ss">)</span>
<span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">OldRange</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">NewValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">NewMin</span>
<span class="k">else</span>
{
<span class="w">    </span><span class="nv">NewRange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">NewMax</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">NewMin</span><span class="ss">)</span><span class="w">  </span>
<span class="w">    </span><span class="nv">NewValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(((</span><span class="nv">OldValue</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">OldMin</span><span class="ss">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">NewRange</span><span class="ss">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nv">OldRange</span><span class="ss">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">NewMin</span>
}
</pre></div>

<p>Note that in this case we're forced to pick one of the possible new range
values arbitrarily. Depending on context, sensible choices could be: <code>NewMin</code>
( <em>see sample</em> ), <code>NewMax</code> or <code>(NewMin + NewMax) / 2</code></p>
<p><br></p>
<h3>Suggest</h3>
<p>That's a simple linear conversion.</p>
<div class="code"><pre class="code literal-block">new_value = ( (old_value - old_min) / (old_max - old_min) ) * (new_max - new_min) + new_min
</pre></div>

<p>So converting 10000 on the scale of -16000 to 16000 to a new scale of 0 to 100
yields:</p>
<div class="code"><pre class="code literal-block">old_value = 10000
old_min = -16000
old_max = 16000
new_min = 0
new_max = 100

new_value = ( ( 10000 - -16000 ) / (16000 - -16000) ) * (100 - 0) + 0
          = 81.25
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/when-should-one-use-a-spinlock-instead-of-mutex/" class="u-url">When should one use a spinlock instead of mutex?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/when-should-one-use-a-spinlock-instead-of-mutex/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T20:44:46+08:00" itemprop="datePublished" title="2023-03-04 20:44">2023-03-04 20:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I think both are doing the same job,how do you decide which one to use for
synchronization?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>The Theory</strong></p>
<p>In theory, when a thread tries to lock a mutex and it does not succeed,
because the mutex is already locked, it will go to sleep, immediately allowing
another thread to run. It will continue to sleep until being woken up, which
will be the case once the mutex is being unlocked by whatever thread was
holding the lock before. When a thread tries to lock a spinlock and it does
not succeed, it will continuously re-try locking it, until it finally
succeeds; thus it will not allow another thread to take its place (however,
the operating system will forcefully switch to another thread, once the CPU
runtime quantum of the current thread has been exceeded, of course).</p>
<p><strong>The Problem</strong></p>
<p>The problem with mutexes is that putting threads to sleep and waking them up
again are both rather expensive operations, they'll need quite a lot of CPU
instructions and thus also take some time. If now the mutex was only locked
for a very short amount of time, the time spent in putting a thread to sleep
and waking it up again might exceed the time the thread has actually slept by
far and it might even exceed the time the thread would have wasted by
constantly polling on a spinlock. On the other hand, polling on a spinlock
will constantly waste CPU time and if the lock is held for a longer amount of
time, this will waste a lot more CPU time and it would have been much better
if the thread was sleeping instead.</p>
<p><strong>The Solution</strong></p>
<p>Using spinlocks on a single-core/single-CPU system makes usually no sense,
since as long as the spinlock polling is blocking the only available CPU core,
no other thread can run and since no other thread can run, the lock won't be
unlocked either. IOW, a spinlock wastes only CPU time on those systems for no
real benefit. If the thread was put to sleep instead, another thread could
have ran at once, possibly unlocking the lock and then allowing the first
thread to continue processing, once it woke up again.</p>
<p>On a multi-core/multi-CPU systems, with plenty of locks that are held for a
very short amount of time only, the time wasted for constantly putting threads
to sleep and waking them up again might decrease runtime performance
noticeably. When using spinlocks instead, threads get the chance to take
advantage of their full runtime quantum (always only blocking for a very short
time period, but then immediately continue their work), leading to much higher
processing throughput.</p>
<p><strong>The Practice</strong></p>
<p>Since very often programmers cannot know in advance if mutexes or spinlocks
will be better (e.g. because the number of CPU cores of the target
architecture is unknown), nor can operating systems know if a certain piece of
code has been optimized for single-core or multi-core environments, most
systems don't strictly distinguish between mutexes and spinlocks. In fact,
most modern operating systems have hybrid mutexes and hybrid spinlocks. What
does that actually mean?</p>
<p>A hybrid mutex behaves like a spinlock at first on a multi-core system. If a
thread cannot lock the mutex, it won't be put to sleep immediately, since the
mutex might get unlocked pretty soon, so instead the mutex will first behave
exactly like a spinlock. Only if the lock has still not been obtained after a
certain amount of time (or retries or any other measuring factor), the thread
is really put to sleep. If the same code runs on a system with only a single
core, the mutex will not spinlock, though, as, see above, that would not be
beneficial.</p>
<p>A hybrid spinlock behaves like a normal spinlock at first, but to avoid
wasting too much CPU time, it may have a back-off strategy. It will usually
not put the thread to sleep (since you don't want that to happen when using a
spinlock), but it may decide to stop the thread (either immediately or after a
certain amount of time; this is called "yielding") and allow another thread to
run, thus increasing chances that the spinlock is unlocked (you still have the
costs of a thread switch but not the costs of putting a thread to sleep and
waking it up again).</p>
<p><strong>Summary</strong></p>
<p>If in doubt, use mutexes, they are usually the better choice and most modern
systems will allow them to spinlock for a very short amount of time, if this
seems beneficial. Using spinlocks can sometimes improve performance, but only
under certain conditions and the fact that you are in doubt rather tells me,
that you are not working on any project currently where a spinlock might be
beneficial. You might consider using your own "lock object", that can either
use a spinlock or a mutex internally (e.g. this behavior could be configurable
when creating such an object), initially use mutexes everywhere and if you
think that using a spinlock somewhere might really help, give it a try and
compare the results (e.g. using a profiler), but be sure to test both cases, a
single-core and a multi-core system before you jump to conclusions (and
possibly different operating systems, if your code will be cross-platform).</p>
<h3>Update: A Warning for iOS</h3>
<p>Actually not iOS specific but iOS is the platform where most developers may
face that problem: If your system has a thread scheduler, that does not
guarantee that any thread, no matter how low its priority may be, will
eventually get a chance to run, then spinlocks can lead to permanent
deadlocks. The iOS scheduler distinguishes different classes of threads and
threads on a lower class will only run if no thread in a higher class wants to
run as well. There is no back-off strategy for this, so if you permanently
have high class threads available, low class threads will never get any CPU
time and thus never any chance to perform any work.</p>
<p>The problem appears as follow: Your code obtains a spinlock in a low prio
class thread and while it is in the middle of that lock, the time quantum has
exceeded and the thread stops running. The only way how this spinlock can be
released again is if that low prio class thread gets CPU time again but this
is not guaranteed to happen. You may have a couple of high prio class threads
that constantly want to run and the task scheduler will always prioritize
those. One of them may run across the spinlock and try to obtain it, which
isn't possible of course, and the system will make it yield. The problem is: A
thread that yielded is immediately available for running again! Having a
higher prio than the thread holding the lock, the thread holding the lock has
no chance to get CPU runtime. Either some other thread will get runtime or the
thread that just yielded.</p>
<p>Why does this problem not occur with mutexes? When the high prio thread cannot
obtain the mutex, it won't yield, it may spin a bit but will eventually be
sent to sleep. A sleeping thread is not available for running until it is
woken up by an event, e.g. an event like the mutex being unlocked it has been
waiting for. Apple is aware of that problem and has deprecated <code>OSSpinLock</code> as
a result. The new lock is called <code>os_unfair_lock</code>. This lock avoids the
situation mentioned above as it is aware of the different thread priority
classes. If you are sure that using spinlocks is a good idea in your iOS
project, use that one. Stay away from <code>OSSpinLock</code>! And under no circumstances
implement your own spinlocks in iOS! If in doubt, use a mutex. macOS is not
affected by this issue as it has a different thread scheduler that won't allow
any thread (even low prio threads) to "run dry" on CPU time, still the same
situation can arise there and will then lead to very poor performance, thus
<code>OSSpinLock</code> is deprecated on macOS as well.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Continuing with Mecki's suggestion, this article pthread mutex vs pthread
spinlock on Alexander Sandler's blog, Alex on Linux shows how the <code>spinlock</code> &amp;
<code>mutexes</code> can be implemented to test the behavior using #ifdef.</p>
<p>However, be sure to take the final call based on your observation,
understanding as the example given is an isolated case, your project
requirement, environment may be entirely different.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2501.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2499.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
