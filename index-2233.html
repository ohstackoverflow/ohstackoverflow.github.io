<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2233) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2233.html">
<link rel="prev" href="index-2234.html" type="text/html">
<link rel="next" href="index-2232.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/eclipse-jump-to-closing-brace/" class="u-url">Eclipse jump to closing brace</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/eclipse-jump-to-closing-brace/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T00:47:24+08:00" itemprop="datePublished" title="2023-03-04 00:47">2023-03-04 00:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>What is the keyboard short cut in Eclipse to jump to the closing brace of a
scope?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Place the cursor next to an opening <em>or closing</em> brace and punch <code>Ctrl</code> +
<code>Shift</code> + <code>P</code> to find the matching brace. If Eclipse can't find one you'll
get a <em>"No matching bracket found"</em> message.</p>
<p><strong><em>edit:</em></strong> as mentioned by Romaintaz below, you can also get Eclipse to auto-
select all of the code between two curly braces simply by double-clicking to
the immediate right of a opening brace.</p>
<p><br></p>
<h3>Suggest</h3>
<p>As the shortcut <code>Ctrl</code> + <code>Shift</code> + <code>P</code> has been cited, I just wanted to add
a really interesting feature: just double-click to the immediate right of the
<code>{</code>, and Eclipse will select the whole code block between the opening <code>{</code> and
corresponding closing <code>}</code>. Similarly, double-click to the immediate left of
the closing '}' and eclipse will select the block.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-does-date-parse-give-incorrect-results/" class="u-url">Why does Date.parse give incorrect results?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-does-date-parse-give-incorrect-results/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T00:46:06+08:00" itemprop="datePublished" title="2023-03-04 00:46">2023-03-04 00:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <h4>Case One:</h4>
<div class="code"><pre class="code literal-block">new Date(Date.parse("Jul 8, 2005"));
</pre></div>

<h4>Output:</h4>
<p>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</p>
<h4>Case Two:</h4>
<div class="code"><pre class="code literal-block">new Date(Date.parse("2005-07-08"));
</pre></div>

<h4>Output:</h4>
<p>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</p>
<hr>
<p>Why is the second parse incorrect?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Until the 5th edition spec came out, the <code>Date.parse</code> method was completely
<em>implementation dependent</em> (<code>new Date(string)</code> is equivalent to
<code>Date.parse(string)</code> except the latter returns a number rather than a <code>Date</code>).
In the 5th edition spec the requirement was added to support a simplified
<em>(and slightly incorrect)</em> ISO-8601 (also see What are valid Date Time Strings
in JavaScript?). But other than that, there was <em>no</em> requirement for what
<code>Date.parse</code> / <code>new Date(string)</code> should accept other than that they had to
accept whatever <code>Date#toString</code> output (without saying what that was).</p>
<p>As of ECMAScript 2017 (edition 8), implementations were required to parse
their output for <code>Date#toString</code> and <code>Date#toUTCString</code>, but the format of
those strings was not specified.</p>
<p>As of ECMAScript 2019 (edition 9) the format for <code>Date#toString</code> and
<code>Date#toUTCString</code>, have been specified as (respectively):</p>
<ol>
<li>
<p>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]<br>
e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</p>
</li>
<li>
<p>ddd, DD MMM YYYY HH:mm:ss Z<br>
e.g. Tue 10 Jul 2018 13:09:58 GMT</p>
</li>
</ol>
<p>providing 2 more formats that <code>Date.parse</code> should parse reliably in new
implementations (noting that support is not ubiquitous and non–compliant
implementations will remain in use for some time).</p>
<p>I would recommend that date strings are parsed manually and the Date
constructor used with year, month and day arguments to avoid ambiguity:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// parse a date in yyyy-mm-dd format</span>
<span class="k">function</span><span class="w"> </span><span class="nf">parseDate</span><span class="p">(</span>input<span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">parts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">input</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// new Date(year, month [, day [, hours[, minutes[, seconds[, ms]]]]])</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Date</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Note: months are 0-based</span>
<span class="p">}</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>During recent experience writing a JS interpreter I wrestled plenty with the
inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here.
Hopefully sharing this stuff will help others with any questions about the
differences among browsers in how they handle dates.</p>
<h2>The Input Side</h2>
<p>All implementations store their date values internally as 64-bit numbers that
represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the
same thing as UTC). This date is the ECMAScript epoch that is also used by
other languages such as Java and POSIX systems such as UNIX. Dates occurring
after the epoch are positive numbers and dates prior are negative.</p>
<p>The following code is interpreted as the same date in all current browsers,
but with the local timezone offset:</p>
<div class="code"><pre class="code literal-block">Date.parse('1/1/1970'); // 1 January, 1970
</pre></div>

<p>In my timezone (EST, which is -05:00), the result is 18000000 because that's
how many ms are in 5 hours (it's only 4 hours during daylight savings months).
The value will be different in different time zones. This behaviour is
specified in ECMA-262 so all browsers do it the same way.</p>
<p>While there is some variance in the input string formats that the major
browsers will parse as dates, they essentially interpret them the same as far
as time zones and daylight saving is concerned even though parsing is largely
implementation dependent.</p>
<p>However, the ISO 8601 format is different. It's one of only two formats
outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same
way by all implementations (the other is the format specified for
Date.prototype.toString).</p>
<p>But, even for ISO 8601 format strings, some implementations get it wrong. Here
is a comparison output of Chrome and Firefox when this answer was originally
written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings
that <em>should</em> be parsed to exactly the same value in all implementations:</p>
<div class="code"><pre class="code literal-block"><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s1">'1970-01-01T00:00:00Z'</span><span class="o">);</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="nt">Chrome</span><span class="o">:</span><span class="w"> </span><span class="nt">0</span><span class="w">         </span><span class="nt">FF</span><span class="o">:</span><span class="w"> </span><span class="nt">0</span>
<span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s1">'1970-01-01T00:00:00-0500'</span><span class="o">);</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">Chrome</span><span class="o">:</span><span class="w"> </span><span class="nt">18000000</span><span class="w">  </span><span class="nt">FF</span><span class="o">:</span><span class="w"> </span><span class="nt">18000000</span>
<span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s1">'1970-01-01T00:00:00'</span><span class="o">);</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nt">Chrome</span><span class="o">:</span><span class="w"> </span><span class="nt">0</span><span class="w">         </span><span class="nt">FF</span><span class="o">:</span><span class="w"> </span><span class="nt">18000000</span>
</pre></div>

<ul>
<li>In the first case, the "Z" specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</li>
<li>In the second case, the "-0500" specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</li>
<li>The third case, where there is no specifier, <em>should</em> be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</li>
</ul>
<p>This difference has been fixed as of 2020, but other quirks exist between
browsers when parsing ISO 8601 format strings.</p>
<p>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date–only format
(YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to
be parsed as local. Here is the output from FF with the long and short ISO
date formats with no time zone specifier.</p>
<div class="code"><pre class="code literal-block"><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s1">'1970-01-01T00:00:00'</span><span class="o">);</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="nt">18000000</span>
<span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s1">'1970-01-01'</span><span class="o">);</span><span class="w">                </span><span class="o">//</span><span class="w"> </span><span class="nt">0</span>
</pre></div>

<p>So the first is parsed as local because it's ISO 8601 date and time with no
timezone, and the second is parsed as UTC because it's ISO 8601 date only.</p>
<p>So, to answer the original question directly, <code>"YYYY-MM-DD"</code> is required by
ECMA-262 to be interpreted as UTC, while the other is interpreted as local.
That's why:</p>
<h4>This doesn't produce equivalent results:</h4>
<div class="code"><pre class="code literal-block">console.log(new Date(Date.parse("Jul 8, 2005")).toString()); // Local
console.log(new Date(Date.parse("2005-07-08")).toString());  // UTC
</pre></div>

<h4>This does:</h4>
<div class="code"><pre class="code literal-block"><span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Date</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"Jul 8, 2005"</span><span class="o">))</span><span class="p">.</span><span class="nc">toString</span><span class="o">());</span>
<span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Date</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"2005-07-08T00:00:00"</span><span class="o">))</span><span class="p">.</span><span class="nc">toString</span><span class="o">());</span>
</pre></div>

<p>The bottom line is this for parsing date strings. The ONLY ISO 8601 string
that you can safely parse across browsers is the long form <strong>with an offset</strong>
(either ±HH:mm or "Z"). If you do that you can safely go back and forth
between local and UTC time.</p>
<h4>This works across browsers (after IE9):</h4>
<div class="code"><pre class="code literal-block"><span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Date</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"2005-07-08T00:00:00Z"</span><span class="o">))</span><span class="p">.</span><span class="nc">toString</span><span class="o">());</span>
</pre></div>

<p>Most current browsers do treat the other input formats equally, including the
frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY
hh:mm:ss ap) formats. All of the following formats (except the last) are
treated as local time input in all browsers. The output of this code is the
same in all browsers in my timezone. The last one is treated as -05:00
regardless of the host timezone because the offset is set in the timestamp:</p>
<div class="code"><pre class="code literal-block"><span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"1/1/1970"</span><span class="o">));</span>
<span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"1/1/1970 12:00:00 AM"</span><span class="o">));</span>
<span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"Thu Jan 01 1970"</span><span class="o">));</span>
<span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"Thu Jan 01 1970 00:00:00"</span><span class="o">));</span>
<span class="nt">console</span><span class="p">.</span><span class="nc">log</span><span class="o">(</span><span class="nt">Date</span><span class="p">.</span><span class="nc">parse</span><span class="o">(</span><span class="s2">"Thu Jan 01 1970 00:00:00 GMT-0500"</span><span class="o">));</span>
</pre></div>

<p>However, since parsing of even the formats specified in ECMA-262 is not
consistent, it is recommended to never rely on the built–in parser and to
always manually parse strings, say using a library and provide the format to
the parser.</p>
<p>E.g. in moment.js you might write:</p>
<div class="code"><pre class="code literal-block">let m = moment('1/1/1970', 'M/D/YYYY');
</pre></div>

<h2>The Output Side</h2>
<p>On the output side, all browsers translate time zones the same way but they
handle the string formats differently. Here are the <code>toString</code> functions and
what they output. Notice the <code>toUTCString</code> and <code>toISOString</code> functions output
5:00 AM on my machine. Also, the timezone name may be an abbreviation and may
be different in different implementations.</p>
<p><strong>Converts from UTC to Local time before printing</strong></p>
<div class="code"><pre class="code literal-block"> - toString
 - toDateString
 - toTimeString
 - toLocaleString
 - toLocaleDateString
 - toLocaleTimeString
</pre></div>

<p><strong>Prints the stored UTC time directly</strong></p>
<div class="code"><pre class="code literal-block"> - toUTCString
 - toISOString
</pre></div>

<hr>
<div class="code"><pre class="code literal-block">**In Chrome**


toString            Thu Jan 01 1970 00:00:00 GMT-05:00 (Eastern Standard Time)
toDateString        Thu Jan 01 1970
toTimeString        00:00:00 GMT-05:00 (Eastern Standard Time)
toLocaleString      1/1/1970 12:00:00 AM
toLocaleDateString  1/1/1970
toLocaleTimeString  00:00:00 AM

toUTCString         Thu, 01 Jan 1970 05:00:00 GMT
toISOString         1970-01-01T05:00:00.000Z
</pre></div>

<hr>
<div class="code"><pre class="code literal-block">**In Firefox**


toString            Thu Jan 01 1970 00:00:00 GMT-05:00 (Eastern Standard Time)
toDateString        Thu Jan 01 1970
toTimeString        00:00:00 GMT-0500 (Eastern Standard Time)
toLocaleString      Thursday, January 01, 1970 12:00:00 AM
toLocaleDateString  Thursday, January 01, 1970
toLocaleTimeString  12:00:00 AM

toUTCString         Thu, 01 Jan 1970 05:00:00 GMT
toISOString         1970-01-01T05:00:00.000Z
</pre></div>

<hr>
<p>I normally don't use the ISO format for string input. The only time that using
that format is beneficial to me is when dates need to be sorted as strings.
The ISO format is sortable as-is while the others are not. If you have to have
cross-browser compatibility, either specify the timezone or use a compatible
string format.</p>
<p>The code <code>new Date('12/4/2013').toString()</code> goes through the following
internal pseudo-transformation:</p>
<div class="code"><pre class="code literal-block"><span class="w">  </span><span class="ss">"12/4/2013"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">toUCT</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">storage</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">toLocal</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">print</span><span class="w"> </span><span class="ss">"12/4/2013"</span>
</pre></div>

<p>I hope this answer was helpful.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-generate-a-tsconfig-json-file/" class="u-url">How can I generate a tsconfig.json file?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-generate-a-tsconfig-json-file/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-04T00:44:47+08:00" itemprop="datePublished" title="2023-03-04 00:44">2023-03-04 00:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>How can I generate a <code>tsconfig.json</code> via the command line? I tried command
<code>tsc init</code>, but this doesn't work.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It is supported since the release of TypeScript 1.6.</p>
<p>The correct command is <code>--init</code> not <code>init</code>:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>tsc<span class="w"> </span>--init
</pre></div>

<p>Try to run in your console the following to check the version:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>tsc<span class="w"> </span>-v
</pre></div>

<p>If the version is older than 1.6 you will need to update:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>npm<span class="w"> </span>install<span class="w"> </span>-g<span class="w"> </span>typescript
</pre></div>

<p>Remember that you need to install node.js to use npm.</p>
<p><br></p>
<h3>Suggest</h3>
<p>For those who have TypeScript installed as a local package (and possibly as a
dev dependency) via:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>npm<span class="w"> </span>install<span class="w"> </span>typescript<span class="w"> </span>--save-dev
</pre></div>

<p>...and who have added <em>tsc</em> script to package.json:</p>
<div class="code"><pre class="code literal-block">"scripts": {
   ...
   "tsc": "tsc"
},
</pre></div>

<p>You can call <code>tsc --init</code> via <code>npm</code>:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>npm<span class="w"> </span>run<span class="w"> </span>tsc<span class="w"> </span>--<span class="w"> </span>--init
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2234.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2232.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
