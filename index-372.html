<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 372) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-372.html">
<link rel="prev" href="index-373.html" type="text/html">
<link rel="next" href="index-371.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-jiang-shu-zu-de-suo-you-cheng-yuan-chu-shi-hua-wei-xiang-tong-de-zhi/" class="u-url">如何将数组的所有成员初始化为相同的值？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-jiang-shu-zu-de-suo-you-cheng-yuan-chu-shi-hua-wei-xiang-tong-de-zhi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:14:59+08:00" itemprop="datePublished" title="2023-02-17 05:14">2023-02-17 05:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>我在C</strong> 中有一个大数组（如果有所不同，则不是 <strong>C++ ）。</strong> 我想初始化相同值的所有成员。</p>
<p>我可以发誓我曾经知道一个简单的方法来做到这一点。我可以<code>memset()</code>在我的案例中使用，但是没有一种方法可以直接内置到 C 语法中吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>除非该值为 0（在这种情况下，您可以省略初始化程序的某些部分，相应的元素将被初始化为 0），否则没有简单的方法。</p>
<p>不过，不要忽视显而易见的解决方案：</p>
<div class="code"><pre class="code literal-block">int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
</pre></div>

<p>具有缺失值的元素将被初始化为 0：</p>
<div class="code"><pre class="code literal-block">int myArray[10] = { 1, 2 }; // initialize to 1,2,0,0,0...
</pre></div>

<p>所以这会将所有元素初始化为 0：</p>
<div class="code"><pre class="code literal-block">int myArray[10] = { 0 }; // all elements 0
</pre></div>

<p>在 C++ 中，一个空的初始化列表也会将每个元素初始化为 0。在 C23 之前，C不允许这样做：</p>
<div class="code"><pre class="code literal-block">int myArray[10] = {}; // all elements 0 in C++ and C23
</pre></div>

<p>请记住，如果未指定初始化程序，具有静态存储持续时间的对象将初始化为 0：</p>
<div class="code"><pre class="code literal-block">static int myArray[10]; // all elements 0
</pre></div>

<p>而且“0”并不一定意味着“所有位为零”，因此使用上面的方法比 memset() 更好、更便携。（浮点值将被初始化为 +0，指向空值的指针等）</p>
<p><br></p>
<h3>更多建议</h3>
<p>如果您的编译器是 GCC，您可以使用以下“GNU 扩展”语法：</p>
<div class="code"><pre class="code literal-block">int array[1024] = {[0 ... 1023] = 5};
</pre></div>

<p>查看详细说明：http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Designated-Inits.html</p>
<p><br><br><a href="posts/how-to-initialize-all-members-of-an-array-to-the-same-value/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/zai-rest-api-shi-ji-chang-jing-zhong-shi-yong-put-yu-patch-fang-fa/" class="u-url">在 REST API 实际场景中使用 PUT 与 PATCH 方法</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/zai-rest-api-shi-ji-chang-jing-zhong-shi-yong-put-yu-patch-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:14:29+08:00" itemprop="datePublished" title="2023-02-17 05:14">2023-02-17 05:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>首先，一些定义：</p>
<p>PUT 在第 9.6 节 RFC 2616中定义：</p>
<blockquote>
<p>PUT 方法请求将封闭的实体存储在提供的 Request-URI 下。如果 Request-URI 引用一个已经存在的资源，那么封闭的实体
<strong>应该被认为是驻留在源服务器上的实体的修改版本</strong> 。如果请求 URI 不指向现有资源，并且该 URI
能够被请求用户代理定义为新资源，则源服务器可以使用该 URI 创建资源。</p>
</blockquote>
<p>PATCH 在RFC 5789中定义：</p>
<blockquote>
<p>PATCH 方法请求将请求实体中描述的 <strong>一组更改</strong> 应用于由 Request-URI 标识的资源。</p>
</blockquote>
<p>同样根据RFC 2616 第 9.1.2 节， PUT 是幂等的，而 PATCH 不是。</p>
<p>现在让我们来看一个真实的例子。<code>/users</code>当我对数据进行 POST<code>{username: 'skwee357', email:
'skwee357@domain.example'}</code>并且服务器能够创建资源时，它将以 201 和资源位置（假设<code>/users/1</code>）进行响应，并且对
GET 的任何下一次调用都<code>/users/1</code>将返回<code>{id: 1, username: 'skwee357', email:
'skwee357@domain.example'}</code>。</p>
<p>现在假设我想修改我的电子邮件。电子邮件修改被认为是“一组更改”，因此我应该<code>/users/1</code>使用“补丁文件”进行 PATCH。在我的例子中，它将是
JSON 文档：<code>{email: 'skwee357@newdomain.example'}</code>. 然后服务器返回
200（假设权限没问题）。这让我想到第一个问题：</p>
<ul>
<li>PATCH 不是幂等的。它在 RFC 2616 和 RFC 5789 中是这样说的。但是，如果我发出相同的 PATCH 请求（使用我的新电子邮件），我将获得相同的资源状态（我的电子邮件被修改为请求的值）。为什么 PATCH 不是幂等的？</li>
</ul>
<p>PATCH 是一个比较新的动词（RFC 于 2010 年 3 月引入），它来解决“修补”或修改一组字段的问题。在引入 PATCH 之前，大家都使用 PUT
来更新资源。但是引入PATCH之后，让我很困惑PUT是干什么用的。这让我想到了第二个（也是主要的）问题：</p>
<ul>
<li>PUT 和 PATCH 之间的真正区别是什么？我在某处读到 PUT 可能用于 <strong>替换</strong> 特定资源下的整个实体，因此应该发送完整的实体（而不是像 PATCH 那样的属性集）。这种情况的实际用途是什么？您什么时候想替换/覆盖特定资源 URI 上的实体，为什么不考虑更新/修补实体这样的操作？我看到的 PUT 的唯一实际用例是在集合上发出 PUT，即<code>/users</code>替换整个集合。在引入 PATCH 之后，在特定实体上发布 PUT 就没有意义了。我错了吗？</li>
</ul>
<p><br><br></p>
<h2>解答</h2>
<p><strong>注意</strong> ：当我第一次花时间阅读有关 REST 的内容时，幂等性是一个难以理解的概念。正如进一步的评论（和Jason Hoetger
的回答）所示，我在最初的回答中仍然没有完全正确。有一段时间，我一直拒绝广泛更新这个答案，以避免有效地剽窃
Jason，但我现在正在编辑它，因为，好吧，我被要求这样做（在评论中）。</p>
<p>阅读我的回答后，我建议您也阅读Jason Hoetger对这个问题的出色回答，我会尽量让我的回答更好，而不是简单地从 Jason 那里窃取。</p>
<h3>为什么 PUT 是幂等的？</h3>
<p>正如您在 RFC 2616 引文中指出的那样，PUT 被认为是幂等的。当您 PUT 资源时，这两个假设在起作用：</p>
<ol>
<li>
<p>您指的是一个实体，而不是一个集合。</p>
</li>
<li>
<p>您提供的实体是完整的（ <em>整个</em> 实体）。</p>
</li>
</ol>
<p>让我们看看你的一个例子。</p>
<div class="code"><pre class="code literal-block"><span class="err">{</span><span class="w"> </span><span class="ss">"username"</span><span class="err">:</span><span class="w"> </span><span class="ss">"skwee357"</span><span class="p">,</span><span class="w"> </span><span class="ss">"email"</span><span class="err">:</span><span class="w"> </span><span class="ss">"skwee357@domain.example"</span><span class="w"> </span><span class="err">}</span>
</pre></div>

<p>如果您<code>/users</code>按照您的建议将此文档发布到 ，那么您可能会取回一个实体，例如</p>
<div class="code"><pre class="code literal-block"><span class="err">##</span><span class="w"> </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="mi">1</span>

<span class="err">{</span>
<span class="w">    </span><span class="ss">"username"</span><span class="err">:</span><span class="w"> </span><span class="ss">"skwee357"</span><span class="p">,</span>
<span class="w">    </span><span class="ss">"email"</span><span class="err">:</span><span class="w"> </span><span class="ss">"skwee357@domain.example"</span>
<span class="err">}</span>
</pre></div>

<p>如果以后要修改此实体，请在 PUT 和 PATCH 之间进行选择。PUT 可能如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="err">PUT /users/1</span>
<span class="err">{</span>
<span class="err">    "username": "skwee357",</span>
<span class="err">    "email": "skwee357@gmail.com"       // new email address</span>
<span class="err">}</span>
</pre></div>

<p>您可以使用 PATCH 完成相同的操作。这可能看起来像这样：</p>
<div class="code"><pre class="code literal-block"><span class="err">PATCH /users/1</span>
<span class="err">{</span>
<span class="err">    "email": "skwee357@gmail.com"       // new email address</span>
<span class="err">}</span>
</pre></div>

<p>您会立即注意到这两者之间的区别。PUT 包含此用户的所有参数，但 PATCH 仅包含正在修改的参数 ( <code>email</code>)。</p>
<p>使用 PUT 时，假定您要发送完整的实体，并且该完整的实体 <em>会替换</em> 该 URI 上的任何现有实体。在上面的示例中，PUT 和 PATCH
实现了相同的目标：它们都更改了该用户的电子邮件地址。但是 PUT 通过替换整个实体来处理它，而 PATCH 只更新提供的字段，而其他字段不受影响。</p>
<p>由于 PUT 请求包括整个实体，如果您重复发出相同的请求，它应该总是有相同的结果（您发送的数据现在是实体的全部数据）。因此 PUT 是幂等的。</p>
<h3>使用 PUT 错误</h3>
<p>如果在 PUT 请求中使用上述 PATCH 数据会发生什么情况？</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /users/1</span>
<span class="err">{</span>
<span class="err">    "username": "skwee357",</span>
<span class="err">    "email": "skwee357@domain.example"</span>
<span class="err">}</span>
<span class="err">PUT /users/1</span>
<span class="err">{</span>
<span class="err">    "email": "skwee357@gmail.com"       // new email address</span>
<span class="err">}</span>

<span class="err">GET /users/1</span>
<span class="err">{</span>
<span class="err">    "email": "skwee357@gmail.com"      // new email address... and nothing else!</span>
<span class="err">}</span>
</pre></div>

<p>（出于这个问题的目的，我假设服务器没有任何特定的必填字段，并且会允许这种情况发生......实际上可能并非如此。）</p>
<p>因为我们使用了 PUT，但只提供了<code>email</code>，现在这是这个实体中唯一的东西。这导致数据丢失。</p>
<p>这个例子是为了说明目的——永远不要真正这样做（除非你的意图是删除省略的字段，当然......那么你正在使用 PUT，因为它应该被使用）。这个 PUT
请求在技术上是幂等的，但这并不意味着它不是一个糟糕的、失败的想法。</p>
<h3>PATCH如何做到幂等？</h3>
<p>在上面的例子中，PATCH <em>是</em> 幂等的。您进行了更改，但如果您一次又一次地进行相同的更改，它总是会返回相同的结果：您将电子邮件地址更改为新值。</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /users/1</span>
<span class="err">{</span>
<span class="err">    "username": "skwee357",</span>
<span class="err">    "email": "skwee357@domain.example"</span>
<span class="err">}</span>
<span class="err">PATCH /users/1</span>
<span class="err">{</span>
<span class="err">    "email": "skwee357@gmail.com"       // new email address</span>
<span class="err">}</span>

<span class="err">GET /users/1</span>
<span class="err">{</span>
<span class="err">    "username": "skwee357",</span>
<span class="err">    "email": "skwee357@gmail.com"       // email address was changed</span>
<span class="err">}</span>
<span class="err">PATCH /users/1</span>
<span class="err">{</span>
<span class="err">    "email": "skwee357@gmail.com"       // new email address... again</span>
<span class="err">}</span>

<span class="err">GET /users/1</span>
<span class="err">{</span>
<span class="err">    "username": "skwee357",</span>
<span class="err">    "email": "skwee357@gmail.com"       // nothing changed since last GET</span>
<span class="err">}</span>
</pre></div>

<h3>我原来的例子，为了准确性而修正</h3>
<p>我最初有我认为显示非幂等性的例子，但它们具有误导性/不正确。我将保留示例，但使用它们来说明不同的事情：针对同一实体的多个 PATCH
文档，修改不同的属性，不会使 PATCH 非幂等。</p>
<p>假设在过去的某个时间添加了一个用户。这是你开始的状态。</p>
<div class="code"><pre class="code literal-block"><span class="err">{</span>
<span class="w">  </span><span class="ss">"id"</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"name"</span><span class="err">:</span><span class="w"> </span><span class="ss">"Sam Kwee"</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"email"</span><span class="err">:</span><span class="w"> </span><span class="ss">"skwee357@olddomain.example"</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"address"</span><span class="err">:</span><span class="w"> </span><span class="ss">"123 Mockingbird Lane"</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"city"</span><span class="err">:</span><span class="w"> </span><span class="ss">"New York"</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"state"</span><span class="err">:</span><span class="w"> </span><span class="ss">"NY"</span><span class="p">,</span>
<span class="w">  </span><span class="ss">"zip"</span><span class="err">:</span><span class="w"> </span><span class="ss">"10001"</span>
<span class="err">}</span>
</pre></div>

<p>在 PATCH 之后，您有一个修改后的实体：</p>
<div class="code"><pre class="code literal-block"><span class="err">PATCH /users/1</span>
<span class="err">{"email": "skwee357@newdomain.example"}</span>

<span class="err">{</span>
<span class="err">  "id": 1,</span>
<span class="err">  "name": "Sam Kwee",</span>
<span class="err">  "email": "skwee357@newdomain.example",    // the email changed, yay!</span>
<span class="err">  "address": "123 Mockingbird Lane",</span>
<span class="err">  "city": "New York",</span>
<span class="err">  "state": "NY",</span>
<span class="err">  "zip": "10001"</span>
<span class="err">}</span>
</pre></div>

<p>如果您随后重复应用您的 PATCH，您将继续得到相同的结果：电子邮件已更改为新值。A 进去，A 出来，因此这是幂等的。</p>
<p>一个小时后，在你去泡咖啡休息一下之后，其他人带着他们自己的 PATCH 来了。看来邮局一直在做一些改变。</p>
<div class="code"><pre class="code literal-block"><span class="err">PATCH /users/1</span>
<span class="err">{"zip": "12345"}</span>

<span class="err">{</span>
<span class="err">  "id": 1,</span>
<span class="err">  "name": "Sam Kwee",</span>
<span class="err">  "email": "skwee357@newdomain.example",  // still the new email you set</span>
<span class="err">  "address": "123 Mockingbird Lane",</span>
<span class="err">  "city": "New York",</span>
<span class="err">  "state": "NY",</span>
<span class="err">  "zip": "12345"                      // and this change as well</span>
<span class="err">}</span>
</pre></div>

<p>由于这个来自邮局的 PATCH 本身不关心电子邮件，只关心邮政编码，如果重复应用，它也会得到相同的结果：邮政编码被设置为新值。A进去，A出来，所以这也是
<em>幂</em> 等的。</p>
<p>第二天，您决定再次发送 PATCH。</p>
<div class="code"><pre class="code literal-block"><span class="err">PATCH /users/1</span>
<span class="err">{"email": "skwee357@newdomain.example"}</span>

<span class="err">{</span>
<span class="err">  "id": 1,</span>
<span class="err">  "name": "Sam Kwee",</span>
<span class="err">  "email": "skwee357@newdomain.example",</span>
<span class="err">  "address": "123 Mockingbird Lane",</span>
<span class="err">  "city": "New York",</span>
<span class="err">  "state": "NY",</span>
<span class="err">  "zip": "12345"</span>
<span class="err">}</span>
</pre></div>

<p>您的补丁具有与昨天相同的效果：它设置了电子邮件地址。A 进去了，A 出来了，所以这也是幂等的。</p>
<h3>我在原来的答案中错了什么</h3>
<p>我想做出一个重要的区分（我在最初的回答中弄错了）。许多服务器将通过发回新的实体状态以及您的修改（如果有）来响应您的 REST 请求。因此，当您收到此
<em>回复时，它</em> <em>与您昨天收到的回复</em> 不同，因为邮政编码不是您上次收到的回复。但是，您的请求与邮政编码无关，只与电子邮件有关。所以你的 PATCH
文档仍然是幂等的——你在 PATCH 中发送的电子邮件现在是实体上的电子邮件地址。</p>
<h3>那么 PATCH 什么时候不是幂等的呢？</h3>
<p>为了完整地处理这个问题，我再次向您推荐Jason Hoetger 的回答，它已经完全回答了这个问题。</p>
<p><br></p>
<h3>更多建议</h3>
<p>尽管 Dan Lowe 的出色回答非常彻底地回答了 OP 关于 PUT 和 PATCH 之间的区别的问题，但它对为什么 PATCH
不是幂等的问题的回答并不完全正确。</p>
<p>为了说明为什么 PATCH 不是幂等的，它有助于从幂等的定义开始（来自维基百科）：</p>
<blockquote>
<p>术语幂等更广泛地用于描述如果执行一次或多次将产生相同结果的操作 [...] 幂等函数是具有属性 f(f(x)) = f(x) 的函数任意值 x。</p>
</blockquote>
<p>用更易于理解的语言，幂等 PATCH 可以定义为：在使用补丁文档对资源进行 PATCH 之后，所有使用相同补丁文档对同一资源的后续 PATCH
调用都不会更改该资源。</p>
<p>相反，非幂等操作是 f(f(x)) != f(x)，对于 PATCH 可以表示为：在使用补丁文档 PATCH 资源之后，后续 PATCH
调用相同的资源相同的补丁文件 <strong>确实</strong> 改变了资源。</p>
<p>为了说明非幂等 PATCH，假设有一个 /users 资源，并假设调用<code>GET /users</code>返回一个用户列表，当前：</p>
<div class="code"><pre class="code literal-block"><span class="o">[</span><span class="n">{ "id": 1, "username": "firstuser", "email": "firstuser@example.org" }</span><span class="o">]</span>
</pre></div>

<p>假设服务器允许 PATCHing /users，而不是像 OP 示例中那样 PATCHing /users/{id}。让我们发出这个 PATCH 请求：</p>
<div class="code"><pre class="code literal-block"><span class="err">PATCH /users</span>
<span class="err">[{ "op": "add", "username": "newuser", "email": "newuser@example.org" }]</span>
</pre></div>

<p>我们的补丁文件指示服务器添加一个名为<code>newuser</code>用户列表的新用户。第一次调用后，<code>GET /users</code>将返回：</p>
<div class="code"><pre class="code literal-block"><span class="o">[</span><span class="n">{ "id": 1, "username": "firstuser", "email": "firstuser@example.org" },</span>
<span class="n"> { "id": 2, "username": "newuser", "email": "newuser@example.org" }</span><span class="o">]</span>
</pre></div>

<p>现在，如果我们发出与上面 <em>完全相同的PATCH 请求，会发生什么？</em> （为了这个例子，我们假设 /users
资源允许重复的用户名。）“op”是“add”，所以一个新用户被添加到列表中，随后返回<code>GET /users</code>：</p>
<div class="code"><pre class="code literal-block"><span class="o">[</span><span class="n">{ "id": 1, "username": "firstuser", "email": "firstuser@example.org" },</span>
<span class="n"> { "id": 2, "username": "newuser", "email": "newuser@example.org" },</span>
<span class="n"> { "id": 3, "username": "newuser", "email": "newuser@example.org" }</span><span class="o">]</span>
</pre></div>

<p>/users 资源 <em>再次</em> 更改，即使我们针对 <em>完全相同的端点发布了</em> <em>完全相同的</em> PATCH 。如果我们的 PATCH 是 f(x)，则
f(f(x)) 与 f(x) 不同，因此， <strong>这个特定的 PATCH 不是幂等的</strong> 。 __ ****</p>
<p>尽管不能 <em>保证</em> PATCH是幂等的，但 PATCH 规范中没有任何内容可以阻止您在特定服务器上进行所有 PATCH 操作是幂等的。RFC 5789
甚至预见到了幂等 PATCH 请求的优势：</p>
<blockquote>
<p>PATCH 请求可以以幂等的方式发出，这也有助于防止在相似的时间范围内对同一资源的两个 PATCH 请求之间发生冲突而导致的不良结果。</p>
</blockquote>
<p>在 Dan 的示例中，他的 PATCH 操作实际上是幂等的。在那个例子中， /users/1 实体在我们的 PATCH 请求之间发生了变化，但不是 <em>因为</em>
我们的 PATCH 请求；实际上是邮局的 <em>不同</em> 补丁文档导致邮政编码发生变化。Post Office不同的PATCH是不同的操作；如果我们的 PATCH
是 f(x)，那么邮局的 PATCH 就是 g(x)。幂等性指出<code>f(f(f(x))) = f(x)</code>，但不保证<code>f(g(f(x)))</code>。</p>
<p><br><br><a href="posts/use-of-put-vs-patch-methods-in-rest-api-real-life-scenarios/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ke-yi-zai-qi-fan-wei-zhi-wai-fang-wen-ju-bu-bian-liang-de-nei-cun-ma/" class="u-url">可以在其范围之外访问局部变量的内存吗？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ke-yi-zai-qi-fan-wei-zhi-wai-fang-wen-ju-bu-bian-liang-de-nei-cun-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:14:00+08:00" itemprop="datePublished" title="2023-02-17 05:14">2023-02-17 05:14</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我有以下代码。</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kr">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>而且代码只是在运行，没有运行时异常！</p>
<p>输出是<code>58</code></p>
<p>怎么会这样？局部变量的内存不是在其函数之外不可访问吗？</p>
<p><br><br></p>
<h2>解答</h2>
<blockquote>
<p>怎么会这样？局部变量的内存不是在其函数之外不可访问吗？</p>
</blockquote>
<p>你租了一个旅馆房间。你把一本书放在床头柜最上面的抽屉里，然后去睡觉。您第二天早上退房，但“忘记”归还钥匙。你偷了钥匙！</p>
<p>一周后，你回到酒店，没有办理入住手续，拿着偷来的钥匙溜进你原来的房间，查看抽屉。你的书还在。惊人！</p>
<p><strong>怎么可能？ 如果你没有租房间，酒店房间抽屉里的东西是不是无法访问？</strong></p>
<p>好吧，显然这种情况可以在现实世界中发生，这没问题。当您不再被授权进入房间时，没有神秘的力量会导致您的书消失。也没有神秘的力量阻止你用偷来的钥匙进入房间。</p>
<p>酒店管理人员无需 <em>删除</em>
您的图书。您没有与他们签订合同，说如果您留下东西，他们会为您切碎。如果您使用偷来的钥匙非法重新进入您的房间以取回它，酒店保安人员不需要 <em>抓住</em>
您偷偷溜进来的情况。您没有与他们签订合同说“如果我试图偷偷溜回我的房间”房间待会儿，你必须阻止我。”
而是你和他们签了一份“我保证以后不偷偷溜回我房间”的契约， <em>你违约了</em> 。</p>
<p>在这种情况下 <strong>任何事情都有可能发生</strong>
。这本书可以在那里——你很幸运。别人的书可能在那里，而你的书可能在旅馆的炉子里。当你进来的时候，可能有人就在那里，把你的书撕成碎片。酒店本可以完全移除桌子和预订，并用衣柜取而代之。整个酒店可能即将被拆除，取而代之的是一个足球场，而你在偷偷摸摸的时候会在爆炸中丧生。</p>
<p>你不知道会发生什么；当你退房并偷了一把钥匙以后非法使用时，你就放弃了生活在一个可预测的、安全的世界中的权利，因为 <em>你</em> 选择了打破系统的规则。</p>
<p><strong>C++ 不是一种安全的语言</strong>
。它会愉快地允许你打破系统的规则。如果你试图做一些非法和愚蠢的事情，比如回到一个你无权进入的房间，并在一张可能不再存在的桌子上翻找，C++ 不会阻止你。比
C++ 更安全的语言通过限制您的权力来解决这个问题——例如，通过对密钥进行更严格的控制。</p>
<h3>更新</h3>
<p>天哪，这个答案引起了很多关注。（我不确定为什么——我认为这只是一个“有趣”的小类比，但无论如何。）</p>
<p>我认为用更多的技术思想来稍微更新一下可能是密切相关的。</p>
<p>编译器负责生成代码，该代码管理由该程序操作的数据的存储。有许多不同的方法可以生成代码来管理内存，但随着时间的推移，有两种基本技术已经根深蒂固。</p>
<p>第一个是拥有某种“长期存在”的存储区域，其中存储中每个字节的“生命周期”——即它与某个程序变量有效关联的时间段——不能轻易提前预测.
编译器生成对“堆管理器”的调用，它知道如何在需要时动态分配存储并在不再需要时回收它。</p>
<p>第二种方法是拥有一个“短期”存储区域，其中每个字节的生命周期都是众所周知的。在这里，生命周期遵循“嵌套”模式。这些短寿命变量中寿命最长的将在任何其他短寿命变量之前分配，并将最后释放。寿命较短的变量将在寿命最长的变量之后分配，并在它们之前被释放。这些寿命较短的变量的生命周期“嵌套”在寿命较长的变量的生命周期中。</p>
<p>局部变量遵循后一种模式；当进入一个方法时，它的局部变量就会活跃起来。当该方法调用另一个方法时，新方法的局部变量就会生效。它们会在第一个方法的局部变量死掉之前死掉。可以提前计算出与局部变量相关的存储生命周期开始和结束的相对顺序。</p>
<p>出于这个原因，局部变量通常生成为存储在“堆栈”数据结构上，因为堆栈具有这样的属性，即第一个压入它的东西将是最后一个弹出的东西。</p>
<p>就好比酒店决定只按顺序出租房间，等比你号高的人都退房了你才能退房。</p>
<p>因此，让我们考虑一下堆栈。在许多操作系统中，每个线程都有一个堆栈，并且堆栈被分配为某个固定大小。当你调用一个方法时，东西被压入堆栈。如果您随后将指向堆栈的指针传递回您的方法，就像原始海报在这里所做的那样，那只是指向某个完全有效的百万字节内存块中间的指针。在我们的类比中，您退房；当你这样做时，你只是检查了编号最高的房间。如果没有其他人在您之后登记入住，而您又非法返回您的房间，那么您的所有物品保证仍然
<em>在这家酒店</em> 。</p>
<p>我们将堆栈用于临时商店，因为它们真的很便宜也很容易。不需要 C++ 的实现来使用堆栈来存储局部变量；它可以使用堆。它不会，因为那会使程序变慢。</p>
<p>C++
的实现不需要让你留在堆栈上的垃圾保持原样，这样你以后就可以非法回来取它；编译器生成将您刚刚腾出的“房间”中的所有内容归零的代码是完全合法的。又不是因为那会很贵。</p>
<p>不需要 C++
的实现来确保当堆栈在逻辑上收缩时，曾经有效的地址仍然映射到内存中。允许该实现告诉操作系统“我们现在已经完成了使用此堆栈页面。除非我另有说明，否则如果有人触及先前有效的堆栈页面，则发出一个异常来破坏进程”。同样，实现实际上并没有这样做，因为它很慢而且没有必要。</p>
<p>相反，实现让你犯错并侥幸逃脱。大多数时候。直到有一天，真正可怕的事情出了问题，这个过程爆炸了。</p>
<p>这是有问题的。有很多规则，很容易不小心打破它们。我当然有很多次。更糟糕的是，问题通常只有在内存损坏发生数十亿纳秒后检测到损坏时才会出现，此时很难找出是谁搞砸了。</p>
<p>更多内存安全的语言通过限制你的权力来解决这个问题。在“普通”C#
中，根本无法获取本地地址并将其返回或存储以备后用。您可以获取本地地址，但语言设计巧妙，因此在本地生命周期结束后无法使用它。为了获取本地地址并将其传回，您必须将编译器置于特殊的“不安全”模式，
<em>并</em> 在您的程序中添加“不安全”一词，以提醒您注意您可能正在做的事实可能违反规则的危险事物。</p>
<p>进一步阅读：</p>
<ul>
<li>如果 C# 确实允许返回引用怎么办？巧合的是，这是今天博客文章的主题：</li>
</ul>
<p><em>Ref 返回和 ref 局部变量</em></p>
<ul>
<li>为什么要用栈来管理内存？C# 中的值类型是否始终存储在堆栈中？虚拟内存是如何工作的？以及有关 C# 内存管理器工作原理的更多主题。其中许多文章也与 C++ 程序员密切相关：</li>
</ul>
<p><em>内存管理</em></p>
<p><br></p>
<h3>更多建议</h3>
<p>您只是简单地读取和写入 <em>曾经</em> 是 的地址的内存<code>a</code>。现在您在
之外<code>foo</code>，它只是指向某个随机内存区域的指针。碰巧在您的示例中，该内存区域确实存在并且目前没有其他人在使用它。</p>
<p>继续使用它不会破坏任何东西，而且还没有其他东西覆盖它。因此，<code>5</code>仍然存在。在真实的程序中，该内存几乎会立即被重用，这样做会破坏某些东西（尽管症状可能要到很久以后才会出现！）。</p>
<p>当您从
返回时<code>foo</code>，您告诉操作系统您不再使用该内存并且可以将其重新分配给其他内存。如果你很幸运并且它永远不会被重新分配，并且操作系统没有发现你再次使用它，那么你就可以摆脱谎言。尽管您最终可能会覆盖以该地址结尾的任何其他内容。</p>
<p>现在如果你想知道为什么编译器不报错，那可能是因为<code>foo</code>被优化淘汰了。它通常会警告你这种事情。<code>a</code>C
假定您知道自己在做什么，并且从技术上讲，您在这里没有违反范围（在 之外没有对自身的引用<code>foo</code>），只有内存访问规则，它只会触发警告而不是错误。</p>
<p>简而言之：这通常不会奏效，但有时会偶然发生。</p>
<p><br><br><a href="posts/can-a-local-variable-s-memory-be-accessed-outside-its-scope/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-373.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-371.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
