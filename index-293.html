<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 293) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-293.html">
<link rel="prev" href="index-294.html" type="text/html">
<link rel="next" href="index-292.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-python-zhong-jin-xing-huan-xing-xu-xing/" class="u-url">如何在 Python 中进行换行（续行）？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-python-zhong-jin-xing-huan-xing-xu-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:53+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>鉴于：</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' + 'c' + 'd'
</pre></div>

<p>我如何将上面的内容写成两行？</p>
<div class="code"><pre class="code literal-block">e = 'a' + 'b' +
    'c' + 'd'
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>什么是线？你可以在下一行有参数没有任何问题：</p>
<div class="code"><pre class="code literal-block">a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, 
            blahblah6, blahblah7)
</pre></div>

<p>否则你可以这样做：</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span>
<span class="w">    </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span><span class="ss">)</span>:
</pre></div>

<p>或者使用显式换行符：</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">True</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span>\
<span class="w">   </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">False</span>:
</pre></div>

<p>查看样式指南以获取更多信息。</p>
<p>使用括号，您的示例可以写成多行：</p>
<div class="code"><pre class="code literal-block">a = ('1' + '2' + '3' +
    '4' + '5')
</pre></div>

<p>使用显式换行可以获得相同的效果：</p>
<div class="code"><pre class="code literal-block">a = '1' + '2' + '3' + \
    '4' + '5'
</pre></div>

<p>请注意，样式指南说最好使用带括号的隐式延续，但在这种特殊情况下，仅在表达式周围添加括号可能是错误的方法。</p>
<p><br></p>
<h3>更多建议</h3>
<p>来自 <em>PEP 8——Python 代码风格指南</em> ：</p>
<blockquote>
<p><strong>包装长行的首选方法是在圆括号、方括号和大括号内使用 Python 的隐含行延续。</strong>
通过将表达式括在括号中，可以将长行分成多行。应该优先使用这些而不是使用反斜杠来续行。</p>
<p>反斜杠有时可能仍然适用。例如，长的、多个 with 语句不能使用隐式延续，所以反斜杠是可以接受的：</p>
<div class="code"><pre class="code literal-block">with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
     file_2.write(file_1.read())
</pre></div>

<p>另一个这样的例子是 assert 语句。</p>
<p>确保适当地缩进续行。绕过二元运算符的首选位置是在运算符 <strong>之后，而不是在它之前。</strong> 一些例子：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Rectangle</span>(<span class="nb">Blob</span>):

  <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                <span class="n">color</span>=<span class="s">'black'</span>, <span class="n">emphasis</span>=<span class="n">None</span>, <span class="n">highlight</span>=<span class="mi">0</span>):
       <span class="k">if</span> (<span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span>
          <span class="n">color</span> == <span class="s">'red'</span> <span class="o">and</span> <span class="n">emphasis</span> == <span class="s">'strong'</span> <span class="o">or</span>
           <span class="n">highlight</span> &gt; <span class="mi">100</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"sorry, you lose"</span>)
       <span class="k">if</span> <span class="n">width</span> == <span class="mi">0</span> <span class="o">and</span> <span class="n">height</span> == <span class="mi">0</span> <span class="o">and</span> (<span class="n">color</span> == <span class="s">'red'</span> <span class="o">or</span>
                                          <span class="n">emphasis</span> <span class="k">is</span> <span class="n">None</span>):
           <span class="n">raise</span> <span class="n">ValueError</span>(<span class="s">"I don't think so -- values are %s, %s"</span> %
                            (<span class="n">width</span>, <span class="n">height</span>))
       <span class="nb">Blob</span>.<span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">width</span>, <span class="n">height</span>,
                     <span class="n">color</span>, <span class="n">emphasis</span>,
</pre></div>

<p>highlight)file_2.write(file_1.read())
</p>
</blockquote>
<p>PEP8 现在推荐数学家及其出版商使用的 <em>相反约定</em> （用于打破二进制运算）以提高可读性。</p>
<p>Donald Knuth 的 breaking <strong>before</strong> a binary operator
垂直对齐运算符的风格，从而减少了眼睛在确定添加和减去哪些项目时的工作量。</p>
<p>来自PEP8： <em>应该在二元运算符之前还是之后换行？</em> :</p>
<blockquote>
<p>Donald Knuth
在他的计算机和排版系列中解释了传统规则：“虽然段落中的公式总是在二元运算和关系之后中断，但显示的公式总是在二元运算之前中断”[3]。</p>
<p>遵循数学传统通常会产生更具可读性的代码：</p>
<div class="code"><pre class="code literal-block"># Yes: easy to match operators with operands
</pre></div>

</blockquote>
<div class="code"><pre class="code literal-block">income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</pre></div>

<blockquote>
<p>在 Python 代码中，允许在二元运算符之前或之后中断，只要约定在本地保持一致即可。对于新代码，建议使用 Knuth 的风格。</p>
</blockquote>
<p>[3]：Donald Knuth 的 The TeXBook，第 195 和 196 页</p>
<p><br><br><a href="posts/how-can-i-do-a-line-break-line-continuation-in-python/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-bi-xu-zai-na-li-yi-ji-wei-shi-yao-bi-xu-fang-zhi-mo-ban-he-lei-xing-ming-cheng-guan-jian-zi/" class="u-url">我必须在哪里以及为什么必须放置“模板”和“类型名称”关键字？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-bi-xu-zai-na-li-yi-ji-wei-shi-yao-bi-xu-fang-zhi-mo-ban-he-lei-xing-ming-cheng-guan-jian-zi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:27+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在模板中，我必须在哪里以及为什么必须放置<code>typename</code>依赖<code>template</code>名称？<br>
到底什么是相关名称？</p>
<p>我有以下代码：</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="nt">will</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="nt">too</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="n">Q</span><span class="p">:</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="kc">to</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">typename</span><span class="o">/</span><span class="n">template</span><span class="w"> </span><span class="n">here</span><span class="o">?</span>
<span class="w">        </span><span class="n">typedef</span><span class="w"> </span><span class="n">Tail</span><span class="o">::</span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
<span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">For</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">last</span><span class="w"> </span><span class="nt">node</span><span class="w"> </span><span class="nt">Tn</span><span class="o">.</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">char</span><span class="w"> </span><span class="err">fail</span><span class="cp">[</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">sizeof</span><span class="p">(</span><span class="nx">U</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Cannot</span><span class="w"> </span><span class="err">be</span><span class="w"> </span><span class="err">instantiated</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">any</span><span class="w"> </span><span class="err">U</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">template</span><span class="o">&lt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">struct</span><span class="w"> </span><span class="nt">inUnion</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>我遇到的问题是在线<code>typedef Tail::inUnion&lt;U&gt; dummy</code>。我相当确定这<code>inUnion</code>是一个从属名称，而 VC++
完全正确地扼杀了它。<br>
我也知道我应该能够<code>template</code>在某处添加以告诉编译器 inUnion 是一个模板 ID。但具体在哪里？然后它是否应该假设 inUnion
是一个类模板，即<code>inUnion&lt;U&gt;</code>命名一个类型而不是一个函数？</p>
<p><br><br></p>
<h2>解答</h2>
<p>（也可以在这里查看我的 C++11 答案）</p>
<p>为了解析 C++ 程序，编译器需要知道某些名称是否是类型。以下示例表明：</p>
<div class="code"><pre class="code literal-block">t * f;
</pre></div>

<p>这应该如何解析？对于许多语言，编译器不需要知道名称的含义来解析并基本上知道一行代码的作用。然而，在 C++
中，上述内容会根据其<code>t</code>含义产生截然不同的解释。如果它是一个类型，那么它将是一个指针的声明<code>f</code>。但是，如果它不是类型，它将是乘法。所以 C++ 标准在第
(3/7) 段说：</p>
<blockquote>
<p>一些名称表示类型或模板。通常，无论何时遇到一个名称，在继续解析包含它的程序之前，有必要确定该名称是否表示这些实体之一。确定这一点的过程称为名称查找。</p>
</blockquote>
<p>如果引用模板类型参数，编译器将如何找出名称<code>t::x</code>所指的内容？可以是可以相乘的静态 int 数据成员，或者同样可以是可以屈服于声明的嵌套类或
typedef。 <strong>如果名称具有此属性 - 在知道实际模板参数之前无法查找它 - 那么它称为</strong> <strong> <em>依赖名称</em></strong>
<strong>（它“依赖于”模板参数）。</strong><code>t``x</code> <strong> __</strong></p>
<p>您可能建议等到用户实例化模板：</p>
<blockquote>
<p><em>等到用户实例化模板，稍后再找出真正的含义<code>t::x * f;</code>。</em></p>
</blockquote>
<p>这将起作用并且实际上被标准允许作为一种可能的实现方法。这些编译器基本上将模板的文本复制到内部缓冲区中，只有在需要实例化时，它们才会解析模板并可能检测定义中的错误。但是，其他实现并没有因为模板作者所犯的错误而困扰模板的用户（可怜的同事！），而是选择尽早检查模板并尽快在定义中给出错误，甚至在实例化发生之前。</p>
<p>因此必须有一种方法可以告诉编译器某些名称是类型而某些名称不是。</p>
<h3>“类型名”关键字</h3>
<p>答案是： <em>我们</em>
决定编译器应该如何解析它。如果<code>t::x</code>是依赖名称，那么我们需要在它前面加上前缀，<code>typename</code>以告诉编译器以某种方式解析它。该标准在
(14.6/2) 中说：</p>
<blockquote>
<p>在模板声明或定义中使用并依赖于模板参数的名称被假定为不命名类型，除非适用的名称查找找到类型名称或名称由关键字 typename 限定。</p>
</blockquote>
<p>有许多名称<code>typename</code>不是必需的，因为编译器可以通过在模板定义中查找适用的名称来确定如何解析构造本身——例如，<code>T
*f;</code>when<code>T</code>是类型模板参数。但要<code>t::x * f;</code>成为声明，它必须写成<code>typename t::x *f;</code>.
如果省略关键字并且名称被认为是非类型，但是当实例化发现它表示类型时，编译器会发出通常的错误消息。有时，错误会在定义时给出：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// t::x is taken as non-type, but as an expression the following misses an</span>
<span class="c1">// operator between the two names or a semicolon separating them.</span>
<span class="n">t</span><span class="p">::</span><span class="n">x</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
</pre></div>

<p>_该语法<code>typename</code>仅允许在限定名称之前_使用 - 因此，如果非限定名称这样做，则它们总是被认为是指代类型，这是理所当然的。</p>
<p>正如介绍性文本所暗示的那样，表示模板的名称也存在类似的陷阱。</p>
<h3>“模板”关键字</h3>
<p>还记得上面的初始引用以及标准如何要求对模板进行特殊处理吗？让我们来看下面这个看似无辜的例子：</p>
<div class="code"><pre class="code literal-block"><span class="nt">boost</span><span class="p">::</span><span class="nd">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nt">int</span><span class="o">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">f</span><span class="o">;</span>
</pre></div>

<p>对于人类读者来说，这可能看起来很明显。编译器不是这样。<code>boost::function</code>想象一下and的以下任意定义<code>f</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nt">namespace</span><span class="w"> </span><span class="nt">boost</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">function</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">main</span><span class="o">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="err">int</span><span class="w"> </span><span class="err">f</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">boost</span><span class="p">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="w"> </span><span class="nf">int</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>这实际上是一个有效的 <em>表达</em> ！它使用小于运算符<code>boost::function</code>与零 ( <code>int()</code>)
进行比较，然后使用大于运算符将结果<code>bool</code>与进行比较<code>f</code>。然而你可能很清楚，<code>boost::function</code> 在现实生活中是一个模板，所以编译器知道
(14.2/3)：</p>
<blockquote>
<p>在名称查找 (3.4) 发现名称是模板名称后，如果此名称后跟 &lt;，则 &lt; 始终被视为模板参数列表的开头，而永远不会作为名称后跟较少的名称比运算符。</p>
</blockquote>
<p>现在我们又回到了与<code>typename</code>.
如果我们在解析代码时还不能知道名称是否是模板怎么办？我们需要<code>template</code>在模板名称之前立即插入，如<code>14.2/4</code>. 这看起来像：</p>
<div class="code"><pre class="code literal-block"><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">f</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">call</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">template</span>
</pre></div>

<p>模板名称不仅可以出现在 a 之后<code>::</code>，还可以出现在 a 之后<code>-&gt;</code>或<code>.</code>类成员访问中。您也需要在那里插入关键字：</p>
<div class="code"><pre class="code literal-block"><span class="n">this</span><span class="o">-&gt;</span><span class="n">template</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// call a function template</span>
</pre></div>

<hr>
<h3>依赖关系</h3>
<p>对于那些书架上放着厚厚的标准书并且想知道我到底在说什么的人，我将稍微谈谈标准中是如何规定的。</p>
<p>在模板声明中，一些构造具有不同的含义，具体取决于您用于实例化模板的模板参数：表达式可能具有不同的类型或值，变量可能具有不同的类型，或者函数调用可能最终调用不同的函数。这种构造通常被认为
<em>依赖</em> 于模板参数。</p>
<p>该标准通过构造是否依赖来精确定义规则。它将它们分成逻辑上不同的组：一个捕获类型，另一个捕获表达式。表达式可能取决于它们的值和/或它们的类型。所以我们有，附加了典型的例子：</p>
<ul>
<li>依赖类型（例如：类型模板参数<code>T</code>）</li>
<li>依赖于值的表达式（例如：非类型模板参数<code>N</code>）</li>
<li>类型相关的表达式（例如：转换为类型模板参数<code>(T)0</code>）</li>
</ul>
<p>大多数规则都是直观的，并且是递归构建的：例如，构造为的类型<code>T[N]</code>是依赖类型，如果<code>N</code>是值依赖表达式或是<code>T</code>依赖类型。<code>(14.6.2/1</code>关于依赖类型、<code>(14.6.2.2)</code>类型依赖表达式和<code>(14.6.2.3)</code>值依赖表达式的详细信息，请参阅
) 部分。</p>
<h4>相关名称</h4>
<p>标准对于什么 <em>是</em> 依赖 <em>名称</em> 有点不清楚。在简单的阅读中（你知道，最小惊喜原则），它定义为 <em>依赖名称</em>
的所有内容都是下面函数名称的特例。但是由于显然<code>T::x</code>还需要在实例化上下文中查找，因此它也需要是一个从属名称（幸运的是，从 C++14
中期开始，委员会已经开始研究如何解决这个令人困惑的定义）。</p>
<p>为了避免这个问题，我求助于对标准文本的简单解释。在表示依赖类型或表达式的所有构造中，它们的一个子集表示名称。因此，这些名称是“从属名称”。名称可以采用不同的形式——标准说：</p>
<blockquote>
<p>名称是标识符 (2.11)、运算符函数 ID (13.5)、转换函数 ID (12.3.2) 或模板 ID (14.2)
的使用，表示实体或标签（6.6.4， 6.1)</p>
</blockquote>
<p>标识符只是一个简单的字符/数字序列，而接下来的两个是<code>operator +</code>和<code>operator type</code>形式。最后一种形式是<code>template-name
&lt;argument list&gt;</code>. 所有这些都是名称，按照标准中的常规使用，名称还可以包含限定符，说明应在哪个名称空间或类中查找名称。</p>
<p>值依赖表达式<code>1 + N</code>不是名称，而是<code>N</code>名称。所有作为名称的依赖构造的子集称为 <em>依赖名称</em>
。然而，函数名称在模板的不同实例化中可能具有不同的含义，但不幸的是并没有被这个一般规则所捕获。</p>
<h4>依赖函数名称</h4>
<p>不是本文的主要关注点，但仍值得一提：函数名称是一个单独处理的异常。标识符函数名称不依赖于自身，而是依赖于调用中使用的类型相关参数表达式。在示例中<code>f((T)0)</code>，<code>f</code>是从属名称。在标准中，这在
处指定<code>(14.6.2/1)</code>。</p>
<h3>附加说明和示例</h3>
<p>在足够多的情况下，我们同时需要<code>typename</code>和<code>template</code>。您的代码应如下所示</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">Tail</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">UnionNode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">public</span><span class="w"> </span><span class="nt">Tail</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">template&lt;typename</span><span class="w"> </span><span class="err">U&gt;</span><span class="w"> </span><span class="err">struct</span><span class="w"> </span><span class="err">inUnion</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">typedef</span><span class="w"> </span><span class="err">typename</span><span class="w"> </span><span class="n">Tail</span><span class="p">:</span><span class="o">:</span><span class="n">template</span><span class="w"> </span><span class="n">inUnion</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="o">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>关键字<code>template</code>不必总是出现在名称的最后部分。它可以出现在用作范围的类名之前的中间，如下例所示</p>
<div class="code"><pre class="code literal-block"><span class="nt">typename</span><span class="w"> </span><span class="nt">t</span><span class="p">::</span><span class="nd">template</span><span class="w"> </span><span class="nt">iterator</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">value_type</span><span class="w"> </span><span class="nt">v</span><span class="o">;</span>
</pre></div>

<p>在某些情况下，禁止使用关键字，详见下文</p>
<ul>
<li>
<p>不允许在依赖基类的名称上写<code>typename</code>. 假定给定的名称是类类型名称。对于基类列表和构造函数初始化列表中的名称都是如此：</p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : /<em> typename </em>/ SomeBase<t>::type 
 { };</t></p>
</li>
<li>
<p>在 using 声明中，不可能<code>template</code>在 last 之后使用<code>::</code>，并且 C++ 委员会表示不致力于解决方案。</p>
<div class="code"><pre class="code literal-block"> template &lt;typename T&gt;
</pre></div>

<p>struct derive_from_Has_type : SomeBase<t> {
    using SomeBase<t>::template type; // error
    using typename SomeBase<t>::type; // typename <em>is</em> allowed
 };</t></t></t></p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<h3>C++11</h3>
<h4>问题</h4>
<p><code>typename</code>虽然 C++03 中关于何时需要的规则<code>template</code>在很大程度上是合理的，但它的表述有一个恼人的缺点</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typedef</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">result_type</span><span class="p">;</span>

<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// error, "this" is dependent, "template" keyword needed</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">g</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// error, "A&lt;T&gt;" is dependent, "typename" keyword needed</span>
<span class="w">    </span><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="n">result_type</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>

<p>可以看出，即使编译器可以完美地确定自己只能是<code>A::result_type</code>（<code>int</code>因此是一种类型），并且<code>this-&gt;g</code>只能是<code>g</code>稍后声明的成员模板（即使<code>A</code>在某处明确专门化，那也会不会影响该模板中的代码，因此它的含义不会受到以后<code>A</code>!)
的专业化的影响。</p>
<h4>当前实例化</h4>
<p>为了改善这种情况，在 C++11 中，当类型引用封闭模板时，语言会进行跟踪。要知道，类型必须是通过使用某种形式的名称形成的，这是它自己的名称（在上面， ,
<code>A</code>, <code>A&lt;T&gt;</code>）<code>::A&lt;T&gt;</code>。已知由此类名称引用的类型是 <em>当前实例化</em>
。<code>A::NestedClass</code>如果形成名称的类型是成员/嵌套类（那么，都是当前实例化） ，则可能有多个类型都是<code>A</code>当前实例化。</p>
<p>基于这个概念，
<strong>如果</strong><code>CurrentInstantiation::Foo</code>发现,<code>Foo</code>和<code>CurrentInstantiationTyped-&gt;Foo</code>(例如<code>A
*a = this; a-&gt;Foo</code>) 是 <em>当前实例化</em> 类或其非依赖基类之一的类的成员（只需执行立即查找名称）。 ****</p>
<p>如果限定符是当前实例化的成员，则现在不再需要关键字和<code>typename</code>。<code>template</code>这里要记住的一个关键点是，它
<em>仍然</em><code>A&lt;T&gt;</code>是一个类型相关的名称（毕竟也是类型相关的）。但已知是一种类型——编译器将“神奇地”查看这种依赖类型来解决这个问题。
__<code>T``A&lt;T&gt;::result_type</code></p>
<div class="code"><pre class="code literal-block"><span class="nt">struct</span><span class="w"> </span><span class="nt">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">typedef</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">result_type</span><span class="p">;</span>
<span class="p">}</span><span class="o">;</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">C</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">could</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">specialized</span><span class="o">!</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nt">B</span><span class="o">,</span><span class="w"> </span><span class="nt">C</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">void</span><span class="w"> </span><span class="err">f()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK,</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation!</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="n">A</span><span class="p">:</span><span class="o">:</span><span class="n">result_type</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">dependent</span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="n">D</span><span class="o">::</span><span class="n">result_type</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">error,</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r2</span><span class="p">;</span>

<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">OK</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">now</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">relying</span><span class="w"> </span><span class="err">on</span><span class="w"> </span><span class="err">C&lt;T&gt;</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">provide</span><span class="w"> </span><span class="err">it</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">But</span><span class="w"> </span><span class="err">not</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">member</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">current</span><span class="w"> </span><span class="err">instantiation</span>
<span class="w">    </span><span class="err">typename</span><span class="w"> </span><span class="n">D</span><span class="p">:</span><span class="o">:</span><span class="n">questionable_type</span><span class="w"> </span><span class="n">r3</span><span class="p">;</span><span class="w">        </span>
<span class="w">  </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>这令人印象深刻，但我们可以做得更好吗？该语言甚至更进一步，
<em>要求</em><code>D::result_type</code>实现在实例化时再次查找<code>D::f</code>（即使它已经在定义时找到了它的含义）。如果现在查找结果不同或导致歧义，则程序格式错误，必须给出诊断。想象一下如果我们<code>C</code>这样定义会发生什么</p>
<div class="code"><pre class="code literal-block">template&lt;&gt;
struct C&lt;int&gt; {
  typedef bool result_type;
  typedef int questionable_type;
};
</pre></div>

<p>编译器需要在实例化时捕获错误<code>D&lt;int&gt;::f</code>。因此，您可以获得两个世界中最好的：“延迟”查找保护您，如果您可能遇到依赖基类的麻烦，以及“立即”查找，使您免于<code>typename</code>和<code>template</code>.</p>
<h4>未知专业</h4>
<p>在 的代码中<code>D</code>，名称<code>typename D::questionable_type</code>不是当前实例化的成员。相反，该语言将其标记为 <em>未知专业化的成员</em>
。特别是，当您正在执行<code>DependentTypeName::Foo</code>or<code>DependentTypedName-&gt;Foo</code>并且依赖类型不是 <em>当前</em>
实例化（在这种情况下编译器可以放弃并说“我们稍后再看是什么<code>Foo</code>”）或者它 <em>是</em> 当前实例化和在它或其非依赖基类中找不到名称，并且还有依赖基类。</p>
<p><code>h</code>想象一下如果我们在上面定义的<code>A</code>类模板中有一个成员函数会发生什么</p>
<div class="code"><pre class="code literal-block">void h() {
  typename A&lt;T&gt;::questionable_type x;
}
</pre></div>

<p>在 C++03 中，该语言允许捕获此错误，因为永远不可能有有效的实例化方法<code>A&lt;T&gt;::h</code>（无论您向 提供什么参数<code>T</code>）。在 C++11
中，该语言现在有进一步的检查，以便为编译器提供更多理由来实现此规则。由于<code>A</code>没有依赖基类，并且<code>A</code>没有声明成员<code>questionable_type</code>，因此该名称
<em>既不</em><code>A&lt;T&gt;::questionable_type</code>是当前实例化的成员 <em>，也不是</em> __ __未知专业的成员。
在那种情况下，该代码不可能在实例化时有效编译，因此语言禁止限定符是当前实例化的名称既不是未知特化的成员也不是当前实例化的成员（但是,
这种违规仍然不需要诊断）。</p>
<h4>例子和琐事</h4>
<p>您可以在这个答案上尝试这些知识，看看上面的定义在现实世界的例子中是否对您有意义（在那个答案中重复它们的细节略有减少）。</p>
<p>C++11 规则使以下有效的 C++03 代码格式错误（这不是 C++ 委员会的意图，但可能不会修复）</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>
<span class="n">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kr">virtual</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">void</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">  </span><span class="n">C</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">g</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>这个有效的 C++03 代码将在实例化时绑定<code>this-&gt;f</code>到<code>A::f</code>，一切都很好。然而，C++11
立即将其绑定到<code>B::f</code>并在实例化时需要仔细检查，检查查找是否仍然匹配。但是，在实例化时<code>C&lt;A&gt;::g</code>，将应用支配规则，查找将<code>A::f</code>改为查找。</p>
<p><br><br><a href="posts/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/d-xiao-lu-di-yu-0-9/" class="u-url">\d 效率低于 [0-9]</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/d-xiao-lu-di-yu-0-9/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:16:00+08:00" itemprop="datePublished" title="2023-02-17 03:16">2023-02-17 03:16</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>[0123456789]</code>我昨天对有人在正则表​​达式中使用而不是<code>[0-9]</code>or的答案发表了评论<code>\d</code>。我说过使用范围或数字说明符可能比使用字符集更有效。</p>
<p>我决定今天对此进行测试，令我惊讶的是（至少在 c# regex 引擎中）<code>\d</code>似乎比其他两个似乎差别不大的效率低。这是我对 10000 个随机字符串的
1000 个随机字符串的测试输出，其中 5077 个实际包含一个数字：</p>
<div class="code"><pre class="code literal-block">Regex \d           took 00:00:00.2141226 result: 5077/10000
Regex [0-9]        took 00:00:00.1357972 result: 5077/10000  63.42 % of first
Regex [0123456789] took 00:00:00.1388997 result: 5077/10000  64.87 % of first
</pre></div>

<p>出于两个原因，这让我感到惊讶，如果有人能阐明一些问题，我会很感兴趣：</p>
<ol>
<li>我原以为范围会比集合更有效地实施。</li>
<li>我不明白为什么<code>\d</code>比<code>[0-9]</code>. <code>\d</code>除了简写之外还有更多吗<code>[0-9]</code>？</li>
</ol>
<p>这是测试代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Linq</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Diagnostics</span><span class="p">;</span>
<span class="n">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">RegularExpressions</span><span class="p">;</span>

<span class="n">namespace</span><span class="w"> </span><span class="n">SO_RegexPerformance</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="n">Program</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Random</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">            </span><span class="c1">//10K random strings</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">//generate random string</span>
<span class="w">                </span><span class="n">var</span><span class="w"> </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">();</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//add a-z randomly</span>
<span class="w">                    </span><span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">((</span><span class="kt">char</span><span class="p">)(</span><span class="sc">'a'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">26</span><span class="p">)));</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="c1">//in roughly 50% of them, put a digit</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">//replace 1 char with a digit 0-9</span>
<span class="w">                    </span><span class="n">sb</span><span class="p">[</span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">Length</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="sc">'0'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">strings</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">baseTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">@"\d"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">();</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">testTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">"[0-9]"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"  {0:P2} of first"</span><span class="p">,</span><span class="w"> </span><span class="n">testTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">baseTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="p">);</span>
<span class="w">            </span><span class="n">testTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="s">"[0123456789]"</span><span class="p">);</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"  {0:P2} of first"</span><span class="p">,</span><span class="w"> </span><span class="n">testTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">baseTime</span><span class="p">.</span><span class="n">TotalMilliseconds</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">TimeSpan</span><span class="w"> </span><span class="n">testPerfomance</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strings</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">regex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">sw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Stopwatch</span><span class="p">();</span>

<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">successes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">rex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Regex</span><span class="p">(</span><span class="n">regex</span><span class="p">);</span>

<span class="w">            </span><span class="n">sw</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">            </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rex</span><span class="p">.</span><span class="n">Match</span><span class="p">(</span><span class="n">str</span><span class="p">).</span><span class="n">Success</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">successes</span><span class="o">++</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">sw</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>

<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">"Regex {0,-12} took {1} result: {2}/{3}"</span><span class="p">,</span><span class="w"> </span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">,</span><span class="w"> </span><span class="n">successes</span><span class="p">,</span><span class="w"> </span><span class="n">strings</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p><code>\d</code>检查所有 Unicode 数字，但<code>[0-9]</code>仅限于这 10 个字符。例如，波斯数字 ,是与 匹配但不与<code>۱۲۳۴۵۶۷۸۹</code>匹配的
Unicode 数字的示例。<code>\d``[0-9]</code></p>
<p>您可以使用以下代码生成所有此类字符的列表：</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">UInt16</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="kt">UInt16</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Convert</span><span class="p">.</span><span class="n">ToChar</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Regex</span><span class="p">.</span><span class="n">IsMatch</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="s">@"\d"</span><span class="p">))</span>
<span class="w">        </span><span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</pre></div>

<p>其中产生：</p>
<blockquote>
<p>0123456789 ٠١٢٣٤٥٦٧٨٩۰۱۲۳۴۵۶۷۸۹߀߁߂߃߄߅߆߇߈߉०१२३४५६७८
९୦୧୨୩୪୫୬୭୮୯᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙᥆᥇᥈᥉᥊᥋᥌᥍᥎᥏᧑᧒᧓᧔᧕᧖᧗᧘᧙᧑᧒᧓᧔᧕᧖᧗᧘᧙᭐᭑᭒᭓᭔᭕᭖᭗᭘᭙᮰᮱᮲᮳᮴᮵᮶᮷᮸᮹᱀᱁᱂᱃᱄᱅᱆᱇᱈᱉᱐᱑᱒᱓᱔᱕᱖᱗᱘᱙꘠꘡꘢꘣꘤꘥꘦꘧꘨꘩꣐꣑꣒꣓꣔꣕꣖꣗꣘꣙꤀꤁꤂꤃꤄꤅꤆꤇꤈꤉꩐꩑꩒꩓꩔꩕꩖꩗꩘꩙０１２３４５６７８９</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p>感谢 ByteBlast 在文档中注意到这一点。只需更改正则表达式构造函数：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">rex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Regex</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span><span class="w"> </span><span class="n">RegexOptions</span><span class="o">.</span><span class="n">ECMAScript</span><span class="p">);</span>
</pre></div>

<p>给出新的时间：</p>
<div class="code"><pre class="code literal-block">Regex \d           took 00:00:00.1355787 result: 5077/10000
Regex [0-9]        took 00:00:00.1360403 result: 5077/10000  100.34 % of first
Regex [0123456789] took 00:00:00.1362112 result: 5077/10000  100.47 % of first
</pre></div>

<p><br><br><a href="posts/d-less-efficient-than-0-9/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-294.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-292.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
