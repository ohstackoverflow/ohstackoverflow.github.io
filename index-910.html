<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 910) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-910.html">
<link rel="prev" href="index-911.html" type="text/html">
<link rel="next" href="index-909.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wei-shi-yao-git-mo-ren-zhi-xing-kuai-jin-he-bing/" class="u-url">为什么 git 默认执行快进合并？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wei-shi-yao-git-mo-ren-zhi-xing-kuai-jin-he-bing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T19:28:49+08:00" itemprop="datePublished" title="2023-02-17 19:28">2023-02-17 19:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>来自 mercurial，我使用分支来组织功能。当然，我也想在我的历史中看到这个工作流程。</p>
<p>我使用 git 开始了我的新项目并完成了我的第一个功能。合并功能时，我意识到 git 使用快进，即如果可能它会将我的更改直接应用到 master
分支并忘记我的分支。</p>
<p>所以想想未来：我是唯一一个从事这个项目的人。如果我使用 git
的默认方法（快进合并），我的历史将导致一个巨大的主分支。没有人知道我为每个功能使用了一个单独的分支，因为最后我将只有那个巨大的 master
分支。会不会显得很不专业？</p>
<p>通过这种推理，我不想快进合并，也看不出为什么它是默认设置。这有什么好？</p>
<p><br><br></p>
<h2>解答</h2>
<p>快进合并对于短期分支有意义，但在更复杂的历史中，非快进合并可能使历史更容易理解，并且更容易恢复一组提交。</p>
<p><em><strong>警告</strong> ：非快进也有潜在的副作用。请查看https://sandofsky.com/blog/git-workflow.html，避免“no-
ff”及其“检查点提交”破坏对分或责备，并仔细考虑它是否应该成为<code>master</code>.</em></p>
<p><img alt="替代文字" src="images/vRdkr.png"><br>
（来自nvie.com，Vincent Driessen，发表“ <strong>A successful Git branching model</strong> ”）</p>
<blockquote>
<p><strong>在 develop 上合并完成的功能</strong></p>
<p>完成的功能可能会合并到开发分支中，以将它们添加到即将发布的版本中：</p>
</blockquote>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>checkout<span class="w"> </span>develop
Switched<span class="w"> </span>to<span class="w"> </span>branch<span class="w"> </span><span class="s1">'develop'</span>
$<span class="w"> </span>git<span class="w"> </span>merge<span class="w"> </span>--no-ff<span class="w"> </span>myfeature
Updating<span class="w"> </span>ea1b82a..05e9557
<span class="o">(</span>Summary<span class="w"> </span>of<span class="w"> </span>changes<span class="o">)</span>
$<span class="w"> </span>git<span class="w"> </span>branch<span class="w"> </span>-d<span class="w"> </span>myfeature
Deleted<span class="w"> </span>branch<span class="w"> </span>myfeature<span class="w"> </span><span class="o">(</span>was<span class="w"> </span>05e9557<span class="o">)</span>.
$<span class="w"> </span>git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>develop
</pre></div>

<blockquote>
<p>该<code>--no-
ff</code>标志导致合并始终创建一个新的提交对象，即使合并可以快进执行。这样可以避免丢失有关功能分支历史存在的信息，并将所有添加该功能的提交组合在一起。</p>
</blockquote>
<p>Jakub Narębski还提到了 <strong><code>merge.ff</code></strong> 配置：</p>
<blockquote>
<p>默认情况下，Git 在合并作为当前提交后代的提交时不会创建额外的合并提交。相反，当前分支的提示是快进的。<br>
当设置为 时<code>false</code>，这个变量告诉 Git 在这种情况下创建一个额外的合并提交（相当于<code>--no-ff</code>从命令行给出选项）。<br>
当设置为 ' <code>only</code>' 时，只允许这样的快进合并（相当于<code>--ff-only</code>从命令行给出选项）。</p>
</blockquote>
<hr>
<p>快进是默认设置，因为：</p>
<ul>
<li>短期分支在 Git 中很容易创建和使用</li>
<li>短命的分支通常会隔离许多可以在该分支内自由重组的提交</li>
<li>这些提交实际上是主分支的一部分：一旦重组，主分支就会快速转发以包含它们。</li>
</ul>
<p>但是，如果您预期在一个主题/功能分支上有一个迭代工作流（即，我合并，然后我回到这个功能分支并添加更多提交），那么在主分支中只包含合并是有用的，而不是功能分支的所有中间提交。</p>
<p>在这种情况下，您最终可以设置这种配置文件：</p>
<div class="code"><pre class="code literal-block"><span class="k">[branch "master"]</span>
<span class="c1"># This is the list of cmdline options that should be added to git-merge </span>
<span class="c1"># when I merge commits into the master branch.</span>

<span class="c1"># The option --no-commit instructs git not to commit the merge</span>
<span class="c1"># by default. This allows me to do some final adjustment to the commit log</span>
<span class="c1"># message before it gets commited. I often use this to add extra info to</span>
<span class="c1"># the merge message or rewrite my local branch names in the commit message</span>
<span class="c1"># to branch names that are more understandable to the casual reader of the git log.</span>

<span class="c1"># Option --no-ff instructs git to always record a merge commit, even if</span>
<span class="c1"># the branch being merged into can be fast-forwarded. This is often the</span>
<span class="c1"># case when you create a short-lived topic branch which tracks master, do</span>
<span class="c1"># some changes on the topic branch and then merge the changes into the</span>
<span class="c1"># master which remained unchanged while you were doing your work on the</span>
<span class="c1"># topic branch. In this case the master branch can be fast-forwarded (that</span>
<span class="c1"># is the tip of the master branch can be updated to point to the tip of</span>
<span class="c1"># the topic branch) and this is what git does by default. With --no-ff</span>
<span class="c1"># option set, git creates a real merge commit which records the fact that</span>
<span class="c1"># another branch was merged. I find this easier to understand and read in</span>
<span class="c1"># the log.</span>

<span class="na">mergeoptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">--no-commit --no-ff</span>
</pre></div>

<hr>
<p>OP 在评论中添加：</p>
<blockquote>
<p>我认为 [short-lived] 分支的快进有一定意义，但将其设为默认操作意味着 git 假设您......经常有 [short-lived]
分支。合理的？</p>
</blockquote>
<p>杰弗洛米回答：</p>
<blockquote>
<p>我认为分支机构的生命周期因用户而异。但是，在有经验的用户中，可能存在生命周期短得多的分支的趋势。</p>
<p>对我来说， <strong>一个短暂的分支是我创建的一个分支，目的是使某个操作更容易</strong> （变基，可能，或快速修补和测试），然后在我完成后立即删除。<br>
这意味着它很可能 <strong>应该被吸收到它从中分叉出来的主题分支中</strong>
，并且主题分支将被合并为一个分支。没有人需要知道我在内部做了什么来创建实现该给定功能的一系列提交。</p>
</blockquote>
<p>更一般地说，我补充说：</p>
<blockquote>
<p>这实际上取决于您的开发工作流程：</p>
<ul>
<li>如果它是线性的，一个分支是有意义的。</li>
<li>如果您需要隔离功能并长时间处理它们并反复合并它们，那么几个分支是有意义的。
</li>
</ul>
<p>请参阅“ <strong>你应该何时分支？</strong> ”</p>
</blockquote>
<p>实际上，当您考虑 Mercurial 分支模型时，它的核心是每个存储库 <em>一个</em> 分支（即使您可以创建匿名头、书签甚至命名分支）<br>
请参阅“Git 和 Mercurial - 比较和对比”。</p>
<blockquote>
<p>默认情况下，Mercurial 使用匿名轻量级代码行，在其术语中称为“heads”。<br>
Git 使用轻量级命名分支，通过单射映射将远程存储库中的分支名称映射到远程跟踪分支的名称。<br>
Git“强制”你命名分支（嗯，除了一个未命名的分支，这是一种称为“分离的 HEAD
”的情况），但我认为这更适用于分支繁重的工作流程，例如主题分支工作流程，意思是单个存储库范例中的多个分支。</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p>让我扩展一下VonC的非常全面的答案：</p>
<hr>
<p>首先，如果我没记错的话，Git 在默认情况下不会在快 <em>进情况下创建</em> <em>合并提交的</em> 事实来自考虑单分支“平等存储库”，其中 <strong>相互拉动用于同步</strong>
这两个存储库（a您可以在大多数用户文档中找到第一个示例工作流，包括“Git 用户手册”和“示例版本控制”）。在这种情况下，您不使用 pull
来合并完全实现的分支，而是使用它来跟上其他工作。当您碰巧将同步保存并存储在存储库中以备将来使用时，您不希望拥有短暂且不重要的事实。 __ ****</p>
<p>请注意，功能分支和在单个存储库中拥有多个分支的实用性只是在后来才出现，VCS 的广泛使用具有良好的合并支持，并且尝试了各种基于合并的工作流。这就是为什么例如
Mercurial 最初只支持每个存储库一个分支（加上跟踪远程分支的匿名提示），如“Mercurial：权威指南”的旧版本所示。</p>
<hr>
<p>其次，当遵循使用 <strong>特性分支的</strong> <strong>最佳实践</strong>
时，即特性分支应该全部从稳定版本开始（通常是从上一个版本开始），以便能够通过选择要合并的特性分支来挑选和选择要包含的特性， <strong>你通常不处于快进状态</strong>
……这使得这个问题没有实际意义。在合并第一个分支时，您需要担心创建一个真正的合并而不是快进（假设您没有将单次提交更改直接放在“master”上）；所有其他后来的合并当然都处于非快进情况。</p>
<hr>
<p>HTH</p>
<p><br><br><a href="posts/why-does-git-perform-fast-forward-merges-by-default/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-cha-kan-han-shu-de-yuan-dai-ma/" class="u-url">如何查看函数的源代码？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-cha-kan-han-shu-de-yuan-dai-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T19:28:23+08:00" itemprop="datePublished" title="2023-02-17 19:28">2023-02-17 19:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想查看一个函数的源代码，看看它是如何工作的。我知道我可以通过在提示符下输入函数名称来打印函数：</p>
<div class="code"><pre class="code literal-block">&gt; t
function (x) 
UseMethod("t")
&lt;bytecode: 0x2332948&gt;
&lt;environment: namespace:base&gt;
</pre></div>

<p>在这种情况下，什么<code>UseMethod("t")</code>意思？我如何找到实际使用的源代码，例如：<code>t(1:10)</code>？</p>
<p><code>UseMethod</code>当我看到和当我看到<code>standardGeneric</code>和<code>showMethods</code>时有区别吗<code>with</code>？</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="nv">with</span>
<span class="nv">standardGeneric</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="s2">"with"</span><span class="w"> </span><span class="nv">defined</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">package</span><span class="w"> </span><span class="s2">"base"</span>

<span class="nv">function</span><span class="w"> </span><span class="ss">(</span><span class="nv">data</span>,<span class="w"> </span><span class="nv">expr</span>,<span class="w"> </span>...<span class="ss">)</span><span class="w"> </span>
<span class="nv">standardGeneric</span><span class="ss">(</span><span class="s2">"with"</span><span class="ss">)</span>
<span class="o">&lt;</span><span class="nv">bytecode</span>:<span class="w"> </span><span class="mi">0</span><span class="nv">x102fb3fc0</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nv">environment</span>:<span class="w"> </span><span class="mi">0</span><span class="nv">x102fab988</span><span class="o">&gt;</span>
<span class="nv">Methods</span><span class="w"> </span><span class="nv">may</span><span class="w"> </span><span class="nv">be</span><span class="w"> </span><span class="nv">defined</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">arguments</span>:<span class="w"> </span><span class="nv">data</span>
<span class="nv">Use</span><span class="w">  </span><span class="nv">showMethods</span><span class="ss">(</span><span class="s2">"with"</span><span class="ss">)</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nv">currently</span><span class="w"> </span><span class="nv">available</span><span class="w"> </span><span class="nv">ones</span>.
</pre></div>

<p>在其他情况下，我可以看到正在调用 R 函数，但我找不到这些函数的源代码。</p>
<div class="code"><pre class="code literal-block"><span class="err">&gt;</span><span class="w"> </span><span class="nf">ts.union</span>
<span class="nf">function</span><span class="w"> </span><span class="p">(...,</span><span class="w"> </span><span class="no">dframe</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">FALSE</span><span class="p">)</span><span class="w"> </span>
<span class="no">.cbind.ts</span><span class="p">(</span><span class="no">list</span><span class="p">(...),</span><span class="w"> </span><span class="no">.makeNamesTs</span><span class="p">(...),</span><span class="w"> </span><span class="no">dframe</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">dframe</span><span class="p">,</span><span class="w"> </span><span class="no">union</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">TRUE</span><span class="p">)</span>
<span class="err">&lt;</span><span class="nl">bytecode:</span><span class="w"> </span><span class="err">0</span><span class="nf">x36fbf88</span><span class="err">&gt;</span>
<span class="err">&lt;</span><span class="nl">environment:</span><span class="w"> </span><span class="nl">namespace:</span><span class="nf">stats</span><span class="err">&gt;</span>
<span class="err">&gt;</span><span class="w"> </span><span class="na">.cbindts</span>
<span class="nl">Error:</span><span class="w"> </span><span class="nf">object</span><span class="w"> </span><span class="err">'</span><span class="no">.cbindts</span><span class="err">'</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">found</span>
<span class="err">&gt;</span><span class="w"> </span><span class="na">.makeNamesTs</span>
<span class="nl">Error:</span><span class="w"> </span><span class="nf">object</span><span class="w"> </span><span class="err">'</span><span class="no">.makeNamesTs</span><span class="err">'</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">found</span>
</pre></div>

<p>我如何找到像<code>.cbindts</code>和这样的功能<code>.makeNamesTs</code>？</p>
<p>在其他情况下，有一些 R 代码，但大部分工作似乎是在其他地方完成的。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="n">matrix</span>
<span class="nf">function </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">dimnames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="nf">if </span><span class="p">(</span><span class="nf">is.object</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="nf">is.atomic</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.vector</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="w">    </span><span class="nf">.Internal</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="p">,</span><span class="w"> </span><span class="n">dimnames</span><span class="p">,</span><span class="w"> </span><span class="nf">missing</span><span class="p">(</span><span class="n">nrow</span><span class="p">),</span><span class="w"> </span>
<span class="w">        </span><span class="nf">missing</span><span class="p">(</span><span class="n">ncol</span><span class="p">)))</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="n">bytecode</span><span class="o">:</span><span class="w"> </span><span class="mh">0x134bd10</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">environment</span><span class="o">:</span><span class="w"> </span><span class="n">namespace</span><span class="o">:</span><span class="n">base</span><span class="o">&gt;</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">.Internal</span>
<span class="nf">function </span><span class="p">(</span><span class="n">call</span><span class="p">)</span><span class="w">  </span><span class="nf">.Primitive</span><span class="p">(</span><span class="s">".Internal"</span><span class="p">)</span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">.Primitive</span>
<span class="nf">function </span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w">  </span><span class="nf">.Primitive</span><span class="p">(</span><span class="s">".Primitive"</span><span class="p">)</span>
</pre></div>

<p>我如何找出函数的作用<code>.Primitive</code>？同样，一些函数调用<code>.C</code>、<code>.Call</code>、<code>.Fortran</code>、<code>.External</code>或<code>.Internal</code>。我怎样才能找到那些的源代码？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>UseMethod("t")</code>告诉您这<code>t()</code>是一个 ( S3 ) 泛型函数，它具有针对不同对象类的方法。</p>
<h2>S3方法调度系统</h2>
<p>对于 S3 类，您可以使用<code>methods</code>函数列出特定通用函数或类的方法。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="nf">methods</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="n">t.data.frame</span><span class="w"> </span><span class="n">t.default</span><span class="w">    </span><span class="n">t.ts</span><span class="o">*</span>

<span class="w">   </span><span class="n">Non</span><span class="o">-</span><span class="n">visible</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">asterisked</span>
<span class="o">&gt;</span><span class="w"> </span><span class="nf">methods</span><span class="p">(</span><span class="n">class</span><span class="o">=</span><span class="s">"ts"</span><span class="p">)</span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="n">aggregate.ts</span><span class="w">     </span><span class="n">as.data.frame.ts</span><span class="w"> </span><span class="n">cbind.ts</span><span class="o">*</span><span class="w">        </span><span class="n">cycle.ts</span><span class="o">*</span><span class="w">       </span>
<span class="w"> </span><span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="w"> </span><span class="n">diffinv.ts</span><span class="o">*</span><span class="w">      </span><span class="n">diff.ts</span><span class="w">          </span><span class="n">kernapply.ts</span><span class="o">*</span><span class="w">    </span><span class="n">lines.ts</span><span class="w">        </span>
<span class="w"> </span><span class="p">[</span><span class="m">9</span><span class="p">]</span><span class="w"> </span><span class="n">monthplot.ts</span><span class="o">*</span><span class="w">    </span><span class="n">na.omit.ts</span><span class="o">*</span><span class="w">      </span><span class="n">Ops.ts</span><span class="o">*</span><span class="w">          </span><span class="n">plot.ts</span><span class="w">         </span>
<span class="p">[</span><span class="m">13</span><span class="p">]</span><span class="w"> </span><span class="n">print.ts</span><span class="w">         </span><span class="n">time.ts</span><span class="o">*</span><span class="w">         </span><span class="p">[</span><span class="o">&lt;-</span><span class="n">.ts</span><span class="o">*</span><span class="w">          </span><span class="p">[</span><span class="n">.ts</span><span class="o">*</span><span class="w">           </span>
<span class="p">[</span><span class="m">17</span><span class="p">]</span><span class="w"> </span><span class="n">t.ts</span><span class="o">*</span><span class="w">            </span><span class="n">window</span><span class="o">&lt;-</span><span class="n">.ts</span><span class="o">*</span><span class="w">     </span><span class="n">window.ts</span><span class="o">*</span>

<span class="w">   </span><span class="n">Non</span><span class="o">-</span><span class="n">visible</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">asterisked</span>
</pre></div>

<p>“不可见函数带有星号”表示该函数未从其包的命名空间中导出。您仍然可以通过函数<code>:::</code>（即<code>stats:::t.ts</code>）或使用<code>getAnywhere()</code>.
<code>getAnywhere()</code>很有用，因为您不必知道函数来自哪个包。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="n">getAnywhere</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">ts</span><span class="p">)</span>
<span class="n">A</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="err">‘</span><span class="n">t</span><span class="p">.</span><span class="n">ts</span><span class="err">’</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="k">found</span>
<span class="n">It</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="k">found</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">places</span>
<span class="w">  </span><span class="n">registered</span><span class="w"> </span><span class="n">S3</span><span class="w"> </span><span class="k">method</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">stats</span>
<span class="w">  </span><span class="nl">namespace</span><span class="p">:</span><span class="n">stats</span>
<span class="k">with</span><span class="w"> </span><span class="k">value</span>

<span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="n">cl</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">oldClass</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="n">other</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="err">!</span><span class="p">(</span><span class="n">cl</span><span class="w"> </span><span class="o">%</span><span class="ow">in</span><span class="o">%</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="ss">"ts"</span><span class="p">,</span><span class="w"> </span><span class="ss">"mts"</span><span class="p">))</span>
<span class="w">    </span><span class="k">class</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">any</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="n">cl</span><span class="o">[</span><span class="n">other</span><span class="o">]</span>
<span class="w">    </span><span class="n">attr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="ss">"tsp"</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">NULL</span>
<span class="w">    </span><span class="n">t</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="err">}</span>
<span class="o">&lt;</span><span class="nl">bytecode</span><span class="p">:</span><span class="w"> </span><span class="mh">0x294e410</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nl">environment</span><span class="p">:</span><span class="w"> </span><span class="nl">namespace</span><span class="p">:</span><span class="n">stats</span><span class="o">&gt;</span>
</pre></div>

<h2>S4方法调度系统</h2>
<p>S4系统是较新的方法调度系统，是S3系统的替代品。以下是 S4 函数的示例：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="nv">library</span><span class="ss">(</span><span class="nv">Matrix</span><span class="ss">)</span>
<span class="nv">Loading</span><span class="w"> </span><span class="nv">required</span><span class="w"> </span><span class="nv">package</span>:<span class="w"> </span><span class="nv">lattice</span>
<span class="o">&gt;</span><span class="w"> </span><span class="nv">chol2inv</span>
<span class="nv">standardGeneric</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="s2">"chol2inv"</span><span class="w"> </span><span class="nv">defined</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">package</span><span class="w"> </span><span class="s2">"base"</span>

<span class="nv">function</span><span class="w"> </span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span>...<span class="ss">)</span><span class="w"> </span>
<span class="nv">standardGeneric</span><span class="ss">(</span><span class="s2">"chol2inv"</span><span class="ss">)</span>
<span class="o">&lt;</span><span class="nv">bytecode</span>:<span class="w"> </span><span class="mi">0</span><span class="nv">x000000000eafd790</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nv">environment</span>:<span class="w"> </span><span class="mi">0</span><span class="nv">x000000000eb06f10</span><span class="o">&gt;</span>
<span class="nv">Methods</span><span class="w"> </span><span class="nv">may</span><span class="w"> </span><span class="nv">be</span><span class="w"> </span><span class="nv">defined</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">arguments</span>:<span class="w"> </span><span class="nv">x</span>
<span class="nv">Use</span><span class="w">  </span><span class="nv">showMethods</span><span class="ss">(</span><span class="s2">"chol2inv"</span><span class="ss">)</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nv">currently</span><span class="w"> </span><span class="nv">available</span><span class="w"> </span><span class="nv">ones</span>.
</pre></div>

<p>输出已经提供了大量信息。<code>standardGeneric</code>是 S4 功能的指标。提供查看已定义 S4 方法的方法很有帮助：</p>
<div class="code"><pre class="code literal-block">&gt; showMethods(chol2inv)
Function: chol2inv (package base)
x="ANY"
x="CHMfactor"
x="denseMatrix"
x="diagonalMatrix"
x="dtrMatrix"
x="sparseMatrix"
</pre></div>

<p><code>getMethod</code>可以用来查看其中一种方法的源代码：</p>
<div class="code"><pre class="code literal-block">&gt; getMethod("chol2inv", "diagonalMatrix")
Method Definition:

function (x, ...) 
{
    chk.s(...)
    tcrossprod(solve(x))
}
&lt;bytecode: 0x000000000ea2cc70&gt;
&lt;environment: namespace:Matrix&gt;

Signatures:
        x               
target  "diagonalMatrix"
defined "diagonalMatrix"
</pre></div>

<p>还有一些方法，每个方法都有更复杂的签名，例如</p>
<div class="code"><pre class="code literal-block">require(raster)
showMethods(extract)
Function: extract (package raster)
x="Raster", y="data.frame"
x="Raster", y="Extent"
x="Raster", y="matrix"
x="Raster", y="SpatialLines"
x="Raster", y="SpatialPoints"
x="Raster", y="SpatialPolygons"
x="Raster", y="vector"
</pre></div>

<p>要查看这些方法之一的源代码，必须提供整个签名，例如</p>
<div class="code"><pre class="code literal-block">getMethod("extract" , signature = c( x = "Raster" , y = "SpatialPolygons") )
</pre></div>

<p>仅提供部分签名是不够的</p>
<div class="code"><pre class="code literal-block"><span class="nv">getMethod</span><span class="ss">(</span><span class="s2">"extract"</span>,<span class="nv">signature</span><span class="o">=</span><span class="s2">"SpatialPolygons"</span><span class="ss">)</span>
#<span class="nv">Error</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">getMethod</span><span class="ss">(</span><span class="s2">"extract"</span>,<span class="w"> </span><span class="nv">signature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"SpatialPolygons"</span><span class="ss">)</span><span class="w"> </span>:<span class="w"> </span>
#<span class="w">  </span><span class="nv">No</span><span class="w"> </span><span class="nv">method</span><span class="w"> </span><span class="nv">found</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="s2">"extract"</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">signature</span><span class="w"> </span><span class="nv">SpatialPolygons</span>
</pre></div>

<h2>调用未导出函数的函数</h2>
<p>对于<code>ts.union</code>,<code>.cbindts</code>和<code>.makeNamesTs</code>是命名空间中未导出的函数<code>stats</code>。您可以使用<code>:::</code>运算符或查看未导出函数的源代码<code>getAnywhere</code>。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;</span><span class="w"> </span><span class="nl">stats</span><span class="p">:</span><span class="o">::</span><span class="p">.</span><span class="n">makeNamesTs</span>
<span class="k">function</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">as</span><span class="p">.</span><span class="n">list</span><span class="p">(</span><span class="n">substitute</span><span class="p">(</span><span class="n">list</span><span class="p">(...)))</span><span class="o">[</span><span class="n">-1L</span><span class="o">]</span>
<span class="w">    </span><span class="n">nm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">names</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="w">    </span><span class="n">fixup</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">is</span><span class="p">.</span><span class="k">null</span><span class="p">(</span><span class="n">nm</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="n">seq_along</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">nm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">""</span>
<span class="w">    </span><span class="n">dep</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="n">l</span><span class="o">[</span><span class="n">fixup</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">deparse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">[</span><span class="n">1L</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">is</span><span class="p">.</span><span class="k">null</span><span class="p">(</span><span class="n">nm</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">any</span><span class="p">(</span><span class="n">fixup</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="n">nm</span><span class="o">[</span><span class="n">fixup</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dep</span>
<span class="w">    </span><span class="n">nm</span>
<span class="err">}</span>
<span class="o">&lt;</span><span class="nl">bytecode</span><span class="p">:</span><span class="w"> </span><span class="mh">0x38140d0</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nl">environment</span><span class="p">:</span><span class="w"> </span><span class="nl">namespace</span><span class="p">:</span><span class="n">stats</span><span class="o">&gt;</span>
</pre></div>

<h2>调用编译代码的函数</h2>
<p>请注意，“已编译”不是指由 <strong>编译器</strong> 包创建的字节编译 R 代码。上面输出中的一行<code>&lt;bytecode:
0x294e410&gt;</code>表明该函数是字节编译的，您仍然可以从 R 命令行查看源代码。</p>
<p>Functions that call <code>.C</code>, <code>.Call</code>, <code>.Fortran</code>, <code>.External</code>, <code>.Internal</code>, or
<code>.Primitive</code> are calling entry points in compiled code, so you will have to
look at sources of the compiled code if you want to fully understand the
function. This GitHub mirror of the R source code is a decent place to start.
The function <code>pryr::show_c_source</code> can be a useful tool as it will take you
directly to a GitHub page for <code>.Internal</code> and <code>.Primitive</code> calls. Packages may
use <code>.C</code>, <code>.Call</code>, <code>.Fortran</code>, and <code>.External</code>; but not <code>.Internal</code> or
<code>.Primitive</code>, because these are used to call functions built into the R
interpreter.</p>
<p>Calls to some of the above functions may use an object instead of a character
string to reference the compiled function. In those cases, the object is of
class <code>"NativeSymbolInfo"</code>, <code>"RegisteredNativeSymbol"</code>, or <code>"NativeSymbol"</code>;
and printing the object yields useful information. For example, <code>optim</code> calls
<code>.External2(C_optimhess, res$par, fn1, gr1, con)</code> (note that's <code>C_optimhess</code>,
not <code>"C_optimhess"</code>). <code>optim</code> is in the stats package, so you can type
<code>stats:::C_optimhess</code> to see information about the compiled function being
called.</p>
<h3>Compiled code in a package</h3>
<p>If you want to view compiled code in a package, you will need to
download/unpack the package source. The installed binaries are not sufficient.
A package's source code is available from the same CRAN (or CRAN compatible)
repository that the package was originally installed from. The
<code>download.packages()</code> function can get the package source for you.</p>
<div class="code"><pre class="code literal-block"><span class="n">download</span><span class="o">.</span><span class="n">packages</span><span class="p">(</span><span class="n">pkgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Matrix"</span><span class="p">,</span><span class="w"> </span>
<span class="w">                  </span><span class="n">destdir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"."</span><span class="p">,</span>
<span class="w">                  </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"source"</span><span class="p">)</span>
</pre></div>

<p>This will download the source version of the Matrix package and save the
corresponding <code>.tar.gz</code> file in the current directory. Source code for
compiled functions can be found in the <code>src</code> directory of the uncompressed and
untared file. The uncompressing and untaring step can be done outside of <code>R</code>,
or from within <code>R</code> using the <code>untar()</code> function. It is possible to combine the
download and expansion step into a single call (note that only one package at
a time can be downloaded and unpacked in this way):</p>
<div class="code"><pre class="code literal-block"><span class="n">untar</span><span class="p">(</span><span class="n">download</span><span class="o">.</span><span class="n">packages</span><span class="p">(</span><span class="n">pkgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Matrix"</span><span class="p">,</span>
<span class="w">                        </span><span class="n">destdir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"."</span><span class="p">,</span>
<span class="w">                        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"source"</span><span class="p">)[,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

<p>Alternatively, if the package development is hosted publicly (e.g. via GitHub,
R-Forge, or RForge.net), you can probably browse the source code online.</p>
<h3>Compiled code in a base package</h3>
<p>Certain packages are considered "base" packages. These packages ship with R
and their version is locked to the version of R. Examples include <code>base</code>,
<code>compiler</code>, <code>stats</code>, and <code>utils</code>. As such, they are not available as separate
downloadable packages on CRAN as described above. Rather, they are part of the
R source tree in individual package directories under <code>/src/library/</code>. How to
access the R source is described in the next section.</p>
<h3>Compiled code built into the R interpreter</h3>
<p>If you want to view the code built-in to the R interpreter, you will need to
download/unpack the R sources; or you can view the sources online via the R
Subversion repository or Winston Chang's github mirror.</p>
<p>Uwe Ligges 的R 新闻文章 (PDF)（第 43
页）是有关如何查看<code>.Internal</code>和函数源代码的很好的一般参考<code>.Primitive</code>。基本步骤是先在
中查找函数名<code>src/main/names.c</code>，然后在<code>src/main/*</code>.</p>
<p><br></p>
<h3>更多建议</h3>
<p>除了关于这个问题及其重复项的其他答案之外，这里还有一个很好的方法来获取包函数的源代码，而无需知道它在哪个包中。例如，如果我们想要源代码<code>randomForest::rfcv()</code>：</p>
<h4>要在弹出窗口中 <strong>查看/编辑它：</strong>
</h4>
<div class="code"><pre class="code literal-block">edit(getAnywhere('rfcv'), file='source_rfcv.r')

View(getAnywhere('rfcv'), file='source_rfcv.r')
</pre></div>

<p>请注意，<code>edit()</code>打开文本编辑器（用户选择），而<code>View()</code>调用电子表格样式的数据查看器。</p>
<ul>
<li>
<code>View()</code>非常适合浏览（多列） <strong>数据</strong> ，但对于玩具长度以外的任何 <strong>代码通常都很糟糕。</strong>
</li>
<li>所以当只想查看 <strong>代码</strong> 时，<code>edit()</code>IMO 实际上比 好得多<code>View()</code>，因为有了它，<code>edit()</code>您可以折叠/隐藏/模拟所有 arg-parsing/checking/default/error-message 逻辑，这些逻辑可能占 R 函数的 70% ，然后到达函数实际操作的部分（！），它的返回类型是什么类型的对象，它是否递归以及如何递归等。</li>
</ul>
<h4>要 <strong>重定向到一个单独的文件</strong> （这样你就可以在你最喜欢的 IDE/编辑器中调出代码/使用 grep/等处理它）：</h4>
<div class="code"><pre class="code literal-block">capture.output(getAnywhere('rfcv'), file='source_rfcv.r')
</pre></div>

<p><br><br><a href="posts/how-can-i-view-the-source-code-for-a-function/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/cong-fu-ye-mian-diao-yong-iframe-zhong-de-javascript-dai-ma/" class="u-url">从父页面调用 iframe 中的 JavaScript 代码</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/cong-fu-ye-mian-diao-yong-iframe-zhong-de-javascript-dai-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T19:27:51+08:00" itemprop="datePublished" title="2023-02-17 19:27">2023-02-17 19:27</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>基本上，我<code>iframe</code>在页面中嵌入了一个，并且<code>iframe</code>有一些我需要从父页面调用的JavaScript例程。</p>
<p>现在相反的过程非常简单，因为您只需要调用<code>parent.functionName()</code>，但不幸的是，我需要的恰恰相反。</p>
<p>请注意，我的问题不是更改 的源URL ，<code>iframe</code>而是调用<code>iframe</code>.</p>
<p><br><br></p>
<h2>解答</h2>
<p>假设您的 iFrame 的 ID 是“targetFrame”，您要调用的函数是<code>targetFunction()</code>：</p>
<div class="code"><pre class="code literal-block">document.getElementById('targetFrame').contentWindow.targetFunction();
</pre></div>

<p><code>window.frames</code>您还可以使用而不是访问框架<code>document.getElementById</code>。</p>
<div class="code"><pre class="code literal-block"><span class="c1">// this option does not work in most of latest versions of chrome and Firefox</span>
<span class="nb">window</span><span class="p">.</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">frameElement</span><span class="p">.</span><span class="n">contentWindow</span><span class="p">.</span><span class="n">targetFunction</span><span class="p">();</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>这里有一些怪癖需要注意。</p>
<ol>
<li>
<p><code>HTMLIFrameElement.contentWindow</code>可能是更简单的方法，但它不是一个标准属性，一些浏览器不支持它，主要是旧浏览器。这是因为 DOM Level 1 HTML 标准对对象没有任何规定<code>window</code>。</p>
</li>
<li>
<p>您也可以尝试<code>HTMLIFrameElement.contentDocument.defaultView</code>，一些较旧的浏览器允许，但 IE 不允许。<code>window</code>即便如此，出于与 (1) 相同的原因，该标准并未明确说明您要取回对象，但如果您愿意，可以在此处选择一些额外的浏览器版本。</p>
</li>
<li>
<p><code>window.frames['name']</code>返回窗口是最古老的接口，因此也是最可靠的接口。但是您随后必须使用一个<code>name="..."</code>属性才能通过名称获取框架，这有点难看/ <del>已弃用</del> /过渡。（<code>id="..."</code>会更好，但 IE 不喜欢那样。）</p>
</li>
<li>
<p><code>window.frames[number]</code>也很可靠，但知道正确的索引是诀窍。你可以摆脱这个，例如。如果您知道页面上只有一个 iframe。</p>
</li>
<li>
<p>完全有可能子 iframe 尚未加载，或者其他原因导致它无法访问。您可能会发现反转通信流更容易：也就是说，让子 iframe<code>window.parent</code>在加载完成并准备好回调时通知其脚本。通过将它自己的对象之一（例如回调函数）传递给父脚本，该父脚本然后可以直接与 iframe 中的脚本通信，而不必担心它与什么 HTMLIFrameElement 相关联。</p>
</li>
</ol>
<p><br><br><a href="posts/invoking-javascript-code-in-an-iframe-from-the-parent-page/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-911.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-909.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
