<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 845) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-845.html">
<link rel="prev" href="index-846.html" type="text/html">
<link rel="next" href="index-844.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/amazon-sns-he-amazon-sqs-you-shi-yao-qu-bie/" class="u-url">Amazon SNS 和 Amazon SQS 有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/amazon-sns-he-amazon-sqs-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T17:41:49+08:00" itemprop="datePublished" title="2023-02-17 17:41">2023-02-17 17:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我什么时候应该使用 SNS 和 SQS，为什么它们总是耦合在一起？</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>SNS</strong> 是一个分布式的 <strong>发布-订阅</strong> 系统。当消息被发布者发送到 SNS 时，消息 <strong>被推送给订阅者。</strong></p>
<p><strong>SQS</strong> 是分布式 <strong>排队</strong> 系统。消息 <em>不会</em> 推送给接收者。接收者必须从 <strong>SQS</strong> <strong>轮询或拉取</strong>
消息。消息不能同时被多个接收者接收。任何一个接收者都可以接收消息、处理和删除它。其他接收者稍后不会收到相同的消息。与 SNS 不同，轮询在 SQS
中固有地引入了一些消息传递延迟，SNS 会立即将消息推送给订阅者。SNS 支持多种端点，例如电子邮件、SMS、HTTP 端点和
SQS。如果您希望未知数量和类型的订阅者接收消息，则需要 SNS。 ****</p>
<p>您不必总是将 SNS 和 SQS 结合起来。除了 SQS 之外，您还可以让 SNS 将消息发送到电子邮件、SMS 或 HTTP 端点。将 SNS 与 SQS
耦合有一些优势。您可能不希望外部服务与您的主机建立连接（防火墙可能会阻止所有从外部到您主机的传入连接）。</p>
<p>您的端点可能会因为大量消息而死亡。电子邮件和 SMS 可能不是您快速处理消息的选择。通过将 SNS 与 SQS
相结合，您可以按自己的节奏接收消息。它允许客户端离线，容忍网络和主机故障。您还可以实现有保证的交付。如果您将 SNS 配置为将消息发送到 HTTP
端点或电子邮件或 SMS，多次发送消息失败可能会导致消息被丢弃。</p>
<p>SQS主要用来解耦应用或者集成应用。消息可以在 SQS 中存储很短的时间（最多 14 天）。SNS
将消息的多个副本分发给多个订阅者。例如，假设您要将应用程序生成的数据复制到多个存储系统。您可以使用 SNS
并将此数据发送给多个订阅者，每个订阅者将收到的消息复制到不同的存储系统（S3、主机上的硬盘、数据库等）。</p>
<p><br></p>
<h3>更多建议</h3>
<p><br><br><a href="posts/what-is-the-difference-between-amazon-sns-and-amazon-sqs/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-ru-he-xiu-fu-vi-zhong-zheng-ge-wen-jian-de-suo-jin/" class="u-url">我如何修复 Vi 中整个文件的缩进？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-ru-he-xiu-fu-vi-zhong-zheng-ge-wen-jian-de-suo-jin/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T17:41:21+08:00" itemprop="datePublished" title="2023-02-17 17:41">2023-02-17 17:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在 Vim 中，纠正所有行缩进的命令是什么？</p>
<p>很多时候我会将代码复制并粘贴到远程终端，然后把整个事情搞砸了。我想一举解决这个问题。</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>=</code>, 缩进命令可以采取行动。因此，<code>gg</code>要获取文件的开头，<code>=</code>缩进<code>G</code>到文件的末尾，<code>gg=G</code>.</p>
<p><br></p>
<h3>更多建议</h3>
<p>在粘贴到终端之前，尝试<code>:set paste</code>然后<code>:set nopaste</code>在你完成之后。这将关闭自动缩进、换行和其他扰乱您的粘贴的功能。</p>
<p>编辑：另外，我应该指出，<code>=</code>使用外部程序通常可以获得比缩进更好的结果。例如，我一直在跑步<code>:%!perltidy</code>。<code>astyle</code>,
<code>cindent</code>, 等也可以使用。当然，您可以将它们映射到一个击键，并根据文件类型将不同的映射到相同的击键。</p>
<p><br><br><a href="posts/how-do-i-fix-the-indentation-of-an-entire-file-in-vi/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-jiang-chou-qu-de-wen-ben-nian-tie-dao-vim-ming-ling-xing/" class="u-url">如何将抽取的文本粘贴到 Vim 命令行</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-jiang-chou-qu-de-wen-ben-nian-tie-dao-vim-ming-ling-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T17:40:40+08:00" itemprop="datePublished" title="2023-02-17 17:40">2023-02-17 17:40</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想将提取的文本粘贴到 Vim 的命令行中。是否可以？</p>
<p><br><br></p>
<h2>解答</h2>
<p>是的。打<code>Ctrl</code>-<code>R</code>然后<code>"</code>。如果您在抽出的内容中有文字控制字符，请使用<code>Ctrl</code>- <code>R</code>、<code>Ctrl</code>- <code>O</code>、<code>"</code>。</p>
<p>这里解释了你可以用寄存器做什么。你可以用寄存器做很多事，一旦你知道如何使用它们，你就离不开它们。</p>
<p>寄存器基本上是字符串的存储位置。Vim 有许多以不同方式工作的寄存器：</p>
<ul>
<li>
<code>0</code>（抽出寄存器：当您<code>y</code>在正常模式下使用时，如果没有指定寄存器，抽出的文本会出现在默认寄存器中），</li>
<li>
<code>1</code>到<code>9</code>（移动删除寄存器，当你使用诸如<code>c</code>或 之类的命令时<code>d</code>，已删除的内容转到寄存器 1，寄存器 1 中的内容转到寄存器 2， <em>等等</em> ），</li>
<li>
<code>"</code>（默认寄存器，也称为未命名寄存器。这是- ,<code>"</code>的来源），<code>Ctrl``R``"</code>
</li>
<li>
<code>a</code>to<code>z</code>供您自己使用（大写<code>A</code>to<code>Z</code>是为了附加到相应的寄存器）。</li>
<li>
<code>_</code>（就像<code>/dev/null</code>（Unix）或<code>NUL</code>（Windows）一样，你可以写入它但它被丢弃并且当你从它读取时，它总是空的），</li>
<li>
<code>-</code>（小删除寄存器），</li>
<li>
<code>/``/</code>（搜索模式寄存器，当您使用, <code>?</code>,<code>*</code>或<code>#</code>例如查找文本时更新；您也可以写入它以动态更改搜索模式），</li>
<li>
<code>:``Q</code>（通过or存储最后一个 VimL 输入的命令<code>:</code>，只读），</li>
<li>
<code>+</code>和<code>*</code>（系统剪贴板寄存器，您可以写入它们以设置剪贴板并从中读取剪贴板内容）</li>
</ul>
<p>请参阅<code>:help registers</code>完整参考。</p>
<p>您可以随时使用<code>:registers</code>来显示所有寄存器的内容。此命令的同义词和简写是<code>:display</code>,<code>:reg</code>和<code>:di</code>。</p>
<p>在插入或命令行模式下，<code>Ctrl</code>-<code>R</code>加上一个寄存器名称，插入该寄存器的内容。如果你想按字面意义插入它们（没有自动缩进，没有控制字符转换为<code>0x08</code>退格等），你可以使用<code>Ctrl</code>-
<code>R</code>，<code>Ctrl</code>- <code>O</code>，注册名称。请参阅<code>:help i_CTRL-R</code>以下段落以获取更多参考。</p>
<p>但您也可以执行以下操作（我可能忘记了寄存器的许多用途）。</p>
<ul>
<li>在正常模式下，点击<code>"``:``p</code>。你在 vim 中使用的最后一个命令被粘贴到你的缓冲区中。<br>
Let's
decompose:<code>"</code>是一个普通模式命令，可以让您选择在下一个抽取、删除或粘贴操作期间要使用的寄存器。所以<code>"``:</code>选择冒号寄存器（存储最后一条命令）。然后<code>p</code>是一个你已经知道的命令，它粘贴寄存器的内容。</li>
</ul>
<p>比照。<code>:help "</code>,<code>:help quote_:</code></p>
<ul>
<li>您正在编辑一个 VimL 文件（例如您的<code>.vimrc</code>），现在想执行几行连续的代码：<code>y``j``:``@``"``Enter</code>. <br>
在这里，<code>y``j</code>将当前行和下一行（这是因为 j 是一个线性运动，但这超出了这个答案的范围）到默认寄存器（也称为未命名寄存器）。然后<code>:@</code>Ex
命令播放存储在作为参数给定的寄存器中的 Ex 命令，这<code>"</code>就是您引用未命名寄存器的方式。另请参阅此答案的顶部，这是相关的。</li>
</ul>
<p>不要将<code>"</code>此处使用的（这是一个寄存器名称）与<code>"</code>前面示例中的普通模式命令混淆。</p>
<p>比照。<code>:help :@</code>和<code>:help quote_quote</code></p>
<ul>
<li>
<code>Ctrl</code>在插入模式下将最后一个搜索模式插入到您的文件中，或者使用- <code>R</code>,插入到命令行中<code>/</code>。</li>
</ul>
<p>比照。<code>:help quote_/</code>,<code>help i_CTRL-R</code></p>
<p>推论：保留您的搜索模式，但添加替代方案：<code>/</code> <code>Ctrl</code>- <code>R</code>, <code>/</code> <code>\|alternative</code>.</p>
<ul>
<li>您在可视模式下选择了一行中间的两个单词，用 将它们拉出<code>y</code>，它们在未命名的寄存器中。现在你想在你所在的位置下面打开一个新行，用这两个词：<code>:pu</code>。这是 的简写<code>:put "</code>。该<code>:put</code>命令与许多 Ex 命令一样，只能按行运行。</li>
</ul>
<p>比照。<code>:help :put</code></p>
<p>你也可以这样做：<code>:call setreg('"', @", 'V')</code>then
<code>p</code>。该<code>setreg</code>函数设置名称作为第一个参数（作为字符串）的寄存器，用第二个参数的内容初始化它（并且您可以使用寄存器作为变量，其中名称是 VimL
中的寄存器名称）<code>@x</code>，<code>x</code>并且将其转换为第三个参数中指定的模式，<code>V</code>对于 linewise，对于 characterwise
没有任何内容，<code>^V</code>对于 blockwise 则为文字。</p>
<p>比照。<code>:help setreg()</code>. 反向函数是<code>getreg()</code>和<code>getregtype()</code>。</p>
<ul>
<li>如果你用<code>qa</code>...录制了一个宏<code>q</code>，那么<code>:echo @a</code>它会告诉你你输入了什么，并<code>@a</code>会重播这个宏（可能你知道那个，对于避免重复性任务非常有用）</li>
</ul>
<p>比照。<code>:help q</code>,<code>help @</code></p>
<p>前面示例的推论：如果您在<code>8go</code>剪贴板中，则将<code>@+</code>剪贴板内容作为宏播放，从而转到文件的第 8
个字节。实际上，这几乎适用于每个寄存器。如果您最后插入的字符串处于<code>dd</code>插入模式，则将<code>@.</code>（因为<code>.</code>寄存器包含最后插入的字符串）删除一行。（Vim文档在这方面是错误的，因为它指出寄存器
、 和只能与<code>#</code>、<code>%</code>和-一起使用）。<code>:``.``p``P``:put``Ctrl``R</code></p>
<p>比照。<code>:help @</code></p>
<p>不要混淆<code>:@</code>(从寄存器播放 Vim 命令的命令) 和<code>@</code>(从寄存器播放普通模式命令的普通模式命令)。</p>
<p>值得注意的例外是<code>@:</code>。命令寄存器不包含初始冒号，也不包含最终回车符。但是在普通模式下，<code>@:</code>将按照您的预期进行操作，将寄存器解释为 Ex
命令，而不是尝试在普通模式下播放它。因此，如果您的最后一个命令是<code>:e</code>，则寄存器包含<code>e</code>但<code>@:</code>会重新加载文件，而不是进入单词结尾。</p>
<p>比照。<code>:help @:</code></p>
<ul>
<li>在运行它之前显示您将在普通模式下做什么：<code>@='dd'</code> <code>Enter</code>。一旦你按下这个<code>=</code>键，Vim 就会切换到表达式求值：当你输入一个表达式并按下 时<code>Enter</code>，Vim 会计算它，结果作为一个寄存器内容。当然寄存器<code>=</code>是只读的，而且是一次性的。每次开始使用它时，您都必须输入一个新表达式。</li>
</ul>
<p>比照。<code>:help quote_=</code></p>
<p>推论：如果你正在编辑一个命令，并且你意识到你应该需要从你当前的缓冲区中插入一些行到你的命令行中：不要按<code>Esc</code>！使用<code>Ctrl</code>- <code>R</code>
<code>=getline(58)</code> <code>Enter</code>。之后您将返回到命令行编辑，但它已插入第 58 行的内容。</p>
<ul>
<li>手动定义搜索模式：<code>:let @/ = 'foo'</code>
</li>
</ul>
<p>比照。<code>:help :let</code></p>
<p>请注意，这样做时，您无需<code>/</code>在模式中转义。但是，您当然需要将所有单引号加倍。</p>
<ul>
<li>复制以 开头的所有行<code>foo</code>，然后复制所有包含的行<code>bar</code>到剪贴板，链接这些命令：（<code>qaq</code>重置其中存储空宏的寄存器 <em>）</em><code>:g/^foo/y A</code>，, <code>:g/bar/y A</code>, <code>:let @+ = @a</code>.</li>
</ul>
<p>使用大写寄存器名称使寄存器以追加模式工作</p>
<p>更好的是，如果<code>Q</code>没有被重新映射<code>mswin.vim</code>，用 启动 Ex 模式<code>Q</code>，链接那些实际上更好称为“Ex
命令”的“冒号命令”，然后通过键入返回正常模式<code>visual</code>。</p>
<p>比照。<code>:help :g</code>, <code>:help :y</code>,<code>:help Q</code></p>
<ul>
<li>
<p>双倍空间你的文件：<code>:g/^/put _</code>. 这会将黑洞寄存器的内容（读取时为空，但可写，行为类似于<code>/dev/null</code>）逐行放置在每一行之后（因为每一行都有一个开头！）。</p>
</li>
<li>
<p><code>foo</code>在每行之前添加一行： <code>:g/^/-put ='foo'</code>。这是表达式寄存器的巧妙使用。这里，是(cf. )<code>-</code>的同义词。由于将文本放在行之后，您必须明确告诉它对前一行进行操作。<code>.-1``:help :range``:put</code></p>
</li>
<li>
<p>将整个缓冲区复制到系统剪贴板：<code>:%y+</code>。</p>
</li>
</ul>
<p>比照。<code>:help :range</code>（对于<code>%</code>部分）和<code>:help :y</code>。</p>
<ul>
<li>
<p>如果您错误地录制了宏，您可以键入<code>:let @a='</code> <code>Ctrl</code>-<code>R</code> <code>=replace(@a,"'","''",'g')</code> <code>Enter</code> <code>'</code>并对其进行编辑。这将修改存储在 register 中的宏的内容<code>a</code>，此处显示了如何使用表达式 register 来执行此操作。另一种更简单的修改宏的方法是将其粘贴到缓冲区 ( <code>"ap</code>) 中，对其进行编辑，然后通过选择它和 将其再次放入寄存器中<code>"ay</code>。</p>
</li>
<li>
<p>如果你这样做了<code>dddd</code>，你可能会<code>uu</code>为了撤消而做。<code>p</code>你可以得到最后删除的行。<code>@1</code>但实际上你也可以通过寄存器恢复最多 9 个删除<code>@9</code>。</p>
</li>
</ul>
<p>更好的是，如果你这样做<code>"1P</code>，那么<code>.</code>在普通模式下会播放<code>"2P</code>，等等。</p>
<p>比照。<code>:help .</code>和<code>:help quote_number</code></p>
<ul>
<li>如果你想在插入模式下插入当前日期：<code>Ctrl</code>- <code>R``=strftime('%y%m%d')``Enter</code>。</li>
</ul>
<p>比照。<code>:help strftime()</code></p>
<p>再一次，什么可能令人困惑：</p>
<ul>
<li>
<p><code>:@</code>是一个命令行命令，它将寄存器的内容解释为 vimscript 并将其作为源代码</p>
</li>
<li>
<p><code>@</code>在将寄存器的内容解释为正常模式击键的正常模式命令中（除非您使用<code>:</code>寄存器，它包含最后播放的命令但没有初始冒号：在这种情况下，它会重播命令，就好像您还重新键入了冒号和最后的返回键）。</p>
</li>
<li>
<p><code>"</code>在正常模式下，帮助您选择寄存器以进行抽取、粘贴、删除、更正等操作的命令。</p>
</li>
<li>
<p><code>"</code>也是一个有效的寄存器名称（默认或未命名的寄存器），因此可以作为期望寄存器名称的命令的参数传递</p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>要粘贴系统剪贴板中的内容，您可以使用<code>SHIFT</code>- <code>INS</code>。</p>
<p>它适用于 Windows，但我猜它也适用于 Linux。</p>
<p><br><br><a href="posts/how-to-paste-yanked-text-into-the-vim-command-line/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-846.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-844.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
