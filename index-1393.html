<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1393) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1393.html">
<link rel="prev" href="index-1394.html" type="text/html">
<link rel="next" href="index-1392.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/java-minimax-alpha-beta-pruning-recursion-return/" class="u-url">Java Minimax Alpha-Beta Pruning Recursion Return</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/java-minimax-alpha-beta-pruning-recursion-return/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:02:00+08:00" itemprop="datePublished" title="2023-02-28 03:02">2023-02-28 03:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am trying to implement minimax with alpha-beta pruning for a checkers game
in Java. My minimax algorithm works perfectly. My code runs with the alpha-
beta code in place. Unfortunately, when I play 1000 games vs the standard
minimax algorithm, the alpha-beta algorithm always comes out behind by 50
games or so.</p>
<p>Since alpha-beta pruning should not be reducing the quality of the moves, just
the time it takes to achieve them, something has to be wrong. However, I have
taken out pen and paper and drawn hypothetical leaf node values and used my
algorithm to predict whether it will calculate the correct best move, and
there doesn't appear to be any logic errors. I used the tree from this video:
Alpha-Beta Pruning to trace my algorithm. It logically should make all of the
same choices, and therefore be a functioning implementation.</p>
<p>I have also put print statements into the code (they have been removed to
reduce the clutter), and values are being returned correctly it appears and
pruning does happen. Despite my best efforts I have been unable to find where
the logic error lies. This is my third different attempt at implementing this
and all of them have had the same issue.</p>
<p>I can't post the full code here, it's much too long, so I have included the
methods that are relevant to the error. I'm not certain, but I suspect the
problem may likely be in the non-recursive move() method, though I can't find
a logical error in it so I'd just be thrashing around in it more, probably
making things worse rather than better without having a rhyme or reason.</p>
<p><strong>Is there a trick to recovering multiple integer values from recursive calls
in a for loop?</strong> It works fine with both my minimax and negamax
implementations, but alpha-beta pruning seems to produce some strange results.</p>
<div class="code"><pre class="code literal-block"><span class="nv">@Override</span>
<span class="k">public</span><span class="w"> </span><span class="n">GameState</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="k">Integer</span><span class="p">.</span><span class="n">MAX_VALUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GameTreeNode</span><span class="p">(</span><span class="k">state</span><span class="p">);</span>
<span class="w">    </span><span class="n">GameState</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">bestMove</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">plyDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bestScore</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">            </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bestMove</span><span class="p">;</span>
<span class="err">}</span>

<span class="n">private</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">currentNode</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="k">depth</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">depth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">terminalNode</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">()))</span><span class="w"> </span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getHeuristic</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">());</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">().</span><span class="n">getCurrentPlayer</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">selfColor</span><span class="p">))</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">currentNode</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="k">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span>
<span class="w">            </span><span class="err">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">beta</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">currentNode</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="k">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span>
<span class="w">            </span><span class="err">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">beta</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
<span class="o">//</span><span class="n">Checks</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">terminal</span>
<span class="n">private</span><span class="w"> </span><span class="k">boolean</span><span class="w"> </span><span class="n">terminalNode</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span>
<span class="err">{</span>
<span class="k">if</span><span class="p">(</span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">win</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">lose</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">draw</span><span class="p">))</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>You already fixed your problem, but the problem you encountered is pretty
common. So whenever you build a part of the algorithm for an AI agent, you
have to test it properly. So once your minimax algorithm is correct, you can
just generate many random trees and check whether the results are the same.
For example in python you can do this in this way:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Node</span><span class="p">()</span><span class="err">:</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">children</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">data</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">children</span>

<span class="n">def</span><span class="w"> </span><span class="n">generateTree</span><span class="p">(</span><span class="k">depth</span><span class="p">,</span><span class="w"> </span><span class="n">branching</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">branching</span><span class="o">**</span><span class="k">depth</span>
<span class="w">    </span><span class="k">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">randint(-100, 100) for _ in xrange(total)</span><span class="o">]</span>
<span class="w">    </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">Node(values[i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="err">[]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="err">]</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="k">depth</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">branching</span>
<span class="w">        </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">Node(None, level[i * branching: (i+1) * branching</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="err">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">level</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">values</span>
</pre></div>

<p>Now you can generate a tree with many random trees and compare the results.</p>
<div class="code"><pre class="code literal-block">tree, values = generateTree(depth, branching)
print negamax(tree, depth, 1) == alpha_beta_negamax(tree, depth, float('-inf'), float('inf'), 1)
</pre></div>

<hr>
<p>Do not forget that minimax and alpha-beta return just the best value, whereas
what you are interested in a real game is a move. It is straightforward to
modify them in such a way that they can return a move, but this is up to a
developer to decide how the move is returned. This is because there can be
many moves that lead to the best solution (you can return the first one, last
one or the most common one is to find all the moves and to return the random
one).</p>
<p>In your case the problem was with the randomness of the returned values, so
during the testing the good approach is to fix randomness.</p>
<p><br></p>
<h3>Suggest</h3>
<p>On March 16, 2013, sage88 asked:</p>
<blockquote>
<p><strong>Is there a trick to recovering multiple integer values from recursive
calls in a for loop?</strong> It works fine with both my minimax and negamax
implementations, but alpha-beta pruning seems to produce some strange
results.</p>
</blockquote>
<p>In alpha beta pruning, the only output value of interest is a node's score:
the final value of beta in a min node is considered for the alpha value of its
parent max node; likewise, the final value of alpha in a max node is
considered for the beta value of its parent min node. Therefore:</p>
<p><strong>The answer to your question is the algorithm itself, as it's the most
relevant trick.</strong></p>
<p>That said, there are two errors in your implementation: 1) As Adrian Blackburn
originally pointed out, it's incorrectly returning alpha from a min node and
vice-versa, thereby skewing its accuracy; 2) It's giving up pruning
opportunities by prematurely considering the parent alpha or beta in the
current node's value. This version fixes the return values and maximizes
pruning:</p>
<div class="code"><pre class="code literal-block"><span class="nv">private</span><span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">currentNode</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">depth</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">beta</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">depth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">terminalNode</span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">()))</span><span class="w"> </span>{
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">getHeuristic</span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">())</span><span class="c1">;</span>
<span class="w">    </span>}
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">()</span>.<span class="nv">getCurrentPlayer</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">selfColor</span><span class="ss">))</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">int</span><span class="w"> </span><span class="nv">currentAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nv">INFINITY</span><span class="c1">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span>:<span class="w"> </span><span class="nv">currentNode</span>.<span class="nv">getChildren</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">currentAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">max</span><span class="ss">(</span><span class="nv">currentAlpha</span>,<span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">child</span>,<span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">beta</span><span class="ss">))</span><span class="c1">;</span>
<span class="w">            </span><span class="nv">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">max</span><span class="ss">(</span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">currentAlpha</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nv">beta</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nv">alpha</span><span class="c1">;</span>
<span class="w">            </span>}
<span class="w">        </span>}
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">currentAlpha</span><span class="c1">;</span>
<span class="w">    </span>}
<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">currentBeta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">INFINITY</span><span class="c1">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span>:<span class="w"> </span><span class="nv">currentNode</span>.<span class="nv">getChildren</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">currentBeta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">min</span><span class="ss">(</span><span class="nv">currentBeta</span>,<span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">child</span>,<span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">beta</span><span class="ss">))</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">min</span><span class="ss">(</span><span class="nv">beta</span>,<span class="w"> </span><span class="nv">currentBeta</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">beta</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">alpha</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nv">beta</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">    </span>}
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">currentBeta</span><span class="c1">;</span>
}
</pre></div>

<p>Thanks for contributing a fun and interesting question :)</p>
<p>For more fun, here's a clarification of your <code>move()</code> method, removing a
redundant call to <code>Math.max()</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nv">@Override</span>
<span class="k">public</span><span class="w"> </span><span class="n">GameState</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">GameState</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GameTreeNode</span><span class="p">(</span><span class="k">state</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">plyDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">bestScore</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">null</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">            </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bestMove</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>Finally (even more fun), just a suggestion, a method name change to clarify
the intent of <code>terminalNode()</code>, though I would move this into <code>GameState</code> so
it could be called with no parameters:</p>
<div class="code"><pre class="code literal-block"><span class="nv">private</span><span class="w"> </span><span class="nv">boolean</span><span class="w"> </span><span class="nv">isTerminal</span><span class="ss">(</span><span class="nv">GameState</span><span class="w"> </span><span class="nv">state</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="o">//</span><span class="k">return</span><span class="w"> </span><span class="nv">Is</span>.<span class="nv">any</span><span class="ss">(</span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>,<span class="w"> </span><span class="nv">win</span>,<span class="w"> </span><span class="nv">lose</span>,<span class="w"> </span><span class="nv">draw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">win</span><span class="ss">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">lose</span><span class="ss">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">draw</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/monte-carlo-tree-search-implementation-for-tic-tac-toe/" class="u-url">Monte Carlo Tree Search: Implementation for Tic-Tac-Toe</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/monte-carlo-tree-search-implementation-for-tic-tac-toe/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:01:39+08:00" itemprop="datePublished" title="2023-02-28 03:01">2023-02-28 03:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Edit: Uploded the full source code if you want to see if you can get the AI to
perform better: https://www.dropbox.com/s/ous72hidygbnqv6/MCTS_TTT.rar</p>
<p>Edit: The search space is searched and moves resulting in losses are found.
But moves resulting in losses are not visited very often due to the UCT
algorithm.</p>
<p>To learn about MCTS (Monte Carlo Tree Search) I've used the algorithm to make
an AI for the classic game of tic-tac-toe. I have implemented the algorithm
using the following design:</p>
<p><img alt="MCTS stages" src="images/EieiQ.png"> The tree policy is based on UCT and the
default policy is to perform random moves until the game ends. What I have
observed with my implementation is that the computer sometimes makes
errorneous moves because it fails to "see" that a particular move will result
in a loss directly.</p>
<p>For instance: <img alt="Tic Tac Toe example" src="images/qxgJQ.png"> Notice how the action
6 (red square) is valued slightly higher than the blue square and therefore
the computer marks this spot. I think this is because the game policy is based
on random moves and therefore a good chance exist that the human will not put
a "2" in the blue box. And if the player does not put a 2 in the blue box, the
computer is gaurenteed a win.</p>
<p><strong>My Questions</strong></p>
<p>1) Is this a known issue with MCTS or is it a result of a failed
implementation?</p>
<p>2) What could be possible solutions? I'm thinking about confining the moves in
the selection phase but I'm not sure :-)</p>
<p>The code for the core MCTS:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">//</span><span class="n">THE</span><span class="w"> </span><span class="n">EXECUTING</span><span class="w"> </span><span class="k">FUNCTION</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">unsafe</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">GetBestMove</span><span class="p">(</span><span class="n">Game</span><span class="w"> </span><span class="n">game</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">player</span><span class="p">,</span><span class="w"> </span><span class="n">TreeView</span><span class="w"> </span><span class="n">tv</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>

<span class="w">        </span><span class="o">//</span><span class="n">Setup</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">initial</span><span class="w"> </span><span class="n">variables</span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="n">player</span><span class="p">));</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">startPlayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">player</span><span class="p">;</span>

<span class="w">        </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">);</span>

<span class="w">        </span><span class="o">//</span><span class="n">four</span><span class="w"> </span><span class="nl">phases</span><span class="p">:</span><span class="w"> </span><span class="n">descent</span><span class="p">,</span><span class="w"> </span><span class="n">roll</span><span class="o">-</span><span class="k">out</span><span class="p">,</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">growth</span><span class="w"> </span><span class="n">done</span><span class="w"> </span><span class="n">iteratively</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">times</span>
<span class="w">        </span><span class="o">//-----------------------------------------------------------------------------------------------------</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">iteration</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Selection</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">game</span><span class="p">);</span>
<span class="w">            </span><span class="nc">int</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rollout</span><span class="p">(</span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">game</span><span class="p">,</span><span class="w"> </span><span class="n">startPlayer</span><span class="p">);</span>
<span class="w">            </span><span class="k">Update</span><span class="p">(</span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">);</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="o">//</span><span class="k">Restore</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">highest</span><span class="w"> </span><span class="k">value</span>
<span class="w">        </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>

<span class="w">        </span><span class="o">//</span><span class="n">Draw</span><span class="w"> </span><span class="n">tree</span>
<span class="w">        </span><span class="n">DrawTree</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">);</span>

<span class="w">        </span><span class="o">//</span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="k">Aggregate</span><span class="p">((</span><span class="n">i1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">i1</span><span class="p">.</span><span class="n">visits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i2</span><span class="p">.</span><span class="n">visits</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">i2</span><span class="p">).</span><span class="k">action</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">BestChildUCB</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="k">action</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="n">#1</span><span class="p">.</span><span class="w"> </span><span class="k">Select</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="n">feasible</span><span class="w"> </span><span class="n">moves</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">terminal</span><span class="w"> </span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">Selection</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">Game</span><span class="w"> </span><span class="n">game</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="err">!</span><span class="n">game</span><span class="p">.</span><span class="n">IsTerminal</span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">))</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">List</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span><span class="w"> </span><span class="n">validMoves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">game</span><span class="p">.</span><span class="n">GetValidMoves</span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">validMoves</span><span class="p">.</span><span class="nf">Count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="nf">Count</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">Expand</span><span class="p">(</span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">game</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="k">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BestChildUCB</span><span class="p">(</span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="mf">1.44</span><span class="p">);</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">current</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="n">#1</span><span class="p">.</span><span class="w"> </span><span class="n">Helper</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">BestChildUCB</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="k">double</span><span class="w"> </span><span class="n">C</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="n">bestChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">double</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">double</span><span class="p">.</span><span class="n">NegativeInfinity</span><span class="p">;</span>

<span class="w">        </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="n">children</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="k">double</span><span class="w"> </span><span class="n">UCB1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="k">double</span><span class="p">)</span><span class="n">child</span><span class="p">.</span><span class="k">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="p">)</span><span class="n">child</span><span class="p">.</span><span class="n">visits</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">((</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">Log</span><span class="p">((</span><span class="k">double</span><span class="p">)</span><span class="k">current</span><span class="p">.</span><span class="n">visits</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="p">)</span><span class="n">child</span><span class="p">.</span><span class="n">visits</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UCB1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">best</span><span class="p">)</span>
<span class="w">            </span><span class="err">{</span>
<span class="w">                </span><span class="n">bestChild</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">;</span>
<span class="w">                </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UCB1</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bestChild</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="n">#2</span><span class="p">.</span><span class="w"> </span><span class="n">Expand</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">creating</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">returning</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">node</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">Expand</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">Game</span><span class="w"> </span><span class="n">game</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="n">Copy</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">game</span>
<span class="w">        </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">,</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>

<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span><span class="w"> </span><span class="n">validMoves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">game</span><span class="p">.</span><span class="n">GetValidMoves</span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">validMoves</span><span class="p">.</span><span class="nf">Count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="o">//</span><span class="n">We</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">evaluated</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">move</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="ow">Exists</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="k">action</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">validMoves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">))</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>

<span class="w">            </span><span class="nc">int</span><span class="w"> </span><span class="n">playerActing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="n">PlayerTookAction</span><span class="p">);</span>

<span class="w">            </span><span class="n">Node</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">validMoves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">playerActing</span><span class="p">);</span>
<span class="w">            </span><span class="k">current</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="k">Add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

<span class="w">            </span><span class="o">//</span><span class="n">Do</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">save</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="n">node</span>
<span class="w">            </span><span class="n">game</span><span class="p">.</span><span class="n">Mark</span><span class="p">(</span><span class="n">playerActing</span><span class="p">,</span><span class="w"> </span><span class="n">validMoves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">            </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="k">state</span><span class="p">,</span><span class="w"> </span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">);</span>

<span class="w">            </span><span class="o">//</span><span class="k">Return</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="k">state</span>
<span class="w">            </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">,</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">Exception</span><span class="p">(</span><span class="ss">"Error"</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="n">#3</span><span class="p">.</span><span class="w"> </span><span class="n">Roll</span><span class="o">-</span><span class="k">out</span><span class="p">.</span><span class="w"> </span><span class="n">Simulate</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">game</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">value</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">Rollout</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="n">Game</span><span class="w"> </span><span class="n">game</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">startPlayer</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">Random</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Random</span><span class="p">(</span><span class="mi">1337</span><span class="p">);</span>
<span class="w">        </span><span class="n">helper</span><span class="p">.</span><span class="n">CopyBytes</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">board</span><span class="p">,</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="k">state</span><span class="p">);</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">player</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="k">current</span><span class="p">.</span><span class="n">PlayerTookAction</span><span class="p">);</span>

<span class="w">        </span><span class="o">//</span><span class="n">Do</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">policy</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">winner</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">found</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="p">(</span><span class="n">change</span><span class="vm">?</span><span class="p">)</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">added</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GetWinner</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="o">//</span><span class="n">Random</span>
<span class="w">            </span><span class="n">List</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">game</span><span class="p">.</span><span class="n">GetValidMoves</span><span class="p">();</span>
<span class="w">            </span><span class="n">byte</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">moves</span><span class="o">[</span><span class="n">r.Next(0, moves.Count)</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">game</span><span class="p">.</span><span class="n">Mark</span><span class="p">(</span><span class="n">player</span><span class="p">,</span><span class="w"> </span><span class="n">move</span><span class="p">);</span>
<span class="w">            </span><span class="n">player</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="n">player</span><span class="p">);</span>
<span class="w">        </span><span class="err">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GetWinner</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">startPlayer</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="n">#4</span><span class="p">.</span><span class="w"> </span><span class="k">Update</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">unsafe</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="k">Update</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="k">current</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="k">value</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">do</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="k">current</span><span class="p">.</span><span class="n">visits</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">current</span><span class="p">.</span><span class="k">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">value</span><span class="p">;</span>
<span class="w">            </span><span class="k">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">current</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">null</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Ok, I solved the problem by adding the code:</p>
<div class="code"><pre class="code literal-block"><span class="w">        </span><span class="c1">//If this move is terminal and the opponent wins, this means we have </span>
<span class="w">        </span><span class="c1">//previously made a move where the opponent can always find a move to win.. not good</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GetWinner</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="n">startPlayer</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">current</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">int</span><span class="p">.</span><span class="n">MinValue</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>

<p>I think the problem was that the search space was too small. This ensures that
even if selection does select a move that is actually terminal, this move is
never chosen and resource are used to explore other moves instead :).</p>
<p>Now the AI vs AI always plays tie and the Ai is impossible to beat as human
:-)</p>
<p><br></p>
<h3>Suggest</h3>
<p>Ok, I solved the problem by adding the code:</p>
<div class="code"><pre class="code literal-block"><span class="w">        </span><span class="c1">//If this move is terminal and the opponent wins, this means we have </span>
<span class="w">        </span><span class="c1">//previously made a move where the opponent can always find a move to win.. not good</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GetWinner</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Opponent</span><span class="p">(</span><span class="n">startPlayer</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">current</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">int</span><span class="p">.</span><span class="n">MinValue</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</pre></div>

<p>I think the problem was that the search space was too small. This ensures that
even if selection does select a move that is actually terminal, this move is
never chosen and resource are used to explore other moves instead :).</p>
<p>Now the AI vs AI always plays tie and the Ai is impossible to beat as human
:-)</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/designing-a-twenty-questions-algorithm/" class="u-url">Designing a twenty questions algorithm</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/designing-a-twenty-questions-algorithm/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:01:17+08:00" itemprop="datePublished" title="2023-02-28 03:01">2023-02-28 03:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am interested in writing a twenty questions algorithm similar to what
akinator and, to a lesser extent, 20q.net uses. The latter seems to focus more
on objects, explicitly telling you not to think of persons or places. One
could say that akinator is more general, allowing you to think of literally
anything, including abstractions such as "my brother".</p>
<p>The problem with this is that I don't know what algorithm these sites use, but
from what I read they seem to be using a probabilistic approach in which
questions are given a certain fitness based on how many times they have lead
to correct guesses. This SO question presents several techniques, but rather
vaguely, and I would be interested in more details.</p>
<p>So, what could be an accurate and efficient algorithm for playing twenty
questions?</p>
<p>I am interested in details regarding:</p>
<ol>
<li>What question to ask next.</li>
<li>How to make the best guess at the end of the 20 questions.</li>
<li>How to insert a new object and a new question into the database.</li>
<li>How to query (1, 2) and update (3) the database efficiently.</li>
</ol>
<p>I realize this may not be easy and I'm not asking for code or a 2000 words
presentation. Just a few sentences about each operation and the underlying
data structures should be enough to get me started.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Update, 10+ years later</strong></p>
<p>I'm now hosting a (WIP, but functional) implementation here:
https://twentyq.evobyte.org/ with the code here: https://github.com/evobyte-
apps/open-20-questions. It's based on the same rough idea listed below.</p>
<hr>
<p>Well, over three years later, I did it (although I didn't work full time on
it). I hosted a crude implementation at
http://twentyquestions.azurewebsites.net/ if anyone is interested (please
don't teach it too much wrong stuff yet!).</p>
<p>It wasn't that hard, but I would say it's the non-intuitive kind of not hard
that you don't immediately think of. My methods include some trivial fitness-
based ranking, ideas from reinforcement learning and a round-robin method of
scheduling new questions to be asked. All of this is implemented on a
normalized relational database.</p>
<p>My basic ideas follow. If anyone is interested, I will share code as well,
just contact me. I plan on making it open source eventually, but once I have
done a bit more testing and reworking. So, my ideas:</p>
<ul>
<li>an <strong>Entities</strong> table that holds the characters and objects played;</li>
<li>a <strong>Questions</strong> table that holds the questions, which are also submitted by users;</li>
<li>an <strong>EntityQuestions</strong> table holds entity-question relations. This holds the number of times each answer was given for each question in relation to each entity (well, those for which the question was asked for anyway). It also has a Fitness field, used for ranking questions from "more general" down to "more specific";</li>
<li>a <strong>GameEntities</strong> table is used for ranking the entities according to the answers given so far for each on-going game. An answer of <code>A</code> to a question <code>Q</code> pushes up all the entities for which the majority answer to question <code>Q</code> is <code>A</code>;</li>
<li>The first question asked is picked from those with the highest sum of fitnesses across the <strong>EntityQuestions</strong> table;</li>
<li>Each next question is picked from those with the highest fitness associated with the currently top entries in the <code>GameEntities</code> table. Questions for which the expected answer is Yes are favored even before the fitness, because these have more chances of consolidating the current top ranked entity;</li>
<li>If the system is quite sure of the answer even before all 20 questions have been asked, it will start asking questions not associated with its answer, so as to learn more about that entity. This is done in a round-robin fashion from the global questions pool right now. <strong>Discussion:</strong> is round-robin fine, or should it be fully random?</li>
<li>Premature answers are also given under certain conditions and probabilities;</li>
<li>Guesses are given based on the rankings in <strong>GameEntities</strong>. This allows the system to account for lies as well, because it never eliminates any possibility, just decreases its likeliness of being the answer;</li>
<li>After each game, the fitness and answers statistics are updated accordingly: fitness values for entity-question associations decrease if the game was lost, and increase otherwise.</li>
</ul>
<p>I can provide more details if anyone is interested. I am also open to
collaborating on improving the algorithms and implementation.</p>
<p><br></p>
<h3>Suggest</h3>
<p>This is a very interesting question. Unfortunately I don't have a full answer,
let me just write down the ideas I could come up with in 10 minutes:</p>
<ul>
<li>If you are able to halve the set of available answers on each question, you can distinguish between 2^20 ~ 1 million "objects". Your set is probably going to be larger, so it's right to assume that sometimes you <em>have to make a guess</em>.</li>
<li>You want to maximize <em>utility</em>. Some objects are chosen more often than others. If you want to make good guesses you have to take into consideration the <em>weight</em> of each object (= the probability of that object being picked) when creating the tree.</li>
<li>If you trust a little bit of your users you can gain knowledge based on their answers. This also means that you cannot use a <em>static</em> tree to ask questions because then you'll get the answers for the same questions.. and you'll learn nothing new if you encounter with the same object.</li>
<li>If a simple question is not able to divide the set to two halves, you could combine them to get better results: eg: "is the object green <em>or</em> blue?". "green <em>or</em> has a round shape?" </li>
</ul>
</div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1394.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1392.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
