<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1384) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1384.html">
<link rel="prev" href="index-1385.html" type="text/html">
<link rel="next" href="index-1383.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/find-s-algorithm-simple-question/" class="u-url">FIND-S Algorithm - simple question</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/find-s-algorithm-simple-question/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:52:23+08:00" itemprop="datePublished" title="2023-02-28 02:52">2023-02-28 02:52</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>The FIND-S algorithm is probably one of the most simple machine learning
algorithms. However, I can't find many examples out there.. Just the standard
'sunny, rainy, play-ball' examples that's always used in machine learning.
Please could someone help me with this application (its a past exam question
in machine learning).</p>
<p>Hypotheses are of the form <code>a &lt;= x &lt;= b</code>, <code>c &lt;= y &lt;= d</code> where <code>x</code> and <code>y</code> are
points in an <code>x,y</code> plane and <code>c</code> and <code>d</code> are any integer. Basically, these
hypotheses define rectangles in the <code>x,y</code> space.</p>
<p>These are the training examples where <code>-</code> is a negative example and <code>+</code> is a
positive example and the pairs are the <code>x,y</code> co-ordinates:</p>
<div class="code"><pre class="code literal-block"> + 4, 4
 + 5, 3 
 + 6, 5 
 - 1, 3 
 - 2, 6 
 - 5, 1 
 - 5, 8 
 - 9, 4
</pre></div>

<p>All I want to do is apply FIND-S to this example! It must be simple! Either
some tips or a solution would be awesome.</p>
<p>Thank you.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Find-S seeks <strong>the most restrictive (ie most 'specific') hypothesis that fits
all the positive examples</strong> (negatives are ignored).</p>
<p>In your case, there's an obvious graphical interpretation: "find the smallest
rectangle that contains all the '+' coordinates"...</p>
<p><img alt="hypothesis space" src="images/KePIt.jpg"></p>
<p>... which would be a=4, b=6, c=3, d=5.</p>
<p>The algorithm for doing it would be something like this:</p>
<div class="code"><pre class="code literal-block"><span class="nv">Define</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">hypothesis</span><span class="w"> </span><span class="nv">rectangle</span><span class="w"> </span><span class="nv">h</span>[<span class="nv">a</span>,<span class="nv">b</span>,<span class="nv">c</span>,<span class="nv">d</span>],<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">initialise</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span>[<span class="o">-</span>,<span class="o">-</span>,<span class="o">-</span>,<span class="o">-</span>]
<span class="k">for</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">example</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">within</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">enlarge</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">be</span><span class="w"> </span><span class="nv">just</span><span class="w"> </span><span class="nv">big</span><span class="w"> </span><span class="nv">enough</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">hold</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="ss">(</span><span class="nv">and</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">previous</span><span class="w"> </span><span class="nv">e</span><span class="err">'s)</span>
<span class="err">    } else { do nothing: h already contains e }</span>
<span class="err">}</span>
</pre></div>

<p>If we step through this with your training set, we get:</p>
<div class="code"><pre class="code literal-block"> 0. h = [-,-,-,-] // initial value
 1. h = [4,4,4,4] // (4,4) is not in h: change h so it just contains (4,4)
 2. h = [4,5,3,4] // (5,3) is not in h, so enlarge h to fit (4,4) and (5,3)
 3. h = [4,6,3,5] // (6,5) is not in h, so enlarge again
 4. // no more positive examples left, so we're done.
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/applying-machine-learning-to-a-guessing-game/" class="u-url">Applying machine learning to a guessing game?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/applying-machine-learning-to-a-guessing-game/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:52:06+08:00" itemprop="datePublished" title="2023-02-28 02:52">2023-02-28 02:52</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have a problem with a game I am making. I think I know the solution(or what
solution to apply) but not sure how all the ‘pieces’ fit together.</p>
<p><strong>How the game works:</strong></p>
<p>(from How to approach number guessing game(with a twist) algorithm? )</p>
<p>users will be given items with a value(values change every day and the program
is aware of the change in price). For example</p>
<div class="code"><pre class="code literal-block">Apple = 1
Pears = 2
Oranges  = 3
</pre></div>

<p>They will then get a chance to choose any combo of them they like (i.e. 100
apples, 20 pears, and 1 oranges). The only output the computer gets is the
total value(in this example, its currently $143). The computer will try to
guess what they have. Which obviously it won’t be able to get correctly the
first turn.</p>
<div class="code"><pre class="code literal-block">         Value  quantity(day1)  value(day1)
Apple    1      100             100
Pears    2      20              40
Orange   3      1               3
Total           121             143
</pre></div>

<p>The next turn the user can modify their numbers but no more than 5% of the
total quantity (or some other percent we may chose. I’ll use 5% for example.).
The prices of fruit can change(at random) so the total value may change based
on that also(for simplicity I am not changing fruit prices in this example).
Using the above example, on day 2 of the game, the user returns a value of
$152 and $164 on day 3. Here's an example.</p>
<div class="code"><pre class="code literal-block">quantity(day2)  %change(day2)   value(day2) quantity(day3)  %change(day3)   value(day3)
104                             104         106                             106
21                              42          23                              46
2                               6           4                               12
127             4.96%           152         133             4.72%           164
</pre></div>

<p>*(I hope the tables show up right, I had to manually space them so hopefully its not just doing it on my screen, if it doesn't work let me know and I'll try to upload a screenshot).</p>
<p>I am trying to see if I can figure out what the quantities are over
time(assuming the user will have the patience to keep entering numbers). I
know right now my only restriction is the total value cannot be more than 5%
so I cannot be within 5% accuracy right now so the user will be entering it
forever.</p>
<p><strong>What I have done so far:</strong></p>
<p>I have taken all the values of the fruit and total value of fruit basket
that’s given to me and created a large table of all the possibilities. Once I
have a list of all the possibilities I used graph theory and created nodes for
each possible solution. I then create edges(links) between nodes from each
day(for example day1 to day2) if its within 5% change. I then delete all nodes
that do not have edges(links to other nodes), and as the user keeps playing I
also delete entire paths when the path becomes a dead end. This is great
because it narrows the choices down, but now I’m stuck because I want to
narrow these choices even more. I’ve been told this is a hidden markov problem
but a trickier version because the states are changing(as you can see above
new nodes are being added every turn and old/non-probable ones are being
removed).</p>
<p><strong> if it helps, I got a amazing answer(with sample code) on a python
implementation of the baum-welch model(its used to train the data) here:
Example of implementation of Baum-Welch </strong></p>
<p><strong>What I think needs to be done(this could be wrong):</strong></p>
<p>Now that I narrowed the results down, I am basically trying to allow the
program to try to predict the correct based the narrowed result base. I
thought this was not possible but several people are suggesting this can be
solved with a hidden markov model. I think I can run several iterations over
the data(using a Baum-Welch model) until the probabilities stabilize(and
should get better with more turns from the user). The way hidden markov models
are able to check spelling or handwriting and improve as they make
errors(errors in this case is to pick a basket that is deleted upon the next
turn as being improbable).</p>
<p><strong>Two questions:</strong></p>
<ol>
<li>
<p>How do I figure out the transition and emission matrix if all states are at first equal? For example, as all states are equally likely something must be used to dedicate the probability of states changing. I was thinking of using the graph I made to weight the nodes with the highest number of edges as part of the calculation of transition/emission states? Does that make sense or is there a better approach?</p>
</li>
<li>
<p>How can I keep track of all the changes in states? As new baskets are added and old ones are removed, there becomes an issue of tracking the baskets. I though an Hierarchical Dirichlet Process hidden markov model(hdp-hmm) would be what I needed but not exactly sure how to apply it.</p>
</li>
</ol>
<p>(sorry if I sound a bit frustrated..its a bit hard knowing a problem is
solvable but not able to conceptually grasp what needs to be done).</p>
<p>As always, thanks for your time and any advice/suggestions would be greatly
appreciated.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Like you've said, this problem can be described with a HMM. You are
essentially interested in maintaining a distribution over latent, or hidden,
states which would be the true quantities at each time point. However, it
seems you are confusing the problem of learning the parameters for a HMM
opposed to simply doing inference in a known HMM. You have the latter problem
but propose employing a solution (Baum-Welch) designed to do the former. That
is, you have the model already, you just have to use it.</p>
<p>Interestingly, if you go through coding a discrete HMM for your problem you
get an algorithm very similar to what you describe in your graph-theory
solution. The big difference is that your solution is tracking what is
<strong>possible</strong> whereas a correct inference algorithm, like the Virterbi
algorithm, will track what is <strong>likely</strong>. The difference is clear when there
is overlap in the 5% range on a domain, that is, when multiple possible states
could potentially transition to the same state. Your algorithm might add 2
edges to a point, but I doubt that when you compute the next day that has an
effect (it should count twice, essentially).</p>
<p>Anyway, you could use the Viterbi algortihm, if you are only interested in the
best guess at the most recent day I'll just give you a brief idea how you can
just modify your graph-theory solution. Instead of maintaining edges between
states maintain a fraction representing the probability that state is the
correct one (this distribution is sometimes called the belief state). At each
new day, propagate forward your belief state by incrementing each bucket by
the probability of it's parent (instead of adding an edge your adding a
floating point number). You also have to make sure your belief state is
properly normalized (sums to 1) so just divide by its sum after each update.
After that, you can weight each state by your observation, but since you don't
have a noisy observation you can just go and set all the impossible states to
being zero probability and then re-normalize. You now have a distribution over
underlying quantities conditioned on your observations.</p>
<p>I'm skipping over a lot of statistical details here, just to give you the
idea.</p>
<p>Edit (re: questions): The answer to your question really depends on what you
want, if you want only the distribution for the <em>most recent day</em> then you can
get away with a one-pass algorithm like I've described. If, however, you want
to have the correct distribution over the quantities at <em>every single day</em>
you're going to have to do a backward pass as well. Hence, the aptly named
forward-backward algorithm. I get the sense that since you are looking to go
back a step and delete edges then you probably want the distribution for all
days (unlike I originally assumed). Of course, you noticed there is
information that can be used so that the "future can inform the past" so to
speak, and this is exactly the reason why you need to do the backward pass as
well, it's not really complicated you just have to run the exact same
algorithm starting at the end of the chain. For a good overview check out
Christopher Bishop's 6-piece tutorial on videolectures.net.</p>
<p>Because you mentioned adding/deleting edges let me just clarify the algorithm
I described previously, keep in mind this is for a single forward pass. Let
there be a total of N possible permutations of quantities, so you will have a
belief state that is a <strong>sparse</strong> vector N elements long (called v_0). The
first step you receive a observation of the sum, and you populate the vector
by setting all the possible values to have probability 1.0, then re-normalize.
The next step you create a new sparse vector (v_1) of all 0s, iterate over all
non-zero entries in v_0 and increment (by the probability in v_0) all entries
in v_1 that are within 5%. Then, zero out all the entries in v_1 that are not
possible according to the new observation, then re-normalize v_1 and throw
away v_0. repeat forever, v_1 will always be the correct distribution of
possibilities.</p>
<p>By the way, things can get way more complex than this, if you have noisy
observations or very large states or continuous states. For this reason it's
pretty hard to read some of the literature on statistical inference; it's
quite general.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-is-the-difference-between-monotonicity-and-the-admissibility-of-a-heuristic/" class="u-url">What is the difference between monotonicity and the admissibility of a heuristic?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-is-the-difference-between-monotonicity-and-the-admissibility-of-a-heuristic/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:51:45+08:00" itemprop="datePublished" title="2023-02-28 02:51">2023-02-28 02:51</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm reading over my AI textbook and I'm curious about what the difference is
between monotonicity and admissibility of heuristics (I know they aren't
mutually exclusive).</p>
<p>As far as I can tell, an admissible heuristic simply means you are ensured to
get the shortest path to a solution if one exists.</p>
<p>What I'm struggling with is the concept of the monotonic property. Can someone
describe this to me in a way I might understand?</p>
<p>Similarly, how can I determine if a given heuristic is monotonic/admissible?
One of the examples given in the book is the 8-Piece Sliding Puzzle. One
heuristic I'm considering is the # of out of place tiles, and intuitively I
can say that I know that it is admissible but I have no formal way of showing
if it is admissible/monotonic.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Russel and Norvig, 2ed page 99 says:</p>
<blockquote>
<p>The second solution is to ensure that the optimal path to any repeated state
is always the first one followed -- as is the case with uniform-cost search.
This property holds if we impose an extra requirement on <code>h(n)</code>, namely the
requirement of <strong>consistency</strong> (also called <strong>monotonicity</strong> ).</p>
</blockquote>
<p>When you're talking about functions, monotone means that a function increases
or decreases, but not both. In other words, the ordering in the range stays
the same throughout the domain. For this reason in your problem, the solution
maintains the shortest path no matter what step you start at.</p>
<p>The <strong>admissibility</strong> property of a heuristic means that <em>the cost to reach
the goal is never overestimated (i.e. it's optimistic)</em> (page 98).</p>
<p><br></p>
<h3>Suggest</h3>
<p>Admissibility :</p>
<p>A search algorithm is admissible if it is guaranteed to find a minimal path to
a solution whenever such a solution exists. Breadth first search is
admissible, because it looks at every state at level n before considering any
state at level n+1.</p>
<p>Monotonicity : This property asks if an algorithm is locally admissible---that
is, it always underestimates the cost between any two states in the search
space. Recall that A<em> does not require that g(n) = g</em>(n). A heuristic
function, h is monotone if: 1.For all states ni and nj, where nj is a
descendant of ni, h(ni) - h(nj) &lt;= cost(ni,nj).</p>
<p>2.The heuristic evaluation of the goal state is 0: h(Goal) = 0.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1385.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1383.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
