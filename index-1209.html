<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1209) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1209.html">
<link rel="prev" href="index-1210.html" type="text/html">
<link rel="next" href="index-1208.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-are-the-main-differences-between-jwt-and-oauth-authentication/" class="u-url">What are the main differences between JWT and OAuth authentication?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-are-the-main-differences-between-jwt-and-oauth-authentication/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:52:09+08:00" itemprop="datePublished" title="2023-02-18 03:52">2023-02-18 03:52</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I have a new SPA with a stateless authentication model using JWT. I am often
asked to refer OAuth for authentication flows like asking me to send 'Bearer
tokens' for every request instead of a simple token header but I do think that
OAuth is a lot more complex than a simple JWT based authentication. What are
the main differences, should I make the JWT authentication behave like OAuth?</p>
<p>I am also using the JWT as my XSRF-TOKEN to prevent XSRF but I am being asked
to keep them separate? Should I keep them separate? Any help here will be
appreciated and might lead to a set of guidelines for the community.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>TL;DR</strong> If you have very simple scenarios, like a single client application,
a single API then it might not pay off to go OAuth 2.0. On the other hand, if
there are lots of different clients (browser-based, native mobile, server-
side, etc) then sticking to OAuth 2.0 rules might make it more manageable than
trying to roll your own system.</p>
<hr>
<p>As stated in another answer, JWT (Learn JSON Web Tokens) is just a token
format. It defines a compact and self-contained mechanism for transmitting
data between parties in a way that can be verified and trusted because it is
digitally signed. Additionally, the encoding rules of a JWT also make these
tokens very easy to use within the context of HTTP.</p>
<p>Being self-contained (the actual token contains information about a given
subject), they are also a good choice for implementing stateless
authentication mechanisms (aka <em>Look mum, no sessions!</em> ). When going this
route, the only thing a party must present to be granted access to a protected
resource is the token itself, and the token in question can be called a bearer
token.</p>
<p>In practice, what you're doing can already be classified as bearer token
-based. However, do consider you're not using bearer tokens as specified by
the OAuth 2.0 related specs (see RFC 6750). That would imply relying on the
<code>Authorization</code> HTTP header and using the <code>Bearer</code> authentication scheme.</p>
<p>Regarding the use of the JWT to prevent CSRF: Without knowing exact details
it's difficult to ascertain the validity of that practice. To be honest, it
does not seem correct and/or worthwhile. The following article (Cookies vs
Tokens: The Definitive Guide) may be a useful read on this subject,
particularly the <em>XSS and XSRF Protection</em> section.</p>
<p>One final piece of advice. Even if you don't need to go full OAuth 2.0, I
<strong>would strongly recommend on passing your access token within
the<code>Authorization</code> header instead of going with custom headers</strong>. If they are
really bearer tokens, follow the rules of RFC 6750. If not, you can always
create a custom authentication scheme and still use that header.</p>
<blockquote>
<p>Authorization headers are recognized and specially treated by HTTP proxies
and servers. Thus, the usage of such headers for sending access tokens to
resource servers reduces the likelihood of leakage or unintended storage of
authenticated requests in general, and especially Authorization headers.</p>
</blockquote>
<p>(source: RFC 6819, section 5.4.1)</p>
<p><br></p>
<h3>Suggest</h3>
<p>OAuth 2.0 defines a protocol, i.e. specifies how tokens are transferred, JWT
defines a token format.</p>
<p>OAuth 2.0 and "JWT authentication" have similar appearance when it comes to
the (2nd) stage where the Client presents the token to the Resource Server:
the token is passed in a header.</p>
<p>But "JWT authentication" is not a standard and does not specify <em>how</em> the
Client obtains the token in the first place (the 1st stage). That is where the
perceived complexity of OAuth comes from: it also defines various ways in
which the Client can <em>obtain</em> an access token from something that is called an
Authorization Server.</p>
<p>So the real difference is that JWT is just a token format, OAuth 2.0 is a
protocol (that <em>may</em> use a JWT as a token format).</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-clear-the-nuget-package-cache-using-the-command-line/" class="u-url">How can I clear the NuGet package cache using the command line?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-clear-the-nuget-package-cache-using-the-command-line/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:51:43+08:00" itemprop="datePublished" title="2023-02-18 03:51">2023-02-18 03:51</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I can clear my development computer's NuGet package cache using Visual Studio
menu <em>Tools</em> → <em>Options</em> → <em>NuGet Package Manager</em> → <em>General</em> : <code>Clear
Package Cache</code> button.</p>
<p>I would like to do this on the command line. Unfortunately, I can not find a
related command line switch for nuget.exe.</p>
<p>Did I miss something?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>First, download the NuGet command line tool from here.</p>
<p>Next, open a command prompt and <code>cd</code> to the directory to which <code>nuget.exe</code> was
downloaded.</p>
<p>You can list the local caches with this command:</p>
<div class="code"><pre class="code literal-block">nuget locals all -list
</pre></div>

<p>You can clear all caches with this command:</p>
<div class="code"><pre class="code literal-block">nuget locals all -clear
</pre></div>

<p>Reference: https://docs.nuget.org/consume/command-line-reference</p>
<p><br></p>
<h3>Suggest</h3>
<p>In Visual Studio 2022, go to menu <em>Tools</em> → <em>NuGet Package Manager</em> → <em>Package
Manager Settings</em>. You may find out a button, <code>Clear All NuGet Storage</code>:</p>
<p><img alt="Button to clear NuGet package cache in Visual Studio
2022" src="images/dfthH.png"></p>
<p>The steps are similar in previous versions of Visual Studio too.</p>
<p>If you are using .NET Core, you may clear the cache with this command, which
should work as of .NET Core tools 1.0:</p>
<div class="code"><pre class="code literal-block">dotnet nuget locals all --clear
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/convert-pem-to-crt-and-key/" class="u-url">Convert .pem to .crt and .key</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/convert-pem-to-crt-and-key/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:51:18+08:00" itemprop="datePublished" title="2023-02-18 03:51">2023-02-18 03:51</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Can anyone tell me the correct way/command to extract/convert the certificate
<code>.crt</code> and private key <code>.key</code> files from a <code>.pem</code> file? I just read they are
interchangable, but not how.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I was able to convert pem to crt using this:</p>
<div class="code"><pre class="code literal-block">openssl x509 -outform der -in your-cert.pem -out your-cert.crt
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p><strong>Converting Using OpenSSL</strong></p>
<p>These commands allow you to convert certificates and keys to different formats
to make them compatible with specific types of servers or software.</p>
<ul>
<li>
<p>Convert a DER file (.crt .cer .der) to PEM</p>
<div class="code"><pre class="code literal-block">openssl x509 -inform der -in certificate.cer -out certificate.pem
</pre></div>

</li>
<li>
<p>Convert a PEM file to DER</p>
<div class="code"><pre class="code literal-block">openssl x509 -outform der -in certificate.pem -out certificate.der
</pre></div>

</li>
<li>
<p>Convert a PKCS#12 file (.pfx .p12) containing a private key and certificates to PEM</p>
<div class="code"><pre class="code literal-block">openssl pkcs12 -in keyStore.pfx -out keyStore.pem -nodes
</pre></div>

<p>You can add -nocerts to only output the private key or add -nokeys to only output the certificates.</p>
</li>
<li>
<p>Convert a PEM certificate file and a private key to PKCS#12 (.pfx .p12)</p>
<div class="code"><pre class="code literal-block"><span class="n">openssl</span><span class="w"> </span><span class="n">pkcs12</span><span class="w"> </span><span class="o">-</span><span class="k">export</span><span class="w"> </span><span class="o">-</span><span class="n">out</span><span class="w"> </span><span class="n">certificate</span><span class="o">.</span><span class="n">pfx</span><span class="w"> </span><span class="o">-</span><span class="n">inkey</span><span class="w"> </span><span class="n">privateKey</span><span class="o">.</span><span class="n">key</span><span class="w"> </span><span class="o">-</span><span class="ow">in</span><span class="w"> </span><span class="n">certificate</span><span class="o">.</span><span class="n">crt</span><span class="w"> </span><span class="o">-</span><span class="n">certfile</span><span class="w"> </span><span class="n">CACert</span><span class="o">.</span><span class="n">crt</span>
</pre></div>

</li>
<li>
<p>Convert PEM to CRT (.CRT file)</p>
<div class="code"><pre class="code literal-block">openssl x509 -outform der -in certificate.pem -out certificate.crt
</pre></div>

</li>
</ul>
<p><strong>OpenSSL Convert PEM</strong></p>
<ul>
<li>
<p>Convert PEM to DER</p>
<div class="code"><pre class="code literal-block">openssl x509 -outform der -in certificate.pem -out certificate.der
</pre></div>

</li>
<li>
<p>Convert PEM to P7B</p>
<div class="code"><pre class="code literal-block">openssl crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CACert.cer
</pre></div>

</li>
<li>
<p>Convert PEM to PFX</p>
<div class="code"><pre class="code literal-block"><span class="n">openssl</span><span class="w"> </span><span class="n">pkcs12</span><span class="w"> </span><span class="o">-</span><span class="k">export</span><span class="w"> </span><span class="o">-</span><span class="n">out</span><span class="w"> </span><span class="n">certificate</span><span class="o">.</span><span class="n">pfx</span><span class="w"> </span><span class="o">-</span><span class="n">inkey</span><span class="w"> </span><span class="n">privateKey</span><span class="o">.</span><span class="n">key</span><span class="w"> </span><span class="o">-</span><span class="ow">in</span><span class="w"> </span><span class="n">certificate</span><span class="o">.</span><span class="n">crt</span><span class="w"> </span><span class="o">-</span><span class="n">certfile</span><span class="w"> </span><span class="n">CACert</span><span class="o">.</span><span class="n">crt</span>
</pre></div>

</li>
</ul>
<p><strong>OpenSSL Convert DER</strong></p>
<ul>
<li>Convert DER to PEM<div class="code"><pre class="code literal-block">openssl x509 -inform der -in certificate.cer -out certificate.pem
</pre></div>

</li>
</ul>
<p><strong>OpenSSL Convert P7B</strong></p>
<ul>
<li>
<p>Convert P7B to PEM</p>
<div class="code"><pre class="code literal-block">openssl pkcs7 -print_certs -in certificate.p7b -out certificate.cer
</pre></div>

</li>
<li>
<p>Convert P7B to PFX</p>
<div class="code"><pre class="code literal-block">openssl pkcs7 -print_certs -in certificate.p7b -out certificate.cer
</pre></div>

<p>openssl pkcs12 -export -in certificate.cer -inkey privateKey.key -out certificate.pfx -certfile CACert.cer</p>
</li>
</ul>
<p><strong>OpenSSL Convert PFX</strong></p>
<ul>
<li>Convert PFX to PEM<div class="code"><pre class="code literal-block">openssl pkcs12 -in certificate.pfx -out certificate.cer -nodes
</pre></div>

</li>
</ul>
<p><strong>Generate rsa keys by OpenSSL</strong></p>
<ul>
<li>
<p>Using OpenSSL on the command line you’d first need to generate a public and private key, you should password protect this file using the -passout argument, there are many different forms that this argument can take so consult the OpenSSL documentation about that.</p>
<div class="code"><pre class="code literal-block">openssl genrsa -out private.pem 1024
</pre></div>

</li>
<li>
<p>This creates a key file called private.pem that uses 1024 bits. This file actually have both the private and public keys, so you should extract the public one from this file:</p>
<div class="code"><pre class="code literal-block">openssl rsa -in private.pem -out public.pem -outform PEM -pubout
</pre></div>

<p>or</p>
<p>openssl rsa -in private.pem -pubout &gt; public.pem</p>
<p>or</p>
<p>openssl rsa -in private.pem -pubout -out public.pem</p>
</li>
</ul>
<blockquote>
<p>You’ll now have public.pem containing just your public key, you can freely
share this with 3rd parties. You can test it all by just encrypting
something yourself using your public key and then decrypting using your
private key, first we need a bit of data to encrypt:</p>
</blockquote>
<ul>
<li>
<p>Example file :</p>
<div class="code"><pre class="code literal-block">echo 'too many secrets' &gt; file.txt
</pre></div>

</li>
<li>
<p>You now have some data in file.txt, lets encrypt it using OpenSSL and the public key:</p>
<div class="code"><pre class="code literal-block">openssl rsautl -encrypt -inkey public.pem -pubin -in file.txt -out file.ssl
</pre></div>

</li>
<li>
<p>This creates an encrypted version of file.txt calling it file.ssl, if you look at this file it’s just binary junk, nothing very useful to anyone. Now you can unencrypt it using the private key:</p>
<div class="code"><pre class="code literal-block">openssl rsautl -decrypt -inkey private.pem -in file.ssl -out decrypted.txt
</pre></div>

</li>
<li>
<p>You will now have an unencrypted file in decrypted.txt:</p>
<div class="code"><pre class="code literal-block">cat decrypted.txt
</pre></div>

<p>|output -&gt; too many secrets</p>
</li>
</ul>
<p><strong>RSA TOOLS Options in OpenSSL</strong></p>
<ul>
<li><strong>NAME</strong></li>
</ul>
<blockquote>
<p>rsa - RSA key processing tool</p>
</blockquote>
<ul>
<li><strong>SYNOPSIS</strong></li>
</ul>
<blockquote>
<p>openssl rsa [-help] [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in
filename] [-passin arg] [-out filename] [-passout arg] [-aes128] [-aes192]
[-aes256] [-camellia128] [-camellia192] [-camellia256] [-des] [-des3]
[-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout]
[-RSAPublicKey_in] [-RSAPublicKey_out] [-engine id]</p>
</blockquote>
<ul>
<li><strong>DESCRIPTION</strong></li>
</ul>
<blockquote>
<p>The rsa command processes RSA keys. They can be converted between various
forms and their components printed out. Note this command uses the
traditional SSLeay compatible format for private key encryption: newer
applications should use the more secure PKCS#8 format using the pkcs8
utility.</p>
</blockquote>
<ul>
<li>
<strong>COMMAND OPTIONS</strong><div class="code"><pre class="code literal-block">-help
</pre></div>

</li>
</ul>
<blockquote>
<p>Print out a usage message.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -inform DER|NET|PEM
</pre></div>

<blockquote>
<p>This specifies the input format. The DER option uses an ASN1 DER encoded
form compatible with the PKCS#1 RSAPrivateKey or SubjectPublicKeyInfo
format. The PEM form is the default format: it consists of the DER format
base64 encoded with additional header and footer lines. On input PKCS#8
format private keys are also accepted. The NET form is a format is described
in the NOTES section.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -outform DER|NET|PEM
</pre></div>

<blockquote>
<p>This specifies the output format, the options have the same meaning as the
-inform option.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -in filename
</pre></div>

<blockquote>
<p>This specifies the input filename to read a key from or standard input if
this option is not specified. If the key is encrypted a pass phrase will be
prompted for.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -passin arg
</pre></div>

<blockquote>
<p>the input file password source. For more information about the format of arg
see the PASS PHRASE ARGUMENTS section in openssl.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -out filename
</pre></div>

<blockquote>
<p>This specifies the output filename to write a key to or standard output if
this option is not specified. If any encryption options are set then a pass
phrase will be prompted for. The output filename should not be the same as
the input filename.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -passout password
</pre></div>

<blockquote>
<p>the output file password source. For more information about the format of
arg see the PASS PHRASE ARGUMENTS section in openssl.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea
</pre></div>

<blockquote>
<p>These options encrypt the private key with the specified cipher before
outputting it. A pass phrase is prompted for. If none of these options is
specified the key is written in plain text. This means that using the rsa
utility to read in an encrypted key with no encryption option can be used to
remove the pass phrase from a key, or by setting the encryption options it
can be use to add or change the pass phrase. These options can only be used
with PEM format output files.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -text
</pre></div>

<blockquote>
<p>prints out the various public or private key components in plain text in
addition to the encoded version.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -noout
</pre></div>

<blockquote>
<p>this option prevents output of the encoded version of the key.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -modulus
</pre></div>

<blockquote>
<p>this option prints out the value of the modulus of the key.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -check
</pre></div>

<blockquote>
<p>this option checks the consistency of an RSA private key.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -pubin
</pre></div>

<blockquote>
<p>by default a private key is read from the input file: with this option a
public key is read instead.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -pubout
</pre></div>

<blockquote>
<p>by default a private key is output: with this option a public key will be
output instead. This option is automatically set if the input is a public
key.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -RSAPublicKey_in, -RSAPublicKey_out
</pre></div>

<blockquote>
<p>like -pubin and -pubout except RSAPublicKey format is used instead.</p>
</blockquote>
<div class="code"><pre class="code literal-block">    -engine id
</pre></div>

<blockquote>
<p>specifying an engine (by its unique id string) will cause rsa to attempt to
obtain a functional reference to the specified engine, thus initialising it
if needed. The engine will then be set as the default for all available
algorithms.</p>
</blockquote>
<ul>
<li><strong>NOTES</strong></li>
</ul>
<p>The PEM private key format uses the header and footer lines:</p>
<div class="code"><pre class="code literal-block">    <span class="o">-----</span><span class="kr">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>

<span class="o">-----</span><span class="kr">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
</pre></div>

<p>The PEM public key format uses the header and footer lines:</p>
<div class="code"><pre class="code literal-block">    <span class="o">-----</span><span class="kr">BEGIN</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>

<span class="o">-----</span><span class="kr">END</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>
</pre></div>

<p>The PEM RSAPublicKey format uses the header and footer lines:</p>
<div class="code"><pre class="code literal-block">    <span class="o">-----</span><span class="kr">BEGIN</span> <span class="n">RSA</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>

<span class="o">-----</span><span class="kr">END</span> <span class="n">RSA</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>
</pre></div>

<blockquote>
<p>The NET form is a format compatible with older Netscape servers and
Microsoft IIS .key files, this uses unsalted RC4 for its encryption. It is
not very secure and so should only be used when necessary.</p>
<p>Some newer version of IIS have additional data in the exported .key files.
To use these with the utility, view the file with a binary editor and look
for the string "private-key", then trace back to the byte sequence 0x30,
0x82 (this is an ASN1 SEQUENCE). Copy all the data from this point onwards
to another file and use that as the input to the rsa utility with the
-inform NET option.</p>
</blockquote>
<p><strong>EXAMPLES</strong></p>
<p>To remove the pass phrase on an RSA private key:</p>
<div class="code"><pre class="code literal-block">     openssl rsa -in key.pem -out keyout.pem
</pre></div>

<p>To encrypt a private key using triple DES:</p>
<div class="code"><pre class="code literal-block">     openssl rsa -in key.pem -des3 -out keyout.pem
</pre></div>

<p>To convert a private key from PEM to DER format:</p>
<div class="code"><pre class="code literal-block">      openssl rsa -in key.pem -outform DER -out keyout.der
</pre></div>

<p>To print out the components of a private key to standard output:</p>
<div class="code"><pre class="code literal-block">      openssl rsa -in key.pem -text -noout
</pre></div>

<p>To just output the public part of a private key:</p>
<div class="code"><pre class="code literal-block">      openssl rsa -in key.pem -pubout -out pubkey.pem
</pre></div>

<p>Output the public part of a private key in RSAPublicKey format:</p>
<div class="code"><pre class="code literal-block">      openssl rsa -in key.pem -RSAPublicKey_out -out pubkey.pem
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1210.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1208.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
