<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 421) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-421.html">
<link rel="prev" href="index-422.html" type="text/html">
<link rel="next" href="index-420.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-nei-cun-zhong-chuang-jian-yi-ge-wen-jian-gong-yong-hu-xia-zai-er-bu-shi-tong-guo-fu-wu-qi/" class="u-url">如何在内存中创建一个文件供用户下载，而不是通过服务器？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-nei-cun-zhong-chuang-jian-yi-ge-wen-jian-gong-yong-hu-xia-zai-er-bu-shi-tong-guo-fu-wu-qi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T06:31:35+08:00" itemprop="datePublished" title="2023-02-17 06:31">2023-02-17 06:31</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>有什么办法可以在客户端创建一个文本文件并提示用户下载它，而无需与服务器进行任何交互？</p>
<p>我知道我不能直接写入他们的机器（安全和所有），但我可以创建文件并提示他们保存吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>您可以使用数据 URI。浏览器支持各不相同；参见维基百科。例子：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"data:application/octet-stream;charset=utf-16le;base64,//5mAG8AbwAgAGIAYQByAAoA"</span><span class="nt">&gt;</span>text<span class="w"> </span>file<span class="nt">&lt;/a&gt;</span>
</pre></div>

<p>八位字节流用于强制下载提示。否则，它可能会在浏览器中打开。</p>
<p>对于 CSV，您可以使用：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"data:application/octet-stream,field1%2Cfield2%0Afoo%2Cbar%0Agoo%2Cgai%0A"</span><span class="nt">&gt;</span>CSV<span class="w"> </span>Octet<span class="nt">&lt;/a&gt;</span>
</pre></div>

<p>试试jsFiddle 演示。</p>
<p><br></p>
<h3>更多建议</h3>
<p>您可以使用数据 URI。浏览器支持各不相同；参见维基百科。例子：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"data:application/octet-stream;charset=utf-16le;base64,//5mAG8AbwAgAGIAYQByAAoA"</span><span class="nt">&gt;</span>text<span class="w"> </span>file<span class="nt">&lt;/a&gt;</span>
</pre></div>

<p>八位字节流用于强制下载提示。否则，它可能会在浏览器中打开。</p>
<p>对于 CSV，您可以使用：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"data:application/octet-stream,field1%2Cfield2%0Afoo%2Cbar%0Agoo%2Cgai%0A"</span><span class="nt">&gt;</span>CSV<span class="w"> </span>Octet<span class="nt">&lt;/a&gt;</span>
</pre></div>

<p>试试jsFiddle 演示。</p>
<p><br><br><a href="posts/how-to-create-a-file-in-memory-for-user-to-download-but-not-through-server/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-chu-li-docker-zhong-de-chi-jiu-cun-chu-li-ru-shu-ju-ku/" class="u-url">如何处理 Docker 中的持久存储（例如数据库）</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-chu-li-docker-zhong-de-chi-jiu-cun-chu-li-ru-shu-ju-ku/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T06:31:06+08:00" itemprop="datePublished" title="2023-02-17 06:31">2023-02-17 06:31</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>人们如何处理 Docker 容器的持久存储？</p>
<p>我目前正在使用这种方法：构建图像，例如 PostgreSQL，然后启动容器</p>
<div class="code"><pre class="code literal-block">docker run --volumes-from c0dbc34fd631 -d app_name/postgres
</pre></div>

<p>恕我直言，这有一个缺点，就是我绝不能（意外地）删除容器“c0dbc34fd631”。</p>
<p>另一个想法是将主机卷“-v”挂载到容器中，但是，容器中的 <strong>用户标识</strong> 不一定与主机中的 <strong>用户标识</strong> 匹配，然后权限可能会混乱。</p>
<p>注意：<code>--volumes-from 'cryptic_id'</code>您也可以使用<code>--volumes-from my-data-container</code>where
<code>my-data-container</code>is a name you assigned to a data-only container，例如<code>docker
run --name my-data-container ...</code>（参见已接受的答案）</p>
<p><br><br></p>
<h2>解答</h2>
<h3>Docker 1.9.0 及以上版本</h3>
<p>使用卷 API</p>
<div class="code"><pre class="code literal-block"><span class="nv">docker</span><span class="w"> </span><span class="nv">volume</span><span class="w"> </span><span class="nv">create</span><span class="w"> </span><span class="o">--</span><span class="nv">name</span><span class="w"> </span><span class="nv">hello</span>
<span class="nv">docker</span><span class="w"> </span><span class="nv">run</span><span class="w"> </span><span class="o">-</span><span class="nv">d</span><span class="w"> </span><span class="o">-</span><span class="nv">v</span><span class="w"> </span><span class="nv">hello</span>:<span class="o">/</span><span class="nv">container</span><span class="o">/</span><span class="nv">path</span><span class="o">/</span><span class="k">for</span><span class="o">/</span><span class="nv">volume</span><span class="w"> </span><span class="nv">container_image</span><span class="w"> </span><span class="nv">my_command</span>
</pre></div>

<p>这意味着必须放弃仅数据容器模式以支持新卷。</p>
<p>实际上，卷 API 只是实现数据容器模式的更好方法。</p>
<p>如果您使用 Docker 创建一个容器，<code>-v volume_name:/container/fs/path</code>它将自动为您创建一个命名卷，它可以：</p>
<ol>
<li>通过上市<code>docker volume ls</code>
</li>
<li>通过被识别<code>docker volume inspect volume_name</code>
</li>
<li>备份为普通目录</li>
<li>
<code>--volumes-from</code>通过连接像以前一样备份</li>
</ol>
<p>新的卷 API 添加了一个有用的命令，可让您识别悬空卷：</p>
<div class="code"><pre class="code literal-block">docker volume ls -f dangling=true
</pre></div>

<p>然后通过它的名字删除它：</p>
<div class="code"><pre class="code literal-block">docker volume rm &lt;volume name&gt;
</pre></div>

<p>正如@mpugach 在评论中强调的那样，您可以使用一个漂亮的单行代码摆脱所有悬空的卷：</p>
<div class="code"><pre class="code literal-block">docker volume rm $(docker volume ls -f dangling=true -q)
# Or using 1.13.x
docker volume prune
</pre></div>

<h3>Docker 1.8.x 及以下版本</h3>
<p>似乎最适合生产的方法是使用 <strong>仅数据容器</strong> 。</p>
<p>仅数据容器在准系统图像上运行，实际上除了公开数据卷外什么都不做。</p>
<p>然后你可以运行任何其他容器来访问数据容器卷：</p>
<div class="code"><pre class="code literal-block">docker run --volumes-from data-container some-other-container command-to-execute
</pre></div>

<ul>
<li>在这里您可以很好地了解如何安排不同的容器。</li>
<li>这里有一个关于卷如何工作的很好的见解。</li>
</ul>
<p>在这篇博文中，对所谓的 <strong>容器作为卷模式有一个很好的描述，它阐明了</strong> <strong>只有数据容器</strong> 的要点。</p>
<p><strong>Docker 文档现在将容器作为 volume/s</strong> 模式的权威描述。</p>
<p>以下是 Docker 1.8.x 及以下版本的备份/恢复过程。</p>
<p><strong>备份：</strong></p>
<div class="code"><pre class="code literal-block">sudo docker run --rm --volumes-from DATA -v $(pwd):/backup busybox tar cvf /backup/backup.tar /data
</pre></div>

<ul>
<li>--rm: 退出时移除容器</li>
<li>--volumes-from DATA：附加到 DATA 容器共享的卷</li>
<li>-v $(pwd):/backup: bind 挂载当前目录到容器中；将 tar 文件写入</li>
<li>busybox：一个更简单的小图像——有利于快速维护</li>
<li>tar cvf /backup/backup.tar /data：为 /data 目录中的所有文件创建一个未压缩的 tar 文件</li>
</ul>
<p><strong>恢复：</strong></p>
<div class="code"><pre class="code literal-block"><span class="c1"># Create a new data container</span>
<span class="n">$</span><span class="w"> </span><span class="n">sudo</span><span class="w"> </span><span class="n">docker</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="o">/</span><span class="k">data</span><span class="w"> </span><span class="o">-</span><span class="k">name</span><span class="w"> </span><span class="n">DATA2</span><span class="w"> </span><span class="n">busybox</span><span class="w"> </span><span class="no">true</span>
<span class="c1"># untar the backup files into the new container᾿s data volume</span>
<span class="n">$</span><span class="w"> </span><span class="n">sudo</span><span class="w"> </span><span class="n">docker</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">rm</span><span class="w"> </span><span class="o">--</span><span class="n">volumes</span><span class="o">-</span><span class="k">from</span><span class="w"> </span><span class="n">DATA2</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="n">$</span><span class="p">(</span><span class="n">pwd</span><span class="p">)</span><span class="o">:/</span><span class="k">backup</span><span class="w"> </span><span class="n">busybox</span><span class="w"> </span><span class="n">tar</span><span class="w"> </span><span class="n">xvf</span><span class="w"> </span><span class="o">/</span><span class="k">backup</span><span class="o">/</span><span class="k">backup</span><span class="p">.</span><span class="n">tar</span>
<span class="k">data</span><span class="o">/</span>
<span class="k">data</span><span class="o">/</span><span class="n">sven</span><span class="p">.</span><span class="n">txt</span>
<span class="c1"># Compare to the original container</span>
<span class="n">$</span><span class="w"> </span><span class="n">sudo</span><span class="w"> </span><span class="n">docker</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">--</span><span class="n">rm</span><span class="w"> </span><span class="o">--</span><span class="n">volumes</span><span class="o">-</span><span class="k">from</span><span class="w"> </span><span class="k">DATA</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="n n-Quoted">`pwd`</span><span class="o">:/</span><span class="k">backup</span><span class="w"> </span><span class="n">busybox</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="o">/</span><span class="k">data</span>
<span class="n">sven</span><span class="p">.</span><span class="n">txt</span>
</pre></div>

<p>这是来自优秀的 Brian Goff 的一篇很好的文章，解释了为什么对容器和数据容器使用相同的图像是好的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>在 <strong>Docker 版本 v1.0</strong> 中，可以通过给定的命令在主机上绑定一个文件或目录的挂载：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>-v<span class="w"> </span>/host:/container<span class="w"> </span>...
</pre></div>

<p>上述卷可以用作运行 Docker 的主机上的持久存储。</p>
<p><br><br><a href="posts/how-to-deal-with-persistent-storage-e-g-databases-in-docker/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yong-pipcha-zhao-an-zhuang-liao-na-ge-ban-ben-de-bao/" class="u-url">使用pip查找安装了哪个版本的包</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yong-pipcha-zhao-an-zhuang-liao-na-ge-ban-ben-de-bao/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T06:30:22+08:00" itemprop="datePublished" title="2023-02-17 06:30">2023-02-17 06:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>使用 pip，是否可以找出当前安装的软件包版本？</p>
<p>我知道，<code>pip install XYZ --upgrade</code>但我想知道是否有类似的东西<code>pip info
XYZ</code>。如果不是，那么告诉我当前使用的版本的最佳方法是什么。</p>
<p><br><br></p>
<h2>解答</h2>
<p>从pip 1.3开始，有一个<code>pip show</code>命令。</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>pip<span class="w"> </span>show<span class="w"> </span>Jinja2
---
Name:<span class="w"> </span>Jinja2
Version:<span class="w"> </span><span class="m">2</span>.7.3
Location:<span class="w"> </span>/path/to/virtualenv/lib/python2.7/site-packages
Requires:<span class="w"> </span>markupsafe
</pre></div>

<p>在旧版本中，<code>pip freeze</code>应该<code>grep</code>能很好地完成这项工作。</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>pip<span class="w"> </span>freeze<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>Jinja2
<span class="nv">Jinja2</span><span class="o">==</span><span class="m">2</span>.7.3
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>我刚刚在 pip 中发送了一个拉取请求，其中包含 Hugo Tavares 所说的增强功能：</p>
<p>（以speccloud为例）</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>pip<span class="w"> </span>show<span class="w"> </span>specloud

Package:<span class="w"> </span>specloud
Version:<span class="w"> </span><span class="m">0</span>.4.4
Requires:
nose
figleaf
pinocchio
</pre></div>

<p><br><br><a href="posts/find-which-version-of-package-is-installed-with-pip/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-422.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-420.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
