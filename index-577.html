<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 577) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-577.html">
<link rel="prev" href="index-578.html" type="text/html">
<link rel="next" href="index-576.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/monadzhi-shi-endofunctorslei-bie-zhong-de-yi-ge-yao-ban-qun-you-shi-yao-wen-ti/" class="u-url">monad只是endofunctors类别中的一个幺半群，有什么问题？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/monadzhi-shi-endofunctorslei-bie-zhong-de-yi-ge-yao-ban-qun-you-shi-yao-wen-ti/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:34:18+08:00" itemprop="datePublished" title="2023-02-17 10:34">2023-02-17 10:34</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>下面是谁先说的？</p>
<blockquote>
<p>monad只是endofunctors类别中的一个幺半群，有什么问题？</p>
</blockquote>
<p>还有一个不太重要的注意事项，这是真的吗？如果是的话，您能否给出解释（希望那些没有太多 Haskell 经验的人能够理解）？</p>
<p><br><br></p>
<h2>解答</h2>
<p>这个特别的措辞出自 James Iry，来自他极具娱乐性的 <em>编程语言的简要、不完整和大部分错误的历史</em> ，他在其中虚构地将其归因于 Philip
Wadler。</p>
<p>原始引用来自 Saunders Mac Lane 的 <em>Categories for the Working Mathematician</em>
，这是范畴论的基础文本之一。Here it is in context，这可能是准确了解其含义的最佳位置。</p>
<p>但是，我会试一试。原句是这样的：</p>
<blockquote>
<p>总而言之，X 中的单子只是 X 的内函子范畴中的幺半群，乘积 × 由内函子的组合替换，单位由恒等内函子设置。</p>
</blockquote>
<p><em>这里的X</em> 是一个类别。内函子是从类别到自身的函子（就函数式程序员而言，通常 <em>都是s ，因为他们主要只处理一个类别；类型的类别——但我离题了）。</em>
<em>但是您可以想象另一个类别，即“ X</em><code>Functor</code>上的内函子”类别。这是一个对象是内函子而态射是自然变换的范畴。 __</p>
<p>在这些内函子中，其中一些可能是单子。哪些是单子？正是那些在特定意义上是 <em>幺半群的。</em> 我没有详细说明从单子到幺半群的确切映射（因为 Mac Lane
做得比我希望的要好得多），我只是将它们各自的定义并排放置，让你比较：</p>
<h3>一个幺半群是...</h3>
<ul>
<li>一组， _ <strong>S</strong>_</li>
<li>一个操作， _ <strong>• : S × S → S</strong>_</li>
<li>
<em>S</em> 的一个元素， _ <strong>e : 1 → S</strong>_</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li>
<em>(a • b) • c = a • (b • c)</em> ，对于 <em>S</em> 中的所有 <em>a</em> 、 <em>b</em> 和 <em>c</em> __</li>
<li>
<em>e • a = a • e = a</em> ，对于 <em>S</em> 中的所有 <em>a</em> __</li>
</ul>
<h3>一个单子是...</h3>
<ul>
<li>一个内函子， _ <strong>T : X → X</strong>_<code>* -&gt; *</code> （在 Haskell 中，是一种带有实例的类型构造函数<code>Functor</code>）</li>
<li>自然变换， _ <strong>μ : T × T → T</strong><em> ，其中 </em>×<em> 表示函子组合（ _μ</em> 在 Haskell 中称为 <em><code>join</code></em> ）</li>
<li>一个自然变换， _ <strong>η : I → T</strong><em> ，其中 _I是</em> <em>X</em> 上的身份内函子（ <em>η</em> 在 Haskell 中被称为 <em><code>return</code></em> ）</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li><em>μ ∘ Tμ = μ ∘ μT</em></li>
<li>
<em>μ ∘ Tη = μ ∘ ηT = 1</em> （恒等式自然变换）</li>
</ul>
<p>稍微眯着眼睛，您可能会发现这两个定义都是同一个抽象概念的实例。</p>
<p><br></p>
<h3>更多建议</h3>
<p>首先，我们将要使用的扩展和库：</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span><span class="o">-</span><span class="c1"># LANGUAGE RankNTypes, TypeOperators #-}</span>

<span class="kn">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="n">join</span><span class="p">)</span>
</pre></div>

<p>其中，<code>RankNTypes</code>是唯一对以下内容绝对必要的。我曾经写过一篇解释，<code>RankNTypes</code>有些人似乎觉得有用，所以我会参考它。</p>
<p>引用Tom Crockett 的出色回答，我们有：</p>
<blockquote>
<h3>一个单子是...</h3>
<ul>
<li>一个内函子， _ <strong>T : X - &gt; X</strong>_</li>
<li>自然变换， _ <strong>μ : T × T - &gt; T</strong><em>，其中 </em>×_ 表示函子组合</li>
<li>自然变换 _ <strong>η : I - &gt; T</strong><em>，其中 _I是</em> <em>X</em> 上的身份内函子 __
</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li><em>μ(μ(T × T) × T)) = μ(T × μ(T × T))</em></li>
<li>
<em>μ(η(T)) = T = μ(T(η))</em>
</li>
</ul>
</blockquote>
<p>我们如何将其翻译成 Haskell 代码？ <strong>好吧，让我们从自然变换</strong> 的概念开始：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">--</span> <span class="p">|</span> <span class="nv">A</span> <span class="s s-Atom">natural</span> <span class="s s-Atom">transformations</span> <span class="s s-Atom">between</span> <span class="s s-Atom">two</span> <span class="s s-Atom">'Functor'</span> <span class="s s-Atom">instances</span><span class="p">.</span>  <span class="nv">Law</span><span class="o">:</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">--</span> <span class="o">&gt;</span> <span class="s s-Atom">fmap</span> <span class="s s-Atom">f</span> <span class="p">.</span> <span class="s s-Atom">eta</span> <span class="s s-Atom">g</span> <span class="o">==</span> <span class="s s-Atom">eta</span> <span class="s s-Atom">g</span> <span class="p">.</span> <span class="s s-Atom">fmap</span> <span class="s s-Atom">f</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">--</span> <span class="nv">Neat</span> <span class="s s-Atom">fact</span><span class="p">:</span> <span class="s s-Atom">the</span> <span class="s s-Atom">type</span> <span class="s s-Atom">system</span> <span class="s s-Atom">actually</span> <span class="s s-Atom">guarantees</span> <span class="s s-Atom">this</span> <span class="s s-Atom">law</span><span class="p">.</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">newtype</span> <span class="nf">f</span> <span class="o">:-&gt;</span> <span class="s s-Atom">g</span> <span class="o">=</span>
    <span class="nv">Natural</span> <span class="p">{</span> <span class="s s-Atom">eta</span> <span class="o">::</span> <span class="s s-Atom">forall</span> <span class="s s-Atom">x</span><span class="p">.</span> <span class="s s-Atom">f</span> <span class="s s-Atom">x</span> <span class="s s-Atom">-&gt;</span> <span class="s s-Atom">g</span> <span class="s s-Atom">x</span> <span class="p">}</span>
</pre></div>

<p>形式的类型<code>f :-&gt; g</code>类似于函数类型，但与其将其视为两种 <em>类型</em> （属于 kind ）之间的 <em>函数</em> ，不如将其视为两个 <strong>函子</strong> （属于
kind ）之间的 <strong>态射。</strong> 例子： __<code>*</code> <strong><em>* </em></strong>*<code>* -&gt; *</code></p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">listToMaybe</span> <span class="o">::</span> <span class="p">[]</span> <span class="o">:-&gt;</span> <span class="nv">Maybe</span>
<span class="s s-Atom">listToMaybe</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">go</span>
    <span class="s s-Atom">where</span> <span class="s s-Atom">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="nv">Nothing</span>
          <span class="nf">go</span> <span class="p">(</span><span class="s s-Atom">x</span><span class="p">:</span><span class="k">_</span><span class="p">)</span> <span class="o">=</span> <span class="nv">Just</span> <span class="s s-Atom">x</span>

<span class="s s-Atom">maybeToList</span> <span class="o">::</span> <span class="nv">Maybe</span> <span class="o">:-&gt;</span> <span class="p">[]</span>
<span class="s s-Atom">maybeToList</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">go</span>
    <span class="s s-Atom">where</span> <span class="s s-Atom">go</span> <span class="nv">Nothing</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="nf">go</span> <span class="p">(</span><span class="nv">Just</span> <span class="s s-Atom">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">x</span><span class="p">]</span>

<span class="s s-Atom">reverse' :: [] :-&gt; []</span>
<span class="s s-Atom">reverse'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">reverse</span>
</pre></div>

<p>基本上，在 Haskell 中，自然转换是从某种类型<code>f x</code>到另一种类型的函数<code>g
x</code>，这样<code>x</code>类型变量对于调用者是“不可访问的”。因此，例如，<code>sort :: Ord a =&gt; [a] -&gt;
[a]</code>不能进行自然转换，因为它对我们可以实例化的类型很“挑剔” <code>a</code>。我经常用来思考的一种直观方法如下：</p>
<ul>
<li>仿函数是一种在不触及 <em>结构的情况下对</em> <em>内容</em> 进行操作的方法。 __</li>
<li>自然转换是一种在不接触或查看 <em>内容的情况下对某事物的</em> <em>结构</em> 进行操作的方式。 __</li>
</ul>
<p>现在，撇开这些不谈，让我们来处理定义的子句。</p>
<p>第一个子句是“一个内函子， _ <strong>T : X - &gt; X</strong>_ ”。好吧，Haskell 中的 every<code>Functor</code>是人们称之为“Hask
类别”的内函子，其对象是 Haskell 类型（属于 kind <code>*</code>），其态射是 Haskell
函数。这听起来像是一个复杂的陈述，但它实际上是一个非常微不足道的陈述。这意味着 a 为您提供了为 any构造类型和从 any构造函数<code>Functor f
:: * -&gt; *</code>的方法，并且这些都遵守函子法则。<code>f a :: * ``a :: *``fmap f :: f a -&gt; f b``f :: a -&gt;
b</code></p>
<p>第二个子句：<code>Identity</code>Haskell 中的仿函数（它是平台自带的，所以你可以直接导入它）是这样定义的：</p>
<div class="code"><pre class="code literal-block">newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
    fmap f (Identity a) = Identity (f a)
</pre></div>

<p>因此，汤姆·克罗克特 (Tom Crockett) 定义的自然变换 _ <strong>η : I - &gt; T</strong>_<code>Monad</code>对于任何实例都可以这样写<code>t</code>：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">return' :: Monad t =&gt; Identity :-&gt; t</span>
<span class="s s-Atom">return'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="p">(</span><span class="s s-Atom">return</span> <span class="p">.</span> <span class="s s-Atom">runIdentity</span><span class="p">)</span>
</pre></div>

<p>第三条：Haskell 中两个函子的组合可以这样定义（平台也有）：</p>
<div class="code"><pre class="code literal-block">newtype Compose f g a = Compose { getCompose :: f (g a) }

-- | The composition of two 'Functor's is also a 'Functor'.
instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
    fmap f (Compose fga) = Compose (fmap (fmap f) fga)
</pre></div>

<p>因此，Tom Crockett 定义的自然变换 _ <strong>μ : T × T - &gt; T</strong>_可以这样写：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">join' :: Monad t =&gt; Compose t t :-&gt; t</span>
<span class="s s-Atom">join'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="p">(</span><span class="s s-Atom">join</span> <span class="p">.</span> <span class="s s-Atom">getCompose</span><span class="p">)</span>
</pre></div>

<p>声明这是内函子类别中的幺半群，则意味着<code>Compose</code>（仅部分应用于其前两个参数）是关联的，这<code>Identity</code>就是它的恒等元。即，以下同构成立：</p>
<ul>
<li><code>Compose f (Compose g h) ~= Compose (Compose f g) h</code></li>
<li><code>Compose f Identity ~= f</code></li>
<li><code>Compose Identity g ~= g</code></li>
</ul>
<p>这些很容易证明，因为<code>Compose</code>和<code>Identity</code>都被定义为<code>newtype</code>，Haskell 报告将
的语义定义为被定义的类型与的数据构造<code>newtype</code>函数的参数类型之间的同构。<code>newtype</code>例如，让我们证明<code>Compose f Identity
~= f</code>：</p>
<div class="code"><pre class="code literal-block">Compose f Identity a
    ~= f (Identity a)                 -- newtype Compose f g a = Compose (f (g a))
    ~= f a                            -- newtype Identity a = Identity a
Q.E.D.
</pre></div>

<p><br><br><a href="posts/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-python-zhong-shi-yong-with-open-da-kai-duo-ge-wen-jian/" class="u-url">如何在 Python 中使用“with open”打开多个文件？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-python-zhong-shi-yong-with-open-da-kai-duo-ge-wen-jian/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:33:03+08:00" itemprop="datePublished" title="2023-02-17 10:33">2023-02-17 10:33</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想一次更改几个文件， <strong>前提是</strong> 我可以写入所有文件。我想知道我是否可以以某种方式将多个打开的调用与<code>with</code>语句结合起来：</p>
<div class="code"><pre class="code literal-block"><span class="k">try</span><span class="o">:</span>
<span class="w">  </span><span class="k">with</span><span class="w"> </span><span class="n">open</span><span class="o">(</span><span class="s1">'a'</span><span class="o">,</span><span class="w"> </span><span class="s1">'w'</span><span class="o">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">open</span><span class="o">(</span><span class="s1">'b'</span><span class="o">,</span><span class="w"> </span><span class="s1">'w'</span><span class="o">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">b</span><span class="o">:</span>
<span class="w">    </span><span class="n">do_something</span><span class="o">()</span>
<span class="n">except</span><span class="w"> </span><span class="n">IOError</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">e</span><span class="o">:</span>
<span class="w">  </span><span class="n">print</span><span class="w"> </span><span class="s1">'Operation failed: %s'</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">e</span><span class="o">.</span><span class="na">strerror</span>
</pre></div>

<p>如果这不可能，那么这个问题的优雅解决方案是什么样的？</p>
<p><br><br></p>
<h2>解答</h2>
<p>从 Python 2.7（或分别为 3.1）开始，您可以编写</p>
<div class="code"><pre class="code literal-block">with open('a', 'w') as a, open('b', 'w') as b:
    do_something()
</pre></div>

<p>（ <em>历史记录</em> ：在早期版本的 Python
中，您有时可以使用<code>contextlib.nested()</code>嵌套上下文管理器。但是，这对于打开多个文件不会按预期工作——有关详细信息，请参阅链接文档。）</p>
<hr>
<p>在极少数情况下，您希望同时打开可变数量的文件，您可以使用<code>contextlib.ExitStack</code>，从 Python 3.3 版开始：</p>
<div class="code"><pre class="code literal-block"><span class="nv">with</span><span class="w"> </span><span class="nv">ExitStack</span><span class="ss">()</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">stack</span>:
<span class="w">    </span><span class="nv">files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">stack</span>.<span class="nv">enter_context</span><span class="ss">(</span><span class="nv">open</span><span class="ss">(</span><span class="nv">fname</span><span class="ss">))</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">fname</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">filenames</span>]
<span class="w">    </span>#<span class="w"> </span><span class="k">Do</span><span class="w"> </span><span class="nv">something</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="s2">"files"</span>
</pre></div>

<p>请注意，更常见的是您希望按顺序处理文件而不是同时打开所有文件，特别是如果您有可变数量的文件：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">fname</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">filenames</span>:
<span class="w">    </span><span class="nv">with</span><span class="w"> </span><span class="nv">open</span><span class="ss">(</span><span class="nv">fname</span><span class="ss">)</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">f</span>:
<span class="w">        </span>#<span class="w"> </span><span class="nv">Process</span><span class="w"> </span><span class="nv">f</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>只需替换<code>and</code>为<code>,</code>即可：</p>
<div class="code"><pre class="code literal-block"><span class="k">try</span><span class="o">:</span>
<span class="w">    </span><span class="k">with</span><span class="w"> </span><span class="n">open</span><span class="o">(</span><span class="s1">'a'</span><span class="o">,</span><span class="w"> </span><span class="s1">'w'</span><span class="o">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">open</span><span class="o">(</span><span class="s1">'b'</span><span class="o">,</span><span class="w"> </span><span class="s1">'w'</span><span class="o">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">b</span><span class="o">:</span>
<span class="w">        </span><span class="n">do_something</span><span class="o">()</span>
<span class="n">except</span><span class="w"> </span><span class="n">IOError</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">e</span><span class="o">:</span>
<span class="w">    </span><span class="n">print</span><span class="w"> </span><span class="s1">'Operation failed: %s'</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">e</span><span class="o">.</span><span class="na">strerror</span>
</pre></div>

<p><br><br><a href="posts/how-can-i-open-multiple-files-using-with-open-in-python/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-ke-yi-shi-yong-na-xie-clearfix-fang-fa/" class="u-url">我可以使用哪些“clearfix”方法？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-ke-yi-shi-yong-na-xie-clearfix-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:32:30+08:00" itemprop="datePublished" title="2023-02-17 10:32">2023-02-17 10:32</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><code>div</code>我有一个包装两列布局的古老问题。我的侧边栏是浮动的，所以我的容器<code>div</code>无法包装内容和侧边栏。</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"content"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"sidebar"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>似乎有很多方法可以修复 Firefox 中的明显错误：</p>
<ul>
<li><code>&lt;br clear="all"/&gt;</code></li>
<li><code>overflow:auto</code></li>
<li><code>overflow:hidden</code></li>
</ul>
<p>在我的情况下，唯一似乎可以正常工作的是<code>&lt;br
clear="all"/&gt;</code>解决方案，它有点邋遢。<code>overflow:auto</code>给我讨厌的滚动条，<code>overflow:hidden</code>肯定有副作用。此外，由于其不正确的行为，IE7
显然不应该遇到此问题，但在我的情况下，它遇到的问题与 Firefox 相同。</p>
<p>我们目前可用的哪种方法是最稳健的？</p>
<p><br><br></p>
<h2>解答</h2>
<p>根据正在生成的设计，以下每个 clearfix CSS 解决方案都有其自身的优势。</p>
<p>clearfix 确实有有用的应用程序，但它也被用作 hack。在您使用 clearfix 之前，这些现代 css 解决方案可能会有用：</p>
<ul>
<li>CSS弹性盒</li>
<li>网格</li>
</ul>
<hr>
<h2>现代 Clearfix 解决方案</h2>
<hr>
<h3>容器与<code>overflow: auto;</code>
</h3>
<p>清除浮动元素的最简单方法是使用<code>overflow: auto</code>包含元素的样式。该解决方案适用于所有现代浏览器。</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div</span><span class="w"> </span><span class="na">style=</span><span class="s">"overflow: auto;"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;img</span>
<span class="w">    </span><span class="na">style=</span><span class="s">"float: right;"</span>
<span class="w">    </span><span class="na">src=</span><span class="s">"path/to/floated-element.png"</span>
<span class="w">    </span><span class="na">width=</span><span class="s">"500"</span>
<span class="w">    </span><span class="na">height=</span><span class="s">"500"</span>
<span class="w">  </span><span class="nt">&gt;</span><span class="w"> </span>
<span class="w">  </span><span class="nt">&lt;p&gt;</span>Your<span class="w"> </span>content<span class="w"> </span>here…<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>一个缺点是，在外部元素上使用某些边距和填充的组合会导致出现滚动条，但这可以通过将边距和填充放在另一个包含父元素的元素上来解决。</p>
<p>使用“溢出：隐藏”也是一个 clearfix 解决方案，但不会有滚动条，但是使用<code>hidden</code>会裁剪位于包含元素之外的任何内容。</p>
<p><em>注意：</em> 浮动元素<code>img</code>在这个例子中是一个标签，但可以是任何 html 元素。</p>
<hr>
<h3>Clearfix 重装上阵</h3>
<p>Thierry Koblentz 在 CSSMojo 上写道：最新的 clearfix 已重新加载。他指出，通过放弃对旧 IE
的支持，解决方案可以简化为一个 css 语句。此外，当具有 clearfix 的元素是兄弟元素时，使用<code>display:
block</code>（而不是<code>display: table</code>）允许边距正确折叠。</p>
<div class="code"><pre class="code literal-block"><span class="nl">.container:</span><span class="err">:</span><span class="nf">after</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">content:</span><span class="w"> </span><span class="err">""</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">block</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">clear:</span><span class="w"> </span><span class="nf">both</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>这是 clearfix 的最新版本。</p>
<hr>
<p>⋮</p>
<p>⋮</p>
<h2>较旧的 Clearfix 解决方案</h2>
<p>以下解决方案对于现代浏览器不是必需的，但对于针对较旧的浏览器可能有用。</p>
<p>请注意，这些解决方案依赖于浏览器错误，因此只有在上述解决方案都不适合您时才应使用。</p>
<p>它们大致按时间顺序列出。</p>
<hr>
<h3>“Beat That ClearFix”，现代浏览器的 clearfix</h3>
<p>CSS Mojo的 Thierry Koblentz指出，当针对现代浏览器时，我们现在可以删除<code>zoom</code>和<code>::before</code>属性/值并简单地使用：</p>
<div class="code"><pre class="code literal-block"><span class="nl">.container:</span><span class="err">:</span><span class="nf">after</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">content:</span><span class="w"> </span><span class="err">""</span><span class="c1">;</span>
<span class="w">    </span><span class="nl">display:</span><span class="w"> </span><span class="nf">table</span><span class="c1">;</span>
<span class="w">    </span><span class="nl">clear:</span><span class="w"> </span><span class="nf">both</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p><em>此解决方案不支持 IE 6/7 ……是故意的！</em></p>
<p>Thierry 还提供：“提醒一句：如果你从头开始一个新项目，那就去做吧，但不要将这种技术与你现在拥有的技术交换，因为即使你不支持旧
IE，你现有的规则也会阻止崩溃的利润率。”</p>
<hr>
<h3>微透明修复</h3>
<p>最新的全球采用的 clearfix 解决方案是Nicolas Gallagher 的 Micro Clearfix。</p>
<p><em>已知支持：Firefox 3.5+、Safari 4+、Chrome、Opera 9+、IE 6+</em></p>
<div class="code"><pre class="code literal-block"><span class="nl">.container:</span><span class="err">:</span><span class="nf">before</span><span class="p">,</span><span class="w"> </span><span class="no">.container</span><span class="p">::</span><span class="no">after</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">content:</span><span class="w"> </span><span class="err">""</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">table</span><span class="c1">;</span>
<span class="err">}</span>
<span class="nl">.container:</span><span class="err">:</span><span class="nf">after</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">clear:</span><span class="w"> </span><span class="nf">both</span><span class="c1">;</span>
<span class="err">}</span>
<span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">zoom:</span><span class="w"> </span><span class="err">1</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<hr>
<h3>溢出属性</h3>
<p>这种基本方法适用于通常情况，当定位的内容不会显示在容器边界之外时。</p>
<p>http://www.quirksmode.org/css/clearing.html - <em>解释了如何解决与此技术相关的常见问题，即<code>width:
100%</code>在容器上设置。</em></p>
<div class="code"><pre class="code literal-block"><span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">overflow:</span><span class="w"> </span><span class="nf">hidden</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">inline-block</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">block</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>除了使用该<code>display</code>属性为 IE 设置“hasLayout”，还可以使用其他属性来触发元素的“hasLayout”。</p>
<div class="code"><pre class="code literal-block"><span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">overflow:</span><span class="w"> </span><span class="nf">hidden</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">zoom:</span><span class="w"> </span><span class="err">1</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">block</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>使用该属性清除浮动的另一种方法<code>overflow</code>是使用下划线 hack。IE 将应用以下划线前缀的值，其他浏览器不会。该属性在 IE
中<code>zoom</code>触发hasLayout ：</p>
<div class="code"><pre class="code literal-block"><span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">overflow:</span><span class="w"> </span><span class="nf">hidden</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">_overflow:</span><span class="w"> </span><span class="nf">visible</span><span class="c1">; /* for IE */</span>
<span class="w">  </span><span class="nl">_zoom:</span><span class="w"> </span><span class="err">1</span><span class="c1">; /* for IE */</span>
<span class="err">}</span>
</pre></div>

<p>虽然这行得通……使用 hack 并不理想。</p>
<hr>
<h3>PIE：简易清算法</h3>
<p>这种较旧的“Easy Clearing”方法具有允许定位元素悬挂在容器边界之外的优点，但代价是更棘手的 CSS。</p>
<p>这个解决方案已经很老了，但是您可以了解有关 Easy Clearing on Position Is Everything
的所有信息：http://www.positioniseverything.net/easyclearing.html</p>
<hr>
<h3>使用“清除”属性的元素</h3>
<p>当您快速将某些东西拍打在一起时，快速而肮脏的解决方案（有一些缺点）：</p>
<div class="code"><pre class="code literal-block"><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="n">style</span><span class="o">=</span><span class="s">"clear: both"</span><span class="w"> </span><span class="o">/&gt;</span><span class="w"> </span><span class="o">&lt;!--</span><span class="w"> </span><span class="n">So</span><span class="w"> </span><span class="n">dirty</span><span class="o">!</span><span class="w"> </span><span class="o">--&gt;</span>
</pre></div>

<h4>缺点</h4>
<ul>
<li>它没有响应，因此如果布局样式根据媒体查询发生变化，则可能无法提供预期的效果。纯 CSS 的解决方案更为理想。</li>
<li>它添加 html 标记而不一定添加任何语义值。</li>
<li>它需要每个实例的内联定义和解决方案，而不是在 css 中对“clearfix”的单个解决方案的类引用和在 html 中对它的类引用。</li>
<li>这使得其他人难以使用代码，因为他们可能不得不编写更多的 hack 来解决它。</li>
<li>将来当您需要/想要使用另一个 clearfix 解决方案时，您将不必返回并删除<code>&lt;br style="clear: both" /&gt;</code>标记周围散落的每个标签。</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<h3>我们试图解决什么问题？</h3>
<p>浮动东西时有两个重要的考虑因素：</p>
<ol>
<li>
<strong>包含后代浮动。</strong> 这意味着所讨论的元素使自己足够高以包裹所有浮动的后代。（他们不会在外面闲逛。）</li>
</ol>
<p><img alt="悬挂在容器外的浮动内容" src="images/3AUJp.png"></p>
<ol>
<li>
<strong>使后代与外界漂浮物隔绝。</strong> 这意味着元素内部的后代应该能够使用<code>clear: both</code>并且不与元素外部的浮动交互。</li>
</ol>
<p><img alt="&lt;code&gt;clear: both&lt;/code&gt; 与 DOM 中其他地方的浮动交互" src="images/XIMXt.png"></p>
<h3>块格式化上下文</h3>
<p>只有一种方法可以做到这两点。那就是建立一个新的块格式化上下文。建立块格式化上下文的元素是一个绝缘的矩形，其中浮动相互交互。块格式化上下文将始终足够高以在视觉上包裹其浮动后代，并且块格式化上下文外部的浮动不会与内部元素交互。这种双向绝缘正是您想要的。在
IE 中，这个相同的概念称为hasLayout，可以通过<code>zoom: 1</code>.</p>
<p>有几种方法可以建立块格式化上下文，但我推荐的解决方案是<code>display: inline-block</code>使用<code>width: 100%</code>.
（当然，使用有一些常见的注意事项<code>width: 100%</code>，因此请使用<code>box-sizing: border-
box</code>或将<code>padding</code>、<code>margin</code>和<code>border</code>放在不同的元素上。）</p>
<h3>最稳健的解决方案</h3>
<p>浮动最常见的应用可能是两列布局。（可以扩展到三列。）</p>
<p>首先是标记结构。</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"sidebar"</span><span class="nt">&gt;</span>
<span class="w">    </span>sidebar<span class="nt">&lt;br/&gt;</span>sidebar<span class="nt">&lt;br/&gt;</span>sidebar
<span class="w">  </span><span class="nt">&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main-content"</span><span class="nt">&gt;</span>
<span class="w">      </span>main<span class="w"> </span>content
<span class="w">      </span><span class="nt">&lt;span</span><span class="w"> </span><span class="na">style=</span><span class="s">"clear: both"</span><span class="nt">&gt;</span>
<span class="w">        </span>main<span class="w"> </span>content<span class="w"> </span>that<span class="w"> </span>uses<span class="w"> </span><span class="nt">&lt;code&gt;</span>clear:<span class="w"> </span>both<span class="nt">&lt;/code&gt;</span>
<span class="w">      </span><span class="nt">&lt;/span&gt;</span>
<span class="w">    </span><span class="nt">&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>现在是 CSS。</p>
<div class="code"><pre class="code literal-block"><span class="cm">/* Should contain all floated and non-floated content, so it needs to</span>
<span class="cm"> * establish a new block formatting context without using overflow: hidden.</span>
<span class="cm"> */</span>
<span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">inline-block</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">width:</span><span class="w"> </span><span class="err">100%</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">zoom:</span><span class="w"> </span><span class="err">1</span><span class="c1">; /* new block formatting context via hasLayout for IE 6/7 */</span>
<span class="err">}</span>

<span class="cm">/* Fixed-width floated sidebar. */</span>
<span class="na">.sidebar</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">float:</span><span class="w"> </span><span class="nf">left</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">width:</span><span class="w"> </span><span class="err">160</span><span class="nf">px</span><span class="c1">;</span>
<span class="err">}</span>

<span class="cm">/* Needs to make space for the sidebar. */</span>
<span class="na">.main</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">margin-left:</span><span class="w"> </span><span class="err">160</span><span class="nf">px</span><span class="c1">;</span>
<span class="err">}</span>

<span class="cm">/* Establishes a new block formatting context to insulate descendants from</span>
<span class="cm"> * the floating sidebar. */</span>
<span class="na">.main-content</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">display:</span><span class="w"> </span><span class="nf">inline-block</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">width:</span><span class="w"> </span><span class="err">100%</span><span class="c1">;</span>
<span class="w">  </span><span class="nl">zoom:</span><span class="w"> </span><span class="err">1</span><span class="c1">; /* new block formatting context via hasLayout for IE 6/7 */</span>
<span class="err">}</span>
</pre></div>

<h3>自己试试</h3>
<p>转到JS Bin来尝试代码，看看这个解决方案是如何从头开始构建的。</p>
<h3>传统的 clearfix 方法被认为是有害的</h3>
<p>传统的clearfix 解决方案的问题在于它们使用两种不同的呈现概念来为 IE 和其他所有人实现相同的目标。在 IE 中，他们使用 hasLayout
来建立新的块格式化上下文，但对于其他人，他们使用生成的框 ( <code>:after</code>) 和<code>clear:
both</code>，这不会建立新的块格式化上下文。这意味着事情不会在所有情况下都表现相同。有关为什么这是不好的解释，请参阅您对 Clearfix 的了解都是错误的。</p>
<p><br><br><a href="posts/what-methods-of-clearfix-can-i-use/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-578.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-576.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
