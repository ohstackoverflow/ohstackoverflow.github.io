<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1982) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1982.html">
<link rel="prev" href="index-1983.html" type="text/html">
<link rel="next" href="index-1981.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-is-a-b-0-faster-than-a-0-b-0-in-java/" class="u-url">Why is (a*b != 0) faster than (a != 0 &amp;&amp; b != 0) in Java?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-is-a-b-0-faster-than-a-0-b-0-in-java/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:03:02+08:00" itemprop="datePublished" title="2023-03-03 14:03">2023-03-03 14:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm writing some code in Java where, at some point, the flow of the program is
determined by whether two int variables, "a" and "b", are non-zero (note: a
and b are never negative, and never within integer overflow range).</p>
<p>I can evaluate it with</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="cm">/* Some code */</span><span class="w"> </span>}
</pre></div>

<p>Or alternatively</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="o">*</span><span class="nv">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="cm">/* Some code */</span><span class="w"> </span>}
</pre></div>

<p>Because I expect that piece of code to run millions of times per run, I was
wondering which one would be faster. I did the experiment by comparing them on
a huge randomly generated array, and I was also curious to see how the
sparsity of the array (fraction of data = 0) would affect the results:</p>
<div class="code"><pre class="code literal-block"><span class="n">long</span><span class="w"> </span><span class="nc">time</span><span class="p">;</span>
<span class="n">final</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="nf">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50000000</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">arbitrary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nc">int</span><span class="err">[][]</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">2</span><span class="o">][</span><span class="n">len</span><span class="o">]</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.9</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.0078125</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nf">len</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="k">double</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">random</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">random</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">fraction</span><span class="p">)</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">random</span><span class="o">*</span><span class="mi">15</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="nc">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nf">len</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="cm">/*insert nums[0][i]*nums[1][i]!=0 or nums[0][i]!=0 &amp;&amp; nums[1][i]!=0*/</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">arbitrary</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="k">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nc">time</span><span class="p">);</span>
<span class="err">}</span>
</pre></div>

<p>And the results show that if you expect "a" or "b" to be equal to 0 more than
~3% of the time, <code>a*b != 0</code> is faster than <code>a!=0 &amp;&amp; b!=0</code>:</p>
<p><img alt="Graphical graph of the results of a AND b non-zero" src="images/POHYD.png"></p>
<p>I'm curious to know why. Could anyone shed some light? Is it the compiler or
is it at the hardware level?</p>
<p><strong>Edit:</strong> <em>Out of curiosity...</em> now that I learned about branch prediction, I
was wondering what the analog comparison would show for a <strong>OR</strong> b is non-
zero:</p>
<p><img alt="Graph of a or b non-zero" src="images/GpJoM.png"></p>
<p>We do see the same effect of branch prediction as expected, interestingly the
graph is somewhat flipped along the X-axis.</p>
<h4>Update</h4>
<p>1- I added <code>!(a==0 || b==0)</code> to the analysis to see what happens.</p>
<p>2- I also included <code>a != 0 || b != 0</code>, <code>(a+b) != 0</code> and <code>(a|b) != 0</code> out of
curiosity, after learning about branch prediction. But they are not logically
equivalent to the other expressions, because only a <em>OR</em> b needs to be non-
zero to return true, so they are not meant to be compared for processing
efficiency.</p>
<p>3- I also added the actual benchmark that I used for the analysis, which is
just iterating an arbitrary int variable.</p>
<p>4- Some people were suggesting to include <code>a != 0 &amp; b != 0</code> as opposed to <code>a
!= 0 &amp;&amp; b != 0</code>, with the prediction that it would behave more closely to <code>a*b
!= 0</code> because we would remove the branch prediction effect. I didn't know that
<code>&amp;</code> could be used with boolean variables, I thought it was only used for
binary operations with integers.</p>
<p>Note: In the context that I was considering all this, int overflow is not an
issue, but that's definitely an important consideration in general contexts.</p>
<p>CPU: Intel Core i7-3610QM @ 2.3GHz</p>
<p>Java version: 1.8.0_45<br>
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)<br>
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I'm ignoring the issue that your benchmarking <em>might</em> be flawed, and taking
the result at face value.</p>
<blockquote>
<p>Is it the compiler or is it at the hardware level?</p>
</blockquote>
<p>That latter, I think:</p>
<div class="code"><pre class="code literal-block"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
</pre></div>

<p>will compile to 2 memory loads and two conditional branches</p>
<div class="code"><pre class="code literal-block"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
</pre></div>

<p>will compile to 2 memory loads, a multiply and one conditional branch.</p>
<p>The multiply is likely to be faster than the second conditional branch if the
hardware-level branch prediction is ineffective. As you increase the ratio ...
the branch prediction is becoming less effective.</p>
<p>The reason that conditional branches are slower is that they cause the
instruction execution pipeline to stall. Branch prediction is about avoiding
the stall by predicting which way the branch is going to go and speculatively
choosing the next instruction based on that. If the prediction fails, there is
a delay while the instruction for the other direction is loaded.</p>
<p>(Note: the above explanation is oversimplified. For a more accurate
explanation, you need to look at the literature provided by the CPU
manufacturer for assembly language coders and compiler writers. The Wikipedia
page on Branch Predictors is good background.)</p>
<hr>
<p>However, there is one thing that you need to be careful about with this
optimization. Are there any values where <code>a * b != 0</code> will give the wrong
answer? Consider cases where computing the product results in integer
overflow.</p>
<hr>
<p><strong>UPDATE</strong></p>
<p>Your graphs tend to confirm what I said.</p>
<ul>
<li>
<p>There is also a "branch prediction" effect in the conditional branch <code>a * b != 0</code> case, and this comes out in the graphs.</p>
</li>
<li>
<p>If you project the curves beyond 0.9 on the X-axis, it looks like 1) they will meet at about 1.0 and 2) the meeting point will be at roughly the same Y value as for X = 0.0.</p>
</li>
</ul>
<hr>
<p><strong>UPDATE 2</strong></p>
<p>I don't understand why the curves are different for the <code>a + b != 0</code> and the
<code>a | b != 0</code> cases. There <em>could be</em> something clever in the branch predictors
logic. Or it could indicate something else.</p>
<p>(Note that this kind of thing can be specific to a particular chip model
number or even version. The results of your benchmarks could be different on
other systems.)</p>
<p>However, they both have the advantage of working for all non-negative values
of <code>a</code> and <code>b</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>I think your benchmark has some flaws and might not be useful for inferring
about real programs. Here are my thoughts:</p>
<ul>
<li>
<p><code>(a|b)!=0</code> and <code>(a+b)!=0</code> test if <em>either</em> value is non-zero, whereas <code>a != 0 &amp;&amp; b != 0</code> and <code>(a*b)!=0</code> test if <em>both</em> are non-zero. So you are not comparing the timing of just the arithmetic: if the condition is true more often, it causes more executions of the <code>if</code> body, which takes more time too.</p>
</li>
<li>
<p><code>(a+b)!=0</code> will do the wrong thing for positive and negative values that sum to zero, so you can't use it in the general case, even if it works here. Also for <code>a=b=0x80000000</code> (MIN_VALUE), the only set bit will overflow out the top.</p>
</li>
<li>
<p>Similarly, <code>(a*b)!=0</code> will do the wrong thing for values that overflow. Random example: 196608 * 327680 is 0 because the true result happens to be divisible by 232, so its low 32 bits are 0, and those bits are all you get if it's an <code>int</code> operation.</p>
</li>
<li>
<p>The VM will optimize the expression during the first few runs of the outer (<code>fraction</code>) loop, when <code>fraction</code> is 0, when the branches are almost never taken. The optimizer may do different things if you start <code>fraction</code> at 0.5.</p>
</li>
<li>
<p>Unless the VM is able to eliminate some of the array bounds checks here, there are four other branches in the expression just due to the bounds checks, and that's a complicating factor when trying to figure out what's happening at a low level. You might get different results if you split the two-dimensional array into two flat arrays, changing <code>nums[0][i]</code> and <code>nums[1][i]</code> to <code>nums0[i]</code> and <code>nums1[i]</code>.</p>
</li>
<li>
<p>CPU branch predictors detect short patterns in the data, or runs of all branches being taken or not taken. Your randomly generated benchmark data is the worst-case scenario for a branch predictor. If real-world data has a predictable pattern, or it has long runs of all-zero and all-non-zero values, the branches could cost <strong>much</strong> less.</p>
</li>
<li>
<p>The particular code that is executed after the condition is met can affect the performance of evaluating the condition itself, because it affects things like whether or not the loop can be unrolled, which CPU registers are available, and if any of the fetched <code>nums</code> values need to be reused after evaluating the condition. Merely incrementing a counter in the benchmark is not a perfect placeholder for what real code would do.</p>
</li>
<li>
<p><code>System.currentTimeMillis()</code> is on most systems not more accurate than +/- 10 ms. <code>System.nanoTime()</code> is usually more accurate.</p>
</li>
</ul>
<p>There are lots of uncertainties, and it's always hard to say anything definite
with these sorts of micro-optimizations because a trick that is faster on one
VM or CPU can be slower on another. If running the 32-bit HotSpot JVM, rather
than the 64-bit version, be aware that it comes in two flavors: with the
"Client" VM having different (weaker) optimizations compared to the "Server"
VM.</p>
<p>If you can disassemble the machine code generated by the VM, do that rather
than trying to guess what it does!</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/in-c-why-is-string-a-reference-type-that-behaves-like-a-value-type/" class="u-url">In C#, why is String a reference type that behaves like a value type?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/in-c-why-is-string-a-reference-type-that-behaves-like-a-value-type/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:02:37+08:00" itemprop="datePublished" title="2023-03-03 14:02">2023-03-03 14:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>A String is a reference type even though it has most of the characteristics of
a value type such as being immutable and having == overloaded to compare the
text rather than making sure they reference the same object.</p>
<p>Why isn't string just a value type then?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Strings aren't value types since they can be huge, and need to be stored on
the heap. Value types are (in all implementations of the CLR as of yet) stored
on the stack. Stack allocating strings would break all sorts of things: the
stack is only 1MB for 32-bit and 4MB for 64-bit, you'd have to box each
string, incurring a copy penalty, you couldn't intern strings, and memory
usage would balloon, etc...</p>
<p><em>(Edit: Added clarification about value type storage being an implementation
detail, which leads to this situation where we have a type with value sematics
not inheriting from System.ValueType. Thanks Ben.)</em></p>
<p><br></p>
<h3>Suggest</h3>
<p>It is not a value type because performance (space and time!) would be terrible
if it were a value type and its value had to be copied every time it were
passed to and returned from methods, etc.</p>
<p>It has value semantics to keep the world sane. Can you imagine how difficult
it would be to code if</p>
<div class="code"><pre class="code literal-block">string s = "hello";
string t = "hello";
bool b = (s == t);
</pre></div>

<p>set <code>b</code> to be <code>false</code>? Imagine how difficult coding just about any application
would be.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/what-do-all-of-scala-s-symbolic-operators-mean/" class="u-url">What do all of Scala's symbolic operators mean?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/what-do-all-of-scala-s-symbolic-operators-mean/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:02:11+08:00" itemprop="datePublished" title="2023-03-03 14:02">2023-03-03 14:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Scala syntax has a lot of symbols. Since these kinds of names are difficult to
find using search engines, a comprehensive list of them would be helpful.</p>
<p>What are all of the symbols in Scala, and what does each of them do?</p>
<p>In particular, I'd like to know about <code>-&gt;</code>, <code>||=</code>, <code>++=</code>, <code>&lt;=</code>, <code>_._</code>, <code>::</code>,
and <code>:+=</code>.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I divide the operators, for the purpose of teaching, into <strong>four categories</strong>
:</p>
<ul>
<li>Keywords/reserved symbols</li>
<li>Automatically imported methods</li>
<li>Common methods</li>
<li>Syntactic sugars/composition</li>
</ul>
<p>It is fortunate, then, that most categories are represented in the question:</p>
<div class="code"><pre class="code literal-block"><span class="o">-&gt;</span><span class="w">    </span><span class="c1">// Automatically imported method</span>
<span class="o">||=</span><span class="w">   </span><span class="c1">// Syntactic sugar</span>
<span class="o">++=</span><span class="w">   </span><span class="c1">// Syntactic sugar/composition or common method</span>
<span class="o">&lt;=</span><span class="w">    </span><span class="c1">// Common method</span>
<span class="n">_</span><span class="p">.</span><span class="n">_</span><span class="w">   </span><span class="c1">// Typo, though it's probably based on Keyword/composition</span>
<span class="o">::</span><span class="w">    </span><span class="c1">// Common method</span>
<span class="o">:+=</span><span class="w">   </span><span class="c1">// Common method</span>
</pre></div>

<p>The exact meaning of most of these methods depend on the class that is
defining them. For example, <code>&lt;=</code> on <code>Int</code> means <em>"less than or equal to"</em>. The
first one, <code>-&gt;</code>, I'll give as example below. <code>::</code> is probably the method
defined on <code>List</code> (though it <em>could</em> be the object of the same name), and
<code>:+=</code> is probably the method defined on various <code>Buffer</code> classes.</p>
<p>So, let's see them.</p>
<h3>Keywords/reserved symbols</h3>
<p>There are some symbols in Scala that are special. Two of them are considered
proper keywords, while others are just "reserved". They are:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span> <span class="n">Keywords</span>
<span class="o">&lt;-</span>  <span class="o">//</span> <span class="n">Used</span> <span class="n">on</span> <span class="k">for</span><span class="o">-</span><span class="n">comprehensions</span><span class="p">,</span> <span class="n">to</span> <span class="n">separate</span> <span class="n">pattern</span> <span class="kn">from</span> <span class="nn">generator</span>
<span class="o">=&gt;</span>  <span class="o">//</span> <span class="n">Used</span> <span class="k">for</span> <span class="n">function</span> <span class="n">types</span><span class="p">,</span> <span class="n">function</span> <span class="n">literals</span> <span class="ow">and</span> <span class="kn">import</span> <span class="nn">renaming</span>

<span class="o">//</span> <span class="n">Reserved</span>
<span class="p">(</span> <span class="p">)</span>        <span class="o">//</span> <span class="n">Delimit</span> <span class="n">expressions</span> <span class="ow">and</span> <span class="n">parameters</span>
<span class="p">[</span> <span class="p">]</span>        <span class="o">//</span> <span class="n">Delimit</span> <span class="nb">type</span> <span class="n">parameters</span>
<span class="p">{</span> <span class="p">}</span>        <span class="o">//</span> <span class="n">Delimit</span> <span class="n">blocks</span>
<span class="o">.</span>          <span class="o">//</span> <span class="n">Method</span> <span class="n">call</span> <span class="ow">and</span> <span class="n">path</span> <span class="n">separator</span>
<span class="o">//</span> <span class="o">/*</span> <span class="o">*/</span>   <span class="o">//</span> <span class="n">Comments</span>
<span class="c1">#          // Used in type notations</span>
<span class="p">:</span>          <span class="o">//</span> <span class="n">Type</span> <span class="n">ascription</span> <span class="ow">or</span> <span class="n">context</span> <span class="n">bounds</span>
<span class="o">&lt;</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">:</span> <span class="o">&lt;%</span>   <span class="o">//</span> <span class="n">Upper</span><span class="p">,</span> <span class="n">lower</span> <span class="ow">and</span> <span class="n">view</span> <span class="n">bounds</span>
<span class="o">&lt;</span><span class="err">?</span> <span class="o">&lt;</span><span class="err">!</span>      <span class="o">//</span> <span class="n">Start</span> <span class="n">token</span> <span class="k">for</span> <span class="n">various</span> <span class="n">XML</span> <span class="n">elements</span>
<span class="s2">" """</span>      <span class="o">//</span> <span class="n">Strings</span>
<span class="s1">'          // Indicate symbols and characters</span>
<span class="o">@</span>          <span class="o">//</span> <span class="n">Annotations</span> <span class="ow">and</span> <span class="n">variable</span> <span class="n">binding</span> <span class="n">on</span> <span class="n">pattern</span> <span class="n">matching</span>
<span class="err">`</span>          <span class="o">//</span> <span class="n">Denote</span> <span class="n">constant</span> <span class="ow">or</span> <span class="n">enable</span> <span class="n">arbitrary</span> <span class="n">identifiers</span>
<span class="p">,</span>          <span class="o">//</span> <span class="n">Parameter</span> <span class="n">separator</span>
<span class="p">;</span>          <span class="o">//</span> <span class="n">Statement</span> <span class="n">separator</span>
<span class="n">_</span><span class="o">*</span>         <span class="o">//</span> <span class="n">vararg</span> <span class="n">expansion</span>
<span class="n">_</span>          <span class="o">//</span> <span class="n">Many</span> <span class="n">different</span> <span class="n">meanings</span>
</pre></div>

<p>These are all <em>part of the language</em> , and, as such, can be found in any text
that properly describe the language, such as Scala Specification(PDF) itself.</p>
<p>The last one, the underscore, deserve a special description, because it is so
widely used, and has so many different meanings. Here's a sample:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">scala._</span>    <span class="o">//</span> <span class="n">Wild</span> <span class="n">card</span> <span class="o">--</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">Scala</span> <span class="ow">is</span> <span class="n">imported</span>
<span class="kn">import</span> <span class="nn">scala.</span><span class="p">{</span> <span class="n">Predef</span> <span class="o">=&gt;</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="p">}</span> <span class="o">//</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">everything</span> <span class="k">except</span> <span class="n">Predef</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">[</span><span class="n">M</span><span class="p">[</span><span class="n">_</span><span class="p">]]</span>       <span class="o">//</span> <span class="n">Higher</span> <span class="n">kinded</span> <span class="nb">type</span> <span class="n">parameter</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">M</span><span class="p">[</span><span class="n">_</span><span class="p">])</span>    <span class="o">//</span> <span class="n">Existential</span> <span class="nb">type</span>
<span class="n">_</span> <span class="o">+</span> <span class="n">_</span>             <span class="o">//</span> <span class="n">Anonymous</span> <span class="n">function</span> <span class="n">placeholder</span> <span class="n">parameter</span>
<span class="n">m</span> <span class="n">_</span>               <span class="o">//</span> <span class="n">Eta</span> <span class="n">expansion</span> <span class="n">of</span> <span class="n">method</span> <span class="n">into</span> <span class="n">method</span> <span class="n">value</span>
<span class="n">m</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>              <span class="o">//</span> <span class="n">Partial</span> <span class="n">function</span> <span class="n">application</span>
<span class="n">_</span> <span class="o">=&gt;</span> <span class="mi">5</span>            <span class="o">//</span> <span class="n">Discarded</span> <span class="n">parameter</span>
<span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="o">=&gt;</span>         <span class="o">//</span> <span class="n">Wild</span> <span class="n">card</span> <span class="n">pattern</span> <span class="o">--</span> <span class="n">matches</span> <span class="n">anything</span>
<span class="n">f</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="n">_</span><span class="o">*</span><span class="p">)</span>         <span class="o">//</span> <span class="n">Sequence</span> <span class="n">xs</span> <span class="ow">is</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">multiple</span> <span class="n">parameters</span> <span class="n">to</span> <span class="n">f</span><span class="p">(</span><span class="n">ys</span><span class="p">:</span> <span class="n">T</span><span class="o">*</span><span class="p">)</span>
<span class="k">case</span><span class="w"> </span><span class="n">Seq</span><span class="p">(</span><span class="n">xs</span> <span class="o">@</span> <span class="k">_</span><span class="o">*</span><span class="p">)</span> <span class="o">//</span> <span class="n">Identifier</span> <span class="n">xs</span> <span class="ow">is</span> <span class="n">bound</span> <span class="n">to</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">matched</span> <span class="n">sequence</span>
</pre></div>

<p>I probably forgot some other meaning, though.</p>
<h3>Automatically imported methods</h3>
<p>So, if you did not find the symbol you are looking for in the list above, then
it must be a method, or part of one. But, often, you'll see some symbol and
the documentation for the class will not have that method. When this happens,
either you are looking at a composition of one or more methods with something
else, or the method has been imported into scope, or is available through an
imported implicit conversion.</p>
<p>These <em>can still be found</em> on ScalaDoc: you just have to know where to look
for them. Or, failing that, look at the index (presently broken on 2.9.1, but
available on nightly).</p>
<p>Every Scala code has three automatic imports:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span> <span class="n">Not</span> <span class="n">necessarily</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">order</span>
<span class="kn">import</span> <span class="nn">_root_.java.lang._</span>      <span class="o">//</span> <span class="n">_root_</span> <span class="n">denotes</span> <span class="n">an</span> <span class="n">absolute</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">_root_.scala._</span>
<span class="kn">import</span> <span class="nn">_root_.scala.Predef._</span>
</pre></div>

<p>The first two only make classes and singleton objects available. The third one
contains all implicit conversions and imported methods, since <code>Predef</code> is an
object itself.</p>
<p>Looking inside <code>Predef</code> quickly show some symbols:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> &lt;:&lt;
<span class="k">class</span> =:=
<span class="n">object</span> &lt;%&lt;
<span class="n">object</span> =:=
</pre></div>

<p>Any other symbol will be made available through an <em>implicit conversion</em>. Just
look at the methods tagged with <code>implicit</code> that receive, as parameter, an
object of type that is receiving the method. For example:</p>
<div class="code"><pre class="code literal-block"><span class="s">"a"</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="c1">// Look for an implicit from String, AnyRef, Any or type parameter</span>
</pre></div>

<p>In the above case, <code>-&gt;</code> is defined in the class <code>ArrowAssoc</code> through the
method <code>any2ArrowAssoc</code> that takes an object of type <code>A</code>, where <code>A</code> is an
unbounded type parameter to the same method.</p>
<h3>Common methods</h3>
<p>So, many symbols are simply methods on a class. For instance, if you do</p>
<div class="code"><pre class="code literal-block">List(1, 2) ++ List(3, 4)
</pre></div>

<p>You'll find the method <code>++</code> right on the ScalaDoc for List. However, there's
one convention that you must be aware when searching for methods. Methods
ending in colon (<code>:</code>) bind <em>to the right</em> instead of the left. In other words,
while the above method call is equivalent to:</p>
<div class="code"><pre class="code literal-block">List(1, 2).++(List(3, 4))
</pre></div>

<p>If I had, instead <code>1 :: List(2, 3)</code>, that would be equivalent to:</p>
<div class="code"><pre class="code literal-block">List(2, 3).::(1)
</pre></div>

<p>So you need to look at the type found <em>on the right</em> when looking for methods
ending in colon. Consider, for instance:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="p">:</span><span class="w"> </span><span class="kr">List</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="o">+</span><span class="w"> </span><span class="mf">4</span>
</pre></div>

<p>The first method (<code>+:</code>) binds to the right, and is found on <code>List</code>. The second
method (<code>:+</code>) is just a normal method, and binds to the left -- again, on
<code>List</code>.</p>
<h3>Syntactic sugars/composition</h3>
<p>So, here's a few syntactic sugars that may hide a method:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="nl">arr</span><span class="p">:</span><span class="w"> </span><span class="k">Array</span><span class="o">[</span><span class="n">Int</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Array</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="nl">n</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="k">update</span><span class="p">(</span><span class="nl">n</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">a_</span><span class="o">=</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">b_</span><span class="o">=</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">c_</span><span class="o">=</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">d_</span><span class="o">=</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">e_</span><span class="o">=</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="o">+</span><span class="p">(</span><span class="nl">v</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="k">map</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">unapply</span><span class="p">(</span><span class="nl">n</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">indices</span><span class="w"> </span><span class="k">contains</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">Some</span><span class="p">(</span><span class="n">arr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">None</span>
<span class="err">}</span>

<span class="n">val</span><span class="w"> </span><span class="n">Ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="nf">var</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">last</span><span class="w"> </span><span class="n">example</span>
<span class="n">println</span><span class="p">(</span><span class="n">Ex</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Ex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="k">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="n">Ex</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">b_</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">//</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="n">Ex</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ss">"val"</span>
<span class="n">val</span><span class="w"> </span><span class="n">Ex</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">unapply</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">assigns</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">c</span>
<span class="o">//</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="n">Ex</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ss">"var"</span>
<span class="n">Ex</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">substituted</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</pre></div>

<p>The last one is interesting, because <em>any</em> symbolic method can be combined to
form an assignment-like method that way.</p>
<p>And, of course, there's various combinations that can appear in code:</p>
<div class="code"><pre class="code literal-block">(_+_) // An expression, or parameter, that is an anonymous function with
      // two parameters, used exactly where the underscores appear, and
      // which calls the "+" method on the first parameter passing the
      // second parameter as argument.
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>One (good, IMO) difference between Scala and other languages is that it lets
you name your methods with almost any character.</p>
<p>What you enumerate is not "punctuation" but plain and simple methods, and as
such their behavior vary from one object to the other (though there are some
conventions).</p>
<p>For example, check the Scaladoc documentation for List, and you'll see some of
the methods you mentioned here.</p>
<p>Some things to keep in mind:</p>
<ul>
<li>
<p>Most of the times the <code>A operator+equal B</code> combination translates to <code>A = A operator B</code>, like in the <code>||=</code> or <code>++=</code> examples.</p>
</li>
<li>
<p>Methods that end in <code>:</code> are right associative, this means that <code>A :: B</code> is actually <code>B.::(A)</code>.</p>
</li>
</ul>
<p>You'll find most answers by browsing the Scala documentation. Keeping a
reference here would duplicate efforts, and it would fall behind quickly :)</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1983.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1981.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
