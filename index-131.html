<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 131) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-131.html">
<link rel="prev" href="index-132.html" type="text/html">
<link rel="next" href="index-130.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/throw-away-local-commits-in-git/" class="u-url">Throw away local commits in Git</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/throw-away-local-commits-in-git/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:23:50+08:00" itemprop="datePublished" title="2023-02-16 22:23">2023-02-16 22:23</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Due to some bad cherry-picking, my local Git repository is currently five
commits ahead of the origin, and not in a good state. I want to get rid of all
these commits and start over again.</p>
<p>Obviously, deleting my working directory and re-cloning would do it, but
downloading everything from GitHub again seems like overkill, and not a good
use of my time.</p>
<p>Maybe <code>git revert</code> is what I need, but I don't want to end up <em>10</em> commits
ahead of the origin (or even six), even if it does get the code itself back to
the right state. I just want to pretend the last half-hour never happened.</p>
<p>Is there a simple command that will do this? It seems like an obvious use
case, but I'm not finding any examples of it.</p>
<hr>
<p>Note that this question is specifically about <em>commits</em> , <em>not</em> about:</p>
<ul>
<li>untracked files</li>
<li>unstaged changes</li>
<li>staged, but uncommitted changes</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p>If your excess commits are only visible to you, you can just do <code>git reset
--hard origin/&lt;branch_name&gt;</code> to move back to where the origin is. This will
reset the state of the repository to the previous commit, and it will discard
all local changes.</p>
<p>Doing a <code>git revert</code> makes <em>new</em> commits to remove <em>old</em> commits in a way that
keeps everyone's history sane.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Delete the most recent commit, without destroying the work you've done:</p>
<p><code>git reset --soft HEAD~1</code></p>
<p>Delete the most recent commit and remove changes:</p>
<p><code>git reset --hard HEAD~1</code></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-can-templates-only-be-implemented-in-the-header-file/" class="u-url">Why can templates only be implemented in the header file?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-can-templates-only-be-implemented-in-the-header-file/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:22:58+08:00" itemprop="datePublished" title="2023-02-16 22:22">2023-02-16 22:22</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Quote from The C++ standard library: a tutorial and handbook:</p>
<blockquote>
<p>The only portable way of using templates at the moment is to implement them
in header files by using inline functions.</p>
</blockquote>
<p>Why is this?</p>
<p>(Clarification: header files are not the <em>only</em> portable solution. But they
are the most convenient portable solution.)</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Caveat: It is <em>not</em> necessary to put the implementation in the header file,
see the alternative solution at the end of this answer.</p>
<p>Anyway, the reason your code is failing is that, when instantiating a
template, the compiler creates a new class with the given template argument.
For example:</p>
<div class="code"><pre class="code literal-block"><span class="nv">template</span><span class="o">&lt;</span><span class="nv">typename</span><span class="w"> </span><span class="nv">T</span><span class="o">&gt;</span>
<span class="nv">struct</span><span class="w"> </span><span class="nv">Foo</span>
{
<span class="w">    </span><span class="nv">T</span><span class="w"> </span><span class="nv">bar</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">void</span><span class="w"> </span><span class="nv">doSomething</span><span class="ss">(</span><span class="nv">T</span><span class="w"> </span><span class="nv">param</span><span class="ss">)</span><span class="w"> </span>{<span class="cm">/* do stuff using T */</span>}
}<span class="c1">;</span>

<span class="o">//</span><span class="w"> </span><span class="nv">somewhere</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span>.<span class="nv">cpp</span>
<span class="nv">Foo</span><span class="o">&lt;</span><span class="nv">int</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">f</span><span class="c1">;</span>
</pre></div>

<p>When reading this line, the compiler will create a new class (let's call it
<code>FooInt</code>), which is equivalent to the following:</p>
<div class="code"><pre class="code literal-block"><span class="nv">struct</span><span class="w"> </span><span class="nv">FooInt</span>
{
<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">bar</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">void</span><span class="w"> </span><span class="nv">doSomething</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">param</span><span class="ss">)</span><span class="w"> </span>{<span class="cm">/* do stuff using int */</span>}
}
</pre></div>

<p>Consequently, the compiler needs to have access to the implementation of the
methods, to instantiate them with the template argument (in this case <code>int</code>).
If these implementations were not in the header, they wouldn't be accessible,
and therefore the compiler wouldn't be able to instantiate the template.</p>
<p>A common solution to this is to write the template declaration in a header
file, then implement the class in an implementation file (for example .tpp),
and include this implementation file at the end of the header.</p>
<p>Foo.h</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">param</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">"Foo.tpp"</span>
</pre></div>

<p>Foo.tpp</p>
<div class="code"><pre class="code literal-block">template &lt;typename T&gt;
void Foo&lt;T&gt;::doSomething(T param)
{
    //implementation
}
</pre></div>

<p>This way, implementation is still separated from declaration, but is
accessible to the compiler.</p>
<h2>Alternative solution</h2>
<p>Another solution is to keep the implementation separated, and explicitly
instantiate all the template instances you'll need:</p>
<p>Foo.h</p>
<div class="code"><pre class="code literal-block"><span class="c1">// no implementation</span>
<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">struct</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
</pre></div>

<p>Foo.cpp</p>
<div class="code"><pre class="code literal-block"><span class="c1">// implementation of Foo's methods</span>

<span class="c1">// explicit instantiations</span>
<span class="n">template</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">template</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">float</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// You will only be able to use Foo with int or float</span>
</pre></div>

<p>If my explanation isn't clear enough, you can have a look at the C++ Super-FAQ
on this subject.</p>
<p><br></p>
<h3>Suggest</h3>
<p>It's because of the requirement for separate compilation and because templates
are instantiation-style polymorphism.</p>
<p>Lets get a little closer to concrete for an explanation. Say I've got the
following files:</p>
<ul>
<li>foo.h <ul>
<li>declares the interface of <code>class MyClass&lt;T&gt;</code>
</li>
</ul>
</li>
<li>foo.cpp <ul>
<li>defines the implementation of <code>class MyClass&lt;T&gt;</code>
</li>
</ul>
</li>
<li>bar.cpp <ul>
<li>uses <code>MyClass&lt;int&gt;</code>
</li>
</ul>
</li>
</ul>
<p>Separate compilation means I should be able to compile <strong>foo.cpp</strong>
independently from <strong>bar.cpp</strong>. The compiler does all the hard work of
analysis, optimization, and code generation on each compilation unit
completely independently; we don't need to do whole-program analysis. It's
only the linker that needs to handle the entire program at once, and the
linker's job is substantially easier.</p>
<p><strong>bar.cpp</strong> doesn't even need to exist when I compile <strong>foo.cpp</strong> , but I
should still be able to link the <strong>foo.o</strong> I already had together with the
<strong>bar.o</strong> I've only just produced, without needing to recompile <strong>foo.cpp</strong>.
<strong>foo.cpp</strong> could even be compiled into a dynamic library, distributed
somewhere else without <strong>foo.cpp</strong> , and linked with code they write years
after I wrote <strong>foo.cpp</strong>.</p>
<p>"Instantiation-style polymorphism" means that the template <code>MyClass&lt;T&gt;</code> isn't
really a generic class that can be compiled to code that can work for any
value of <code>T</code>. That would add overhead such as boxing, needing to pass function
pointers to allocators and constructors, etc. The intention of C++ templates
is to avoid having to write nearly identical <code>class MyClass_int</code>, <code>class
MyClass_float</code>, etc, but to still be able to end up with compiled code that is
mostly as if we <em>had</em> written each version separately. So a template is
<em>literally</em> a template; a class template is <em>not</em> a class, it's a recipe for
creating a new class for each <code>T</code> we encounter. A template cannot be compiled
into code, only the result of instantiating the template can be compiled.</p>
<p>So when <strong>foo.cpp</strong> is compiled, the compiler can't see <strong>bar.cpp</strong> to know
that <code>MyClass&lt;int&gt;</code> is needed. It can see the template <code>MyClass&lt;T&gt;</code>, but it
can't emit code for that (it's a template, not a class). And when <strong>bar.cpp</strong>
is compiled, the compiler can see that it needs to create a <code>MyClass&lt;int&gt;</code>,
but it can't see the template <code>MyClass&lt;T&gt;</code> (only its interface in <strong>foo.h</strong> )
so it can't create it.</p>
<p>If <strong>foo.cpp</strong> itself uses <code>MyClass&lt;int&gt;</code>, then code for that will be
generated while compiling <strong>foo.cpp</strong> , so when <strong>bar.o</strong> is linked to
<strong>foo.o</strong> they can be hooked up and will work. We can use that fact to allow a
finite set of template instantiations to be implemented in a .cpp file by
writing a single template. But there's no way for <strong>bar.cpp</strong> to use the
template <em>as a template</em> and instantiate it on whatever types it likes; it can
only use pre-existing versions of the templated class that the author of
<strong>foo.cpp</strong> thought to provide.</p>
<p>You might think that when compiling a template the compiler should "generate
all versions", with the ones that are never used being filtered out during
linking. Aside from the huge overhead and the extreme difficulties such an
approach would face because "type modifier" features like pointers and arrays
allow even just the built-in types to give rise to an infinite number of
types, what happens when I now extend my program by adding:</p>
<ul>
<li>baz.cpp <ul>
<li>declares and implements <code>class BazPrivate</code>, and uses <code>MyClass&lt;BazPrivate&gt;</code>
</li>
</ul>
</li>
</ul>
<p>There is no possible way that this could work unless we either</p>
<ol>
<li>Have to recompile <strong>foo.cpp</strong> every time we change <em>any other file in the program</em> , in case it added a new novel instantiation of <code>MyClass&lt;T&gt;</code>
</li>
<li>Require that <strong>baz.cpp</strong> contains (possibly via header includes) the full template of <code>MyClass&lt;T&gt;</code>, so that the compiler can generate <code>MyClass&lt;BazPrivate&gt;</code> during compilation of <strong>baz.cpp</strong>.</li>
</ol>
<p>Nobody likes (1), because whole-program-analysis compilation systems take
<em>forever</em> to compile , and because it makes it impossible to distribute
compiled libraries without the source code. So we have (2) instead.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/programmatically-navigate-using-react-router/" class="u-url">Programmatically navigate using React router</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/programmatically-navigate-using-react-router/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:21:53+08:00" itemprop="datePublished" title="2023-02-16 22:21">2023-02-16 22:21</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>With <code>react-router</code> I can use the <code>Link</code> element to create links which are
natively handled by react router.</p>
<p>I see internally it calls <code>this.context.transitionTo(...)</code>.</p>
<p>I want to do a navigation. Not from a link, but from a dropdown selection (as
an example). How can I do this in code? What is <code>this.context</code>?</p>
<p>I saw the <code>Navigation</code> mixin, but can I do this without <code>mixins</code>?</p>
<p><br><br></p>
<h2>Answer</h2>
<blockquote>
<p>UPDATE: 2022: <strong>React Router v6.6.1 with useNavigate</strong></p>
</blockquote>
<p>The <code>useHistory()</code> hook is now deprecated. If you are using React Router 6,
the proper way to navigate programmatically is as follows:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">useNavigate</span> <span class="p">}</span> <span class="kn">from</span> <span class="s2">"react-router-dom"</span><span class="p">;</span>

<span class="n">function</span> <span class="n">HomeButton</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">navigate</span> <span class="o">=</span> <span class="n">useNavigate</span><span class="p">();</span>

  <span class="n">function</span> <span class="n">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">navigate</span><span class="p">(</span><span class="s2">"/home"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="n">button</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"button"</span> <span class="n">onClick</span><span class="o">=</span><span class="p">{</span><span class="n">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="n">Go</span> <span class="n">home</span>
    <span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p><strong>React Router v5.1.0 with hooks</strong></p>
</blockquote>
<p>There is a new <code>useHistory</code> hook in React Router &gt;5.1.0 if you are using React</p>
<blockquote>
<p>16.8.0 and functional components.</p>
</blockquote>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">useHistory</span> <span class="p">}</span> <span class="kn">from</span> <span class="s2">"react-router-dom"</span><span class="p">;</span>

<span class="n">function</span> <span class="n">HomeButton</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">history</span> <span class="o">=</span> <span class="n">useHistory</span><span class="p">();</span>

  <span class="n">function</span> <span class="n">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">history</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s2">"/home"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="n">button</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"button"</span> <span class="n">onClick</span><span class="o">=</span><span class="p">{</span><span class="n">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="n">Go</span> <span class="n">home</span>
    <span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p><strong>React Router v4</strong></p>
</blockquote>
<p>With v4 of React Router, there are three approaches that you can take to
programmatic routing within components.</p>
<ol>
<li>Use the <code>withRouter</code> higher-order component.</li>
<li>Use composition and render a <code>&lt;Route&gt;</code>
</li>
<li>Use the <code>context</code>.</li>
</ol>
<p>React Router is mostly a wrapper around the <code>history</code> library. <code>history</code>
handles interaction with the browser's <code>window.history</code> for you with its
browser and hash histories. It also provides a memory history which is useful
for environments that don't have a global history. This is particularly useful
in mobile app development (<code>react-native</code>) and unit testing with Node.</p>
<p>A <code>history</code> instance has two methods for navigating: <code>push</code> and <code>replace</code>. If
you think of the <code>history</code> as an array of visited locations, <code>push</code> will add a
new location to the array and <code>replace</code> will replace the current location in
the array with the new one. Typically you will want to use the <code>push</code> method
when you are navigating.</p>
<p>In earlier versions of React Router, you had to create your own <code>history</code>
instance, but in v4 the <code>&lt;BrowserRouter&gt;</code>, <code>&lt;HashRouter&gt;</code>, and
<code>&lt;MemoryRouter&gt;</code> components will create a browser, hash, and memory instances
for you. React Router makes the properties and methods of the <code>history</code>
instance associated with your router available through the context, under the
<code>router</code> object.</p>
<h4>1. Use the <code>withRouter</code> higher-order component</h4>
<p>The <code>withRouter</code> higher-order component will inject the <code>history</code> object as a
prop of the component. This allows you to access the <code>push</code> and <code>replace</code>
methods without having to deal with the <code>context</code>.</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">withRouter</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">'react-router-dom'</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">also</span> <span class="n">works</span> <span class="k">with</span> <span class="n">react</span><span class="o">-</span><span class="n">router</span><span class="o">-</span><span class="n">native</span>

<span class="n">const</span> <span class="n">Button</span> <span class="o">=</span> <span class="n">withRouter</span><span class="p">(({</span> <span class="n">history</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="n">button</span>
    <span class="nb">type</span><span class="o">=</span><span class="s1">'button'</span>
    <span class="n">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">history</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/new-location'</span><span class="p">)</span> <span class="p">}}</span>
  <span class="o">&gt;</span>
    <span class="n">Click</span> <span class="n">Me</span><span class="err">!</span>
  <span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
<span class="p">))</span>
</pre></div>

<h4>2. Use composition and render a <code>&lt;Route&gt;</code>
</h4>
<p>The <code>&lt;Route&gt;</code> component isn't just for matching locations. You can render a
pathless route and <strong>it will always match the current location</strong>. The
<code>&lt;Route&gt;</code> component passes the same props as <code>withRouter</code>, so you will be able
to access the <code>history</code> methods through the <code>history</code> prop.</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">Route</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">'react-router-dom'</span>

<span class="n">const</span> <span class="n">Button</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="n">Route</span> <span class="n">render</span><span class="o">=</span><span class="p">{({</span> <span class="n">history</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="n">button</span>
      <span class="nb">type</span><span class="o">=</span><span class="s1">'button'</span>
      <span class="n">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">history</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/new-location'</span><span class="p">)</span> <span class="p">}}</span>
    <span class="o">&gt;</span>
      <span class="n">Click</span> <span class="n">Me</span><span class="err">!</span>
    <span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
  <span class="p">)}</span> <span class="o">/&gt;</span>
<span class="p">)</span>
</pre></div>

<h4>3. Use the context*</h4>
<p><strong>But you probably should not</strong></p>
<p>The last option is one that you should only use if you feel comfortable
working with React's context model (React's Context API is stable as of v16).</p>
<div class="code"><pre class="code literal-block">const<span class="w"> </span>Button<span class="w"> </span>=<span class="w"> </span>(props,<span class="w"> </span>context)<span class="w"> </span>=&gt;<span class="w"> </span>(
<span class="w">  </span><span class="nt">&lt;button</span>
<span class="w">    </span><span class="na">type=</span><span class="s">'button'</span>
<span class="w">    </span><span class="na">onClick=</span><span class="s">{()</span><span class="w"> </span><span class="err">=</span><span class="nt">&gt;</span><span class="w"> </span>{
<span class="w">      </span>//<span class="w"> </span>context.history.push<span class="w"> </span>===<span class="w"> </span>history.push
<span class="w">      </span>context.history.push('/new-location')
<span class="w">    </span>}}
<span class="w">  </span>&gt;
<span class="w">    </span>Click<span class="w"> </span>Me!
<span class="w">  </span><span class="nt">&lt;/button&gt;</span>
)

//<span class="w"> </span>you<span class="w"> </span>need<span class="w"> </span>to<span class="w"> </span>specify<span class="w"> </span>the<span class="w"> </span>context<span class="w"> </span>type<span class="w"> </span>so<span class="w"> </span>that<span class="w"> </span>it
//<span class="w"> </span>is<span class="w"> </span>available<span class="w"> </span>within<span class="w"> </span>the<span class="w"> </span>component
Button.contextTypes<span class="w"> </span>=<span class="w"> </span>{
<span class="w">  </span>history:<span class="w"> </span>React.PropTypes.shape({
<span class="w">    </span>push:<span class="w"> </span>React.PropTypes.func.isRequired
<span class="w">  </span>})
}
</pre></div>

<p>1 and 2 are the simplest choices to implement, so for most use cases, they are
your best bets.</p>
<p><br></p>
<h3>Suggest</h3>
<blockquote>
<p><strong>React-Router v6+</strong> Answer</p>
</blockquote>
<p><strong>TL;DR:</strong> You can use the new <code>useNavigate</code> hook.</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">useNavigate</span> <span class="p">}</span> <span class="kn">from</span> <span class="s2">"react-router-dom"</span><span class="p">;</span>

<span class="n">function</span> <span class="n">Component</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">navigate</span> <span class="o">=</span> <span class="n">useNavigate</span><span class="p">();</span>
  <span class="o">//</span> <span class="n">Somewhere</span> <span class="ow">in</span> <span class="n">your</span> <span class="n">code</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">handler</span><span class="p">:</span>
  <span class="n">navigate</span><span class="p">(</span><span class="s2">"/posts"</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>

<p>The <code>useNavigate</code> hook returns a function which can be used for programmatic
navigation.</p>
<p>Example from the react router documentaion</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">useNavigate</span> <span class="p">}</span> <span class="kn">from</span> <span class="s2">"react-router-dom"</span><span class="p">;</span>

<span class="n">function</span> <span class="n">SignupForm</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">navigate</span> <span class="o">=</span> <span class="n">useNavigate</span><span class="p">();</span>

  <span class="k">async</span> <span class="n">function</span> <span class="n">handleSubmit</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">event</span><span class="o">.</span><span class="n">preventDefault</span><span class="p">();</span>
    <span class="k">await</span> <span class="n">submitForm</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">target</span><span class="p">);</span>
    <span class="n">navigate</span><span class="p">(</span><span class="s2">"../success"</span><span class="p">,</span> <span class="p">{</span> <span class="n">replace</span><span class="p">:</span> <span class="n">true</span> <span class="p">});</span>
    <span class="o">//</span> <span class="n">replace</span><span class="p">:</span> <span class="n">true</span> <span class="n">will</span> <span class="n">replace</span> <span class="n">the</span> <span class="n">current</span> <span class="n">entry</span> <span class="ow">in</span> 
    <span class="o">//</span> <span class="n">the</span> <span class="n">history</span> <span class="n">stack</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">adding</span> <span class="n">a</span> <span class="n">new</span> <span class="n">one</span><span class="o">.</span>

  <span class="p">}</span>

  <span class="k">return</span> <span class="o">&lt;</span><span class="n">form</span> <span class="n">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="n">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">form</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p><strong>React-Router 5.1.0+</strong> Answer (using hooks and React &gt;16.8)</p>
</blockquote>
<p>You can use the <code>useHistory</code> hook on Functional Components and
Programmatically navigate:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">useHistory</span> <span class="p">}</span> <span class="kn">from</span> <span class="s2">"react-router-dom"</span><span class="p">;</span>

<span class="n">function</span> <span class="n">HomeButton</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">history</span> <span class="o">=</span> <span class="n">useHistory</span><span class="p">();</span>
  <span class="o">//</span> <span class="n">use</span> <span class="n">history</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/some/path'</span><span class="p">)</span> <span class="n">here</span>
<span class="p">};</span>
</pre></div>

<blockquote>
<p><strong>React-Router 4.0.0+</strong> Answer</p>
</blockquote>
<p>In 4.0 and above, use the history as a prop of your component.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">React</span><span class="o">.</span><span class="n">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="err">`</span><span class="n">this</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/some/path'</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">here</span>
<span class="p">};</span>
</pre></div>

<p>NOTE: <code>this.props.history</code> does not exist in the case your component was not
rendered by <code>&lt;Route&gt;</code>. You should use <code>&lt;Route path="..."
component={YourComponent}/&gt;</code> to have <code>this.props.history</code> in YourComponent</p>
<blockquote>
<p><strong>React-Router 3.0.0+</strong> Answer</p>
</blockquote>
<p>In 3.0 and above, use the router as a prop of your component.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">React</span><span class="o">.</span><span class="n">Component</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="err">`</span><span class="n">this</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">router</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/some/path'</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">here</span>
<span class="p">};</span>
</pre></div>

<blockquote>
<p><strong>React-Router 2.4.0+</strong> Answer</p>
</blockquote>
<p>In 2.4 and above, use a higher order component to get the router as a prop of
your component.</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">withRouter</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">'react-router'</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Example</span> <span class="n">extends</span> <span class="n">React</span><span class="o">.</span><span class="n">Component</span> <span class="p">{</span>
   <span class="o">//</span> <span class="n">use</span> <span class="err">`</span><span class="n">this</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">router</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">'/some/path'</span><span class="p">)</span><span class="err">`</span> <span class="n">here</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Export</span> <span class="n">the</span> <span class="n">decorated</span> <span class="k">class</span>
<span class="nc">var</span> <span class="n">DecoratedExample</span> <span class="o">=</span> <span class="n">withRouter</span><span class="p">(</span><span class="n">Example</span><span class="p">);</span>

<span class="o">//</span> <span class="n">PropTypes</span>
<span class="n">Example</span><span class="o">.</span><span class="n">propTypes</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">router</span><span class="p">:</span> <span class="n">React</span><span class="o">.</span><span class="n">PropTypes</span><span class="o">.</span><span class="n">shape</span><span class="p">({</span>
    <span class="n">push</span><span class="p">:</span> <span class="n">React</span><span class="o">.</span><span class="n">PropTypes</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">isRequired</span>
  <span class="p">})</span><span class="o">.</span><span class="n">isRequired</span>
<span class="p">};</span>
</pre></div>

<blockquote>
<p><strong>React-Router 2.0.0+</strong> Answer</p>
</blockquote>
<p>This version is backwards compatible with 1.x so there's no need to an Upgrade
Guide. Just going through the examples should be good enough.</p>
<p>That said, if you wish to switch to the new pattern, there's a
<code>browserHistory</code> module inside the router that you can access with</p>
<p><code>import { browserHistory } from 'react-router'</code></p>
<p>Now you have access to your browser history, so you can do things like push,
replace, etc... Like:</p>
<p><code>browserHistory.push('/some/path')</code></p>
<p>Further reading: Histories and Navigation</p>
<hr>
<blockquote>
<p><strong>React-Router 1.x.x</strong> Answer</p>
</blockquote>
<p>I will not go into upgrading details. You can read about that in the Upgrade
Guide</p>
<p>The main change about the question here is the change from <code>Navigation</code> mixin
to <code>History</code>. Now it's using the browser historyAPI to change route so we will
use <code>pushState()</code> from now on.</p>
<p>Here's an exemple using Mixin:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">React</span><span class="o">.</span><span class="n">createClass</span><span class="p">({</span>
<span class="w">  </span><span class="n">mixins</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">History</span><span class="w"> </span><span class="p">],</span>
<span class="w">  </span><span class="n">navigateToHelpPage</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">pushState</span><span class="p">(</span><span class="nb nb-Type">null</span><span class="p">,</span><span class="w"> </span><span class="err">`</span><span class="o">/</span><span class="n">help</span><span class="err">`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">})</span>
</pre></div>

<p>Note that this <code>History</code> comes from rackt/history project. Not from React-
Router itself.</p>
<p>If you don't want to use Mixin for some reason (maybe because of ES6 class),
then you can access the history that you get from the router from
<code>this.props.history</code>. It will be only accessible for the components rendered
by your <code>Router</code>. So, if you want to use it in any child components it needs
to be passed down as an attribute via <code>props</code>.</p>
<p>You can read more about the new release at their 1.0.x documentation</p>
<p>Here is a help page specifically about navigating outside your component</p>
<p>It recommends grabbing a reference <code>history = createHistory()</code> and calling
<code>replaceState</code> on that.</p>
<blockquote>
<p><strong>React-Router 0.13.x</strong> Answer</p>
</blockquote>
<p>I got into the same problem and could only find the solution with the
Navigation mixin that comes with react-router.</p>
<p>Here's how I did it</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">React</span> <span class="kn">from</span> <span class="s1">'react'</span><span class="p">;</span>
<span class="kn">import</span> <span class="p">{</span><span class="n">Navigation</span><span class="p">}</span> <span class="kn">from</span> <span class="s1">'react-router'</span><span class="p">;</span>

<span class="n">let</span> <span class="n">Authentication</span> <span class="o">=</span> <span class="n">React</span><span class="o">.</span><span class="n">createClass</span><span class="p">({</span>
  <span class="n">mixins</span><span class="p">:</span> <span class="p">[</span><span class="n">Navigation</span><span class="p">],</span>

  <span class="n">handleClick</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="o">.</span><span class="n">preventDefault</span><span class="p">();</span>

    <span class="n">this</span><span class="o">.</span><span class="n">transitionTo</span><span class="p">(</span><span class="s1">'/'</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="n">render</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">div</span> <span class="n">onClick</span><span class="o">=</span><span class="p">{</span><span class="n">this</span><span class="o">.</span><span class="n">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="n">Click</span> <span class="n">me</span><span class="err">!</span><span class="o">&lt;/</span><span class="n">div</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>I was able to call <code>transitionTo()</code> without the need to access <code>.context</code></p>
<p>Or you could try the fancy ES6 <code>class</code></p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">React</span> <span class="kn">from</span> <span class="s1">'react'</span><span class="p">;</span>

<span class="n">export</span> <span class="n">default</span> <span class="k">class</span> <span class="nc">Authentication</span> <span class="n">extends</span> <span class="n">React</span><span class="o">.</span><span class="n">Component</span> <span class="p">{</span>
  <span class="n">constructor</span><span class="p">(</span><span class="n">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">props</span><span class="p">);</span>
    <span class="n">this</span><span class="o">.</span><span class="n">handleClick</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">handleClick</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">handleClick</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="o">.</span><span class="n">preventDefault</span><span class="p">();</span>

    <span class="n">this</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">router</span><span class="o">.</span><span class="n">transitionTo</span><span class="p">(</span><span class="s1">'/'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">render</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">div</span> <span class="n">onClick</span><span class="o">=</span><span class="p">{</span><span class="n">this</span><span class="o">.</span><span class="n">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="n">Click</span> <span class="n">me</span><span class="err">!</span><span class="o">&lt;/</span><span class="n">div</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Authentication</span><span class="o">.</span><span class="n">contextTypes</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">router</span><span class="p">:</span> <span class="n">React</span><span class="o">.</span><span class="n">PropTypes</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">isRequired</span>
<span class="p">};</span>
</pre></div>

<blockquote>
<p><strong>React-Router-Redux</strong></p>
<p><strong>Note:</strong> if you're using Redux, there is another project called React-
Router-Redux that gives you redux bindings for ReactRouter, using somewhat
the same approach that React-Redux does</p>
</blockquote>
<p>React-Router-Redux has a few methods available that allow for simple
navigating from inside action creators. These can be particularly useful for
people that have existing architecture in React Native, and they wish to
utilize the same patterns in React Web with minimal boilerplate overhead.</p>
<p>Explore the following methods:</p>
<ul>
<li><code>push(location)</code></li>
<li><code>replace(location)</code></li>
<li><code>go(number)</code></li>
<li><code>goBack()</code></li>
<li><code>goForward()</code></li>
</ul>
<p>Here is an example usage, with Redux-Thunk:</p>
<p><strong>./actioncreators.js</strong></p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="p">{</span> <span class="n">goBack</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">'react-router-redux'</span>

<span class="n">export</span> <span class="n">const</span> <span class="n">onBackPress</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">goBack</span><span class="p">())</span>
</pre></div>

<p><strong>./viewcomponent.js</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;button</span>
<span class="w">  </span><span class="na">disabled=</span><span class="s">{submitting}</span>
<span class="w">  </span><span class="na">className=</span><span class="s">"cancel_button"</span>
<span class="w">  </span><span class="na">onClick=</span><span class="s">{(e)</span><span class="w"> </span><span class="err">=</span><span class="nt">&gt;</span><span class="w"> </span>{
<span class="w">    </span>e.preventDefault()
<span class="w">    </span>this.props.onBackPress()
<span class="w">  </span>}}
&gt;
<span class="w">  </span>CANCEL
<span class="nt">&lt;/button&gt;</span>
</pre></div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-132.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-130.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
