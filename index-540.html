<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 540) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-540.html">
<link rel="prev" href="index-541.html" type="text/html">
<link rel="next" href="index-539.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-it-possible-to-add-dynamically-named-properties-to-javascript-object/" class="u-url">Is it possible to add dynamically named properties to JavaScript object?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-it-possible-to-add-dynamically-named-properties-to-javascript-object/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:28:56+08:00" itemprop="datePublished" title="2023-02-17 09:28">2023-02-17 09:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>In JavaScript, I've created an object like so:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">'PropertyA'</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="s1">'PropertyB'</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="s1">'PropertyC'</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span>
<span class="p">};</span>
</pre></div>

<p>Is it possible to add further properties to this object after its initial
creation if the properties name is not determined until run time? i.e.</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">propName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Property'</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">someUserInput</span>
<span class="o">//</span><span class="n">imagine</span><span class="w"> </span><span class="n">someUserInput</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="s1">'Z'</span><span class="p">,</span><span class="w"> </span><span class="n">how</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="s1">'PropertyZ'</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">to</span><span class="w"> </span>
<span class="o">//</span><span class="n">my</span><span class="w"> </span><span class="n">object</span><span class="err">?</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Yes.</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">'PropertyA'</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="s1">'PropertyB'</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="s1">'PropertyC'</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span>
<span class="p">};</span>

<span class="n">data</span><span class="p">[</span><span class="s2">"PropertyD"</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="o">//</span><span class="w"> </span><span class="n">dialog</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">it</span>
<span class="n">alert</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">PropertyD</span><span class="p">);</span>
<span class="n">alert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">"PropertyD"</span><span class="p">]);</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>ES6 for the win!</p>
<div class="code"><pre class="code literal-block"><span class="n">const</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'B'</span><span class="p">;</span>
<span class="n">const</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'C'</span><span class="p">;</span>

<span class="n">const</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="nl">a</span><span class="p">:</span><span class="w"> </span><span class="k">true</span><span class="p">,</span>
<span class="w">    </span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="err">:</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">dynamic</span><span class="w"> </span><span class="n">property</span>
<span class="w">    </span><span class="o">[</span><span class="n">`interpolated-${c}`</span><span class="o">]</span><span class="err">:</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">dynamic</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">interpolation</span>
<span class="w">    </span><span class="o">[</span><span class="n">`${b}-${c}`</span><span class="o">]</span><span class="err">:</span><span class="w"> </span><span class="k">true</span>
<span class="err">}</span>
</pre></div>

<p>If you log <code>data</code> you get this:</p>
<div class="code"><pre class="code literal-block">{
  a: true,
  B: true,
  interpolated-C: true,
  B-C: true
}
</pre></div>

<p>This makes use of the new Computed Property syntax and Template Literals.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-right-align-flex-item/" class="u-url">How to Right-align flex item?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-right-align-flex-item/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:28:30+08:00" itemprop="datePublished" title="2023-02-17 09:28">2023-02-17 09:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Is there a more flexbox-ish way to right-align "Contact" than to use
<code>position: absolute</code>?</p>
<div class="code"><pre class="code literal-block">.main<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
}

.a,
.b,
.c<span class="w"> </span>{
<span class="w">  </span>background:<span class="w"> </span>#efefef;
<span class="w">  </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>#999;
}

.b<span class="w"> </span>{
<span class="w">  </span>flex:<span class="w"> </span>1;
<span class="w">  </span>text-align:<span class="w"> </span>center;
}

.c<span class="w"> </span>{
<span class="w">  </span>position:<span class="w"> </span>absolute;
<span class="w">  </span>right:<span class="w"> </span>0;
}


<span class="nt">&lt;h2&gt;</span>With<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"b"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Some<span class="w"> </span>title<span class="w"> </span>centered<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;h2&gt;</span>Without<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="cm">&lt;!--&lt;div class="b"&gt;&lt;a href="#"&gt;Some title centered&lt;/a&gt;&lt;/div&gt;--&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>http://jsfiddle.net/vqDK9/</p>
<p><br><br></p>
<h2>Answer</h2>
<p>A more flex approach would be to use an <code>auto</code> left margin (flex items treat
auto margins a bit differently than when used in a block formatting context).</p>
<div class="code"><pre class="code literal-block"><span class="na">.c</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">margin-left:</span><span class="w"> </span><span class="nf">auto</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p><strong>Updated fiddle:</strong></p>
<div class="code"><pre class="code literal-block">.main<span class="w"> </span>{<span class="w"> </span>display:<span class="w"> </span>flex;<span class="w"> </span>}
.a,<span class="w"> </span>.b,<span class="w"> </span>.c<span class="w"> </span>{<span class="w"> </span>background:<span class="w"> </span>#efefef;<span class="w"> </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>#999;<span class="w"> </span>}
.b<span class="w"> </span>{<span class="w"> </span>flex:<span class="w"> </span>1;<span class="w"> </span>text-align:<span class="w"> </span>center;<span class="w"> </span>}
.c<span class="w"> </span>{margin-left:<span class="w"> </span>auto;}


<span class="nt">&lt;h2&gt;</span>With<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"b"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Some<span class="w"> </span>title<span class="w"> </span>centered<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;h2&gt;</span>Without<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">    </span><span class="cm">&lt;!--&lt;div class="b"&gt;&lt;a href="#"&gt;Some title centered&lt;/a&gt;&lt;/div&gt;--&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;h1&gt;</span>Problem<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;p&gt;</span>Is<span class="w"> </span>there<span class="w"> </span>a<span class="w"> </span>more<span class="w"> </span>flexbox-ish<span class="w"> </span>way<span class="w"> </span>to<span class="w"> </span>right<span class="w"> </span>align<span class="w"> </span>"Contact"<span class="w"> </span>than<span class="w"> </span>to<span class="w"> </span>use<span class="w"> </span>position<span class="w"> </span>absolute?<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>Here you go. Set <code>justify-content: space-between</code> on the flex container.</p>
<div class="code"><pre class="code literal-block">.main<span class="w"> </span>{<span class="w"> </span>
<span class="w">    </span>display:<span class="w"> </span>flex;<span class="w"> </span>
<span class="w">    </span>justify-content:<span class="w"> </span>space-between;
<span class="w">  </span>}
.a,<span class="w"> </span>.b,<span class="w"> </span>.c<span class="w"> </span>{<span class="w"> </span>background:<span class="w"> </span>#efefef;<span class="w"> </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>#999;<span class="w"> </span>}
.b<span class="w"> </span>{<span class="w"> </span>text-align:<span class="w"> </span>center;<span class="w"> </span>}


<span class="nt">&lt;h2&gt;</span>With<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"b"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Some<span class="w"> </span>title<span class="w"> </span>centered<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;h2&gt;</span>Without<span class="w"> </span>title<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"main"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"a"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Home<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="cm">&lt;!--     &lt;div class="b"&gt;&lt;a href="#"&gt;Some title centered&lt;/a&gt;&lt;/div&gt; --&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"c"</span><span class="nt">&gt;&lt;a</span><span class="w"> </span><span class="na">href=</span><span class="s">"#"</span><span class="nt">&gt;</span>Contact<span class="nt">&lt;/a&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-does-c-code-for-testing-the-collatz-conjecture-run-faster-than-hand-written-assembly/" class="u-url">Why does C++ code for testing the Collatz conjecture run faster than hand-written assembly?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-does-c-code-for-testing-the-collatz-conjecture-run-faster-than-hand-written-assembly/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:28:01+08:00" itemprop="datePublished" title="2023-02-17 09:28">2023-02-17 09:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I wrote these two solutions for Project Euler Q14, in assembly and in C++.
They implement identical brute force approach for testing the Collatz
conjecture. The assembly solution was assembled with:</p>
<div class="code"><pre class="code literal-block">nasm -felf64 p14.asm &amp;&amp; gcc p14.o -o p14
</pre></div>

<p>The C++ was compiled with:</p>
<div class="code"><pre class="code literal-block">g++ p14.cpp -o p14
</pre></div>

<p>Assembly, <code>p14.asm</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nt">section</span><span class="w"> </span><span class="p">.</span><span class="nc">data</span>
<span class="w">    </span><span class="nt">fmt</span><span class="w"> </span><span class="nt">db</span><span class="w"> </span><span class="s2">"%d"</span><span class="o">,</span><span class="w"> </span><span class="nt">10</span><span class="o">,</span><span class="w"> </span><span class="nt">0</span>

<span class="nt">global</span><span class="w"> </span><span class="nt">main</span>
<span class="nt">extern</span><span class="w"> </span><span class="nt">printf</span>

<span class="nt">section</span><span class="w"> </span><span class="p">.</span><span class="nc">text</span>

<span class="nt">main</span><span class="o">:</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rcx</span><span class="o">,</span><span class="w"> </span><span class="nt">1000000</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">rdi</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">max</span><span class="w"> </span><span class="nt">i</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rsi</span><span class="o">,</span><span class="w"> </span><span class="nt">rsi</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">i</span>

<span class="nt">l1</span><span class="o">:</span>
<span class="w">    </span><span class="nt">dec</span><span class="w"> </span><span class="nt">rcx</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">r10</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">count</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">rcx</span>

<span class="nt">l2</span><span class="o">:</span>
<span class="w">    </span><span class="nt">test</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span>
<span class="w">    </span><span class="nt">jpe</span><span class="w"> </span><span class="nt">even</span>

<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rbx</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span>
<span class="w">    </span><span class="nt">mul</span><span class="w"> </span><span class="nt">rbx</span>
<span class="w">    </span><span class="nt">inc</span><span class="w"> </span><span class="nt">rax</span>
<span class="w">    </span><span class="nt">jmp</span><span class="w"> </span><span class="nt">c1</span>

<span class="nt">even</span><span class="o">:</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rbx</span><span class="o">,</span><span class="w"> </span><span class="nt">2</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rdx</span><span class="o">,</span><span class="w"> </span><span class="nt">rdx</span>
<span class="w">    </span><span class="nt">div</span><span class="w"> </span><span class="nt">rbx</span>

<span class="nt">c1</span><span class="o">:</span>
<span class="w">    </span><span class="nt">inc</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span>
<span class="w">    </span><span class="nt">jne</span><span class="w"> </span><span class="nt">l2</span>

<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmovl</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmovl</span><span class="w"> </span><span class="nt">rsi</span><span class="o">,</span><span class="w"> </span><span class="nt">rcx</span>

<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rcx</span><span class="o">,</span><span class="w"> </span><span class="nt">2</span>
<span class="w">    </span><span class="nt">jne</span><span class="w"> </span><span class="nt">l1</span>

<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">fmt</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">rax</span>
<span class="w">    </span><span class="nt">call</span><span class="w"> </span><span class="nt">printf</span>
<span class="w">    </span><span class="nt">ret</span>
</pre></div>

<p>C++, <code>p14.cpp</code>:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">sequence</span><span class="p">(</span><span class="kr">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">maxi</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999999</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequence</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nf">max</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nf">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">            </span><span class="n">maxi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maxi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>I know about the compiler optimizations to improve speed and everything, but I
don’t see many ways to further optimize my assembly solution (speaking
programmatically, not mathematically).</p>
<p>The C++ code uses modulus every term and division every other term, while the
assembly code only uses a single division every other term.</p>
<p>But the assembly is taking on average 1 second longer than the C++ solution.
Why is this? I am asking mainly out of curiosity.</p>
<h4>Execution times</h4>
<p>My system: 64-bit Linux on 1.4 GHz Intel Celeron 2955U (Haswell
microarchitecture).</p>
<ul>
<li>
<code>g++</code> (unoptimized): avg 1272 ms.</li>
<li>
<code>g++ -O3</code>: avg 578 ms.</li>
<li>
<code>asm (div)</code> (original): avg 2650 ms.</li>
<li>
<code>asm (shr)</code>: avg 679 ms.</li>
<li>@johnfound asm (assembled with NASM): avg 501 ms.</li>
<li>@hidefromkgb asm: avg 200 ms.</li>
<li>@hidefromkgb asm, optimized by @Peter Cordes: avg 145 ms.</li>
<li>@Veedrac C++: avg 81 ms with <code>-O3</code>, 305 ms with <code>-O0</code>.</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p>If you think a 64-bit DIV instruction is a good way to divide by two, then no
wonder the compiler's asm output beat your hand-written code, even with <code>-O0</code>
(compile fast, no extra optimization, and store/reload to memory after/before
every C statement so a debugger can modify variables).</p>
<p>See Agner Fog's Optimizing Assembly guide to learn how to write efficient asm.
He also has instruction tables and a microarch guide for specific details for
specific CPUs. See also the x86 tag wiki for more perf links.</p>
<p>See also this more general question about beating the compiler with hand-
written asm: Is inline assembly language slower than native C++ code?. TL:DR:
yes if you do it wrong (like this question).</p>
<p>Usually you're fine letting the compiler do its thing, especially if you <strong>try
to write C++ that can compile efficiently</strong>. Also see is assembly faster than
compiled languages?. One of the answers links to these neat slides showing how
various C compilers optimize some really simple functions with cool tricks.
<strong>Matt Godbolt's CppCon2017 talk “What Has My Compiler Done for Me Lately?
Unbolting the Compiler's Lid” is in a similar vein.</strong></p>
<hr>
<div class="code"><pre class="code literal-block"><span class="n">even</span><span class="o">:</span>
<span class="w">    </span><span class="n">mov</span><span class="w"> </span><span class="n">rbx</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="n">xor</span><span class="w"> </span><span class="n">rdx</span><span class="o">,</span><span class="w"> </span><span class="n">rdx</span>
<span class="w">    </span><span class="n">div</span><span class="w"> </span><span class="n">rbx</span>
</pre></div>

<p>On Intel Haswell, <strong><code>div r64</code></strong> is 36 uops, with a <strong>latency of 32-96 cycles</strong>
, and a throughput of one per 21-74 cycles. (Plus the 2 uops to set up RBX and
zero RDX, but out-of-order execution can run those early). High-uop-count
instructions like DIV are microcoded, which can also cause front-end
bottlenecks. In this case, latency is the most relevant factor because it's
part of a loop-carried dependency chain.</p>
<p><strong><code>shr rax, 1</code> does the same unsigned division: It's 1 uop, with 1c latency</strong>,
and can run 2 per clock cycle.</p>
<p>For comparison, 32-bit division is faster, but still horrible vs. shifts.
<code>idiv r32</code> is 9 uops, 22-29c latency, and one per 8-11c throughput on Haswell.</p>
<hr>
<p><strong>As you can see from looking at gcc's<code>-O0</code> asm output (Godbolt compiler
explorer), it only uses shifts instructions</strong>. clang <code>-O0</code> does compile
naively like you thought, even using 64-bit IDIV twice. (When optimizing,
compilers do use both outputs of IDIV when the source does a division and
modulus with the same operands, if they use IDIV at all)</p>
<p>GCC doesn't have a totally-naive mode; it always transforms through GIMPLE,
which means some "optimizations" can't be disabled. This includes recognizing
division-by-constant and using shifts (power of 2) or a fixed-point
multiplicative inverse (non power of 2) to avoid IDIV (see <code>div_by_13</code> in the
above godbolt link).</p>
<p><code>gcc -Os</code> (optimize for size) <em>does</em> use IDIV for non-power-of-2 division,
unfortunately even in cases where the multiplicative inverse code is only
slightly larger but much faster.</p>
<hr>
<h2>Helping the compiler</h2>
<p>(summary for this case: use <code>uint64_t n</code>)</p>
<p>First of all, it's only interesting to look at optimized compiler output.
(<code>-O3</code>).<br><strong><code>-O0</code> speed is basically meaningless.</strong></p>
<p>Look at your asm output (on Godbolt, or see How to remove "noise" from
GCC/clang assembly output?). When the compiler doesn't make optimal code in
the first place: <strong>Writing your C/C++ source in a way that guides the compiler
into making better code is usually the best approach</strong>. You have to know asm,
and know what's efficient, but you apply this knowledge indirectly. Compilers
are also a good source of ideas: sometimes clang will do something cool, and
you can hand-hold gcc into doing the same thing: see this answer and what I
did with the non-unrolled loop in @Veedrac's code below.)</p>
<p>This approach is portable, and in 20 years some future compiler can compile it
to whatever is efficient on future hardware (x86 or not), maybe using new ISA
extension or auto-vectorizing. Hand-written x86-64 asm from 15 years ago would
usually not be optimally tuned for Skylake. e.g. compare&amp;branch macro-fusion
didn't exist back then. <strong>What's optimal now for hand-crafted asm for one
microarchitecture might not be optimal for other current and future CPUs.</strong>
Comments on @johnfound's answer discuss major differences between AMD
Bulldozer and Intel Haswell, which have a big effect on this code. But in
theory, <code>g++ -O3 -march=bdver3</code> and <code>g++ -O3 -march=skylake</code> will do the right
thing. (Or <code>-march=native</code>.) Or <code>-mtune=...</code> to just tune, without using
instructions that other CPUs might not support.</p>
<p>My feeling is that guiding the compiler to asm that's good for a current CPU
you care about shouldn't be a problem for future compilers. They're hopefully
better than current compilers at finding ways to transform code, and can find
a way that works for future CPUs. Regardless, future x86 probably won't be
terrible at anything that's good on current x86, and the future compiler will
avoid any asm-specific pitfalls while implementing something like the data
movement from your C source, if it doesn't see something better.</p>
<p>Hand-written asm is a black-box for the optimizer, so constant-propagation
doesn't work when inlining makes an input a compile-time constant. Other
optimizations are also affected. Read
https://gcc.gnu.org/wiki/DontUseInlineAsm before using asm. (And avoid MSVC-
style inline asm: inputs/outputs have to go through memory which adds
overhead.)</p>
<p><strong>In this case</strong> : your <code>n</code> has a signed type, and gcc uses the SAR/SHR/ADD
sequence that gives the correct rounding. (IDIV and arithmetic-shift "round"
differently for negative inputs, see the SAR insn set ref manual entry). (IDK
if gcc tried and failed to prove that <code>n</code> can't be negative, or what. Signed-
overflow is undefined behaviour, so it should have been able to.)</p>
<p>You should have used <code>uint64_t n</code>, so it can just SHR. And so it's portable to
systems where <code>long</code> is only 32-bit (e.g. x86-64 Windows).</p>
<hr>
<p>BTW, <strong>gcc's <em>optimized</em> asm output looks pretty good (using <code>unsigned long
n</code>)</strong>: the inner loop it inlines into <code>main()</code> does this:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="c1"># from gcc5.4 -O3  plus my comments</span>

<span class="w"> </span><span class="c1"># edx= count=1</span>
<span class="w"> </span><span class="c1"># rax= uint64_t n</span>

<span class="nl">.L9:</span><span class="w">                   </span><span class="c1"># do{</span>
<span class="w">    </span><span class="nf">lea</span><span class="w">    </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rax</span><span class="err">+</span><span class="mi">1</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="c1"># rcx = 3*n + 1</span>
<span class="w">    </span><span class="nf">mov</span><span class="w">    </span><span class="no">rdi</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span>
<span class="w">    </span><span class="nf">shr</span><span class="w">    </span><span class="no">rdi</span><span class="w">         </span><span class="c1"># rdi = n&gt;&gt;1;</span>
<span class="w">    </span><span class="nf">test</span><span class="w">   </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">       </span><span class="c1"># set flags based on n%2 (aka n&amp;1)</span>
<span class="w">    </span><span class="nf">mov</span><span class="w">    </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rcx</span>
<span class="w">    </span><span class="nf">cmove</span><span class="w">  </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w">    </span><span class="c1"># n= (n%2) ? 3*n+1 : n/2;</span>
<span class="w">    </span><span class="nf">add</span><span class="w">    </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">      </span><span class="c1"># ++count;</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">    </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">jne</span><span class="w">   </span><span class="no">.L9</span><span class="w">          </span><span class="c1">#}while(n!=1)</span>

<span class="w">  </span><span class="nf">cmp</span><span class="err">/</span><span class="no">branch</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">update</span><span class="w"> </span><span class="no">max</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">maxi</span><span class="p">,</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">next</span><span class="w"> </span><span class="no">n</span>
</pre></div>

<p>The inner loop is branchless, and the critical path of the loop-carried
dependency chain is:</p>
<ul>
<li>3-component LEA (3 cycles)</li>
<li>cmov (2 cycles on Haswell, 1c on Broadwell or later).</li>
</ul>
<p><strong>Total: 5 cycle per iteration, latency bottleneck</strong>. Out-of-order execution
takes care of everything else in parallel with this (in theory: I haven't
tested with perf counters to see if it really runs at 5c/iter).</p>
<p>The FLAGS input of <code>cmov</code> (produced by TEST) is faster to produce than the RAX
input (from LEA-&gt;MOV), so it's not on the critical path.</p>
<p>Similarly, the MOV-&gt;SHR that produces CMOV's RDI input is off the critical
path, because it's also faster than the LEA. MOV on IvyBridge and later has
zero latency (handled at register-rename time). (It still takes a uop, and a
slot in the pipeline, so it's not free, just zero latency). The extra MOV in
the LEA dep chain is part of the bottleneck on other CPUs.</p>
<p>The cmp/jne is also not part of the critical path: it's not loop-carried,
because control dependencies are handled with branch prediction + speculative
execution, unlike data dependencies on the critical path.</p>
<hr>
<h2>Beating the compiler</h2>
<p>GCC did a pretty good job here. It could save one code byte by using <code>inc edx</code>
instead of <code>add edx, 1</code>, because nobody cares about P4 and its false-
dependencies for partial-flag-modifying instructions.</p>
<p>It could also save all the MOV instructions, and the TEST: SHR sets CF= the
bit shifted out, so we can use <code>cmovc</code> instead of <code>test</code> / <code>cmovz</code>.</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="c1">### Hand-optimized version of what gcc does</span>
<span class="nl">.L9:</span><span class="w">                       </span><span class="c1">#do{</span>
<span class="w">    </span><span class="nf">lea</span><span class="w">     </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rax</span><span class="err">+</span><span class="mi">1</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1"># rcx = 3*n + 1</span>
<span class="w">    </span><span class="nf">shr</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">         </span><span class="c1"># n&gt;&gt;=1;    CF = n&amp;1 = n%2</span>
<span class="w">    </span><span class="nf">cmovc</span><span class="w">   </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rcx</span><span class="w">       </span><span class="c1"># n= (n&amp;1) ? 3*n+1 : n/2;</span>
<span class="w">    </span><span class="nf">inc</span><span class="w">     </span><span class="no">edx</span><span class="w">            </span><span class="c1"># ++count;</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">jne</span><span class="w">     </span><span class="no">.L9</span><span class="w">            </span><span class="c1">#}while(n!=1)</span>
</pre></div>

<p>See @johnfound's answer for another clever trick: remove the CMP by branching
on SHR's flag result as well as using it for CMOV: zero only if n was 1 (or 0)
to start with. (Fun fact: SHR with count != 1 on Nehalem or earlier causes a
stall if you read the flag results. That's how they made it single-uop. The
shift-by-1 special encoding is fine, though.)</p>
<p>Avoiding MOV doesn't help with the latency at all on Haswell (Can x86's MOV
really be "free"? Why can't I reproduce this at all?). It does help
<em>significantly</em> on CPUs like Intel pre-IvB, and AMD Bulldozer-family, where
MOV is not zero-latency (and Ice Lake with updated microcode). The compiler's
wasted MOV instructions do affect the critical path. BD's complex-LEA and CMOV
are both lower latency (2c and 1c respectively), so it's a bigger fraction of
the latency. Also, throughput bottlenecks become an issue, because it only has
two integer ALU pipes. See @johnfound's answer, where he has timing results
from an AMD CPU.</p>
<p>Even on Haswell, this version may help a bit by avoiding some occasional
delays where a non-critical uop steals an execution port from one on the
critical path, delaying execution by 1 cycle. (This is called a resource
conflict). It also saves a register, which may help when doing multiple <code>n</code>
values in parallel in an interleaved loop (see below).</p>
<p><strong>LEA's latency depends on the addressing mode</strong> , on Intel SnB-family CPUs.
3c for 3 components (<code>[base+idx+const]</code>, which takes two separate adds), but
only 1c with 2 or fewer components (one add). Some CPUs (like Core2) do even a
3-component LEA in a single cycle, but SnB-family doesn't. Worse, Intel SnB-
family standardizes latencies so there are no 2c uops, otherwise 3-component
LEA would be only 2c like Bulldozer. (3-component LEA is slower on AMD as
well, just not by as much).</p>
<p>So <code>lea rcx, [rax + rax*2]</code> / <code>inc rcx</code> is only 2c latency, faster than <code>lea
rcx, [rax + rax*2 + 1]</code>, on Intel SnB-family CPUs like Haswell. Break-even on
BD, and worse on Core2. It does cost an extra uop, which normally isn't worth
it to save 1c latency, but latency is the major bottleneck here and Haswell
has a wide enough pipeline to handle the extra uop throughput.</p>
<p><strong>Neither gcc, icc, nor clang (on godbolt) used SHR's CF output, always using
an AND or TEST</strong>. Silly compilers. :P They're great pieces of complex
machinery, but a clever human can often beat them on small-scale problems.
(Given thousands to millions of times longer to think about it, of course!
Compilers don't use exhaustive algorithms to search for every possible way to
do things, because that would take too long when optimizing a lot of inlined
code, which is what they do best. They also don't model the pipeline in the
target microarchitecture, at least not in the same detail as IACA or other
static-analysis tools; they just use some heuristics.)</p>
<hr>
<p><strong>Simple loop unrolling won't help</strong> ; this loop bottlenecks on the latency of
a loop-carried dependency chain, not on loop overhead / throughput. This means
it would do well with hyperthreading (or any other kind of SMT), since the CPU
has lots of time to interleave instructions from two threads. This would mean
parallelizing the loop in <code>main</code>, but that's fine because each thread can just
check a range of <code>n</code> values and produce a pair of integers as a result.</p>
<p><strong>Interleaving by hand within a single thread might be viable, too</strong>. Maybe
compute the sequence for a pair of numbers in parallel, since each one only
takes a couple registers, and they can all update the same <code>max</code> / <code>maxi</code>.
This creates more instruction-level parallelism.</p>
<p>The trick is deciding whether to wait until all the <code>n</code> values have reached
<code>1</code> before getting another pair of starting <code>n</code> values, or whether to break
out and get a new start point for just one that reached the end condition,
without touching the registers for the other sequence. Probably it's best to
keep each chain working on useful data, otherwise you'd have to conditionally
increment its counter.</p>
<hr>
<p>You could maybe even do this with SSE packed-compare stuff to conditionally
increment the counter for vector elements where <code>n</code> hadn't reached <code>1</code> yet.
And then to hide the even longer latency of a SIMD conditional-increment
implementation, you'd need to keep more vectors of <code>n</code> values up in the air.
Maybe only worth with 256b vector (4x <code>uint64_t</code>).</p>
<p>I think the best strategy to make detection of a <code>1</code> "sticky" is to mask the
vector of all-ones that you add to increment the counter. So after you've seen
a <code>1</code> in an element, the increment-vector will have a zero, and +=0 is a no-
op.</p>
<h4>Untested idea for manual vectorization</h4>
<div class="code"><pre class="code literal-block"><span class="c1"># starting with YMM0 = [ n_d, n_c, n_b, n_a ]  (64-bit elements)</span>
<span class="c1"># ymm4 = _mm256_set1_epi64x(1):  increment vector</span>
<span class="c1"># ymm5 = all-zeros:  count vector</span>

<span class="o">.</span><span class="n">inner_loop</span><span class="p">:</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">xmm0</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">xmm0</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">set1_epi64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">     </span><span class="c1"># ymm1= 3*n + 1.  Maybe could do this more efficiently?</span>

<span class="w">    </span><span class="n">vpsllq</span><span class="w">    </span><span class="n">ymm3</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="mi">63</span><span class="w">                </span><span class="c1"># shift bit 1 to the sign bit</span>

<span class="w">    </span><span class="n">vpsrlq</span><span class="w">    </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">                 </span><span class="c1"># n /= 2</span>

<span class="w">    </span><span class="c1"># FP blend between integer insns may cost extra bypass latency, but integer blends don't have 1 bit controlling a whole qword.</span>
<span class="w">    </span><span class="n">vpblendvpd</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm3</span><span class="w">       </span><span class="c1"># variable blend controlled by the sign bit of each 64-bit element.  I might have the source operands backwards, I always have to look this up.</span>

<span class="w">    </span><span class="c1"># ymm0 = updated n  in each element.</span>

<span class="w">    </span><span class="n">vpcmpeqq</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">set1_epi64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">vpandn</span><span class="w">   </span><span class="n">ymm4</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span><span class="w">         </span><span class="c1"># zero out elements of ymm4 where the compare was true</span>

<span class="w">    </span><span class="n">vpaddq</span><span class="w">   </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span><span class="w">         </span><span class="c1"># count++ in elements where n has never been == 1</span>

<span class="w">    </span><span class="n">vptest</span><span class="w">   </span><span class="n">ymm4</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span>
<span class="w">    </span><span class="n">jnz</span><span class="w">  </span><span class="o">.</span><span class="n">inner_loop</span>
<span class="w">    </span><span class="c1"># Fall through when all the n values have reached 1 at some point, and our increment vector is all-zero</span>

<span class="w">    </span><span class="n">vextracti128</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">vpmaxq</span><span class="w"> </span><span class="o">....</span><span class="w"> </span><span class="n">crap</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">doesn</span><span class="s1">'t exist</span>
<span class="w">    </span><span class="c1"># Actually just delay doing a horizontal max until the very very end.  But you need some way to record max and maxi.</span>
</pre></div>

<p>You can and should implement this with intrinsics instead of hand-written asm.</p>
<hr>
<h3>Algorithmic / implementation improvement:</h3>
<p>Besides just implementing the same logic with more efficient asm, look for
ways to simplify the logic, or avoid redundant work. e.g. memoize to detect
common endings to sequences. Or even better, look at 8 trailing bits at once
(gnasher's answer)</p>
<p>@EOF points out that <code>tzcnt</code> (or <code>bsf</code>) could be used to do multiple <code>n/=2</code>
iterations in one step. That's probably better than SIMD vectorizing; no SSE
or AVX instruction can do that. It's still compatible with doing multiple
scalar <code>n</code>s in parallel in different integer registers, though.</p>
<p>So the loop might look like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">goto</span><span class="w"> </span><span class="nt">loop_entry</span><span class="o">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nt">C</span><span class="o">++</span><span class="w"> </span><span class="nt">structured</span><span class="w"> </span><span class="nt">like</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">asm</span><span class="o">,</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="nt">illustration</span><span class="w"> </span><span class="nt">only</span>
<span class="nt">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="err">n</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">n*3</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">loop_entry</span><span class="p">:</span>
<span class="w">   </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">_tzcnt_u64</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">   </span><span class="err">n</span><span class="w"> </span><span class="err">&gt;&gt;=</span><span class="w"> </span><span class="err">shift</span><span class="p">;</span>
<span class="w">   </span><span class="err">count</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">shift</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="nt">while</span><span class="o">(</span><span class="nt">n</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nt">1</span><span class="o">);</span>
</pre></div>

<p>This may do significantly fewer iterations, but variable-count shifts are slow
on Intel SnB-family CPUs without BMI2. 3 uops, 2c latency. (They have an input
dependency on the FLAGS because count=0 means the flags are unmodified. They
handle this as a data dependency, and take multiple uops because a uop can
only have 2 inputs (pre-HSW/BDW anyway)). This is the kind that people
complaining about x86's crazy-CISC design are referring to. It makes x86 CPUs
slower than they would be if the ISA was designed from scratch today, even in
a mostly-similar way. (i.e. this is part of the "x86 tax" that costs speed /
power.) SHRX/SHLX/SARX (BMI2) are a big win (1 uop / 1c latency).</p>
<p>It also puts tzcnt (3c on Haswell and later) on the critical path, so it
significantly lengthens the total latency of the loop-carried dependency
chain. It does remove any need for a CMOV, or for preparing a register holding
<code>n&gt;&gt;1</code>, though. <strong>@Veedrac's answer overcomes all this by deferring the
tzcnt/shift for multiple iterations, which is highly effective (see below).</strong></p>
<p>We can safely use BSF or TZCNT interchangeably, because <code>n</code> can never be zero
at that point. TZCNT's machine-code decodes as BSF on CPUs that don't support
BMI1. (Meaningless prefixes are ignored, so REP BSF runs as BSF).</p>
<p>TZCNT performs much better than BSF on AMD CPUs that support it, so it can be
a good idea to use <code>REP BSF</code>, even if you don't care about setting ZF if the
input is zero rather than the output. Some compilers do this when you use
<code>__builtin_ctzll</code> even with <code>-mno-bmi</code>.</p>
<p>They perform the same on Intel CPUs, so just save the byte if that's all that
matters. TZCNT on Intel (pre-Skylake) still has a false-dependency on the
supposedly write-only output operand, just like BSF, to support the
undocumented behaviour that BSF with input = 0 leaves its destination
unmodified. So you need to work around that unless optimizing only for
Skylake, so there's nothing to gain from the extra REP byte. (Intel often goes
above and beyond what the x86 ISA manual requires, to avoid breaking widely-
used code that depends on something it shouldn't, or that is retroactively
disallowed. e.g. Windows 9x's assumes no speculative prefetching of TLB
entries, which was safe when the code was written, before Intel updated the
TLB management rules.)</p>
<p>Anyway, LZCNT/TZCNT on Haswell have the same false dep as POPCNT: see this
Q&amp;A. This is why in gcc's asm output for @Veedrac's code, you see it breaking
the dep chain with xor-zeroing on the register it's about to use as TZCNT's
destination when it doesn't use dst=src. Since TZCNT/LZCNT/POPCNT never leave
their destination undefined or unmodified, this false dependency on the output
on Intel CPUs is a performance bug / limitation. Presumably it's worth some
transistors / power to have them behave like other uops that go to the same
execution unit. The only perf upside is interaction with another uarch
limitation: they can micro-fuse a memory operand with an indexed addressing
mode on Haswell, but on Skylake where Intel removed the false dep for
LZCNT/TZCNT they "un-laminate" indexed addressing modes while POPCNT can still
micro-fuse any addr mode.</p>
<hr>
<h2>Improvements to ideas / code from other answers:</h2>
<p><strong>@hidefromkgb's answer</strong> has a nice observation that you're guaranteed to be
able to do one right shift after a 3n+1. You can compute this more even more
efficiently than just leaving out the checks between steps. The asm
implementation in that answer is broken, though (it depends on OF, which is
undefined after SHRD with a count &gt; 1), and slow: <code>ROR rdi,2</code> is faster than
<code>SHRD rdi,rdi,2</code>, and using two CMOV instructions on the critical path is
slower than an extra TEST that can run in parallel.</p>
<p>I put tidied / improved C (which guides the compiler to produce better asm),
and tested+working faster asm (in comments below the C) up on Godbolt: see the
link in @hidefromkgb's answer. (This answer hit the 30k char limit from the
large Godbolt URLs, but shortlinks can rot and were too long for goo.gl
anyway.)</p>
<p>Also improved the output-printing to convert to a string and make one
<code>write()</code> instead of writing one char at a time. This minimizes impact on
timing the whole program with <code>perf stat ./collatz</code> (to record performance
counters), and I de-obfuscated some of the non-critical asm.</p>
<hr>
<p><strong>@Veedrac's code</strong></p>
<p>I got a minor speedup from right-shifting as much as we <em>know</em> needs doing,
and checking to continue the loop. From 7.5s for limit=1e8 down to 7.275s, on
Core2Duo (Merom), with an unroll factor of 16.</p>
<p>code + comments on Godbolt. Don't use this version with clang; it does
something silly with the defer-loop. Using a tmp counter <code>k</code> and then adding
it to <code>count</code> later changes what clang does, but that <em>slightly</em> hurts gcc.</p>
<p>See discussion in comments: Veedrac's code is <em>excellent</em> on CPUs with BMI1
(i.e. not Celeron/Pentium)</p>
<p><br></p>
<h3>Suggest</h3>
<p>Claiming that the C++ compiler can produce more optimal code than a competent
assembly language programmer is a very bad mistake. And especially in this
case. The human always can make the code better than the compiler can, and
this particular situation is a good illustration of this claim.</p>
<p>The timing difference you're seeing is because the assembly code in the
question is very far from optimal in the inner loops.</p>
<p>(The below code is 32-bit, but can be easily converted to 64-bit)</p>
<p>For example, the sequence function can be optimized to only 5 instructions:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="p">.</span><span class="nc">seq</span><span class="o">:</span>
<span class="w">        </span><span class="nt">inc</span><span class="w">     </span><span class="nt">esi</span><span class="w">                 </span><span class="o">;</span><span class="w"> </span><span class="nt">counter</span>
<span class="w">        </span><span class="nt">lea</span><span class="w">     </span><span class="nt">edx</span><span class="o">,</span><span class="w"> </span><span class="cp">[</span><span class="mi">3</span><span class="o">*</span><span class="nx">eax</span><span class="o">+</span><span class="mi">1</span><span class="cp">]</span><span class="w">      </span><span class="o">;</span><span class="w"> </span><span class="nt">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">3</span><span class="o">*</span><span class="nt">n</span><span class="o">+</span><span class="nt">1</span>
<span class="w">        </span><span class="nt">shr</span><span class="w">     </span><span class="nt">eax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span><span class="w">              </span><span class="o">;</span><span class="w"> </span><span class="nt">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">n</span><span class="o">/</span><span class="nt">2</span>
<span class="w">        </span><span class="nt">cmovc</span><span class="w">   </span><span class="nt">eax</span><span class="o">,</span><span class="w"> </span><span class="nt">edx</span><span class="w">            </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">CF</span><span class="w"> </span><span class="nt">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">edx</span>
<span class="w">        </span><span class="nt">jnz</span><span class="w">     </span><span class="p">.</span><span class="nc">seq</span><span class="w">                </span><span class="o">;</span><span class="w"> </span><span class="nt">jmp</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">n</span><span class="o">&lt;&gt;</span><span class="nt">1</span>
</pre></div>

<p>The whole code looks like:</p>
<div class="code"><pre class="code literal-block"><span class="k">include</span><span class="w"> </span><span class="ss">"%lib%/freshlib.inc"</span>
<span class="nv">@BinaryType</span><span class="w"> </span><span class="n">console</span><span class="p">,</span><span class="w"> </span><span class="n">compact</span>
<span class="n">options</span><span class="p">.</span><span class="n">DebugMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="k">include</span><span class="w"> </span><span class="ss">"%lib%/freshlib.asm"</span>

<span class="k">start</span><span class="err">:</span>
<span class="w">        </span><span class="n">InitializeAll</span>
<span class="w">        </span><span class="n">mov</span><span class="w"> </span><span class="n">ecx</span><span class="p">,</span><span class="w"> </span><span class="mi">999999</span>
<span class="w">        </span><span class="n">xor</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nf">max</span>
<span class="w">        </span><span class="n">xor</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="n">ebx</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="n">i</span>

<span class="w">    </span><span class="p">.</span><span class="nl">main_loop</span><span class="p">:</span>

<span class="w">        </span><span class="n">xor</span><span class="w">     </span><span class="n">esi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">mov</span><span class="w">     </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span>

<span class="w">    </span><span class="p">.</span><span class="nl">seq</span><span class="p">:</span>
<span class="w">        </span><span class="n">inc</span><span class="w">     </span><span class="n">esi</span><span class="w">                 </span><span class="p">;</span><span class="w"> </span><span class="n">counter</span>
<span class="w">        </span><span class="n">lea</span><span class="w">     </span><span class="n">edx</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">3*eax+1</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
<span class="w">        </span><span class="n">shr</span><span class="w">     </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span>
<span class="w">        </span><span class="n">cmovc</span><span class="w">   </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="w">            </span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">CF</span><span class="w"> </span><span class="n">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edx</span>
<span class="w">        </span><span class="n">jnz</span><span class="w">     </span><span class="p">.</span><span class="n">seq</span><span class="w">                </span><span class="p">;</span><span class="w"> </span><span class="n">jmp</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;&gt;</span><span class="mi">1</span>

<span class="w">        </span><span class="n">cmp</span><span class="w">     </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">cmovb</span><span class="w">   </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">cmovb</span><span class="w">   </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span>

<span class="w">        </span><span class="k">dec</span><span class="w">     </span><span class="n">ecx</span>
<span class="w">        </span><span class="n">jnz</span><span class="w">     </span><span class="p">.</span><span class="n">main_loop</span>

<span class="w">        </span><span class="n">OutputValue</span><span class="w"> </span><span class="ss">"Max sequence: "</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="n">OutputValue</span><span class="w"> </span><span class="ss">"Max index: "</span><span class="p">,</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>

<span class="w">        </span><span class="n">FinalizeAll</span>
<span class="w">        </span><span class="n">stdcall</span><span class="w"> </span><span class="n">TerminateAll</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
</pre></div>

<p>In order to compile this code, FreshLib is needed.</p>
<p>In my tests, (1 GHz AMD A4-1200 processor), the above code is approximately
four times faster than the C++ code from the question (when compiled with
<code>-O0</code>: 430 ms vs. 1900 ms), and more than two times faster (430 ms vs. 830 ms)
when the C++ code is compiled with <code>-O3</code>.</p>
<p>The output of both programs is the same: max sequence = 525 on i = 837799.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-541.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-539.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
