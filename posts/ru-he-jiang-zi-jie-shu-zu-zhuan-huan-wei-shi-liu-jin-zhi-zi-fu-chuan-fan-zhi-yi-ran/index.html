<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>如何将字节数组转换为十六进制字符串，反之亦然？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ru-he-jiang-zi-jie-shu-zu-zhuan-huan-wei-shi-liu-jin-zhi-zi-fu-chuan-fan-zhi-yi-ran/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-jiang-lei-tian-jia-dao-gei-ding-yuan-su/" title="如何将类添加到给定元素？" type="text/html">
<link rel="next" href="../zai-virtualenv-zhong-shi-yong-bu-tong-de-python-ban-ben/" title="在 virtualenv 中使用不同的 Python 版本" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="如何将字节数组转换为十六进制字符串，反之亦然？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ru-he-jiang-zi-jie-shu-zu-zhuan-huan-wei-shi-liu-jin-zhi-zi-fu-chuan-fan-zhi-yi-ran/">
<meta property="og:description" content="如何将字节数组转换为十六进制字符串，反之亦然？

解答
Convert.ToHexString从 .NET 5 开始就可以使用。
还有一种反向操作的方法：Convert.FromHexString.

对于旧版本的 .NET，您可以使用：
public static string ByteArrayToString(byte[] ba)
{
  StringBuilder hex = new St">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T01:19:51+08:00">
<meta property="article:tag" content="arrays">
<meta property="article:tag" content="cSharp">
<meta property="article:tag" content="hex">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">如何将字节数组转换为十六进制字符串，反之亦然？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T01:19:51+08:00" itemprop="datePublished" title="2023-02-17 01:19">2023-02-17 01:19</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>如何将字节数组转换为十六进制字符串，反之亦然？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>Convert.ToHexString</code>从 .NET 5 开始就可以使用。<br>
还有一种反向操作的方法：<code>Convert.FromHexString</code>.</p>
<hr>
<p>对于旧版本的 .NET，您可以使用：</p>
<div class="code"><pre class="code literal-block"><span class="nt">public</span><span class="w"> </span><span class="nt">static</span><span class="w"> </span><span class="nt">string</span><span class="w"> </span><span class="nt">ByteArrayToString</span><span class="o">(</span><span class="nt">byte</span><span class="cp">[]</span><span class="w"> </span><span class="nt">ba</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="err">StringBuilder</span><span class="w"> </span><span class="err">hex</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">StringBuilder(ba.Length</span><span class="w"> </span><span class="err">*</span><span class="w"> </span><span class="err">2)</span><span class="p">;</span>
<span class="w">  </span><span class="err">foreach</span><span class="w"> </span><span class="err">(byte</span><span class="w"> </span><span class="err">b</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">ba)</span>
<span class="w">    </span><span class="err">hex.AppendFormat("{0:x2</span><span class="p">}</span><span class="err">"</span><span class="o">,</span><span class="w"> </span><span class="nt">b</span><span class="o">);</span>
<span class="w">  </span><span class="nt">return</span><span class="w"> </span><span class="nt">hex</span><span class="p">.</span><span class="nc">ToString</span><span class="o">();</span>
<span class="err">}</span>
</pre></div>

<p>或者：</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">string</span><span class="w"> </span><span class="nv">ByteArrayToString</span><span class="ss">(</span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">ba</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">BitConverter</span>.<span class="nv">ToString</span><span class="ss">(</span><span class="nv">ba</span><span class="ss">)</span>.<span class="nv">Replace</span><span class="ss">(</span><span class="s2">"-"</span>,<span class="s2">""</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>还有更多的变体，例如这里。</p>
<p>反向转换是这样的：</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">StringToByteArray</span><span class="ss">(</span><span class="nv">String</span><span class="w"> </span><span class="nv">hex</span><span class="ss">)</span>
{
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">NumberChars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">hex</span>.<span class="nv">Length</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">byte</span>[<span class="nv">NumberChars</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>]<span class="c1">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; NumberChars; i += 2)</span>
<span class="w">    </span><span class="nv">bytes</span>[<span class="nv">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Convert</span>.<span class="nv">ToByte</span><span class="ss">(</span><span class="nv">hex</span>.<span class="nv">Substring</span><span class="ss">(</span><span class="nv">i</span>,<span class="w"> </span><span class="mi">2</span><span class="ss">)</span>,<span class="w"> </span><span class="mi">16</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">bytes</span><span class="c1">;</span>
}
</pre></div>

<hr>
<p>Using<code>Substring</code>是结合<code>Convert.ToByte</code>.
有关详细信息，请参阅此答案。如果你需要更好的性能，你必须<code>Convert.ToByte</code>在 drop 之前避免<code>SubString</code>。</p>
<p><br></p>
<h3>更多建议</h3>
<h3>性能分析</h3>
<p><em>注：截至 2015-08-20 的新领导者。</em></p>
<p>我通过一些粗略的性能测试来运行各种转换方法中的每一种<code>Stopwatch</code>，一次运行随机句子（n=61, 1000 次迭代），一次运行 Project
Gutenburg 文本（n=1,238,957, 150 次迭代）。以下是结果，大致从最快到最慢。所有测量均以滴答为单位（10,000 个滴答 = 1
毫秒），所有相关注释都与 [最慢]<code>StringBuilder</code>实现进行了比较。对于使用的代码，请参见下面或我现在维护运行它的代码的测试框架存储库。</p>
<h3>免责声明</h3>
<p><em>警告：不要依赖这些统计数据来做任何具体的事情；
它们只是样本数据的样本运行。如果您确实需要一流的性能，请在代表您的生产需求的环境中使用代表您将使用的内容的数据测试这些方法。</em></p>
<h3>结果</h3>
<ul>
<li>按字节查找<code>unsafe</code>（通过 CodesInChaos） （由airbreather添加到测试回购） <ul>
<li>文本：4,727.85 (105.2X)</li>
<li>句子：0.28 (99.7X)</li>
</ul>
</li>
<li>按字节查找（通过 CodesInChaos）<ul>
<li>文本：10,853.96（快 45.8 倍）</li>
<li>句子：0.65（快 42.7 倍）</li>
</ul>
</li>
<li>字节操作 2（通过 CodesInChaos）<ul>
<li>文本：12,967.69（快 38.4 倍）</li>
<li>句子：0.73（快 37.9 倍）</li>
</ul>
</li>
<li>字节操作（来自 Waleed Eissa）<ul>
<li>文本：16,856.64（快 29.5 倍）</li>
<li>句子：0.70（快 39.5 倍）</li>
</ul>
</li>
<li>Lookup/Shift（通过 Nathan Moinvaziri）<ul>
<li>文本：23,201.23（快 21.4 倍）</li>
<li>句子：1.24（快 22.3 倍）</li>
</ul>
</li>
<li>按半字节查找（来自 Brian Lambert）<ul>
<li>文本：23,879.41（快 20.8 倍）</li>
<li>句子：1.15（快 23.9 倍）</li>
</ul>
</li>
<li>
<code>BitConverter</code>（通过托马拉克）<ul>
<li>文本：113,269.34（快 4.4 倍）</li>
<li>句子：9.98（快 2.8 倍）</li>
</ul>
</li>
<li>
<code>{SoapHexBinary}.ToString</code>（通过迈克罗夫特）<ul>
<li>文本：178,601.39（快 2.8 倍）</li>
<li>句子：10.68（快 2.6 倍）</li>
</ul>
</li>
<li>
<code>{byte}.ToString("X2")</code>（使用<code>foreach</code>）（源自 Will Dean 的回答）<ul>
<li>文本：308,805.38（快 2.4 倍）</li>
<li>句子：16.89（快 2.4 倍）</li>
</ul>
</li>
<li>
<code>{byte}.ToString("X2")</code>（使用<code>{IEnumerable}.Aggregate</code>，需要 System.Linq）（通过 Mark）<ul>
<li>文本：352,828.20（快 2.1 倍）</li>
<li>句子：16.87（快 2.4 倍）</li>
</ul>
</li>
<li>
<code>Array.ConvertAll</code>（使用<code>string.Join</code>）（通过 Will Dean）<ul>
<li>文本：675,451.57（快 1.1 倍）</li>
<li>句子：17.95（快 2.2 倍）</li>
</ul>
</li>
<li>
<code>Array.ConvertAll</code>（使用<code>string.Concat</code>，需要 .NET 4.0）（来自 Will Dean）<ul>
<li>文本：752,078.70（快 1.0 倍）</li>
<li>句子：18.28（快 2.2 倍）</li>
</ul>
</li>
<li>
<code>{StringBuilder}.AppendFormat</code>（使用<code>foreach</code>）（通过 Tomalak）<ul>
<li>文本：672,115.77（快 1.1 倍）</li>
<li>句子：36.82（快 1.1 倍）</li>
</ul>
</li>
<li>
<code>{StringBuilder}.AppendFormat</code>（使用<code>{IEnumerable}.Aggregate</code>，需要 System.Linq）（源自 Tomalak 的回答）<ul>
<li>文本：718,380.63（快 1.0 倍）</li>
<li>句子：39.71（快 1.0 倍）</li>
</ul>
</li>
</ul>
<p>查找表领先于字节操作。基本上，有某种形式的预计算任何给定的半字节或字节将以十六进制表示。然后，当您翻阅数据时，您只需查找下一部分以查看它是什么十六进制字符串。然后该值以某种方式添加到生成的字符串输出中。长期以来，一些开发人员可能更难阅读的字节操作是性能最好的方法。</p>
<p>您最好的选择仍然是找到一些有代表性的数据并在类似生产的环境中进行尝试。如果您有不同的内存限制，您可能更喜欢分配较少的方法，而不是速度更快但消耗更多内存的方法。</p>
<h3>测试代码</h3>
<p>随意使用我使用的测试代码。这里包含一个版本，但您可以随意克隆repo并添加您自己的方法。如果您发现任何有趣的东西或想帮助改进它使用的测试框架，请提交拉取请求。</p>
<ol>
<li>将新的静态方法 ( <code>Func&lt;byte[], string&gt;</code>) 添加到 /Tests/ConvertByteArrayToHexString/Test.cs。</li>
<li>将该方法的名称添加到<code>TestCandidates</code>同一类中的返回值。</li>
<li>
<code>GenerateTestInput</code>通过在同一类中切换评论，确保您正在运行所需的输入版本、句子或文本。</li>
<li>
<p>点击<code>F5</code>并等待输出（/bin 文件夹中也会生成 HTML 转储）。</p>
<p>static string ByteArrayToHexStringViaStringJoinArrayConvertAll(byte[] bytes) {
    return string.Join(string.Empty, Array.ConvertAll(bytes, b =&gt; b.ToString("X2")));
}
static string ByteArrayToHexStringViaStringConcatArrayConvertAll(byte[] bytes) {
    return string.Concat(Array.ConvertAll(bytes, b =&gt; b.ToString("X2")));
}
static string ByteArrayToHexStringViaBitConverter(byte[] bytes) {
    string hex = BitConverter.ToString(bytes);
    return hex.Replace("-", "");
}
static string ByteArrayToHexStringViaStringBuilderAggregateByteToString(byte[] bytes) {
    return bytes.Aggregate(new StringBuilder(bytes.Length * 2), (sb, b) =&gt; sb.Append(b.ToString("X2"))).ToString();
}
static string ByteArrayToHexStringViaStringBuilderForEachByteToString(byte[] bytes) {
    StringBuilder hex = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes)
        hex.Append(b.ToString("X2"));
    return hex.ToString();
}
static string ByteArrayToHexStringViaStringBuilderAggregateAppendFormat(byte[] bytes) {
    return bytes.Aggregate(new StringBuilder(bytes.Length * 2), (sb, b) =&gt; sb.AppendFormat("{0:X2}", b)).ToString();
}
static string ByteArrayToHexStringViaStringBuilderForEachAppendFormat(byte[] bytes) {
    StringBuilder hex = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes)
        hex.AppendFormat("{0:X2}", b);
    return hex.ToString();
}
static string ByteArrayToHexViaByteManipulation(byte[] bytes) {
    char[] c = new char[bytes.Length * 2];
    byte b;
    for (int i = 0; i &lt; bytes.Length; i++) {
        b = ((byte)(bytes[i] &gt;&gt; 4));
        c[i * 2] = (char)(b &gt; 9 ? b + 0x37 : b + 0x30);
        b = ((byte)(bytes[i] &amp; 0xF));
        c[i * 2 + 1] = (char)(b &gt; 9 ? b + 0x37 : b + 0x30);
    }
    return new string(c);
}
static string ByteArrayToHexViaByteManipulation2(byte[] bytes) {
    char[] c = new char[bytes.Length * 2];
    int b;
    for (int i = 0; i &lt; bytes.Length; i++) {
        b = bytes[i] &gt;&gt; 4;
        c[i * 2] = (char)(55 + b + (((b - 10) &gt;&gt; 31) &amp; -7));
        b = bytes[i] &amp; 0xF;
        c[i * 2 + 1] = (char)(55 + b + (((b - 10) &gt;&gt; 31) &amp; -7));
    }
    return new string(c);
}
static string ByteArrayToHexViaSoapHexBinary(byte[] bytes) {
    SoapHexBinary soapHexBinary = new SoapHexBinary(bytes);
    return soapHexBinary.ToString();
}
static string ByteArrayToHexViaLookupAndShift(byte[] bytes) {
    StringBuilder result = new StringBuilder(bytes.Length * 2);
    string hexAlphabet = "0123456789ABCDEF";
    foreach (byte b in bytes) {
        result.Append(hexAlphabet[(int)(b &gt;&gt; 4)]);
        result.Append(hexAlphabet[(int)(b &amp; 0xF)]);
    }
    return result.ToString();
}
static readonly uint<em> _lookup32UnsafeP = (uint</em>)GCHandle.Alloc(_Lookup32, GCHandleType.Pinned).AddrOfPinnedObject();
static string ByteArrayToHexViaLookup32UnsafeDirect(byte[] bytes) {
    var lookupP = _lookup32UnsafeP;
    var result = new string((char)0, bytes.Length * 2);
    fixed (byte<em> bytesP = bytes)
    fixed (char</em> resultP = result) {
        uint<em> resultP2 = (uint</em>)resultP;
        for (int i = 0; i &lt; bytes.Length; i++) {
            resultP2[i] = lookupP[bytesP[i]];
        }
    }
    return result;
}
static uint[] _Lookup32 = Enumerable.Range(0, 255).Select(i =&gt; {
    string s = i.ToString("X2");
    return ((uint)s[0]) + ((uint)s[1] &lt;&lt; 16);
}).ToArray();
static string ByteArrayToHexViaLookupPerByte(byte[] bytes) {
    var result = new char[bytes.Length * 2];
    for (int i = 0; i &lt; bytes.Length; i++)
    {
        var val = _Lookup32[bytes[i]];
        result[2<em>i] = (char)val;
        result[2</em>i + 1] = (char) (val &gt;&gt; 16);
    }
    return new string(result);
}
static string ByteArrayToHexViaLookup(byte[] bytes) {
    string[] hexStringTable = new string[] {
        "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
        "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
        "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
        "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
        "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
        "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
        "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
        "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
        "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
        "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
        "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
        "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
        "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
        "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
        "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
        "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF",
    };
    StringBuilder result = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes) {
        result.Append(hexStringTable[b]);
    }
    return result.ToString();
}</p>
</li>
</ol>
<h4>更新 (2010-01-13)</h4>
<p>添加了 Waleed 对分析的回答。蛮快。</p>
<h4>更新 (2011-10-05)</h4>
<p>添加了<code>string.Concat</code> <code>Array.ConvertAll</code>完整性变体（需要 .NET 4.0）。与版本相当<code>string.Join</code>。</p>
<h4>更新 (2012-02-05)</h4>
<p>测试回购包括更多变体，例如<code>StringBuilder.Append(b.ToString("X2"))</code>. 没有人打乱结果。<code>foreach</code>比
快<code>{IEnumerable}.Aggregate</code>，例如，但<code>BitConverter</code>仍然获胜。</p>
<h4>更新 (2012-04-03)</h4>
<p>添加了 Mykroft 的<code>SoapHexBinary</code>分析答案，它占据了第三位。</p>
<h4>更新 (2013-01-15)</h4>
<p>添加了 CodesInChaos 的字节操作答案，它占据了第一位（在大文本块上有很大优势）。</p>
<h4>更新 (2013-05-23)</h4>
<p>添加了 Nathan Moinvaziri 的查找答案和来自 Brian Lambert 博客的变体。两者都相当快，但在我使用的测试机（AMD Phenom
9750）上没有领先。</p>
<h4>更新 (2014-07-31)</h4>
<p>添加了@CodesInChaos 新的基于字节的查找答案。它似乎在句子测试和全文测试中都处于领先地位。</p>
<h4>更新 (2015-08-20)</h4>
<p>将airbreather 的优化和<code>unsafe</code>变体添加到此答案的
repo中。如果你想玩不安全的游戏，你可以在短字符串和大文本上获得比之前任何顶级获胜者更大的性能提升。</p>
<p><br><br><a href="../how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/arrays/" rel="tag">arrays</a></li>
            <li><a class="tag p-category" href="../../categories/csharp/" rel="tag">cSharp</a></li>
            <li><a class="tag p-category" href="../../categories/hex/" rel="tag">hex</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-jiang-lei-tian-jia-dao-gei-ding-yuan-su/" rel="prev" title="如何将类添加到给定元素？">Previous post</a>
            </li>
            <li class="next">
                <a href="../zai-virtualenv-zhong-shi-yong-bu-tong-de-python-ban-ben/" rel="next" title="在 virtualenv 中使用不同的 Python 版本">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
