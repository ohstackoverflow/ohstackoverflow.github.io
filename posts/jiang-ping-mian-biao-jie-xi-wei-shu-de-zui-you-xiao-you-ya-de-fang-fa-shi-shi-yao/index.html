<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>将平面表解析为树的最有效/优雅的方法是什么？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/jiang-ping-mian-biao-jie-xi-wei-shu-de-zui-you-xiao-you-ya-de-fang-fa-shi-shi-yao/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../zhu-xiao-get-huan-shi-post/" title="注销：GET 还是 POST？" type="text/html">
<link rel="next" href="../jian-ce-liu-lan-qi-he-shi-shou-dao-wen-jian-xia-zai/" title="检测浏览器何时收到文件下载" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="将平面表解析为树的最有效/优雅的方法是什么？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/jiang-ping-mian-biao-jie-xi-wei-shu-de-zui-you-xiao-you-ya-de-fang-fa-shi-shi-yao/">
<meta property="og:description" content="假设您有一个存储有序树层次结构的平面表：
Id   Name         ParentId   Order
 1   'Node 1'            0      10
 2   'Node 1.1'          1      10
 3   'Node 2'            0      20
 4   'Node 1.1.1'        2      10
 5  ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T03:46:10+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="hierarchical-data">
<meta property="article:tag" content="recursion">
<meta property="article:tag" content="sql">
<meta property="article:tag" content="tree">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">将平面表解析为树的最有效/优雅的方法是什么？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:46:10+08:00" itemprop="datePublished" title="2023-02-18 03:46">2023-02-18 03:46</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>假设您有一个存储有序树层次结构的平面表：</p>
<div class="code"><pre class="code literal-block">Id   Name         ParentId   Order
 1   'Node 1'            0      10
 2   'Node 1.1'          1      10
 3   'Node 2'            0      20
 4   'Node 1.1.1'        2      10
 5   'Node 2.1'          3      10
 6   'Node 1.2'          1      20
</pre></div>

<p>这是一个图表，我们有<code>[id] Name</code>. 根节点 0 是虚构的。</p>
<div class="code"><pre class="code literal-block">                       [0]根
                          / \
              [1] 节点 1 [3] 节点 2
              / \ \
    [2] 节点 1.1 [6] 节点 1.2 [5] 节点 2.1
          /          
 [4] 节点 1.1.1
</pre></div>

<p>您将使用哪种简约方法将其作为正确排序、正确缩进的树输出到 HTML（或文本，就此而言）？</p>
<p>进一步假设您只有基本的数据结构（数组和哈希图），没有带有父/子引用的奇特对象，没有 ORM，没有框架，只有您的两只手。该表表示为一个结果集，可以随机访问。</p>
<p>伪代码或者简单的英文都可以，这纯粹是个概念题。</p>
<p>奖励问题：是否有更好的方法在 RDBMS 中存储这样的树结构？</p>
<hr>
<p><strong>编辑和补充</strong></p>
<p>回答一位评论者（Mark Bessey的）问题：根节点不是必需的，因为它无论如何都不会显示。ParentId = 0 是表达“这些是顶级”的约定。Order
列定义了如何对具有相同父节点的节点进行排序。</p>
<p>我所说的“结果集”可以被描绘成哈希图数组（保留在该术语中）。因为我的例子本来就已经存在了。有些答案更进一步并首先构建它，但这没关系。</p>
<p>树可以任意深。每个节点可以有 N 个孩子。不过，我并没有完全想到“数百万条目”树。</p>
<p>不要将我选择的节点命名（“节点 1.1.1”）误认为是可以依赖的东西。这些节点同样可以称为“Frank”或“Bob”，没有暗示命名结构，这只是为了使其可读。</p>
<p><em>我已经发布了我自己的解决方案，所以你们可以把它拆散。</em></p>
<p><br><br></p>
<h2>解答</h2>
<p>既然MySQL 8.0 支持递归查询，那么可以说所有流行的 SQL 数据库都支持标准语法的递归查询。</p>
<div class="code"><pre class="code literal-block">WITH RECURSIVE MyTree AS (
    SELECT * FROM MyTable WHERE ParentId IS NULL
    UNION ALL
    SELECT m.* FROM MyTABLE AS m JOIN MyTree AS t ON m.ParentId = t.Id
)
SELECT * FROM MyTree;
</pre></div>

<p>我在 2017 年的演讲Recursive Query Throwdown中测试了 MySQL 8.0 中的递归查询。</p>
<p>以下是我 2008 年的原始答案：</p>
<hr>
<p>有几种方法可以将树结构数据存储在关系数据库中。您在示例中显示的内容使用两种方法：</p>
<ul>
<li>
<strong>邻接列表</strong> （“父”列）和</li>
<li>
<strong>路径枚举</strong> （名称列中的虚线数字）。</li>
</ul>
<p>另一种解决方案称为 <strong>Nested Sets</strong> ，它也可以存储在同一个表中。阅读 Joe Celko 的“ Smarties SQL
中的树和层次结构”，了解有关这些设计的更多信息。</p>
<p>我通常更喜欢一种称为 <strong>闭包表</strong> （又名“邻接关系”）的设计来存储树结构数据。它需要另一个表，但是查询树非常容易。</p>
<p>我在我的演示文稿Models for Hierarchical Data with SQL and PHP和我的书SQL Antipatterns
Volume 1: Avoiding the Pitfalls of Database Programming中介绍了 Closure Table 。</p>
<div class="code"><pre class="code literal-block">CREATE TABLE ClosureTable (
  ancestor_id   INT NOT NULL REFERENCES FlatTable(id),
  descendant_id INT NOT NULL REFERENCES FlatTable(id),
  PRIMARY KEY (ancestor_id, descendant_id)
);
</pre></div>

<p>将所有路径存储在闭包表中，其中存在从一个节点到另一个节点的直接祖先。为每个节点包含一行以引用自身。例如，使用您在问题中显示的数据集：</p>
<div class="code"><pre class="code literal-block">INSERT INTO ClosureTable (ancestor_id, descendant_id) VALUES
  (1,1), (1,2), (1,4), (1,6),
  (2,2), (2,4),
  (3,3), (3,5),
  (4,4),
  (5,5),
  (6,6);
</pre></div>

<p>现在你可以得到一棵从节点 1 开始的树，如下所示：</p>
<div class="code"><pre class="code literal-block">SELECT f.* 
FROM FlatTable f 
  JOIN ClosureTable a ON (f.id = a.descendant_id)
WHERE a.ancestor_id = 1;
</pre></div>

<p>输出（在 MySQL 客户端中）如下所示：</p>
<div class="code"><pre class="code literal-block">+----+
| id |
+----+
|  1 | 
|  2 | 
|  4 | 
|  6 | 
+----+
</pre></div>

<p>换句话说，节点 3 和 5 被排除在外，因为它们是单独层次结构的一部分，而不是节点 1 的下级。</p>
<hr>
<p>回复：来自 e-satis 关于直系子女（或直系父母）的评论。<code>path_length</code>您可以向 中添加“
”列<code>ClosureTable</code>，以便更轻松地专门查询直系子级或父级（或任何其他距离）。</p>
<div class="code"><pre class="code literal-block">INSERT INTO ClosureTable (ancestor_id, descendant_id, path_length) VALUES
  (1,1,0), (1,2,1), (1,4,2), (1,6,1),
  (2,2,0), (2,4,1),
  (3,3,0), (3,5,1),
  (4,4,0),
  (5,5,0),
  (6,6,0);
</pre></div>

<p>然后您可以在搜索中添加一个术语以查询给定节点的直接子节点。这些是<code>path_length</code>1 的后代。</p>
<div class="code"><pre class="code literal-block">SELECT f.* 
FROM FlatTable f 
  JOIN ClosureTable a ON (f.id = a.descendant_id)
WHERE a.ancestor_id = 1
  AND path_length = 1;

+----+
| id |
+----+
|  2 | 
|  6 | 
+----+
</pre></div>

<hr>
<p>来自@ashraf 的评论：“[按名称] 对整棵树进行排序怎么样？”</p>
<p>下面是一个示例查询，用于返回节点 1 的所有后代节点，将它们连接到包含其他节点属性（例如 ）的 FlatTable，<code>name</code>并按名称排序。</p>
<div class="code"><pre class="code literal-block">SELECT f.name
FROM FlatTable f 
JOIN ClosureTable a ON (f.id = a.descendant_id)
WHERE a.ancestor_id = 1
ORDER BY f.name;
</pre></div>

<hr>
<p>来自@Nate 的评论：</p>
<div class="code"><pre class="code literal-block">SELECT f.name, GROUP_CONCAT(b.ancestor_id order by b.path_length desc) AS breadcrumbs
FROM FlatTable f 
JOIN ClosureTable a ON (f.id = a.descendant_id) 
JOIN ClosureTable b ON (b.descendant_id = a.descendant_id) 
WHERE a.ancestor_id = 1 
GROUP BY a.descendant_id 
ORDER BY f.name

+------------+-------------+
| name       | breadcrumbs |
+------------+-------------+
| Node 1     | 1           |
| Node 1.1   | 1,2         |
| Node 1.1.1 | 1,2,4       |
| Node 1.2   | 1,6         |
+------------+-------------+
</pre></div>

<hr>
<p>今天有用户建议修改。所以版主批准了编辑，但我正在撤销它。</p>
<p>编辑建议上面最后一个查询中的 ORDER BY 应该是<code>ORDER BY b.path_length,
f.name</code>，大概是为了确保排序与层次结构匹配。但这不起作用，因为它会在“Node 1.2”之后订购“Node 1.1.1”。</p>
<p>如果您希望排序以合理的方式匹配层次结构，那是可能的，但不是简单地按路径长度排序。例如，请参阅我对MySQL Closure Table
hierarchical database - How to pull information out in the correct order 的回答。</p>
<p><br></p>
<h3>更多建议</h3>
<p>如果您使用嵌套集（有时称为修改后的预序树遍历），您可以使用单个查询以树顺序提取整个树结构或其中的任何子树，但插入的成本更高，因为您需要管理描述通过树结构的有序路径的列。</p>
<p>对于django-mptt，我使用了这样的结构：</p>
<div class="code"><pre class="code literal-block">id parent_id tree_id level lft right
-- ---------- ------ ------ --- ----
 1 空 1 0 1 14
 2 1 1 1 2 7
 3 2 1 2 3 4
 4 2 1 2 5 6
 5 1 1 1 8 13
 6 5 1 2 9 10
 7 5 1 2 11 12
</pre></div>

<p>它描述了一棵看起来像这样的树（代表<code>id</code>每个项目）：</p>
<div class="code"><pre class="code literal-block"><span class="mf">1</span><span class="n">个</span>
<span class="w"> </span><span class="o">+--</span><span class="w"> </span><span class="mf">2</span>
<span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="o">+--</span><span class="w"> </span><span class="mf">3</span>
<span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="o">+--</span><span class="w"> </span><span class="mf">4</span>
<span class="w"> </span><span class="err">|</span>
<span class="w"> </span><span class="o">+--</span><span class="w"> </span><span class="mf">5</span>
<span class="w">     </span><span class="o">+--</span><span class="w"> </span><span class="mf">6</span>
<span class="w">     </span><span class="o">+--</span><span class="w"> </span><span class="mf">7</span>
</pre></div>

<p>或者，作为一个嵌套的集合图，它使<code>lft</code>和<code>rght</code>值的工作方式更加明显：</p>
<div class="code"><pre class="code literal-block">________________________________________________________________________
| 根 1 |
| __________________________________ ____________________________ | |
| | 儿童 1.1 | | 儿童 1.2 | |
| | __________ __________ | | __________ __________ | |
| | | C 1.1.1 | | C 1.1.2 | | | | C 1.2.1 | | C 1.2.2 | | |
1 2 3__________4 5__________6 7 8 9__________10 11__________12 13 14
| |____________________________________| |____________________________________| |
|________________________________________________________________________|
</pre></div>

<p>如您所见，要按树顺序获取给定节点的整个子树，您只需选择具有<code>lft</code>和<code>rght</code>值介于其<code>lft</code>和<code>rght</code>值之间的所有行。检索给定节点的祖先树也很简单。</p>
<p>为了方便起见，该<code>level</code>列进行了一些非规范化，并且该列允许您为每个顶级节点<code>tree_id</code>重新开始<code>lft</code>和编号，这减少了受插入、移动和删除影响的列数，因为和列必须是在这些操作发生时进行相应调整，以创造或缩小差距。当我试图围绕每个操作所需的查询进行思考时，我做了一些开发笔记。<code>rght``lft``rght</code></p>
<p>在实际使用这些数据来显示树方面，我创建了一个<code>tree_item_iterator</code>实用函数，对于每个节点，它应该为您提供足够的信息来生成您想要的任何类型的显示。</p>
<p>有关 MPTT 的更多信息：</p>
<ul>
<li>SQL 中的树</li>
<li>在数据库中存储分层数据</li>
<li>在 MySQL 中管理分层数据</li>
</ul>
<p><br><br><a href="../what-is-the-most-efficient-elegant-way-to-parse-a-flat-table-into-a-tree/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/hierarchical-data/" rel="tag">hierarchical-data</a></li>
            <li><a class="tag p-category" href="../../categories/recursion/" rel="tag">recursion</a></li>
            <li><a class="tag p-category" href="../../categories/sql/" rel="tag">sql</a></li>
            <li><a class="tag p-category" href="../../categories/tree/" rel="tag">tree</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../zhu-xiao-get-huan-shi-post/" rel="prev" title="注销：GET 还是 POST？">Previous post</a>
            </li>
            <li class="next">
                <a href="../jian-ce-liu-lan-qi-he-shi-shou-dao-wen-jian-xia-zai/" rel="next" title="检测浏览器何时收到文件下载">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
