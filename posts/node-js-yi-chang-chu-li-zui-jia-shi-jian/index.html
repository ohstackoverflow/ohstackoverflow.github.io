<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Node.js 异常处理最佳实践 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/node-js-yi-chang-chu-li-zui-jia-shi-jian/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-cong-fan-xing-lei-huo-fang-fa-de-cheng-yuan-huo-qu-t-de-lei-xing/" title="如何从泛型类或方法的成员获取 T 的类型" type="text/html">
<link rel="next" href="../bash-zhong-dan-xing-while-xun-huan-de-yu-fa/" title="Bash 中单行 while 循环的语法" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Node.js 异常处理最佳实践">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/node-js-yi-chang-chu-li-zui-jia-shi-jian/">
<meta property="og:description" content="我几天前才开始试用
node.js。我意识到只要我的程序中有未处理的异常，节点就会终止。这与我接触过的普通服务器容器不同，在普通服务器容器中，只有工作线程在发生未处理的异常时死亡，并且容器仍然能够接收请求。这提出了几个问题：

是process.on('uncaughtException')唯一有效的防范方法吗？
process.on('uncaughtException')在异步进程执行期间也会">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T12:29:42+08:00">
<meta property="article:tag" content="exception">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="serverside-javascript">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Node.js 异常处理最佳实践</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T12:29:42+08:00" itemprop="datePublished" title="2023-02-17 12:29">2023-02-17 12:29</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我几天前才开始试用
node.js。我意识到只要我的程序中有未处理的异常，节点就会终止。这与我接触过的普通服务器容器不同，在普通服务器容器中，只有工作线程在发生未处理的异常时死亡，并且容器仍然能够接收请求。这提出了几个问题：</p>
<ul>
<li>是<code>process.on('uncaughtException')</code>唯一有效的防范方法吗？</li>
<li>
<code>process.on('uncaughtException')</code>在异步进程执行期间也会捕获未处理的异常吗？</li>
<li>是否有一个已经构建的模块（例如发送电子邮件或写入文件）我可以在未捕获的异常情况下利用？</li>
</ul>
<p>我将不胜感激任何能向我展示在 node.js 中处理未捕获异常的常见最佳实践的指针/文章</p>
<p><br><br></p>
<h2>解答</h2>
<p>更新：Joyent 现在有自己的指南。以下信息更像是一个摘要：</p>
<h3>安全地“抛出”错误</h3>
<p>理想情况下，我们希望尽可能避免未捕获的错误，因此，我们可以根据我们的代码架构使用以下方法之一安全地“抛出”错误，而不是直接抛出错误：</p>
<ul>
<li>
<p>对于同步代码，如果发生错误，返回错误：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Define divider as a syncrhonous function</span>
</pre></div>

<p>var divideSync = function(x,y) {
    // if error condition?
    if ( y === 0 ) {
        // "throw" the error safely by returning it
        return new Error("Can't divide by zero")
    }
    else {
        // no error occured, continue on
        return x/y
    }
}</p>
<p>// Divide 4/2
var result = divideSync(4,2)
// did an error occur?
if ( result instanceof Error ) {
    // handle the error safely
    console.log('4/2=err', result)
}
else {
    // no error occured, continue on
    console.log('4/2='+result)
}</p>
<p>// Divide 4/0
result = divideSync(4,0)
// did an error occur?
if ( result instanceof Error ) {
    // handle the error safely
    console.log('4/0=err', result)
}
else {
    // no error occured, continue on
    console.log('4/0='+result)
}</p>
</li>
<li>
<p>对于基于回调（即异步）的代码，回调的第一个参数是<code>err</code>，如果发生错误<code>err</code>则为错误，如果没有发生错误<code>err</code>则为<code>null</code>。任何其他参数都在<code>err</code>参数之后：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="o">//</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">condition</span><span class="err">?</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="s2">"throw"</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">safely</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">calling</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">completion</span><span class="w"> </span><span class="n">callback</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">error</span>
<span class="w">    </span><span class="n">next</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"Can't divide by zero"</span><span class="p">))</span>
<span class="p">}</span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">occured</span><span class="p">,</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="n">on</span>
<span class="w">    </span><span class="n">next</span><span class="p">(</span><span class="nb nb-Type">null</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>}</p>
<p>divide(4,2,function(err,result){
    // did an error occur?
    if ( err ) {
        // handle the error safely
        console.log('4/2=err', err)
    }
    else {
        // no error occured, continue on
        console.log('4/2='+result)
    }
})</p>
<p>divide(4,0,function(err,result){
    // did an error occur?
    if ( err ) {
        // handle the error safely
        console.log('4/0=err', err)
    }
    else {
        // no error occured, continue on
        console.log('4/0='+result)
    }
})</p>
</li>
<li>
<p>对于多事件代码，错误可能发生在任何地方，而不是抛出错误，<code>error</code>而是触发事件：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Definite our Divider Event Emitter</span>
</pre></div>

<p>var events = require('events')
var Divider = function(){
    events.EventEmitter.call(this)
}
require('util').inherits(Divider, events.EventEmitter)</p>
<p>// Add the divide function
Divider.prototype.divide = function(x,y){
    // if error condition?
    if ( y === 0 ) {
        // "throw" the error safely by emitting it
        var err = new Error("Can't divide by zero")
        this.emit('error', err)
    }
    else {
        // no error occured, continue on
        this.emit('divided', x, y, x/y)
    }</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Chain</span>
<span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
</pre></div>

<p>}</p>
<p>// Create our divider and listen for errors
var divider = new Divider()
divider.on('error', function(err){
    // handle the error safely
    console.log(err)
})
divider.on('divided', function(x,y,result){
    console.log(x+'/'+y+'='+result)
})</p>
<p>// Divide
divider.divide(4,2).divide(4,0)</p>
</li>
</ul>
<h3>安全地“捕获”错误</h3>
<p>但有时，可能仍有代码在某处抛出错误，如果我们不安全地捕获它，可能会导致未捕获的异常和应用程序的潜在崩溃。根据我们的代码架构，我们可以使用以下方法之一来捕获它：</p>
<ul>
<li>
<p>当我们知道错误发生在哪里时，我们可以将该部分包装在node.js 域中</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require</span><span class="p">(</span><span class="s1">'domain'</span><span class="p">)</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
</pre></div>

<p>d.on('error', function(err){
    // handle the error safely
    console.log(err)
})</p>
<p>// catch the uncaught errors in this asynchronous or synchronous code block
d.run(function(){
    // the asynchronous or synchronous code that we want to catch thrown errors on
    var err = new Error('example')
    throw err
})</p>
</li>
<li>
<p>如果我们知道错误发生的地方是同步代码，并且由于某种原因不能使用域（可能是旧版本的节点），我们可以使用 try catch 语句：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// catch the uncaught errors in this synchronous code block</span>
</pre></div>

<p>// try catch statements only work on synchronous code
try {
    // the synchronous code that we want to catch thrown errors on
    var err = new Error('example')
    throw err
} catch (err) {
    // handle the error safely
    console.log(err)
}</p>
</li>
</ul>
<p>但是，注意不要<code>try...catch</code>在异步代码中使用，因为不会捕获异步抛出的错误：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="n">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">setTimeout</span><span class="p">(</span><span class="n">function</span><span class="p">(){</span>
<span class="w">        </span><span class="k">var</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s1">'example'</span><span class="p">)</span>
<span class="w">        </span><span class="n">throw</span><span class="w"> </span><span class="n">err</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">won</span><span class="s1">'t be caught here... crashing our app</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">hence</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">domains</span>
<span class="p">}</span>
</pre></div>

<p>如果您确实想与异步代码结合使用<code>try..catch</code>，则在运行 Node 7.4
或更高版本时，您可以使用<code>async/await</code>本机代码来编写异步函数。</p>
<p>另一件需要注意的事情<code>try...catch</code>是将完成回调包装在语句中的风险，<code>try</code>如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">divide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">condition</span><span class="err">?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="s2">"throw"</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">safely</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">calling</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">completion</span><span class="w"> </span><span class="n">callback</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">error</span>
<span class="w">        </span><span class="n">next</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"Can't divide by zero"</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">occured</span><span class="p">,</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="n">on</span>
<span class="w">        </span><span class="n">next</span><span class="p">(</span><span class="nb nb-Type">null</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span><span class="w"> </span><span class="n">continueElsewhere</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">){</span>
<span class="w">        </span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s1">'elsewhere has failed'</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">divide</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">continueElsewhere</span><span class="p">)</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">divide</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="n">of</span><span class="w"> </span>
<span class="w">        </span><span class="o">//</span><span class="w">   </span><span class="n">continueElsewhere</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="n">statement</span>
<span class="p">}</span>
<span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="s2">"unexpected"</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">of</span><span class="p">:</span><span class="w"> </span><span class="n">elsewhere</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">failed</span>
<span class="p">}</span>
</pre></div>

<p>随着您的代码变得越来越复杂，这个陷阱很容易做到。因此，最好要么使用域，要么返回错误，以避免 (1) 异步代码中出现未捕获的异常 (2) try catch
捕获您不希望的执行。在允许适当线程而不是 JavaScript 的异步事件机器风格的语言中，这不是一个问题。</p>
<ul>
<li>
<p>最后，如果未捕获的错误发生在未包含在域或 try catch 语句中的位置，我们可以使用侦听器使我们的应用程序不崩溃（但是这样做会使应用程序处于<code>uncaughtException</code>未知状态):</p>
<div class="code"><pre class="code literal-block"><span class="c1">// catch the uncaught errors that weren't wrapped in a domain or try catch statement</span>
</pre></div>

<p>// do not use this in modules, but only in applications, as otherwise we could have multiple of these bound
process.on('uncaughtException', function(err) {
    // handle the error safely
    console.log(err)
})</p>
<p>// the asynchronous or synchronous code that emits the otherwise uncaught error
var err = new Error('example')
throw err</p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>以下是关于该主题的许多不同来源的总结和整理，包括代码示例和精选博客文章中的引述。可以在此处找到完整的最佳实践列表</p>
<hr>
<h2><strong>Node.JS 错误处理的最佳实践</strong></h2>
<hr>
<h3>Number1：使用 promises 进行异步错误处理</h3>
<p><strong>TL;DR：</strong> 以回调方式处理异步错误可能是通往地狱的最快途径（又名厄运金字塔）。您可以为代码提供的最好礼物是使用信誉良好的 promise
库，它提供了很多紧凑且熟悉的代码语法，例如 try-catch</p>
<p><strong>否则：</strong> Node.JS 回调风格，function(err,
response)，由于错误处理与随意代码、过度嵌套和笨拙的编码模式的混合，是一种很有前途的代码不可维护的方法</p>
<p><strong>代码示例 - 好</strong></p>
<div class="code"><pre class="code literal-block"><span class="nf">doWork</span><span class="p">()</span>
<span class="na">.then</span><span class="p">(</span><span class="no">doWork</span><span class="p">)</span>
<span class="na">.then</span><span class="p">(</span><span class="no">doError</span><span class="p">)</span>
<span class="na">.then</span><span class="p">(</span><span class="no">doWork</span><span class="p">)</span>
<span class="na">.catch</span><span class="p">(</span><span class="no">errorHandler</span><span class="p">)</span>
<span class="na">.then</span><span class="p">(</span><span class="no">verify</span><span class="p">)</span><span class="c1">;</span>
</pre></div>

<p><strong>反模式代码示例——回调式错误处理</strong></p>
<div class="code"><pre class="code literal-block"><span class="nv">getData</span><span class="ss">(</span><span class="nv">someParameter</span>,<span class="w"> </span><span class="nv">function</span><span class="ss">(</span><span class="nv">err</span>,<span class="w"> </span><span class="nb">result</span><span class="ss">)</span>{
<span class="w">    </span><span class="k">if</span><span class="ss">(</span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">null</span><span class="ss">)</span>
<span class="w">      </span><span class="o">//</span><span class="k">do</span><span class="w"> </span><span class="nv">something</span><span class="w"> </span><span class="nv">like</span><span class="w"> </span><span class="nv">calling</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">given</span><span class="w"> </span><span class="nv">callback</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">pass</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">error</span>
<span class="w">    </span><span class="nv">getMoreData</span><span class="ss">(</span><span class="nv">a</span>,<span class="w"> </span><span class="nv">function</span><span class="ss">(</span><span class="nv">err</span>,<span class="w"> </span><span class="nb">result</span><span class="ss">)</span>{
<span class="w">          </span><span class="k">if</span><span class="ss">(</span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">null</span><span class="ss">)</span>
<span class="w">            </span><span class="o">//</span><span class="k">do</span><span class="w"> </span><span class="nv">something</span><span class="w"> </span><span class="nv">like</span><span class="w"> </span><span class="nv">calling</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">given</span><span class="w"> </span><span class="nv">callback</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">pass</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">error</span>
<span class="w">        </span><span class="nv">getMoreData</span><span class="ss">(</span><span class="nv">b</span>,<span class="w"> </span><span class="nv">function</span><span class="ss">(</span><span class="nv">c</span><span class="ss">)</span>{<span class="w"> </span>
<span class="w">                </span><span class="nv">getMoreData</span><span class="ss">(</span><span class="nv">d</span>,<span class="w"> </span><span class="nv">function</span><span class="ss">(</span><span class="nv">e</span><span class="ss">)</span>{<span class="w"> </span>
<span class="w">                    </span>...
<span class="w">                </span>}<span class="ss">)</span><span class="c1">;</span>
<span class="w">            </span>}<span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span>}<span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span>}<span class="ss">)</span><span class="c1">;</span>
}<span class="ss">)</span><span class="c1">;</span>
</pre></div>

<p><strong>博客引用：“We have a problem with promises”</strong> （来自博客 pouchdb，关键词“Node Promises”排名第
11）</p>
<blockquote>
<p>“......事实上，回调做了一些更险恶的事情：它们剥夺了我们的堆栈，这是我们通常在编程语言中认为理所当然的东西。没有堆栈编写代码很像驾驶没有刹车踏板的汽车：你没有意识到你有多需要它，直到你伸手去拿它，但它不在那里。承诺
<strong>的全部意义在于把我们在异步时丢失的语言基础还给我们：return、throw 和 stack。但是你必须知道如何正确使用承诺才能利用它们。</strong> ”</p>
</blockquote>
<hr>
<h3>Number2：仅使用内置的 Error 对象</h3>
<p><strong>TL;DR：</strong>
将错误作为字符串或自定义类型抛出的代码很常见——这使错误处理逻辑和模块之间的互操作性变得复杂。无论您是拒绝承诺、抛出异常还是发出错误——使用 Node.JS
内置的错误对象可以提高一致性并防止错误信息丢失</p>
<p><strong>否则：</strong>
在执行某些模块时，不确定会返回哪种类型的错误——这使得推断和处理即将到来的异常变得更加困难。甚至值得，使用自定义类型来描述错误可能会导致丢失关键错误信息，如堆栈跟踪！</p>
<p><strong>代码示例 - 正确执行</strong></p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">//</span><span class="n">throwing</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">typical</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">whether</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">async</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">productToAdd</span><span class="p">)</span>
<span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"How can I add new product when no value provided?"</span><span class="p">);</span>

<span class="o">//</span><span class="s1">'throwing'</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">EventEmitter</span>
<span class="k">const</span><span class="w"> </span><span class="n">myEmitter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyEmitter</span><span class="p">();</span>
<span class="n">myEmitter</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s1">'whoops!'</span><span class="p">));</span>

<span class="o">//</span><span class="s1">'throwing'</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">Promise</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">promise</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">resolve</span><span class="p">,</span><span class="w"> </span><span class="n">reject</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">DAL</span><span class="o">.</span><span class="n">getProduct</span><span class="p">(</span><span class="n">productToAdd</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">existingProduct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="p">{</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">existingProduct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb nb-Type">null</span><span class="p">)</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">reject</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"Why fooling us and trying to add an existing product?"</span><span class="p">));</span>
</pre></div>

<p><strong>代码示例反模式</strong></p>
<div class="code"><pre class="code literal-block"><span class="c1">//throwing a String lacks any stack trace information and other important properties</span>
<span class="k">if</span><span class="p">(</span>!<span class="n">productToAdd</span><span class="p">)</span>
<span class="w">    </span><span class="n">throw</span><span class="w"> </span><span class="p">(</span><span class="s">"How can I add new product when no value provided?"</span><span class="p">);</span>
</pre></div>

<p><strong>博客引用：“A string is not an error”</strong> （来自博客 devthought，关键字“Node.JS error
object”排名第 6）</p>
<blockquote>
<p><strong>“......传递字符串而不是错误会导致模块之间的互操作性降低。它破坏了与可能正在执行 instanceof 错误检查的 API
的合同，或者想要了解更多关于错误的信息。我们将看到，错误对象具有</strong> 非常现代 JavaScript
引擎中有趣的属性，除了保存传递给构造函数的消息之外……”</p>
</blockquote>
<hr>
<h3>Number3：区分操作错误和程序员错误</h3>
<p><strong>TL;DR：</strong> 操作错误（例如，API
收到无效输入）指的是错误影响已被充分理解并且可以得到周到处理的已知情况。另一方面，程序员错误（例如，试图读取未定义的变量）指的是未知的代码故障，要求从容地重新启动应用程序</p>
<p><strong>否则：</strong> 当出现错误时，您可能总是会重新启动应用程序，但为什么会因为一个小的和可预测的错误（操作错误）而让约 5000
名在线用户失望？相反的情况也不理想——在发生未知问题（程序员错误）时保持应用程序运行可能会导致不可预测的行为。区分两者允许巧妙地采取行动并根据给定的上下文应用平衡的方法</p>
<p><strong>代码示例 - 正确执行</strong></p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">//</span><span class="n">throwing</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">typical</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">whether</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">async</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">productToAdd</span><span class="p">)</span>
<span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"How can I add new product when no value provided?"</span><span class="p">);</span>

<span class="o">//</span><span class="s1">'throwing'</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">EventEmitter</span>
<span class="k">const</span><span class="w"> </span><span class="n">myEmitter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">MyEmitter</span><span class="p">();</span>
<span class="n">myEmitter</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s1">'error'</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s1">'whoops!'</span><span class="p">));</span>

<span class="o">//</span><span class="s1">'throwing'</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">Promise</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">promise</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">resolve</span><span class="p">,</span><span class="w"> </span><span class="n">reject</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">DAL</span><span class="o">.</span><span class="n">getProduct</span><span class="p">(</span><span class="n">productToAdd</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">existingProduct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="p">{</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">existingProduct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb nb-Type">null</span><span class="p">)</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">reject</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"Why fooling us and trying to add an existing product?"</span><span class="p">));</span>
</pre></div>

<p><strong>代码示例 - 将错误标记为可操作（可信）</strong></p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="n">marking</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">operational</span><span class="w"> </span>
<span class="k">var</span><span class="w"> </span><span class="n">myError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s2">"How can I add new product when no value provided?"</span><span class="p">);</span>
<span class="n">myError</span><span class="o">.</span><span class="n">isOperational</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">true</span><span class="p">;</span>

<span class="o">//</span><span class="ow">or</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">you</span><span class="s1">'re using some centralized error factory (see other examples at the bullet "Use only the built-in Error object")</span>
<span class="n">function</span><span class="w"> </span><span class="n">appError</span><span class="p">(</span><span class="n">commonType</span><span class="p">,</span><span class="w"> </span><span class="n">description</span><span class="p">,</span><span class="w"> </span><span class="n">isOperational</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Error</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="n">Error</span><span class="o">.</span><span class="n">captureStackTrace</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">commonType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">commonType</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">description</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">description</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">isOperational</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isOperational</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">appError</span><span class="p">(</span><span class="n">errorManagement</span><span class="o">.</span><span class="n">commonErrors</span><span class="o">.</span><span class="n">InvalidInput</span><span class="p">,</span><span class="w"> </span><span class="s2">"Describe here what happened"</span><span class="p">,</span><span class="w"> </span><span class="bp">true</span><span class="p">);</span>

<span class="o">//</span><span class="n">error</span><span class="w"> </span><span class="n">handling</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">within</span><span class="w"> </span><span class="n">middleware</span>
<span class="n">process</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="s1">'uncaughtException'</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="o">.</span><span class="n">isOperational</span><span class="p">)</span>
<span class="w">        </span><span class="n">process</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p><strong>博客引用</strong> ：“Otherwise you risk the state”（来自可调试的博客，关键字“Node.JS 未捕获异常”排名第 3）</p>
<blockquote>
<p>“ <strong>......就 throw 在 JavaScript
中的工作方式的本质而言，几乎没有任何方法可以安全地“从你离开的地方继续”，而不泄漏引用，或创建一些其他类型的未定义的脆弱状态。最安全的响应方式一个抛出的错误是关闭进程</strong>
。当然，在一个普通的网络服务器中，你可能有很多连接打开，突然关闭这些连接是不合理的，因为错误是由其他人触发的。更好的方法是向触发错误的请求发送错误响应，同时让其他人在正常时间内完成，并停止监听该工作人员中的新请求”</p>
</blockquote>
<hr>
<h3>Number4：通过但不在中间件内集中处理错误</h3>
<p><strong>TL;DR：</strong> 错误处理逻辑，例如发送给管理员的邮件和日志记录，应该封装在一个专用的集中式对象中，当出现错误时，所有端点（例如 Express
中间件、cron 作业、单元测试）都会调用该对象。</p>
<p><strong>否则：</strong> 不在一个地方处理错误将导致代码重复，并可能导致错误处理不当</p>
<p><strong>代码示例——一个典型的错误流程</strong></p>
<div class="code"><pre class="code literal-block"><span class="c1">//DAL layer, we don't handle errors here</span>
<span class="n">DB</span><span class="p">.</span><span class="n">addDocument</span><span class="p">(</span><span class="n">newCustomer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="p">)</span>
<span class="w">        </span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Error</span><span class="p">(</span><span class="s">"Great error explanation comes here"</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">useful</span><span class="w"> </span><span class="n">parameters</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">//API route code, we catch both sync and async errors and forward to the middleware</span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">customerService</span><span class="p">.</span><span class="n">addNew</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">body</span><span class="p">).</span><span class="nb">then</span><span class="p">(</span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">res</span><span class="p">.</span><span class="n">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="n">json</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nb">error</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">next</span><span class="p">(</span><span class="nb">error</span><span class="p">)</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>
<span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">next</span><span class="p">(</span><span class="nb">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//Error handling middleware, we delegate the handling to the centrzlied error handler</span>
<span class="n">app</span><span class="p">.</span><span class="n">use</span><span class="p">(</span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">errorHandler</span><span class="p">.</span><span class="n">handleError</span><span class="p">(</span><span class="n">err</span><span class="p">).</span><span class="nb">then</span><span class="p">((</span><span class="n">isOperationalError</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span>!<span class="n">isOperationalError</span><span class="p">)</span>
<span class="w">            </span><span class="n">next</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p><strong>博客引用：</strong> “有时较低级别除了将错误传播给他们的调用者之外不能做任何有用的事情”（来自博客 Joyent，关键字“Node.JS
错误处理”排名第一）</p>
<blockquote>
<p>“......您可能最终会在堆栈的多个级别处理相同的错误。当较低级别除了将错误传播给它们的调用者之外不能做任何有用的事情时，就会发生这种情况，调用者将错误传播给它的调用者，等等。通常，只有顶层调用者知道适当的响应是什么，无论是重试操作、向用户报告错误还是其他。但这并不意味着您应该尝试将所有错误报告给单个顶层回调，因为回调本身无法知道错误发生在什么上下文中”</p>
</blockquote>
<hr>
<h3>Number5：使用 Swagger 记录 API 错误</h3>
<p><strong>TL;DR：</strong> 让您的 API 调用者知道可能返回哪些错误，以便他们可以周到地处理这些错误而不会崩溃。这通常是通过 REST API 文档框架（如
Swagger）完成的</p>
<p><strong>否则：</strong> API 客户端可能决定崩溃并重新启动只是因为他收到了一个他无法理解的错误。注意：您的 API 的调用者可能是您（在微服务环境中非常典型）</p>
<p><strong>博客引用：</strong> “你必须告诉你的调用者会发生什么错误”（来自博客 Joyent，关键字“Node.JS 日志记录”排名第一）</p>
<blockquote>
<p>……我们已经讨论了如何处理错误，但是当您编写一个新函数时，您如何将错误传递给调用您的函数的代码？…如果您不知道会发生什么错误或不知道它们的含义，那么您的程序就不可能是正确的，除非是偶然的。所以如果你正在编写一个新函数，你必须告诉你的调用者可能会发生什么错误以及它们意味着什么</p>
</blockquote>
<hr>
<h3>Number6：当一个陌生人来到镇上时优雅地结束这个过程</h3>
<p><strong>TL;DR：</strong> 当发生未知错误时（开发人员错误，请参阅第 3 条最佳实践）- 应用程序的健康状况存在不确定性。一种常见的做法是使用 Forever 和
PM2 等“重启”工具小心地重启进程</p>
<p><strong>否则：</strong>
当捕获到不熟悉的异常时，某些对象可能处于故障状态（例如，全局使用的事件发射器由于某些内部故障而不再触发事件）并且所有未来的请求可能会失败或行为异常</p>
<p><strong>代码示例——决定是否崩溃</strong></p>
<div class="code"><pre class="code literal-block"><span class="c1">//deciding whether to crash when an uncaught exception arrives</span>
<span class="c1">//Assuming developers mark known operational errors with error.isOperational=true, read best practice #3</span>
<span class="n">process</span><span class="p">.</span><span class="n">on</span><span class="p">(</span><span class="s">'uncaughtException'</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="nb">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">errorManagement</span><span class="p">.</span><span class="n">handler</span><span class="p">.</span><span class="n">handleError</span><span class="p">(</span><span class="nb">error</span><span class="p">);</span>
<span class="w"> </span><span class="k">if</span><span class="p">(</span>!<span class="n">errorManagement</span><span class="p">.</span><span class="n">handler</span><span class="p">.</span><span class="n">isTrustedError</span><span class="p">(</span><span class="nb">error</span><span class="p">))</span>
<span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">});</span>


<span class="c1">//centralized error handler encapsulates error-handling related logic </span>
<span class="k">function</span><span class="w"> </span><span class="nf">errorHandler</span><span class="p">(){</span>
<span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">handleError</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">logger</span><span class="p">.</span><span class="n">logError</span><span class="p">(</span><span class="n">err</span><span class="p">).</span><span class="nb">then</span><span class="p">(</span><span class="n">sendMailToAdminIfCritical</span><span class="p">).</span><span class="nb">then</span><span class="p">(</span><span class="n">saveInOpsQueueIfCritical</span><span class="p">).</span><span class="nb">then</span><span class="p">(</span><span class="n">determineIfOperationalError</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">isTrustedError</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="nb">error</span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">error</span><span class="p">.</span><span class="n">isOperational</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>

<p><strong>博客引用：</strong> “关于错误处理的三种思想流派”（来自博客 jsrecipes）</p>
<blockquote>
<p>…There are primarily three schools of thoughts on error handling: 1. Let the
application crash and restart it. 2. Handle all possible errors and never
crash. <strong>3. Balanced approach between the two</strong></p>
</blockquote>
<hr>
<h3>Number7: Use a mature logger to increase errors visibility</h3>
<p><strong>TL;DR:</strong> A set of mature logging tools like Winston, Bunyan or Log4J, will
speed-up error discovery and understanding. So forget about console.log.</p>
<p><strong>Otherwise:</strong> Skimming through console.logs or manually through messy text
file without querying tools or a decent log viewer might keep you busy at work
until late</p>
<p><strong>Code example - Winston logger in action</strong></p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="n">your</span><span class="w"> </span><span class="n">centralized</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="n">object</span>
<span class="k">var</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">winston</span><span class="o">.</span><span class="n">Logger</span><span class="p">({</span>
<span class="w"> </span><span class="n">level</span><span class="p">:</span><span class="w"> </span><span class="s1">'info'</span><span class="p">,</span>
<span class="w"> </span><span class="n">transports</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="p">(</span><span class="n">winston</span><span class="o">.</span><span class="n">transports</span><span class="o">.</span><span class="n">Console</span><span class="p">)(),</span>
<span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="p">(</span><span class="n">winston</span><span class="o">.</span><span class="n">transports</span><span class="o">.</span><span class="n">File</span><span class="p">)({</span><span class="w"> </span><span class="n">filename</span><span class="p">:</span><span class="w"> </span><span class="s1">'somefile.log'</span><span class="w"> </span><span class="p">})</span>
<span class="w"> </span><span class="p">]</span>
<span class="w"> </span><span class="p">});</span>

<span class="o">//</span><span class="n">custom</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">somewhere</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">logger</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">'info'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Test Log Message with some parameter </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span><span class="w"> </span><span class="s1">'some parameter'</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">anything</span><span class="p">:</span><span class="w"> </span><span class="s1">'This is metadata'</span><span class="w"> </span><span class="p">});</span>
</pre></div>

<p><strong>Blog quote:</strong> "Lets identify a few requirements (for a logger):" (From the
blog strongblog)</p>
<blockquote>
<p>…Lets identify a few requirements (for a logger): 1. Time stamp each log
line. This one is pretty self explanatory – you should be able to tell when
each log entry occured. 2. Logging format should be easily digestible by
humans as well as machines. 3. Allows for multiple configurable destination
streams. For example, you might be writing trace logs to one file but when
an error is encountered, write to the same file, then into error file and
send an email at the same time…</p>
</blockquote>
<hr>
<h3>Number8: Discover errors and downtime using APM products</h3>
<p><strong>TL;DR:</strong> Monitoring and performance products (a.k.a APM) proactively gauge
your codebase or API so they can auto-magically highlight errors, crashes and
slow parts that you were missing</p>
<p><strong>Otherwise:</strong> You might spend great effort on measuring API performance and
downtimes, probably you’ll never be aware which are your slowest code parts
under real world scenario and how these affects the UX</p>
<p><strong>Blog quote:</strong> "APM products segments" (From the blog Yoni Goldberg)</p>
<blockquote>
<p>"…APM products constitutes 3 major segments: <strong>1. Website or API monitoring
–</strong> external services that constantly monitor uptime and performance via
HTTP requests. Can be setup in few minutes. Following are few selected
contenders: Pingdom, Uptime Robot, and New Relic <strong>2. Code instrumentation
–</strong> products family which require to embed an agent within the application
to benefit feature slow code detection, exceptions statistics, performance
monitoring and many more. Following are few selected contenders: New Relic,
App Dynamics <strong>3. Operational intelligence dashboard –</strong> these line of
products are focused on facilitating the ops team with metrics and curated
content that helps to easily stay on top of application performance. This is
usually involves aggregating multiple sources of information (application
logs, DB logs, servers log, etc) and upfront dashboard design work.
Following are few selected contenders: Datadog, Splunk"</p>
</blockquote>
<hr>
<p><strong><em>The above is a shortened version - see here more best practices and
examples</em></strong></p>
<p><br><br><a href="../node-js-best-practice-exception-handling/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/exception/" rel="tag">exception</a></li>
            <li><a class="tag p-category" href="../../categories/nodejs/" rel="tag">node.js</a></li>
            <li><a class="tag p-category" href="../../categories/serverside-javascript/" rel="tag">serverside-javascript</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-cong-fan-xing-lei-huo-fang-fa-de-cheng-yuan-huo-qu-t-de-lei-xing/" rel="prev" title="如何从泛型类或方法的成员获取 T 的类型">Previous post</a>
            </li>
            <li class="next">
                <a href="../bash-zhong-dan-xing-while-xun-huan-de-yu-fa/" rel="next" title="Bash 中单行 while 循环的语法">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
