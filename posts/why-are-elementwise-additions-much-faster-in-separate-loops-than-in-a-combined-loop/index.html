<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Why are elementwise additions much faster in separate loops than in a combined loop? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/why-are-elementwise-additions-much-faster-in-separate-loops-than-in-a-combined-loop/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-can-i-save-username-and-password-in-git/" title="How can I save username and password in Git?" type="text/html">
<link rel="next" href="../generate-random-number-between-two-numbers-in-javascript/" title="Generate random number between two numbers in JavaScript" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Why are elementwise additions much faster in separate loops than in a ">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/why-are-elementwise-additions-much-faster-in-separate-loops-than-in-a-combined-loop/">
<meta property="og:description" content="Suppose a1, b1, c1, and d1 point to heap memory, and my numerical code
has the following core loop.
const int n = 100000;

for (int j = 0; j &lt; n; j++) {
    a1[j] += b1[j];
    c1[j] += d1[j];
}


Thi">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T21:30:13+08:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="compiler-optimization">
<meta property="article:tag" content="performance">
<meta property="article:tag" content="vectorization">
<meta property="article:tag" content="x86">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Why are elementwise additions much faster in separate loops than in a combined loop?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T21:30:13+08:00" itemprop="datePublished" title="2023-02-16 21:30">2023-02-16 21:30</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Suppose <code>a1</code>, <code>b1</code>, <code>c1</code>, and <code>d1</code> point to heap memory, and my numerical code
has the following core loop.</p>
<div class="code"><pre class="code literal-block"><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>This loop is executed 10,000 times via another outer <code>for</code> loop. To speed it
up, I changed the code to:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>Compiled on Microsoft Visual C++ 10.0 with full optimization and SSE2 enabled
for 32-bit on a Intel Core 2 Duo (x64), the first example takes 5.5 seconds
and the double-loop example takes only 1.9 seconds.</p>
<p>Disassembly for the first loop basically looks like this (this block is
repeated about five times in the full program):</p>
<div class="code"><pre class="code literal-block">movsd       xmm0,mmword ptr [edx+18h]
addsd       xmm0,mmword ptr [ecx+20h]
movsd       mmword ptr [ecx+20h],xmm0
movsd       xmm0,mmword ptr [esi+10h]
addsd       xmm0,mmword ptr [eax+30h]
movsd       mmword ptr [eax+30h],xmm0
movsd       xmm0,mmword ptr [edx+20h]
addsd       xmm0,mmword ptr [ecx+28h]
movsd       mmword ptr [ecx+28h],xmm0
movsd       xmm0,mmword ptr [esi+18h]
addsd       xmm0,mmword ptr [eax+38h]
</pre></div>

<p>Each loop of the double loop example produces this code (the following block
is repeated about three times):</p>
<div class="code"><pre class="code literal-block">addsd       xmm0,mmword ptr [eax+28h]
movsd       mmword ptr [eax+28h],xmm0
movsd       xmm0,mmword ptr [ecx+20h]
addsd       xmm0,mmword ptr [eax+30h]
movsd       mmword ptr [eax+30h],xmm0
movsd       xmm0,mmword ptr [ecx+28h]
addsd       xmm0,mmword ptr [eax+38h]
movsd       mmword ptr [eax+38h],xmm0
movsd       xmm0,mmword ptr [ecx+30h]
addsd       xmm0,mmword ptr [eax+40h]
movsd       mmword ptr [eax+40h],xmm0
</pre></div>

<p>The question turned out to be of no relevance, as the behavior severely
depends on the sizes of the arrays (n) and the CPU cache. So if there is
further interest, I rephrase the question:</p>
<ul>
<li>
<p>Could you provide some solid insight into the details that lead to the different cache behaviors as illustrated by the five regions on the following graph?</p>
</li>
<li>
<p>It might also be interesting to point out the differences between CPU/cache architectures, by providing a similar graph for these CPUs.</p>
</li>
</ul>
<p>Here is the full code. It uses TBB <code>Tick_Count</code> for higher resolution timing,
which can be disabled by not defining the <code>TBB_TIMING</code> Macro:</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iomanip</span><span class="o">&gt;</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">cmath</span><span class="o">&gt;</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>

<span class="o">//</span><span class="n">#define</span><span class="w"> </span><span class="n">TBB_TIMING</span>

<span class="n">#ifdef</span><span class="w"> </span><span class="n">TBB_TIMING</span><span class="w">   </span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">tbb</span><span class="o">/</span><span class="n">tick_count</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="nl">tbb</span><span class="p">:</span><span class="err">:</span><span class="n">tick_count</span><span class="p">;</span>
<span class="n">#else</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="nc">time</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="n">#endif</span>

<span class="k">using</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="n">std</span><span class="p">;</span>

<span class="o">//</span><span class="n">#define</span><span class="w"> </span><span class="n">preallocate_memory</span><span class="w"> </span><span class="n">new_cont</span>

<span class="n">enum</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">new_cont</span><span class="p">,</span><span class="w"> </span><span class="n">new_sep</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>

<span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">b1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">d1</span><span class="p">;</span>


<span class="n">void</span><span class="w"> </span><span class="n">allo</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">cont</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">new_cont</span><span class="p">:</span>
<span class="w">        </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">double</span><span class="o">[</span><span class="n">n*4</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">new_sep</span><span class="p">:</span>
<span class="w">        </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">double</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">double</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">double</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">double</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">a1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">d1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">c1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">b1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>

<span class="n">void</span><span class="w"> </span><span class="n">ff</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">cont</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span><span class="err">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">new_sep</span><span class="p">:</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">c1</span><span class="p">;</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">new_cont</span><span class="p">:</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">a1</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>

<span class="k">double</span><span class="w"> </span><span class="n">plain</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">cont</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">loops</span><span class="p">)</span>
<span class="err">{</span>
<span class="n">#ifndef</span><span class="w"> </span><span class="n">preallocate_memory</span>
<span class="w">    </span><span class="n">allo</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="n">#endif</span>

<span class="n">#ifdef</span><span class="w"> </span><span class="n">TBB_TIMING</span><span class="w">   </span>
<span class="w">    </span><span class="n">tick_count</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">tick_count</span><span class="p">:</span><span class="err">:</span><span class="n">now</span><span class="p">();</span>
<span class="n">#else</span>
<span class="w">    </span><span class="n">clock_t</span><span class="w"> </span><span class="k">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">loops</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">                </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="n">#ifdef</span><span class="w"> </span><span class="n">TBB_TIMING</span><span class="w">   </span>
<span class="w">    </span><span class="n">tick_count</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">tick_count</span><span class="p">:</span><span class="err">:</span><span class="n">now</span><span class="p">();</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="k">double</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="k">double</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">).</span><span class="n">seconds</span><span class="p">();</span>
<span class="n">#else</span>
<span class="w">    </span><span class="n">clock_t</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="k">double</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="k">double</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="k">double</span><span class="p">)(</span><span class="k">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">start</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="k">double</span><span class="p">(</span><span class="n">CLOCKS_PER_SEC</span><span class="p">);</span>
<span class="n">#endif</span>

<span class="n">#ifndef</span><span class="w"> </span><span class="n">preallocate_memory</span>
<span class="w">    </span><span class="n">ff</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="err">}</span>


<span class="n">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="err">{</span><span class="w">   </span>
<span class="w">    </span><span class="n">freopen</span><span class="p">(</span><span class="ss">"C:\\test.csv"</span><span class="p">,</span><span class="w"> </span><span class="ss">"w"</span><span class="p">,</span><span class="w"> </span><span class="n">stdout</span><span class="p">);</span>

<span class="w">    </span><span class="nc">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">" "</span><span class="p">;</span>

<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">na</span><span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="err">{</span><span class="ss">"new_cont"</span><span class="p">,</span><span class="w"> </span><span class="ss">"new_sep"</span><span class="err">}</span><span class="p">;</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"n"</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="n">#ifdef</span><span class="w"> </span><span class="n">preallocate_memory</span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"_loops_"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">na</span><span class="o">[</span><span class="n">preallocate_memory</span><span class="o">]</span><span class="p">;</span>
<span class="n">#else</span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"_loops_"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">na</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">nmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span>

<span class="n">#ifdef</span><span class="w"> </span><span class="n">preallocate_memory</span>
<span class="w">    </span><span class="n">allo</span><span class="p">(</span><span class="n">preallocate_memory</span><span class="p">,</span><span class="w"> </span><span class="n">nmax</span><span class="p">);</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="n">L</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nmax</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)))</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">const</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000000</span><span class="o">/</span><span class="n">n</span><span class="p">;</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">plain</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>It shows FLOP/s for different values of <code>n</code>.</p>
<p><img alt="Performace chart" src="../../images/426bP.gif"></p>
<p><br><br></p>
<h2>Answer</h2>
<p>Upon further analysis of this, I believe this is (at least partially) caused
by the data alignment of the four-pointers. This will cause some level of
cache bank/way conflicts.</p>
<p>If I've guessed correctly on how you are allocating your arrays, they <em><strong>are
likely to be aligned to the page line</strong></em>.</p>
<p>This means that all your accesses in each loop will fall on the same cache
way. However, Intel processors have had 8-way L1 cache associativity for a
while. But in reality, the performance isn't completely uniform. Accessing
4-ways is still slower than say 2-ways.</p>
<p><strong>EDIT: It does in fact look like you are allocating all the arrays
separately.</strong> Usually when such large allocations are requested, the allocator
will request fresh pages from the OS. Therefore, there is a high chance that
large allocations will appear at the same offset from a page-boundary.</p>
<p><strong>Here's the test code:</strong></p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span>

<span class="n">#ifdef</span><span class="w"> </span><span class="n">ALLOCATE_SEPERATE</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="n">#else</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="k">double</span><span class="w"> </span><span class="o">*</span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="o">//</span><span class="w">  </span><span class="n">Zero</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">prevent</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="n">chance</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">denormals</span><span class="p">.</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeof</span><span class="p">(</span><span class="k">double</span><span class="p">));</span>

<span class="w">    </span><span class="o">//</span><span class="w">  </span><span class="k">Print</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">addresses</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">clock_t</span><span class="w"> </span><span class="k">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>

<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">++</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="err">{</span>

<span class="n">#if</span><span class="w"> </span><span class="n">ONE_LOOP</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">            </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="n">#else</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">            </span><span class="n">a1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">            </span><span class="n">c1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">d1</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="n">#endif</span>

<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="n">clock_t</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"seconds = "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="p">)(</span><span class="k">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">system</span><span class="p">(</span><span class="ss">"pause"</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<hr>
<p><strong>Benchmark Results:</strong></p>
<h2>EDIT: Results on an <em>actual</em> Core 2 architecture machine:</h2>
<p><strong>2 x Intel Xeon X5482 Harpertown @ 3.2 GHz:</strong></p>
<div class="code"><pre class="code literal-block">#define ALLOCATE_SEPERATE
#define ONE_LOOP
00600020
006D0020
007A0020
00870020
seconds = 6.206

#define ALLOCATE_SEPERATE
//#define ONE_LOOP
005E0020
006B0020
00780020
00850020
seconds = 2.116

//#define ALLOCATE_SEPERATE
#define ONE_LOOP
00570020
00633520
006F6A20
007B9F20
seconds = 1.894

//#define ALLOCATE_SEPERATE
//#define ONE_LOOP
008C0020
00983520
00A46A20
00B09F20
seconds = 1.993
</pre></div>

<p>Observations:</p>
<ul>
<li>
<p><strong>6.206 seconds</strong> with one loop and <strong>2.116 seconds</strong> with two loops. This reproduces the OP's results exactly.</p>
</li>
<li>
<p><strong>In the first two tests, the arrays are allocated separately.</strong> You'll notice that they all have the same alignment relative to the page.</p>
</li>
<li>
<p><strong>In the second two tests, the arrays are packed together to break that alignment.</strong> Here you'll notice both loops are faster. Furthermore, the second (double) loop is now the slower one as you would normally expect.</p>
</li>
</ul>
<p>As @Stephen Cannon points out in the comments, there is a very likely
possibility that this alignment causes <em><strong>false aliasing</strong></em> in the load/store
units or the cache. I Googled around for this and found that Intel actually
has a hardware counter for <em><strong>partial address aliasing</strong></em> stalls:</p>
<p>http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmw_dp/events/partial_address_alias.html</p>
<hr>
<h2>5 Regions - Explanations</h2>
<p><strong>Region 1:</strong></p>
<p>This one is easy. The dataset is so small that the performance is dominated by
overhead like looping and branching.</p>
<p><strong>Region 2:</strong></p>
<p><del>Here, as the data sizes increase, the amount of relative overhead goes down
and the performance "saturates". Here two loops is slower because it has twice
as much loop and branching overhead.</del></p>
<p>I'm not sure exactly what's going on here... Alignment could still play an
effect as Agner Fog mentions cache bank conflicts. (That link is about Sandy
Bridge, but the idea should still be applicable to Core 2.)</p>
<p><strong>Region 3:</strong></p>
<p>At this point, the data no longer fits in the L1 cache. So performance is
capped by the L1 &lt;-&gt; L2 cache bandwidth.</p>
<p><strong>Region 4:</strong></p>
<p>The performance drop in the single-loop is what we are observing. And as
mentioned, this is due to the alignment which (most likely) causes <em><strong>false
aliasing</strong></em> stalls in the processor load/store units.</p>
<p>However, in order for false aliasing to occur, there must be a large enough
stride between the datasets. This is why you don't see this in region 3.</p>
<p><strong>Region 5:</strong></p>
<p>At this point, nothing fits in the cache. So you're bound by memory bandwidth.</p>
<hr>
<p><img alt="2 x Intel X5482 Harpertown @ 3.2 GHz" src="../../images/ElCGL.png"><img alt="Intel Core i7 870
@ 2.8 GHz" src="../../images/QMpwj.png"><img alt="Intel Core i7 2600K @ 4.4
GHz" src="../../images/NpyhG.png"></p>
<p><br></p>
<h3>Suggest</h3>
<p>OK, the right answer definitely has to do something with the CPU cache. But to
use the cache argument can be quite difficult, especially without data.</p>
<p>There are many answers, that led to a lot of discussion, but let's face it:
Cache issues can be very complex and are not one dimensional. They depend
heavily on the size of the data, so my question was unfair: It turned out to
be at a very interesting point in the cache graph.</p>
<p>@Mysticial's answer convinced a lot of people (including me), probably because
it was the only one that seemed to rely on facts, but it was only one "data
point" of the truth.</p>
<p>That's why I combined his test (using a continuous vs. separate allocation)
and @James' Answer's advice.</p>
<p>The graphs below shows, that most of the answers and especially the majority
of comments to the question and answers can be considered completely wrong or
true depending on the exact scenario and parameters used.</p>
<p>Note that my initial question was at <strong>n = 100.000</strong>. This point (by accident)
exhibits special behavior:</p>
<ol>
<li>
<p>It possesses the greatest discrepancy between the one and two loop'ed version (almost a factor of three)</p>
</li>
<li>
<p>It is the only point, where one-loop (namely with continuous allocation) beats the two-loop version. (This made Mysticial's answer possible, at all.)</p>
</li>
</ol>
<p>The result using initialized data:</p>
<p><img alt="Enter image description here" src="../../images/orxF8.png"></p>
<p>The result using uninitialized data (this is what Mysticial tested):</p>
<p><img alt="Enter image description here" src="../../images/mZPh9.png"></p>
<p>And this is a hard-to-explain one: Initialized data, that is allocated once
and reused for every following test case of different vector size:</p>
<p><img alt="Enter image description here" src="../../images/aiDfv.png"></p>
<h3>Proposal</h3>
<p>Every low-level performance related question on Stack Overflow should be
required to provide MFLOPS information for the whole range of cache relevant
data sizes! It's a waste of everybody's time to think of answers and
especially discuss them with others without this information.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/compiler-optimization/" rel="tag">compiler-optimization</a></li>
            <li><a class="tag p-category" href="../../categories/performance/" rel="tag">performance</a></li>
            <li><a class="tag p-category" href="../../categories/vectorization/" rel="tag">vectorization</a></li>
            <li><a class="tag p-category" href="../../categories/x86/" rel="tag">x86</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-can-i-save-username-and-password-in-git/" rel="prev" title="How can I save username and password in Git?">Previous post</a>
            </li>
            <li class="next">
                <a href="../generate-random-number-between-two-numbers-in-javascript/" rel="next" title="Generate random number between two numbers in JavaScript">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
