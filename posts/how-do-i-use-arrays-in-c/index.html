<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How do I use arrays in C++? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-do-i-use-arrays-in-c/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-are-the-differences-between-normal-and-slim-package-of-jquery/" title="What are the differences between normal and slim package of jquery?" type="text/html">
<link rel="next" href="../jquery-if-checkbox-is-checked/" title="jQuery if checkbox is checked" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How do I use arrays in C++?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-do-i-use-arrays-in-c/">
<meta property="og:description" content="C++ inherited arrays from C where they are used virtually everywhere. C++
provides abstractions that are easier to use and less error-prone
(std::vector&lt;T&gt; since C++98 and std::array&lt;T, n&gt; since C++11">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T04:23:29+08:00">
<meta property="article:tag" content="arrays">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="c++-faq">
<meta property="article:tag" content="multidimensional-array">
<meta property="article:tag" content="pointers">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How do I use arrays in C++?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T04:23:29+08:00" itemprop="datePublished" title="2023-03-03 04:23">2023-03-03 04:23</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>C++ inherited arrays from C where they are used virtually everywhere. C++
provides abstractions that are easier to use and less error-prone
(<code>std::vector&lt;T&gt;</code> since C++98 and <code>std::array&lt;T, n&gt;</code> since C++11), so the need
for arrays does not arise quite as often as it does in C. However, when you
read legacy code or interact with a library written in C, you should have a
firm grasp on how arrays work.</p>
<p>This FAQ is split into five parts:</p>
<ol>
<li>arrays on the type level and accessing elements</li>
<li>array creation and initialization</li>
<li>assignment and parameter passing</li>
<li>multidimensional arrays and arrays of pointers</li>
<li>common pitfalls when using arrays</li>
</ol>
<p>If you feel something important is missing in this FAQ, write an answer and
link it here as an additional part.</p>
<p>In the following text, "array" means "C array", not the class template
<code>std::array</code>. Basic knowledge of the C declarator syntax is assumed. Note that
the manual usage of <code>new</code> and <code>delete</code> as demonstrated below is extremely
dangerous in the face of exceptions, but that is the topic of another FAQ.</p>
<hr>
<p><em>(Note: This is meant to be an entry to Stack Overflow's C++ FAQ. If you want
to critique the idea of providing an FAQ in this form, then the posting on
meta that started all this would be the place to do that. Answers to that
question are monitored in the C++ chatroom, where the FAQ idea started out in
the first place, so your answer is very likely to get read by those who came
up with the idea.)</em></p>
<p><br><br></p>
<h2>Answer</h2>
<h2>Arrays on the type level</h2>
<p>An array type is denoted as <code>T[n]</code> where <code>T</code> is the <em>element type</em> and <code>n</code> is
a positive <em>size</em> , the number of elements in the array. The array type is a
product type of the element type and the size. If one or both of those
ingredients differ, you get a distinct type:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="n">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kr">int</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="kr">float</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">"distinct element type"</span><span class="p">);</span>
<span class="n">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kr">int</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w">   </span><span class="kr">int</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">"distinct size"</span><span class="p">);</span>
</pre></div>

<p>Note that the size is part of the type, that is, array types of different size
are incompatible types that have absolutely nothing to do with each other.
<code>sizeof(T[n])</code> is equivalent to <code>n * sizeof(T)</code>.</p>
<h3>Array-to-pointer decay</h3>
<p>The only "connection" between <code>T[n]</code> and <code>T[m]</code> is that both types can
implicitly be <em>converted</em> to <code>T*</code>, and the result of this conversion is a
pointer to the first element of the array. That is, anywhere a <code>T*</code> is
required, you can provide a <code>T[n]</code>, and the compiler will silently provide
that pointer:</p>
<div class="code"><pre class="code literal-block">                  +---+---+---+---+---+---+---+---+
the_actual_array: |   |   |   |   |   |   |   |   |   int[8]
                  +---+---+---+---+---+---+---+---+
                    ^
                    |
                    |
                    |
                    |  pointer_to_the_first_element   int*
</pre></div>

<p>This conversion is known as "array-to-pointer decay", and it is a major source
of confusion. The size of the array is lost in this process, since it is no
longer part of the type (<code>T*</code>). Pro: Forgetting the size of an array on the
type level allows a pointer to point to the first element of an array of <em>any</em>
size. Con: Given a pointer to the first (or any other) element of an array,
there is no way to detect how large that array is or where exactly the pointer
points to relative to the bounds of the array. Pointers are extremely stupid.</p>
<h3>Arrays are not pointers</h3>
<p>The compiler will silently generate a pointer to the first element of an array
whenever it is deemed useful, that is, whenever an operation would fail on an
array but succeed on a pointer. This conversion from array to pointer is
trivial, since the resulting pointer <em>value</em> is simply the address of the
array. Note that the pointer is <em>not</em> stored as part of the array itself (or
anywhere else in memory). <strong>An array is not a pointer.</strong></p>
<div class="code"><pre class="code literal-block"><span class="nt">static_assert</span><span class="o">(!</span><span class="nt">std</span><span class="p">::</span><span class="nd">is_same</span><span class="o">&lt;</span><span class="nt">int</span><span class="cp">[</span><span class="mi">8</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">int</span><span class="o">*&gt;</span><span class="p">::</span><span class="nd">value</span><span class="o">,</span><span class="w"> </span><span class="s2">"an array is not a pointer"</span><span class="o">);</span>
</pre></div>

<p>One important context in which an array does <em>not</em> decay into a pointer to its
first element is when the <code>&amp;</code> operator is applied to it. In that case, the <code>&amp;</code>
operator yields a pointer to the <em>entire</em> array, not just a pointer to its
first element. Although in that case the <em>values</em> (the addresses) are the
same, a pointer to the first element of an array and a pointer to the entire
array are completely distinct types:</p>
<div class="code"><pre class="code literal-block"><span class="nt">static_assert</span><span class="o">(!</span><span class="nt">std</span><span class="p">::</span><span class="nd">is_same</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">*,</span><span class="w"> </span><span class="nt">int</span><span class="o">(*)</span><span class="cp">[</span><span class="mi">8</span><span class="cp">]</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">value</span><span class="o">,</span><span class="w"> </span><span class="s2">"distinct element type"</span><span class="o">);</span>
</pre></div>

<p>The following ASCII art explains this distinction:</p>
<div class="code"><pre class="code literal-block"><span class="c">      </span><span class="nb">+-----------------------------------+</span>
<span class="c">      | </span><span class="nb">+---+---+---+---+---+---+---+---+</span><span class="c"> |</span>
<span class="nb">+---</span><span class="nv">&gt;</span><span class="c"> | |   |   |   |   |   |   |   |   | | int</span><span class="k">[</span><span class="c">8</span><span class="k">]</span>
<span class="c">|     | </span><span class="nb">+---+---+---+---+---+---+---+---+</span><span class="c"> |</span>
<span class="c">|     </span><span class="nb">+---</span><span class="c">^</span><span class="nb">-------------------------------+</span>
<span class="c">|         |</span>
<span class="c">|         |</span>
<span class="c">|         |</span>
<span class="c">|         |  pointer_to_the_first_element   int*</span>
<span class="c">|</span>
<span class="c">|  pointer_to_the_entire_array              int(*)</span><span class="k">[</span><span class="c">8</span><span class="k">]</span>
</pre></div>

<p>Note how the pointer to the first element only points to a single integer
(depicted as a small box), whereas the pointer to the entire array points to
an array of 8 integers (depicted as a large box).</p>
<p>The same situation arises in classes and is maybe more obvious. A pointer to
an object and a pointer to its first data member have the same <em>value</em> (the
same address), yet they are completely distinct types.</p>
<p>If you are unfamiliar with the C declarator syntax, the parenthesis in the
type <code>int(*)[8]</code> are essential:</p>
<ul>
<li>
<code>int(*)[8]</code> is a pointer to an array of 8 integers.</li>
<li>
<code>int*[8]</code> is an array of 8 pointers, each element of type <code>int*</code>.</li>
</ul>
<h2>Accessing elements</h2>
<p>C++ provides two syntactic variations to access individual elements of an
array. Neither of them is superior to the other, and you should familiarize
yourself with both.</p>
<h3>Pointer arithmetic</h3>
<p>Given a pointer <code>p</code> to the first element of an array, the expression <code>p+i</code>
yields a pointer to the i-th element of the array. By dereferencing that
pointer afterwards, one can access individual elements:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*(</span><span class="nt">x</span><span class="o">+</span><span class="nt">3</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*(</span><span class="nt">x</span><span class="o">+</span><span class="nt">7</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">endl</span><span class="o">;</span>
</pre></div>

<p>If <code>x</code> denotes an <em>array</em> , then array-to-pointer decay will kick in, because
adding an array and an integer is meaningless (there is no plus operation on
arrays), but adding a pointer and an integer makes sense:</p>
<div class="code"><pre class="code literal-block">   +---+---+---+---+---+---+---+---+
x: |   |   |   |   |   |   |   |   |   int[8]
   +---+---+---+---+---+---+---+---+
     ^           ^               ^
     |           |               |
     |           |               |
     |           |               |
x+0  |      x+3  |          x+7  |     int*
</pre></div>

<p>(Note that the implicitly generated pointer has no name, so I wrote <code>x+0</code> in
order to identify it.)</p>
<p>If, on the other hand, <code>x</code> denotes a <em>pointer</em> to the first (or any other)
element of an array, then array-to-pointer decay is not necessary, because the
pointer on which <code>i</code> is going to be added already exists:</p>
<div class="code"><pre class="code literal-block">   +---+---+---+---+---+---+---+---+
   |   |   |   |   |   |   |   |   |   int[8]
   +---+---+---+---+---+---+---+---+
     ^           ^               ^
     |           |               |
     |           |               |
   +-|-+         |               |
x: | | |    x+3  |          x+7  |     int*
   +---+
</pre></div>

<p>Note that in the depicted case, <code>x</code> is a pointer <em>variable</em> (discernible by
the small box next to <code>x</code>), but it could just as well be the result of a
function returning a pointer (or any other expression of type <code>T*</code>).</p>
<h3>Indexing operator</h3>
<p>Since the syntax <code>*(x+i)</code> is a bit clumsy, C++ provides the alternative syntax
<code>x[i]</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nt">x</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nt">x</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">endl</span><span class="o">;</span>
</pre></div>

<p>Due to the fact that addition is commutative, the following code does exactly
the same:</p>
<div class="code"><pre class="code literal-block"><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">", "</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>The definition of the indexing operator leads to the following interesting
equivalence:</p>
<div class="code"><pre class="code literal-block"><span class="o">&amp;</span><span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w">  </span><span class="o">==</span><span class="w">  </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w">  </span><span class="n">x</span><span class="o">+</span><span class="n">i</span>
</pre></div>

<p>However, <code>&amp;x[0]</code> is generally <em>not</em> equivalent to <code>x</code>. The former is a
pointer, the latter an array. Only when the context triggers array-to-pointer
decay can <code>x</code> and <code>&amp;x[0]</code> be used interchangeably. For example:</p>
<div class="code"><pre class="code literal-block"><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mh">0</span><span class="p">];</span><span class="w">  </span><span class="c1">// rewritten as &amp;*(array+0), decay happens due to the addition</span>
<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">      </span><span class="c1">// decay happens due to the assignment</span>
</pre></div>

<p>On the first line, the compiler detects an assignment from a pointer to a
pointer, which trivially succeeds. On the second line, it detects an
assignment from an <em>array</em> to a pointer. Since this is meaningless (but
<em>pointer</em> to pointer assignment makes sense), array-to-pointer decay kicks in
as usual.</p>
<h3>Ranges</h3>
<p>An array of type <code>T[n]</code> has <code>n</code> elements, indexed from <code>0</code> to <code>n-1</code>; there is
no element <code>n</code>. And yet, to support half-open ranges (where the beginning is
<em>inclusive</em> and the end is <em>exclusive</em> ), C++ allows the computation of a
pointer to the (non-existent) n-th element, but it is illegal to dereference
that pointer:</p>
<div class="code"><pre class="code literal-block">   +---+---+---+---+---+---+---+---+....
x: |   |   |   |   |   |   |   |   |   .   int[8]
   +---+---+---+---+---+---+---+---+....
     ^                               ^
     |                               |
     |                               |
     |                               |
x+0  |                          x+8  |     int*
</pre></div>

<p>For example, if you want to sort an array, both of the following would work
equally well:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">sort</span><span class="o">(</span><span class="nt">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">0</span><span class="o">,</span><span class="w"> </span><span class="nt">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">n</span><span class="o">);</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">sort</span><span class="o">(&amp;</span><span class="nt">x</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">x</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">n</span><span class="o">);</span>
</pre></div>

<p>Note that it is illegal to provide <code>&amp;x[n]</code> as the second argument since this
is equivalent to <code>&amp;*(x+n)</code>, and the sub-expression <code>*(x+n)</code> technically
invokes undefined behavior in C++ (but not in C99).</p>
<p>Also note that you could simply provide <code>x</code> as the first argument. That is a
little too terse for my taste, and it also makes template argument deduction a
bit harder for the compiler, because in that case the first argument is an
array but the second argument is a pointer. (Again, array-to-pointer decay
kicks in.)</p>
<p><br></p>
<h3>Suggest</h3>
<p>Programmers often confuse multidimensional arrays with arrays of pointers.</p>
<h2>Multidimensional arrays</h2>
<p>Most programmers are familiar with named multidimensional arrays, but many are
unaware of the fact that multidimensional array can also be created
anonymously. Multidimensional arrays are often referred to as "arrays of
arrays" or " <em>true</em> multidimensional arrays".</p>
<h3>Named multidimensional arrays</h3>
<p>When using named multidimensional arrays, <em>all</em> dimensions must be known at
compile time:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_int</span><span class="p">();</span>
<span class="nc">int</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_int</span><span class="p">();</span>

<span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">okay</span>

<span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">H</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">ISO</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">forbids</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">array</span>
<span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">W</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">ISO</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">forbids</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">array</span>
<span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">H</span><span class="o">][</span><span class="n">W</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">ISO</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">forbids</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">array</span>
</pre></div>

<p>This is how a named multidimensional array looks like in memory:</p>
<div class="code"><pre class="code literal-block"><span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">connect_four: |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">              |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">              |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">              |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">              |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">              |   |   |   |   |   |   |   |</span>
<span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
</pre></div>

<p>Note that 2D grids such as the above are merely helpful visualizations. From
the point of view of C++, memory is a "flat" sequence of bytes. The elements
of a multidimensional array are stored in row-major order. That is,
<code>connect_four[0][6]</code> and <code>connect_four[1][0]</code> are neighbors in memory. In
fact, <code>connect_four[0][7]</code> and <code>connect_four[1][0]</code> denote the same element!
This means that you can take multi-dimensional arrays and treat them as large,
one-dimensional arrays:</p>
<div class="code"><pre class="code literal-block">int* p = &amp;connect_four[0][0];
int* q = p + 42;
some_int_sequence_algorithm(p, q);
</pre></div>

<h3>Anonymous multidimensional arrays</h3>
<p>With anonymous multidimensional arrays, all dimensions <em>except the first</em> must
be known at compile time:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">[</span><span class="n">7</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">okay</span>
<span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">[</span><span class="n">7</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">H</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">okay</span>

<span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">[</span><span class="n">W</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">W</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">ISO</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">forbids</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">array</span>
<span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">[</span><span class="n">W</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">H</span><span class="o">][</span><span class="n">W</span><span class="o">]</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">ISO</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">forbids</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">array</span>
</pre></div>

<p>This is how an anonymous multidimensional array looks like in memory:</p>
<div class="code"><pre class="code literal-block"><span class="c">              </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        </span><span class="nb">+---</span><span class="nv">&gt;</span><span class="c"> |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |     |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |     |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |     |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |     |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |     |   |   |   |   |   |   |   |</span>
<span class="c">        |     </span><span class="nb">+---+---+---+---+---+---+---+</span>
<span class="c">        |</span>
<span class="c">      </span><span class="nb">+-</span><span class="c">|</span><span class="nb">-+</span>
<span class="c">   p: | | |</span>
<span class="c">      </span><span class="nb">+---+</span>
</pre></div>

<p>Note that the array itself is still allocated as a single block in memory.</p>
<h2>Arrays of pointers</h2>
<p>You can overcome the restriction of fixed width by introducing another level
of indirection.</p>
<h3>Named arrays of pointers</h3>
<p>Here is a named array of five pointers which are initialized with anonymous
arrays of different lengths:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="o">*</span><span class="w"> </span><span class="n">triangle</span><span class="o">[</span><span class="n">5</span><span class="o">]</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">5 - i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>

<span class="o">//</span><span class="w"> </span><span class="p">...</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>And here is how it looks like in memory:</p>
<div class="code"><pre class="code literal-block">          +---+---+---+---+---+
          |   |   |   |   |   |
          +---+---+---+---+---+
            ^
            | +---+---+---+---+
            | |   |   |   |   |
            | +---+---+---+---+
            |   ^
            |   | +---+---+---+
            |   | |   |   |   |
            |   | +---+---+---+
            |   |   ^
            |   |   | +---+---+
            |   |   | |   |   |
            |   |   | +---+---+
            |   |   |   ^
            |   |   |   | +---+
            |   |   |   | |   |
            |   |   |   | +---+
            |   |   |   |   ^
            |   |   |   |   |
            |   |   |   |   |
          +-|-+-|-+-|-+-|-+-|-+
triangle: | | | | | | | | | | |
          +---+---+---+---+---+
</pre></div>

<p>Since each line is allocated individually now, viewing 2D arrays as 1D arrays
does not work anymore.</p>
<h3>Anonymous arrays of pointers</h3>
<p>Here is an anonymous array of 5 (or any other number of) pointers which are
initialized with anonymous arrays of different lengths:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_five</span><span class="p">();</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">number</span>
<span class="nc">int</span><span class="o">**</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">*[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">n - i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>

<span class="o">//</span><span class="w"> </span><span class="p">...</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
<span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">extra</span><span class="w"> </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="err">!</span>
</pre></div>

<p>And here is how it looks like in memory:</p>
<div class="code"><pre class="code literal-block">          +---+---+---+---+---+
          |   |   |   |   |   |
          +---+---+---+---+---+
            ^
            | +---+---+---+---+
            | |   |   |   |   |
            | +---+---+---+---+
            |   ^
            |   | +---+---+---+
            |   | |   |   |   |
            |   | +---+---+---+
            |   |   ^
            |   |   | +---+---+
            |   |   | |   |   |
            |   |   | +---+---+
            |   |   |   ^
            |   |   |   | +---+
            |   |   |   | |   |
            |   |   |   | +---+
            |   |   |   |   ^
            |   |   |   |   |
            |   |   |   |   |
          +-|-+-|-+-|-+-|-+-|-+
          | | | | | | | | | | |
          +---+---+---+---+---+
            ^
            |
            |
          +-|-+
       p: | | |
          +---+
</pre></div>

<h2>Conversions</h2>
<p>Array-to-pointer decay naturally extends to arrays of arrays and arrays of
pointers:</p>
<div class="code"><pre class="code literal-block">int array_of_arrays[6][7];
int (*pointer_to_array)[7] = array_of_arrays;

int* array_of_pointers[6];
int** pointer_to_pointer = array_of_pointers;
</pre></div>

<p>However, there is no implicit conversion from <code>T[h][w]</code> to <code>T**</code>. If such an
implicit conversion did exist, the result would be a pointer to the first
element of an array of <code>h</code> pointers to <code>T</code> (each pointing to the first element
of a line in the original 2D array), but that pointer array does not exist
anywhere in memory yet. If you want such a conversion, you must create and
fill the required pointer array manually:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span>

<span class="nc">int</span><span class="o">**</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">*[</span><span class="n">6</span><span class="o">]</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>

<span class="o">//</span><span class="w"> </span><span class="p">...</span>

<span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</pre></div>

<p>Note that this generates a view of the original multidimensional array. If you
need a copy instead, you must create extra arrays and copy the data yourself:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">7</span><span class="o">]</span><span class="p">;</span>

<span class="nc">int</span><span class="o">**</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">*[</span><span class="n">6</span><span class="o">]</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">7</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span><span class="p">(</span><span class="n">connect_four</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">connect_four</span><span class="o">[</span><span class="n">i + 1</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="err">}</span>

<span class="o">//</span><span class="w"> </span><span class="p">...</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
<span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/arrays/" rel="tag">arrays</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B-faq/" rel="tag">c++-faq</a></li>
            <li><a class="tag p-category" href="../../categories/multidimensional-array/" rel="tag">multidimensional-array</a></li>
            <li><a class="tag p-category" href="../../categories/pointers/" rel="tag">pointers</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-are-the-differences-between-normal-and-slim-package-of-jquery/" rel="prev" title="What are the differences between normal and slim package of jquery?">Previous post</a>
            </li>
            <li class="next">
                <a href="../jquery-if-checkbox-is-checked/" rel="next" title="jQuery if checkbox is checked">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
