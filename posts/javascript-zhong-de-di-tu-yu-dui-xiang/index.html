<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript 中的地图与对象 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/javascript-zhong-de-di-tu-yu-dui-xiang/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../shi-yong-python-die-dai-zi-fu-chuan-zhong-de-mei-ge-zi-fu/" title="使用 Python 迭代字符串中的每个字符" type="text/html">
<link rel="next" href="../shi-yao-suan-fa-ji-suan-di-tu-shang-cong-a-dian-dao-b-dian-de-fang-xiang/" title="什么算法计算地图上从 A 点到 B 点的方向？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="JavaScript 中的地图与对象">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/javascript-zhong-de-di-tu-yu-dui-xiang/">
<meta property="og:description" content="我刚刚发现了这个功能：

地图：地图对象是简单的键/值映射。

这让我很困惑。Map常规 JavaScript 对象是字典，那么a 与字典有何不同？从概念上讲，它们是相同的（根据Stack Overflow
上的另一个问题）
该文档也无济于事：

Map 对象是键/值对的集合，其中键和值都可以是任意 ECMAScript 语言值。不同的键值只能出现在 Map
集合中的一个键/值对中。使用创建地图时">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T03:56:05+08:00">
<meta property="article:tag" content="dictionary">
<meta property="article:tag" content="ecmascript-6">
<meta property="article:tag" content="javascript">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">JavaScript 中的地图与对象</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:56:05+08:00" itemprop="datePublished" title="2023-02-18 03:56">2023-02-18 03:56</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我刚刚发现了这个功能：</p>
<blockquote>
<p>地图：地图对象是简单的键/值映射。</p>
</blockquote>
<p>这让我很困惑。<code>Map</code>常规 JavaScript 对象是字典，那么a 与字典有何不同？从概念上讲，它们是相同的（根据Stack Overflow
上的另一个问题）</p>
<p>该文档也无济于事：</p>
<blockquote>
<p>Map 对象是键/值对的集合，其中键和值都可以是任意 ECMAScript 语言值。不同的键值只能出现在 Map
集合中的一个键/值对中。使用创建地图时选择的比较算法区分的不同键值。</p>
<p>Map 对象可以按插入顺序迭代其元素。Map 对象必须使用哈希表或其他机制来实现，平均而言，这些机制提供的访问时间与集合中的元素数量呈次线性关系。本
Map 对象规范中使用的数据结构仅用于描述 Map 对象所需的可观察语义。它不是一个可行的实施模型。</p>
</blockquote>
<p>......对我来说仍然听起来像一个对象，所以很明显我错过了一些东西。</p>
<p>为什么 JavaScript 获得了一个（得到良好支持的）<code>Map</code>对象？它有什么作用？</p>
<p><br><br></p>
<h2>解答</h2>
<p>根据 MDN：</p>
<blockquote>
<p>Map 对象可以按插入顺序迭代其元素 - 循环<code>for..of</code>将为每次迭代返回一个 [key, value] 数组。</p>
</blockquote>
<p>和</p>
<blockquote>
<p>对象与映射的相似之处在于，两者都允许您将键设置为值、检索这些值、删除键以及检测键中是否存储了某些内容。正因为如此，对象在历史上一直被用作地图；但是，对象和地图之间存在重要差异，这使得使用地图更好。</p>
<p>一个对象有一个原型，所以映射中有默认键。但是，这可以使用 map = Object.create(null)
绕过。对象的键是字符串，它们可以是映射的任何值。您可以轻松获得地图的大小，而您必须手动跟踪对象的大小。</p>
</blockquote>
<p><em>地图</em></p>
<p>顺序迭代是开发人员长期以来一直想要的功能，部分原因是它确保在所有浏览器中具有相同的性能。所以对我来说这是一个很大的问题。</p>
<p>该<code>myMap.has(key)</code>方法和属性将特别方便<code>myMap.size</code>。</p>
<p><br></p>
<h3>更多建议</h3>
<p>关键区别在于对象仅支持字符串和符号键，而地图或多或少支持任何键类型。</p>
<p>如果我<code>obj[123] = true</code>这样做然后<code>Object.keys(obj)</code>我会得到<code>["123"]</code>而不是<code>[123]</code>。Map
会保留键的类型并返回，<code>[123]</code>这很好。地图还允许您使用对象作为键。传统上，要执行此操作，您必须为对象提供某种唯一标识符以对它们进行哈希处理（我认为我从未<code>getObjectId</code>在
JavaScript 中看到过类似的东西作为标准的一部分）。地图还保证了秩序的保存，因此更利于保存，有时可以节省您做一些分类的时间。</p>
<p>在实践中，地图和对象之间有几个优点和缺点。对象既有优点也有缺点，它们被非常紧密地集成到 JavaScript 的核心中，这使它们与 Map
的区别显着超出了关键支持的差异。</p>
<p>一个直接的优势是您拥有对对象的语法支持，可以轻松访问元素。您还可以使用 JSON
直接支持它。当用作散列时，得到一个根本没有任何属性的对象是很烦人的。默认情况下，如果您想将对象用作哈希表，它们将被污染，并且您经常需要<code>hasOwnProperty</code>在访问属性时调用它们。您可以在这里看到默认情况下对象是如何被污染的，以及如何创建希望未被污染的对象以用作散列：</p>
<div class="code"><pre class="code literal-block"><span class="p">({}).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">native</span><span class="w"> </span><span class="n">code</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
<span class="n">JSON</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="err">'</span><span class="p">{}</span><span class="err">'</span><span class="p">).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">native</span><span class="w"> </span><span class="n">code</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
<span class="p">(</span><span class="n">Object</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">null</span><span class="p">)).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">undefined</span>
<span class="n">JSON</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="err">'</span><span class="p">{}</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">typeof</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="err">'</span><span class="n">object</span><span class="err">'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Object</span><span class="p">.</span><span class="n">setPrototypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="p">,</span><span class="n">v</span><span class="p">)).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">undefined</span>
</pre></div>

<p>对象上的污染不仅会使代码更烦人、更慢等，而且还会对安全性产生潜在影响。</p>
<p>对象不是纯粹的哈希表，但它们正在尝试做更多的事情。你有头痛之类的问题<code>hasOwnProperty</code>，无法轻松获得长度 (
<code>Object.keys(obj).length</code>) 等。对象并不意味着纯粹用作哈希映射，而是用作动态可扩展对象，因此当您将它们用作纯哈希表时会出现问题。</p>
<p>各种常用操作的比较/列表：</p>
<div class="code"><pre class="code literal-block"><span class="k">Object</span><span class="err">:</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="p">;</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="k">create</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="w">   </span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">   </span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="n">o</span><span class="o">[</span><span class="n">k</span><span class="o">]++</span><span class="p">;</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="k">values</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="s1">'key'</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">o</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="s1">'key'</span><span class="p">));</span>
<span class="w">   </span><span class="k">delete</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="p">);</span>
<span class="w">   </span><span class="k">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">o</span><span class="p">).</span><span class="n">length</span>
<span class="k">Map</span><span class="err">:</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">Map</span><span class="p">();</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s1">'key'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="n">foreach</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">values</span><span class="p">())</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">has</span><span class="p">(</span><span class="s1">'key'</span><span class="p">));</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">'key'</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">size</span><span class="p">();</span>
</pre></div>

<p>还有一些其他的选项、方法、方法等有不同的起伏（性能、简洁、可移植、可扩展等）。对象作为语言的核心有点奇怪，所以你有很多静态方法来处理它们。</p>
<p>除了 Maps 保留键类型的优势以及能够支持对象作为键之类的东西之外，它们还与对象所具有的副作用隔离开来。一个 Map
是一个纯粹的散列，没有关于试图同时成为一个对象的混淆。还可以使用代理功能轻松扩展地图。Object 目前有一个 Proxy
类，但是性能和内存使用情况很糟糕，实际上创建你自己的代理看起来像 Map for Objects 目前比 Proxy 执行得更好。</p>
<p>地图的一个重大缺点是它们不直接支持 JSON。解析是可能的，但它有几个问题：</p>
<div class="code"><pre class="code literal-block"><span class="n">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nf">str</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="s1">'object'</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">Map</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="err">}</span><span class="p">);</span>
</pre></div>

<p>以上将引入严重的性能损失，并且也不支持任何字符串键。JSON 编码更加困难和有问题（这是许多方法之一）：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// An alternative to this it to use a replacer in JSON.stringify.</span>
<span class="n">Map</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">toJSON</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">JSON</span><span class="p">.</span><span class="n">stringify</span><span class="p">({</span>
<span class="w">        </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="n">Array</span><span class="p">.</span><span class="n">from</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">keys</span><span class="p">()),</span>
<span class="w">        </span><span class="n">values</span><span class="p">:</span><span class="w"> </span><span class="n">Array</span><span class="p">.</span><span class="n">from</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">};</span>
</pre></div>

<p>如果你纯粹使用地图，这还不错，但是当你混合类型或使用非标量值作为键时它会遇到问题（并不是说 JSON 是完美的那种问题，IE 循环对象引用).
我没有测试过它，但与 stringify 相比，它很可能会严重损害性能。</p>
<p>其他脚本语言通常没有这样的问题，因为它们具有 Map、Object 和 Array 的显式非标量类型。对于非标量类型，Web
开发通常是一种痛苦，在这种情况下，您必须处理诸如 PHP 使用 A/M 将 Array/Map 与 Object 合并以获取属性以及 JavaScript
将 Map/Object 与 Array 合并扩展 M/O 之类的事情。合并复杂类型是高级脚本语言的魔鬼克星。</p>
<p>到目前为止，这些主要是关于实施的问题，但基本操作的性能也很重要。性能也很复杂，因为它取决于引擎和使用情况。对我的测试持保留态度，因为我不能排除任何错误（我必须赶时间）。您还应该运行自己的测试以确认我的测试仅检查非常具体的简单场景以仅提供粗略指示。根据
Chrome 中针对非常大的对象/地图的测试，对象的性能更差，因为删除显然与键的数量成正比，而不是 O(1)：</p>
<div class="code"><pre class="code literal-block">Object Set Took: 146
Object Update Took: 7
Object Get Took: 4
Object Delete Took: 8239
Map Set Took: 80
Map Update Took: 51
Map Get Took: 40
Map Delete Took: 2
</pre></div>

<p>Chrome
显然在获取和更新方面有很强的优势，但删除性能非常糟糕。在这种情况下，地图使用的内存稍微多一点（开销），但是只有一个对象/地图使用数百万个键进行测试，地图开销的影响没有很好地表达出来。如果我正确阅读配置文件，内存管理对象似乎也会更早释放，这可能是有利于对象的一个​​好处。</p>
<p>在 Firefox 中，这个特定的基准测试是另一回事：</p>
<div class="code"><pre class="code literal-block">Object Set Took: 435
Object Update Took: 126
Object Get Took: 50
Object Delete Took: 2
Map Set Took: 63
Map Update Took: 59
Map Get Took: 33
Map Delete Took: 1
</pre></div>

<p>我应该立即指出，在这个特定的基准测试中，从 Firefox 中删除对象不会导致任何问题，但是在其他基准测试中它会导致问题，尤其是当有很多键时，就像在
Chrome 中一样。对于大型集合，地图在 Firefox 中显然更胜一筹。</p>
<p>然而，这并不是故事的结局，许多小物体或地图呢？我已经对此做了一个快速基准测试，但不是一个详尽的基准测试（设置/获取），其中在上述操作中使用少量键表现最佳。这个测试更多的是关于内存和初始化。</p>
<div class="code"><pre class="code literal-block">Map Create: 69    // new Map
Object Create: 34 // {}
</pre></div>

<p>同样，这些数字各不相同，但基本上 Object 有很好的领先优势。在某些情况下，Objects 相对于 maps 的领先优势是极端的（大约好 10
倍），但平均而言大约要好 2-3 倍。极端的性能峰值似乎可以双向发挥作用。我只在 Chrome
和创建中对此进行了测试，以分析内存使用情况和开销。我很惊讶地看到，在 Chrome 中，一键地图使用的内存似乎比一键对象多 30 倍。</p>
<p>用于使用上述所有操作（4 个键）测试许多小对象：</p>
<div class="code"><pre class="code literal-block">Chrome Object Took: 61
Chrome Map Took: 67
Firefox Object Took: 54
Firefox Map Took: 139
</pre></div>

<p>在内存分配方面，它们在释放/ GC方面表现相同，但 Map
使用的内存是其五倍。这个测试使用了四个键，而在上一个测试中我只设置了一个键，所以这可以解释内存开销的减少。我跑了几次这个测试，就整体速度而言，地图/对象对于
Chrome 来说或多或少是并驾齐驱的。在 Firefox for small Objects 中，总体上与地图相比具有明显的性能优势。</p>
<p>这当然不包括可能变化很大的个别选项。我不建议对这些数字进行微优化。您可以从中得到的是，根据经验，对于非常大的键值存储更强烈地考虑映射，对于小型键值存储更强烈地考虑对象。</p>
<p>除此之外，这两个的最佳策略是实施它并使其首先起作用。在进行性能分析时，请务必记住，有时您在查看它们时认为不会很慢的事情可能会非常慢，因为在对象键删除情况下会出现引擎怪癖。</p>
<p><br><br><a href="../map-vs-object-in-javascript/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dictionary/" rel="tag">dictionary</a></li>
            <li><a class="tag p-category" href="../../categories/ecmascript-6/" rel="tag">ecmascript-6</a></li>
            <li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../shi-yong-python-die-dai-zi-fu-chuan-zhong-de-mei-ge-zi-fu/" rel="prev" title="使用 Python 迭代字符串中的每个字符">Previous post</a>
            </li>
            <li class="next">
                <a href="../shi-yao-suan-fa-ji-suan-di-tu-shang-cong-a-dian-dao-b-dian-de-fang-xiang/" rel="next" title="什么算法计算地图上从 A 点到 B 点的方向？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
