<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Does functional programming replace GoF design patterns? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/does-functional-programming-replace-gof-design-patterns/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../grouping-functions-tapply-by-aggregate-and-the-apply-family/" title="Grouping functions (tapply, by, aggregate) and the *apply family" type="text/html">
<link rel="next" href="../how-can-i-navigate-back-to-the-last-cursor-position-in-visual-studio-code/" title="How can I navigate back to the last cursor position in Visual Studio Code?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Does functional programming replace GoF design patterns?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/does-functional-programming-replace-gof-design-patterns/">
<meta property="og:description" content="Since I started learning F# and OCaml last year, I've read a huge number of
articles which insist that design patterns (especially in Java) are
workarounds for the missing features in imperative langu">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:24:27+08:00">
<meta property="article:tag" content="design-patterns">
<meta property="article:tag" content="functional-programming">
<meta property="article:tag" content="oop">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Does functional programming replace GoF design patterns?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:24:27+08:00" itemprop="datePublished" title="2023-02-17 05:24">2023-02-17 05:24</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Since I started learning F# and OCaml last year, I've read a huge number of
articles which insist that design patterns (especially in Java) are
workarounds for the missing features in imperative languages. One article I
found makes a fairly strong claim:</p>
<blockquote>
<p>Most people I've met have read the Design Patterns book by the Gang of Four
(GoF). Any self respecting programmer will tell you that the book is
language agnostic and the patterns apply to software engineering in general,
regardless of which language you use. This is a noble claim. Unfortunately
it is far removed from the truth.</p>
<p>Functional languages are extremely expressive. <strong>In a functional language
one does not need design patterns because the language is likely so high
level, you end up programming in concepts that eliminate design patterns all
together.</strong></p>
</blockquote>
<p>The main features of functional programming (FP) include functions as first-
class values, currying, immutable values, etc. It doesn't seem obvious to me
that OO design patterns are approximating any of those features.</p>
<p>Additionally, in functional languages which support OOP (such as F# and
OCaml), it seems obvious to me that programmers using these languages would
use the same design patterns found available to every other OOP language. In
fact, right now I use F# and OCaml every day, and there are no striking
differences between the patterns I use in these languages vs. the patterns I
use when I write in Java.</p>
<p>Is there any truth to the claim that functional programming eliminates the
need for OOP design patterns? If so, could you post or link to an example of a
typical OOP design pattern and its functional equivalent?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The blog post you quoted overstates its claim a bit. FP doesn't <em>eliminate</em>
the need for design patterns. The term "design patterns" just isn't widely
used to describe the same thing in FP languages. But they exist. Functional
languages have plenty of best practice rules of the form "when you encounter
problem X, use code that looks like Y", which is basically what a design
pattern is.</p>
<p>However, it's correct that most OOP-specific design patterns are pretty much
irrelevant in functional languages.</p>
<p>I don't think it should be particularly controversial to say that design
patterns <em>in general</em> only exist to patch up shortcomings in the language. And
if another language can solve the same problem trivially, that other language
won't have need of a design pattern for it. Users of that language may not
even be aware that the problem <em>exists</em> , because, well, it's not a problem in
that language.</p>
<p>Here is what the Gang of Four has to say about this issue:</p>
<blockquote>
<p>The choice of programming language is important because it influences one's
point of view. Our patterns assume Smalltalk/C++-level language features,
and that choice determines what can and cannot be implemented easily. If we
assumed procedural languages, we might have included design patterns called
"Inheritance", "Encapsulation," and "Polymorphism". Similarly, some of our
patterns are supported directly by the less common object-oriented
languages. CLOS has multi-methods, for example, which lessen the need for a
pattern such as Visitor. In fact, there are enough differences between
Smalltalk and C++ to mean that some patterns can be expressed more easily in
one language than the other. (See Iterator for example.)</p>
</blockquote>
<p>(The above is a quote from the Introduction to the Design Patterns book, page
4, paragraph 3)</p>
<blockquote>
<p>The main features of functional programming include functions as first-class
values, currying, immutable values, etc. It doesn't seem obvious to me that
OO design patterns are approximating any of those features.</p>
</blockquote>
<p>What is the command pattern, if not an approximation of first-class functions?
:) In an FP language, you'd simply pass a function as the argument to another
function. In an OOP language, you have to wrap up the function in a class,
which you can instantiate and then pass that object to the other function. The
effect is the same, but in OOP it's called a design pattern, and it takes a
whole lot more code. And what is the abstract factory pattern, if not
currying? Pass parameters to a function a bit at a time, to configure what
kind of value it spits out when you finally call it.</p>
<p>So yes, several GoF design patterns are rendered redundant in FP languages,
because more powerful and easier to use alternatives exist.</p>
<p>But of course there are still design patterns which are <em>not</em> solved by FP
languages. What is the FP equivalent of a singleton? (Disregarding for a
moment that singletons are generally a terrible pattern to use.)</p>
<p>And it works both ways too. As I said, FP has its design patterns too; people
just don't usually think of them as such.</p>
<p>But you may have run across monads. What are they, if not a design pattern for
"dealing with global state"? That's a problem that's so simple in OOP
languages that no equivalent design pattern exists there.</p>
<p>We don't need a design pattern for "increment a static variable", or "read
from that socket", because it's just what you <em>do</em>.</p>
<p>Saying a monad is a design pattern is as absurd as saying the Integers with
their usual operations and zero element is a design pattern. No, a monad is a
<strong>mathematical pattern</strong> , not a design pattern.</p>
<p>In (pure) functional languages, side effects and mutable state are impossible,
unless you work around it with the monad "design pattern", or any of the other
methods for allowing the same thing.</p>
<blockquote>
<p>Additionally, in functional languages which support OOP (such as F# and
OCaml), it seems obvious to me that programmers using these languages would
use the same design patterns found available to every other OOP language. In
fact, right now I use F# and OCaml everyday, and there are no striking
differences between the patterns I use in these languages vs the patterns I
use when I write in Java.</p>
</blockquote>
<p>Perhaps because you're still thinking imperatively? A lot of people, after
dealing with imperative languages all their lives, have a hard time giving up
on that habit when they try a functional language. (I've seen some pretty
funny attempts at F#, where literally <em>every</em> function was just a string of
'let' statements, basically as if you'd taken a C program, and replaced all
semicolons with 'let'. :))</p>
<p>But another possibility might be that you just haven't realized that you're
solving problems trivially which would require design patterns in an OOP
language.</p>
<p>When you use currying, or pass a function as an argument to another, stop and
think about how you'd do that in an OOP language.</p>
<blockquote>
<p>Is there any truth to the claim that functional programming eliminates the
need for OOP design patterns?</p>
</blockquote>
<p>Yep. :) When you work in a FP language, you no longer need the OOP-specific
design patterns. But you still need some general design patterns, like MVC or
other non-OOP specific stuff, and you need a couple of new FP-specific "design
patterns" instead. All languages have their shortcomings, and design patterns
are usually how we work around them.</p>
<p>Anyway, you may find it interesting to try your hand at "cleaner" FP
languages, like ML (my personal favorite, at least for learning purposes), or
Haskell, where you don't have the OOP crutch to fall back on when you're faced
with something new.</p>
<hr>
<p>As expected, a few people objected to my definition of design patterns as
"patching up shortcomings in a language", so here's my justification:</p>
<p>As already said, most design patterns are specific to one programming
paradigm, or sometimes even one specific language. Often, they solve problems
that only <em>exist</em> in that paradigm (see monads for FP, or abstract factories
for OOP).</p>
<p>Why doesn't the abstract factory pattern exist in FP? Because the problem it
tries to solve does not exist there.</p>
<p>So, if a problem exists in OOP languages, which does not exist in FP
languages, then clearly that is a shortcoming of OOP languages. The problem
can be solved, but your language does not do so, but requires a bunch of
boilerplate code from you to work around it. Ideally, we'd like our
programming language to magically make <em>all</em> problems go away. Any problem
that is still there is in principle a shortcoming of the language. ;)</p>
<p><br></p>
<h3>Suggest</h3>
<blockquote>
<p>Is there any truth to the claim that functional programming eliminates the
need for OOP design patterns?</p>
</blockquote>
<p>Functional programming is not the same as object-oriented programming. Object-
oriented design patterns don't apply to functional programming. Instead, you
have functional programming design patterns.</p>
<p>For functional programming, you won't read the OO design pattern books; you'll
read other books on FP design patterns.</p>
<blockquote>
<p>language agnostic</p>
</blockquote>
<p>Not totally. Only language-agnostic with respect to OO languages. The design
patterns don't apply to procedural languages at all. They barely make sense in
a relational database design context. They don't apply when designing a
spreadsheet.</p>
<blockquote>
<p>a typical OOP design pattern and its functional equivalent?</p>
</blockquote>
<p>The above shouldn't exist. That's like asking for a piece of procedural code
rewritten as OO code. Ummm... If I translate the original Fortran (or C) into
Java, I haven't done anything more than translate it. If I totally rewrite it
into an OO paradigm, it will no longer look anything like the original Fortran
or C -- it will be unrecognizable.</p>
<p>There's no simple mapping from OO design to functional design. They're very
different ways of looking at the problem.</p>
<p>Functional programming (like <em>all</em> styles of programming) has design patterns.
Relational databases have design patterns, OO has design patterns, and
procedural programming has design patterns. Everything has design patterns,
even the architecture of buildings.</p>
<p>Design patterns -- as a concept -- are a timeless way of building,
irrespective of technology or problem domain. However, specific design
patterns apply to specific problem domains and technologies.</p>
<p>Everyone who thinks about what they're doing will uncover design patterns.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/design-patterns/" rel="tag">design-patterns</a></li>
            <li><a class="tag p-category" href="../../categories/functional-programming/" rel="tag">functional-programming</a></li>
            <li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../grouping-functions-tapply-by-aggregate-and-the-apply-family/" rel="prev" title="Grouping functions (tapply, by, aggregate) and the *apply family">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-can-i-navigate-back-to-the-last-cursor-position-in-visual-studio-code/" rel="next" title="How can I navigate back to the last cursor position in Visual Studio Code?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
