<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java Minimax Alpha-Beta Pruning Recursion Return | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/java-minimax-alpha-beta-pruning-recursion-return/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../monte-carlo-tree-search-implementation-for-tic-tac-toe/" title="Monte Carlo Tree Search: Implementation for Tic-Tac-Toe" type="text/html">
<link rel="next" href="../python-justifying-numpy-array/" title="Python: Justifying NumPy array" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Java Minimax Alpha-Beta Pruning Recursion Return">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/java-minimax-alpha-beta-pruning-recursion-return/">
<meta property="og:description" content="I am trying to implement minimax with alpha-beta pruning for a checkers game
in Java. My minimax algorithm works perfectly. My code runs with the alpha-
beta code in place. Unfortunately, when I play ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-28T03:02:00+08:00">
<meta property="article:tag" content="alpha-beta-pruning">
<meta property="article:tag" content="artificial-intelligence">
<meta property="article:tag" content="java">
<meta property="article:tag" content="minimax">
<meta property="article:tag" content="recursion">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java Minimax Alpha-Beta Pruning Recursion Return</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:02:00+08:00" itemprop="datePublished" title="2023-02-28 03:02">2023-02-28 03:02</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I am trying to implement minimax with alpha-beta pruning for a checkers game
in Java. My minimax algorithm works perfectly. My code runs with the alpha-
beta code in place. Unfortunately, when I play 1000 games vs the standard
minimax algorithm, the alpha-beta algorithm always comes out behind by 50
games or so.</p>
<p>Since alpha-beta pruning should not be reducing the quality of the moves, just
the time it takes to achieve them, something has to be wrong. However, I have
taken out pen and paper and drawn hypothetical leaf node values and used my
algorithm to predict whether it will calculate the correct best move, and
there doesn't appear to be any logic errors. I used the tree from this video:
Alpha-Beta Pruning to trace my algorithm. It logically should make all of the
same choices, and therefore be a functioning implementation.</p>
<p>I have also put print statements into the code (they have been removed to
reduce the clutter), and values are being returned correctly it appears and
pruning does happen. Despite my best efforts I have been unable to find where
the logic error lies. This is my third different attempt at implementing this
and all of them have had the same issue.</p>
<p>I can't post the full code here, it's much too long, so I have included the
methods that are relevant to the error. I'm not certain, but I suspect the
problem may likely be in the non-recursive move() method, though I can't find
a logical error in it so I'd just be thrashing around in it more, probably
making things worse rather than better without having a rhyme or reason.</p>
<p><strong>Is there a trick to recovering multiple integer values from recursive calls
in a for loop?</strong> It works fine with both my minimax and negamax
implementations, but alpha-beta pruning seems to produce some strange results.</p>
<div class="code"><pre class="code literal-block"><span class="nv">@Override</span>
<span class="k">public</span><span class="w"> </span><span class="n">GameState</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="k">Integer</span><span class="p">.</span><span class="n">MAX_VALUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GameTreeNode</span><span class="p">(</span><span class="k">state</span><span class="p">);</span>
<span class="w">    </span><span class="n">GameState</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">bestMove</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">plyDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bestScore</span><span class="p">)</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">            </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bestMove</span><span class="p">;</span>
<span class="err">}</span>

<span class="n">private</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">currentNode</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="k">depth</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">depth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">terminalNode</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">()))</span><span class="w"> </span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getHeuristic</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">());</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">getState</span><span class="p">().</span><span class="n">getCurrentPlayer</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">selfColor</span><span class="p">))</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">currentNode</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="k">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span>
<span class="w">            </span><span class="err">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">beta</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="nl">child</span><span class="p">:</span><span class="w"> </span><span class="n">currentNode</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span>
<span class="w">        </span><span class="err">{</span>
<span class="w">            </span><span class="n">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="k">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">));</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">beta</span><span class="p">)</span>
<span class="w">            </span><span class="err">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">beta</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
<span class="o">//</span><span class="n">Checks</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">terminal</span>
<span class="n">private</span><span class="w"> </span><span class="k">boolean</span><span class="w"> </span><span class="n">terminalNode</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span>
<span class="err">{</span>
<span class="k">if</span><span class="p">(</span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">win</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">lose</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="k">state</span><span class="p">.</span><span class="n">getStatus</span><span class="p">().</span><span class="k">equals</span><span class="p">(</span><span class="n">draw</span><span class="p">))</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>You already fixed your problem, but the problem you encountered is pretty
common. So whenever you build a part of the algorithm for an AI agent, you
have to test it properly. So once your minimax algorithm is correct, you can
just generate many random trees and check whether the results are the same.
For example in python you can do this in this way:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Node</span><span class="p">()</span><span class="err">:</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">children</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">data</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">children</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">children</span>

<span class="n">def</span><span class="w"> </span><span class="n">generateTree</span><span class="p">(</span><span class="k">depth</span><span class="p">,</span><span class="w"> </span><span class="n">branching</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">branching</span><span class="o">**</span><span class="k">depth</span>
<span class="w">    </span><span class="k">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">randint(-100, 100) for _ in xrange(total)</span><span class="o">]</span>
<span class="w">    </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">Node(values[i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="err">[]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="err">]</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="k">depth</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">branching</span>
<span class="w">        </span><span class="k">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">Node(None, level[i * branching: (i+1) * branching</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">xrange</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="err">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">level</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">values</span>
</pre></div>

<p>Now you can generate a tree with many random trees and compare the results.</p>
<div class="code"><pre class="code literal-block">tree, values = generateTree(depth, branching)
print negamax(tree, depth, 1) == alpha_beta_negamax(tree, depth, float('-inf'), float('inf'), 1)
</pre></div>

<hr>
<p>Do not forget that minimax and alpha-beta return just the best value, whereas
what you are interested in a real game is a move. It is straightforward to
modify them in such a way that they can return a move, but this is up to a
developer to decide how the move is returned. This is because there can be
many moves that lead to the best solution (you can return the first one, last
one or the most common one is to find all the moves and to return the random
one).</p>
<p>In your case the problem was with the randomness of the returned values, so
during the testing the good approach is to fix randomness.</p>
<p><br></p>
<h3>Suggest</h3>
<p>On March 16, 2013, sage88 asked:</p>
<blockquote>
<p><strong>Is there a trick to recovering multiple integer values from recursive
calls in a for loop?</strong> It works fine with both my minimax and negamax
implementations, but alpha-beta pruning seems to produce some strange
results.</p>
</blockquote>
<p>In alpha beta pruning, the only output value of interest is a node's score:
the final value of beta in a min node is considered for the alpha value of its
parent max node; likewise, the final value of alpha in a max node is
considered for the beta value of its parent min node. Therefore:</p>
<p><strong>The answer to your question is the algorithm itself, as it's the most
relevant trick.</strong></p>
<p>That said, there are two errors in your implementation: 1) As Adrian Blackburn
originally pointed out, it's incorrectly returning alpha from a min node and
vice-versa, thereby skewing its accuracy; 2) It's giving up pruning
opportunities by prematurely considering the parent alpha or beta in the
current node's value. This version fixes the return values and maximizes
pruning:</p>
<div class="code"><pre class="code literal-block"><span class="nv">private</span><span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">currentNode</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">depth</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="nv">beta</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">depth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">terminalNode</span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">()))</span><span class="w"> </span>{
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">getHeuristic</span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">())</span><span class="c1">;</span>
<span class="w">    </span>}
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">currentNode</span>.<span class="nv">getState</span><span class="ss">()</span>.<span class="nv">getCurrentPlayer</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">selfColor</span><span class="ss">))</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">int</span><span class="w"> </span><span class="nv">currentAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nv">INFINITY</span><span class="c1">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span>:<span class="w"> </span><span class="nv">currentNode</span>.<span class="nv">getChildren</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">currentAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">max</span><span class="ss">(</span><span class="nv">currentAlpha</span>,<span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">child</span>,<span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">beta</span><span class="ss">))</span><span class="c1">;</span>
<span class="w">            </span><span class="nv">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">max</span><span class="ss">(</span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">currentAlpha</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">alpha</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nv">beta</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nv">alpha</span><span class="c1">;</span>
<span class="w">            </span>}
<span class="w">        </span>}
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">currentAlpha</span><span class="c1">;</span>
<span class="w">    </span>}
<span class="w">    </span><span class="nv">int</span><span class="w"> </span><span class="nv">currentBeta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">INFINITY</span><span class="c1">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">GameTreeNode</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span>:<span class="w"> </span><span class="nv">currentNode</span>.<span class="nv">getChildren</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">        </span><span class="nv">currentBeta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">min</span><span class="ss">(</span><span class="nv">currentBeta</span>,<span class="w"> </span><span class="nv">miniMax</span><span class="ss">(</span><span class="nv">child</span>,<span class="w"> </span><span class="nv">depth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">alpha</span>,<span class="w"> </span><span class="nv">beta</span><span class="ss">))</span><span class="c1">;</span>
<span class="w">        </span><span class="nv">beta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Math</span>.<span class="nv">min</span><span class="ss">(</span><span class="nv">beta</span>,<span class="w"> </span><span class="nv">currentBeta</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">beta</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">alpha</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nv">beta</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">    </span>}
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">currentBeta</span><span class="c1">;</span>
}
</pre></div>

<p>Thanks for contributing a fun and interesting question :)</p>
<p>For more fun, here's a clarification of your <code>move()</code> method, removing a
redundant call to <code>Math.max()</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nv">@Override</span>
<span class="k">public</span><span class="w"> </span><span class="n">GameState</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">GameState</span><span class="w"> </span><span class="k">state</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">GameState</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GameTreeNode</span><span class="p">(</span><span class="k">state</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">GameTreeNode</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">gameTreeRoot</span><span class="p">.</span><span class="n">getChildren</span><span class="p">())</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">miniMax</span><span class="p">(</span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">plyDepth</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">bestScore</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">bestScore</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">bestMove</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">null</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">bestMove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child</span><span class="p">.</span><span class="n">getState</span><span class="p">();</span>
<span class="w">            </span><span class="n">bestScore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bestMove</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>Finally (even more fun), just a suggestion, a method name change to clarify
the intent of <code>terminalNode()</code>, though I would move this into <code>GameState</code> so
it could be called with no parameters:</p>
<div class="code"><pre class="code literal-block"><span class="nv">private</span><span class="w"> </span><span class="nv">boolean</span><span class="w"> </span><span class="nv">isTerminal</span><span class="ss">(</span><span class="nv">GameState</span><span class="w"> </span><span class="nv">state</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="o">//</span><span class="k">return</span><span class="w"> </span><span class="nv">Is</span>.<span class="nv">any</span><span class="ss">(</span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>,<span class="w"> </span><span class="nv">win</span>,<span class="w"> </span><span class="nv">lose</span>,<span class="w"> </span><span class="nv">draw</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">win</span><span class="ss">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">lose</span><span class="ss">)</span>
<span class="w">        </span><span class="o">||</span><span class="w"> </span><span class="nv">state</span>.<span class="nv">getStatus</span><span class="ss">()</span>.<span class="nv">equals</span><span class="ss">(</span><span class="nv">draw</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/alpha-beta-pruning/" rel="tag">alpha-beta-pruning</a></li>
            <li><a class="tag p-category" href="../../categories/artificial-intelligence/" rel="tag">artificial-intelligence</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/minimax/" rel="tag">minimax</a></li>
            <li><a class="tag p-category" href="../../categories/recursion/" rel="tag">recursion</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../monte-carlo-tree-search-implementation-for-tic-tac-toe/" rel="prev" title="Monte Carlo Tree Search: Implementation for Tic-Tac-Toe">Previous post</a>
            </li>
            <li class="next">
                <a href="../python-justifying-numpy-array/" rel="next" title="Python: Justifying NumPy array">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
