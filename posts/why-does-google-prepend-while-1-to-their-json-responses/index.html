<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Why does Google prepend while(1); to their JSON responses? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/why-does-google-prepend-while-1-to-their-json-responses/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../understanding-slicing/" title="Understanding slicing" type="text/html">
<link rel="next" href="../avoiding-nullpointerexception-in-java/" title="Avoiding NullPointerException in Java" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Why does Google prepend while(1); to their JSON responses?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/why-does-google-prepend-while-1-to-their-json-responses/">
<meta property="og:description" content="Why does Google prepend while(1); to their (private) JSON responses?
For example, here's a response while turning a calendar on and off in Google
Calendar:
while (1);
[
  ['u', [
    ['smsSentFlag', '">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T19:00:49+08:00">
<meta property="article:tag" content="ajax">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="json">
<meta property="article:tag" content="security">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Why does Google prepend while(1); to their JSON responses?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:00:49+08:00" itemprop="datePublished" title="2023-02-16 19:00">2023-02-16 19:00</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Why does Google prepend <code>while(1);</code> to their (private) JSON responses?</p>
<p>For example, here's a response while turning a calendar on and off in Google
Calendar:</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
[
<span class="w">  </span>[<span class="s1">'u'</span>,<span class="w"> </span>[
<span class="w">    </span>[<span class="s1">'smsSentFlag'</span>,<span class="w"> </span><span class="s1">'false'</span>],
<span class="w">    </span>[<span class="s1">'hideInvitations'</span>,<span class="w"> </span><span class="s1">'false'</span>],
<span class="w">    </span>[<span class="s1">'remindOnRespondedEventsOnly'</span>,<span class="w"> </span><span class="s1">'true'</span>],
<span class="w">    </span>[<span class="s1">'hideInvitations_remindOnRespondedEventsOnly'</span>,<span class="w"> </span><span class="s1">'false_true'</span>],
<span class="w">    </span>[<span class="s1">'Calendar ID stripped for privacy'</span>,<span class="w"> </span><span class="s1">'false'</span>],
<span class="w">    </span>[<span class="s1">'smsVerifiedFlag'</span>,<span class="w"> </span><span class="s1">'true'</span>]
<span class="w">  </span>]]
]
</pre></div>

<p>I would assume this is to prevent people from doing an <code>eval()</code> on it, but all
you'd really have to do is replace the <code>while</code> and then you'd be set. I would
assume the eval prevention is to make sure people write safe JSON parsing
code.</p>
<p>I've seen this used in a couple of other places, too, but a lot more so with
Google (Mail, Calendar, Contacts, etc.) Strangely enough, Google Docs starts
with <code>&amp;&amp;&amp;START&amp;&amp;&amp;</code> instead, and Google Contacts seems to start with <code>while(1);
&amp;&amp;&amp;START&amp;&amp;&amp;</code>.</p>
<p>What's going on here?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It prevents JSON hijacking, a major JSON security issue that is formally fixed
in all major browsers since 2011 with ECMAScript 5.</p>
<p>Contrived example: say Google has a URL like
<code>mail.google.com/json?action=inbox</code> which returns the first 50 messages of
your inbox in JSON format. Evil websites on other domains can't make AJAX
requests to get this data due to the same-origin policy, but they can include
the URL via a <code>&lt;script&gt;</code> tag. The URL is visited with <em>your</em> cookies, and by
overriding the global array constructor or accessor methods they can have a
method called whenever an object (array or hash) attribute is set, allowing
them to read the JSON content.</p>
<p>The <code>while(1);</code> or <code>&amp;&amp;&amp;BLAH&amp;&amp;&amp;</code> prevents this: an AJAX request at
<code>mail.google.com</code> will have full access to the text content, and can strip it
away. But a <code>&lt;script&gt;</code> tag insertion blindly executes the JavaScript without
any processing, resulting in either an infinite loop or a syntax error.</p>
<p>This does not address the issue of cross-site request forgery.</p>
<p><br></p>
<h3>Suggest</h3>
<p>It prevents disclosure of the response through JSON hijacking.</p>
<p>In theory, the content of HTTP responses is protected by the Same Origin
Policy: pages from one domain cannot get any pieces of information from pages
on the other domain (unless explicitly allowed).</p>
<p>An attacker can request pages on other domains on your behalf, e.g. by using a
<code>&lt;script src=...&gt;</code> or <code>&lt;img&gt;</code> tag, but it can't get any information about the
result (headers, contents).</p>
<p>Thus, if you visit an attacker's page, it couldn't read your email from
gmail.com.</p>
<p>Except that when using a script tag to request JSON content, the JSON is
executed as JavaScript in an attacker's controlled environment. If the
attacker can replace the Array or Object constructor or some other method used
during object construction, anything in the JSON would pass through the
attacker's code, and be disclosed.</p>
<p>Note that this happens when the JSON is executed as JavaScript, not when it's
parsed.</p>
<p>There are multiple countermeasures:</p>
<h2>Making sure the JSON never executes</h2>
<p>By placing a <code>while(1);</code> statement before the JSON data, Google ensures that
the JSON data is never executed as JavaScript.</p>
<p>Only a legitimate page could actually get the whole content, strip the
<code>while(1);</code>, and parse the remainder as JSON.</p>
<p>Things like <code>for(;;);</code> have been seen on Facebook for instance, with the same
results.</p>
<h2>Making sure the JSON is not valid JavaScript</h2>
<p>Similarly, adding invalid tokens before the JSON, like <code>&amp;&amp;&amp;START&amp;&amp;&amp;</code>, makes
sure that it is never executed.</p>
<h2>Always return JSON with an Object on the outside</h2>
<p>This is OWASP recommended way to protect from JSON hijacking and is the less
intrusive one.</p>
<p>Similarly to the previous counter-measures, it makes sure that the JSON is
never executed as JavaScript.</p>
<p>A valid JSON object, when not enclosed by anything, is not valid in
JavaScript, since the <code>{ }</code> gets interpreted as a code block:</p>
<div class="code"><pre class="code literal-block">eval('{"foo":"bar"}')
// SyntaxError: Unexpected token :
</pre></div>

<p>This is however valid JSON:</p>
<div class="code"><pre class="code literal-block">JSON.parse('{"foo":"bar"}')
// Object {foo: "bar"}
</pre></div>

<p>So, make sure you always return an Object at the top level of the response and
make sure that the JSON is not valid JavaScript, while still being valid JSON.</p>
<p>As noted by @hvd in the comments, the empty object <code>{}</code> is valid JavaScript,
and knowing the object is empty may itself be valuable information.</p>
<h2>Comparison of the above methods</h2>
<p>The OWASP way is less intrusive, as it needs no client library changes, and
transfers valid JSON. It is unsure whether past or future browser bugs could
defeat this, however. As noted by @oriadam, it is unclear whether data could
be leaked in a parse error through an error handling or not (e.g.
window.onerror).</p>
<p>Google's way requires a client library in order for it to support automatic
de-serialization and can be considered to be safer with regard to browser
bugs.</p>
<p>Both methods require server-side changes in order to avoid developers
accidentally sending vulnerable JSON.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/ajax/" rel="tag">ajax</a></li>
            <li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
            <li><a class="tag p-category" href="../../categories/json/" rel="tag">json</a></li>
            <li><a class="tag p-category" href="../../categories/security/" rel="tag">security</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../understanding-slicing/" rel="prev" title="Understanding slicing">Previous post</a>
            </li>
            <li class="next">
                <a href="../avoiding-nullpointerexception-in-java/" rel="next" title="Avoiding NullPointerException in Java">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
