<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>使用 Unix 工具解析 JSON | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yong-unix-gong-ju-jie-xi-json/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-jiang-huan-jing-bian-liang-chuan-di-gei-docker-rong-qi/" title="如何将环境变量传递给 Docker 容器？" type="text/html">
<link rel="next" href="../wo-ru-he-tong-guo-guan-dao-chuan-shu-stderr-er-bu-shi-stdout/" title="我如何通过管道传输 stderr 而不是 stdout？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="使用 Unix 工具解析 JSON">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yong-unix-gong-ju-jie-xi-json/">
<meta property="og:description" content="我正在尝试解析从 curl 请求返回的 JSON，如下所示：
curl 'http://twitter.com/users/username.json' |
    sed -e 's/[{}]/''/g' | 
    awk -v k=&quot;text&quot; '{n=split($0,a,&quot;,&quot;); for (i=1; i&lt;=n; i++) print a[i]}'


上面将 JSON 拆分为字段，例">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T04:30:36+08:00">
<meta property="article:tag" content="bash">
<meta property="article:tag" content="jq">
<meta property="article:tag" content="json">
<meta property="article:tag" content="parsing">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">使用 Unix 工具解析 JSON</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:30:36+08:00" itemprop="datePublished" title="2023-02-17 04:30">2023-02-17 04:30</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我正在尝试解析从 curl 请求返回的 JSON，如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span><span class="w"> </span><span class="s1">'http://twitter.com/users/username.json'</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="n">sed</span><span class="w"> </span><span class="o">-</span><span class="n">e</span><span class="w"> </span><span class="s1">'s/[{}]/''/g'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="n">awk</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="ss">"text"</span><span class="w"> </span><span class="s1">'{n=split($0,a,","); for (i=1; i&lt;=n; i++) print a[i]}'</span>
</pre></div>

<p>上面将 JSON 拆分为字段，例如：</p>
<div class="code"><pre class="code literal-block"><span class="c">% ...</span>
<span class="s">"geo_enabled"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"friends_count"</span><span class="p">:</span><span class="mi">245</span>
<span class="s">"profile_text_color"</span><span class="p">:</span><span class="s">"000000"</span>
<span class="s">"status"</span><span class="p">:</span><span class="s">"in_reply_to_screen_name"</span><span class="p">:</span><span class="nb">null</span>
<span class="s">"source"</span><span class="p">:</span><span class="s">"web"</span>
<span class="s">"truncated"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"text"</span><span class="p">:</span><span class="s">"My status"</span>
<span class="s">"favorited"</span><span class="p">:</span><span class="nb">false</span>
<span class="c">% ...</span>
</pre></div>

<p>如何打印特定字段（由 表示<code>-v k=text</code>）？</p>
<p><br><br></p>
<h2>解答</h2>
<p>有许多专门设计用于从命令行操作 JSON 的工具，并且比使用 Awk 更容易和更可靠，例如<code>jq</code>：</p>
<div class="code"><pre class="code literal-block">curl -s 'https://api.github.com/users/lambda' | jq -r '.name'
</pre></div>

<p><code>json</code>您还可以使用系统上可能已经安装的工具来执行此操作，例如使用module 的Python ，从而避免任何额外的依赖项，同时仍然可以享受适当的
JSON 解析器的好处。以下假设您想要使用 UTF-8，原始 JSON 应该以这种方式进行编码，并且大多数现代终端也使用这种方式：</p>
<p>蟒蛇 3：</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python3</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print(json.load(sys.stdin)['name'])"</span>
</pre></div>

<p>蟒蛇2：</p>
<div class="code"><pre class="code literal-block"><span class="n">export</span> <span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python2</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print json.load(sys.stdin)['name']"</span>
</pre></div>

<h3>经常问的问题</h3>
<h4>为什么不是纯 shell 解决方案？</h4>
<p>标准的POSIX/单一 Unix 规范
shell是一种非常有限的语言，它不包含表示序列（列表或数组）或关联数组（在其他一些语言中也称为哈希表、映射、字典或对象）的工具。这使得在可移植 shell
脚本中表示解析 JSON 的结果有些棘手。有一些 hacky 方法可以做到这一点，但如果键或值包含某些特殊字符，它们中的许多方法可能会失败。</p>
<p>Bash 4 及更高版本、zsh 和 ksh 支持数组和关联数组，但这些 shell 并非普遍可用（由于从 GPLv2 到 GPLv3，macOS 在
Bash 3 停止更新 Bash，而许多 Linux 系统没有zsh 开箱即用）。您可能可以编写一个可以在 Bash 4 或 zsh
中运行的脚本，其中之一在当今大多数 macOS、Linux 和 BSD 系统上都可用，但是很难编写适用于这种情况的 shebang 行多语言脚本。</p>
<p>最后，在 shell 中编写一个完整的 JSON 解析器将是一个足够重要的依赖项，您不妨只使用现有的依赖项，如 jq 或
Python。它不会是一行代码，甚至是一小段五行代码，就可以很好地实现。</p>
<h4>为什么不使用 awk、sed 或 grep？</h4>
<p>可以使用这些工具从具有已知形状并以已知方式格式化的 JSON 中进行一些快速提取，例如每行一个键。在其他答案中有几个对此建议的示例。</p>
<p>但是，这些工具是为基于行或基于记录的格式而设计的；它们不是为递归解析具有可能的转义字符的匹配定界符而设计的。</p>
<p>因此，这些使用 awk/sed/grep 的快速而肮脏的解决方案可能很脆弱，如果输入格式的某些方面发生变化，例如折叠空格，或向 JSON
对象添加额外的嵌套级别，或在其中转义引号，则会中断一个字符串。一个足以处理所有 JSON
输入而不中断的解决方案也将相当庞大和复杂，因此与添加对<code>jq</code>Python 或 Python 的另一个依赖没有太大区别。</p>
<p>我以前不得不处理由于 shell
脚本中的输入解析不佳而导致删除的大量客户数据，所以我从不推荐快速而肮脏的方法，因为这种方法可能很脆弱。如果您正在进行一次性处理，请参阅其他答案以获取建议，但我仍然强烈建议您只使用经过测试的现有
JSON 解析器。</p>
<h3>历史笔记</h3>
<p>这个答案最初推荐jsawk，它应该仍然有效，但使用起来比 更麻烦一点<code>jq</code>，并且取决于安装的独立 JavaScript 解释器，这比 Python
解释器更不常见，因此以上答案可能更可取：</p>
<div class="code"><pre class="code literal-block"><span class="nv">curl</span><span class="w"> </span><span class="o">-</span><span class="nv">s</span><span class="w"> </span><span class="s1">'https://api.github.com/users/lambda'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">jsawk</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="s1">'return this.name'</span>
</pre></div>

<p>这个答案最初也使用问题中的 Twitter API，但该 API 不再有效，因此很难复制示例进行测试，并且新的 Twitter API 需要 API
密钥，所以我转而使用 GitHub API无需 API 密钥即可轻松使用。原始问题的第一个答案是：</p>
<div class="code"><pre class="code literal-block">curl 'http://twitter.com/users/username.json' | jq -r '.text'
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>为了快速提取特定键的值，我个人喜欢使用“grep -o”，它只返回正则表达式的匹配项。例如，要从推文中获取“文本”字段，类似于：</p>
<div class="code"><pre class="code literal-block">grep -Po '"text":.*?[^\\]",' tweets.json
</pre></div>

<p>这个正则表达式比你想象的更健壮；例如，它可以很好地处理在其中嵌入逗号和转义引号的字符串。我认为只要多做一点工作，你就可以做出一个实际上保证提取价值的东西，如果它是原子的。（如果它有嵌套，那么正则表达式当然不能这样做。）</p>
<p>为了进一步清理（尽管保持字符串的原始转义），您可以使用类似的东西<code>| perl -pe 's/"text"://; s/^"//;
s/",$//'</code>：（我为这个分析做了这个。）</p>
<p>对于所有坚持认为您应该使用真正的 JSON 解析器的仇恨者——是的，这对于正确性至关重要，但是</p>
<ol>
<li>要进行真正快速的分析，例如计算值以检查数据清理错误或获得对数据的总体感觉，在命令行上敲打一些东西会更快。打开编辑器编写脚本会让人分心。</li>
<li>
<code>grep -o</code>比 Python 标准<code>json</code>库快几个数量级，至少在对推文执行此操作时（每条约 2 KB）。我不确定这是否只是因为<code>json</code>速度慢（我应该在某个时候与 yajl 进行比较）；但原则上，正则表达式应该更快，因为它是有限状态并且更可优化，而不是必须支持递归的解析器，在这种情况下，会花费大量 CPU 为您不关心的结构构建树。（如果有人编写了一个有限状态转换器来进行适当的（深度受限的）JSON 解析，那就太棒了！与此同时我们有“grep -o”。）</li>
</ol>
<p>为了编写可维护的代码，我总是使用真正的解析库。我没有尝试过jsawk，但如果它运行良好，那将解决第 1 点。</p>
<p>最后一个更古怪的解决方案：我写了一个脚本，它使用
Python<code>json</code>并将你想要的键提取到制表符分隔的列中；然后我通过一个<code>awk</code>允许对列进行命名访问的包装器进行管道传输。在这里：json2tsv 和
tsvawk 脚本。所以对于这个例子，它将是：</p>
<div class="code"><pre class="code literal-block">json2tsv id text &lt; tweets.json | tsvawk '{print "tweet " $id " is: " $text}'
</pre></div>

<p>这种方法没有解决 #2，比单个 Python 脚本效率低，而且有点脆弱：它强制对字符串值中的换行符和制表符进行规范化，以与 awk
的字段/记录分隔的世界观相得益彰。但它确实让你留在命令行上，比<code>grep -o</code>.</p>
<p><br><br><a href="../parsing-json-with-unix-tools/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/bash/" rel="tag">bash</a></li>
            <li><a class="tag p-category" href="../../categories/jq/" rel="tag">jq</a></li>
            <li><a class="tag p-category" href="../../categories/json/" rel="tag">json</a></li>
            <li><a class="tag p-category" href="../../categories/parsing/" rel="tag">parsing</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-jiang-huan-jing-bian-liang-chuan-di-gei-docker-rong-qi/" rel="prev" title="如何将环境变量传递给 Docker 容器？">Previous post</a>
            </li>
            <li class="next">
                <a href="../wo-ru-he-tong-guo-guan-dao-chuan-shu-stderr-er-bu-shi-stdout/" rel="next" title="我如何通过管道传输 stderr 而不是 stdout？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
