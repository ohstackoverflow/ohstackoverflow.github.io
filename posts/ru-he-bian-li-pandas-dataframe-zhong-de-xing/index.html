<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>如何遍历 Pandas DataFrame 中的行 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ru-he-bian-li-pandas-dataframe-zhong-de-xing/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../fu-dian-shu-xue-pi-liao-ma/" title="浮点数学坏了吗？" type="text/html">
<link rel="next" href="../jiang-xian-you-de-wei-ti-jiao-de-gong-zuo-yi-dong-dao-git-zhong-de-xin-fen-zhi/" title="将现有的、未提交的工作移动到 Git 中的新分支" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="如何遍历 Pandas DataFrame 中的行">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ru-he-bian-li-pandas-dataframe-zhong-de-xing/">
<meta property="og:description" content="我有一个熊猫数据框，df：
   c1   c2
0  10  100
1  11  110
2  12  120


如何遍历此数据框的行？对于每一行，我希望能够通过列名访问其元素（单元格中的值）。例如：
for row in df.rows:
    print(row['c1'], row['c2'])



我发现了一个类似的问题，建议使用以下任一方法：
for date, row in ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T19:22:03+08:00">
<meta property="article:tag" content="dataframe">
<meta property="article:tag" content="pandas">
<meta property="article:tag" content="python">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">如何遍历 Pandas DataFrame 中的行</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:22:03+08:00" itemprop="datePublished" title="2023-02-16 19:22">2023-02-16 19:22</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我有一个熊猫数据框，<code>df</code>：</p>
<div class="code"><pre class="code literal-block">   c1   c2
0  10  100
1  11  110
2  12  120
</pre></div>

<p>如何遍历此数据框的行？对于每一行，我希望能够通过列名访问其元素（单元格中的值）。例如：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">rows</span>:
<span class="w">    </span><span class="nv">print</span><span class="ss">(</span><span class="nv">row</span>[<span class="s1">'c1'</span>],<span class="w"> </span><span class="nv">row</span>[<span class="s1">'c2'</span>]<span class="ss">)</span>
</pre></div>

<hr>
<p>我发现了一个类似的问题，建议使用以下任一方法：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="nv">date</span>,<span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">T</span>.<span class="nv">iteritems</span><span class="ss">()</span>:



<span class="k">for</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">df</span>.<span class="nv">iterrows</span><span class="ss">()</span>:
</pre></div>

<p>但是我不明白对象<code>row</code>是什么以及如何使用它。</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>DataFrame.iterrows</code>是一个产生索引和行的生成器（作为一个系列）：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'c1'</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="s1">'c2'</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">]})</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>  <span class="c1"># make sure indexes pair with number of rows</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">'c1'</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s1">'c2'</span><span class="p">])</span>



<span class="mi">10</span> <span class="mi">100</span>
<span class="mi">11</span> <span class="mi">110</span>
<span class="mi">12</span> <span class="mi">120</span>
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<blockquote>
<h3>如何遍历 Pandas DataFrame 中的行</h3>
</blockquote>
<h2>答：不要*！</h2>
<p>Pandas
中的迭代是一种反模式，只有在用尽所有其他选项时才应该这样做。你不应该<code>iter</code>在超过几千行的情况下使用任何名称中带有“”的函数，否则你将不得不习惯大量
<strong>的</strong> 等待。</p>
<p>你想打印一个 DataFrame 吗？使用 <strong><code>DataFrame.to_string()</code></strong> 。</p>
<p>你想计算一些东西吗？在这种情况下，按此顺序搜索方法（从此处修改的列表）：</p>
<ol>
<li>矢量化</li>
<li>Cython例程</li>
<li>列表理解（香草<code>for</code>循环）</li>
<li>
<strong><code>DataFrame.apply()</code></strong> : i) 可以在 Cython 中执行的归约，ii) Python 空间中的迭代</li>
<li>
<strong><code>DataFrame.itertuples()</code></strong> 和 <strong><code>iteritems()</code></strong>
</li>
<li><strong><code>DataFrame.iterrows()</code></strong></li>
</ol>
<p><code>iterrows</code>并且<code>itertuples</code>（在回答这个问题时都获得了很多选票）应该在非常罕见的情况下使用，例如为顺序处理生成行对象/名称元组，这实际上是这些函数唯一有用的地方。</p>
<p><strong>诉诸权威</strong></p>
<p>关于迭代的文档页面有一个巨大的红色警告框，上面写着：</p>
<blockquote>
<p>遍历 pandas 对象通常很慢。在许多情况下，不需要手动遍历行 [...]。</p>
</blockquote>
<ul>
<li>它实际上比“不要”要复杂一点。<code>df.iterrows()</code>是这个问题的正确答案，但“向量化你的操作”是更好的答案。我承认在某些情况下无法避免迭代（例如，某些操作的结果取决于为前一行计算的值）。但是，需要对库有一定的了解才能知道什么时候。如果您不确定是否需要迭代解决方案，您可能不需要。PS：要了解更多关于我写这个答案的理由，请跳到最底部。</li>
</ul>
<hr>
<h3>比循环更快：矢量化，Cython</h3>
<p>pandas（通过 NumPy 或通过 Cythonized
函数）“矢量化”了大量基本操作和计算。这包括算术、比较、（大多数）归约、重塑（例如旋转）、连接和分组操作。查看有关Essential Basic
Functionality的文档，找到适合您的问题的矢量化方法。</p>
<p>如果不存在，请随意使用自定义Cython 扩展编写您自己的。</p>
<hr>
<h3>下一个最好的事情：列出理解*</h3>
<p>如果 1) 没有可用的矢量化解决方案，2) 性能很重要，但还不够重要，无法解决代码的 cythonizing 问题，并且 3)
您正在尝试执行元素转换在你的代码上。有大量证据表明，列表理解对于许多常见的 Pandas 任务来说足够快（有时甚至更快）。</p>
<p>公式很简单，</p>
<div class="code"><pre class="code literal-block"><span class="c1"># Iterating over one column - `f` is some function that processes your data</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'col'</span><span class="err">]]</span>
<span class="c1"># Iterating over two columns, use `zip`</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zip</span><span class="p">(</span><span class="n">df</span><span class="err">[</span><span class="s1">'col1'</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'col2'</span><span class="err">]</span><span class="p">)</span><span class="err">]</span>
<span class="c1"># Iterating over multiple columns - same data type</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="k">row</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">row</span><span class="err">[</span><span class="n">n</span><span class="err">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">df</span><span class="err">[[</span><span class="s1">'col1'</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="s1">'coln'</span><span class="err">]]</span><span class="p">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="err">]</span>
<span class="c1"># Iterating over multiple columns - differing data type</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[</span><span class="n">f</span><span class="p">(</span><span class="k">row</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">row</span><span class="err">[</span><span class="n">n</span><span class="err">]</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">zip</span><span class="p">(</span><span class="n">df</span><span class="err">[</span><span class="s1">'col1'</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">df</span><span class="err">[</span><span class="s1">'coln'</span><span class="err">]</span><span class="p">)</span><span class="err">]</span>
</pre></div>

<p>如果您可以将业务逻辑封装到一个函数中，则可以使用调用它的列表理解。您可以通过原始 Python 代码的简单性和速度来处理任意复杂的事情。</p>
<p><strong>注意事项</strong></p>
<p>列表理解假定您的数据易于使用——这意味着您的数据类型是一致的并且您没有 NaN，但这不能总是得到保证。</p>
<ol>
<li>第一个更明显，但是在处理 NaN 时，如果存在内置的 pandas 方法（因为它们具有更好的极端情况处理逻辑），则更喜欢它们，或者确保您的业务逻辑包含适当的 NaN 处理逻辑。</li>
<li>在处理混合数据类型时，您应该迭代而<code>zip(df['A'], df['B'], ...)</code>不是因为<code>df[['A', 'B']].to_numpy()</code>后者隐式地将数据向上转换为最常见的类型。例如，如果 A 是数字而 B 是字符串，<code>to_numpy()</code>会将整个数组转换为字符串，这可能不是您想要的。幸运的是，<code>zip</code>将您的列一起 ping 是最直接的解决方法。</li>
</ol>
<p><strong>*您的里程数可能会因上述注意事项</strong> 部分中概述的原因而有所不同。</p>
<hr>
<h3>一个明显的例子</h3>
<p>让我们通过添加两个 pandas 列的简单示例来演示差异<code>A + B</code>。这是一个可向量化的操作，因此很容易对比上面讨论的方法的性能。</p>
<p><img alt="" src="../../images/y44RJ.png"></p>
<p>基准代码，供大家参考。底部的一行测量了一个用 numpandas 编写的函数，numpandas 是一种与 NumPy 大量混合以发挥最大性能的
Pandas 风格。除非您知道自己在做什么，否则应避免编写 numpandas 代码。尽可能坚持使用 API（即，优先<code>vec</code>于<code>vec_numpy</code>）。</p>
<p>然而，我应该提一下，它并不总是如此干脆。有时“什么是最佳操作方法”的答案是“这取决于您的数据”。我的建议是在选择一种方法之前先针对您的数据测试不同的方法。</p>
<hr>
<h3>我的个人意见*</h3>
<p>对 iter 系列的各种替代方案进行的大多数分析都是通过性能的镜头进行的。然而，在大多数情况下，您通常会处理一个合理大小的数据集（不超过几千行或 10
万行），性能将仅次于解决方案的简单性/可读性。</p>
<p>在选择用于解决问题的方法时，这是我个人的偏好。</p>
<p>对于新手：</p>
<blockquote>
<p><em>矢量化</em> （如果可能） <em>；<code>apply()</code>; 列表理解；<code>itertuples()</code>/ <code>iteritems()</code>; <code>iterrows()</code>;
Cython</em></p>
</blockquote>
<p>对于更有经验的人：</p>
<blockquote>
<p><em>矢量化</em> （如果可能） <em>；<code>apply()</code>; 列表理解；赛通; <code>itertuples()</code>/
<code>iteritems()</code>;<code>iterrows()</code></em></p>
</blockquote>
<p>对于任何可以向量化的问题，向量化都是最惯用的方法。始终寻求矢量化！如有疑问，请查阅文档，或在 Stack Overflow
上查找有关您的特定任务的现有问题。</p>
<p>我确实倾向于继续谈论<code>apply</code>我的很多帖子有多糟糕，但我承认对于初学者来说更容易理解它在做什么。此外，在我的这篇文章<code>apply</code>中解释了很多用例。</p>
<p>Cython 在列表中排名靠后，因为它需要更多的时间和精力才能正确完成。您通常永远不需要使用 pandas
编写需要这种性能水平的代码，即使是列表理解也无法满足。</p>
<p>*与任何个人意见一样，请带上大量盐！</p>
<hr>
<h3>进一步阅读</h3>
<ul>
<li>
<p>10 Minutes to pandas和Essential Basic Functionality - 向您介绍 Pandas 及其向量化*/cythonized 函数库的有用链接。</p>
</li>
<li>
<p>增强性能- 增强标准 Pandas 操作文档中的入门读物</p>
</li>
<li>
<p><em>pandas 中的 for 循环真的很糟糕吗？ 我什么时候应该关心？</em>- 我详细写了一篇关于列表理解及其对各种操作（主要是涉及非数字数据的操作）的适用性的文章</p>
</li>
<li>
<p><em>我什么时候应该（不）想在我的代码中使用 pandas apply() ？</em> -<code>apply</code>很慢（但不像<code>iter*</code>家庭那么慢。但是，在某些情况下，人们可以（或应该）考虑将其<code>apply</code>作为一种严肃的选择，尤其是在某些<code>GroupBy</code>操作中）。</p>
</li>
<li>
<p>Pandas 字符串方法是“矢量化”的，因为它们在系列中指定但对每个元素进行操作。底层机制仍然是迭代的，因为字符串操作本质上很难向量化。</p>
</li>
</ul>
<hr>
<h3>为什么我写这个答案</h3>
<p>我从新用户那里注意到的一个常见趋势是提出“如何迭代我的 df 来执行
X？”形式的问题。<code>iterrows()</code>显示在循环内执行某些操作时调用的代码<code>for</code>。这就是为什么。没有被介绍过矢量化概念的图书馆新用户可能会将解决他们问题的代码想象为迭代他们的数据来做某事。不知道如何遍历
DataFrame，他们做的第一件事就是谷歌搜索并在这个问题上结束。然后他们看到接受的答案告诉他们如何去做，他们闭上眼睛并运行这段代码，而没有首先质疑迭代是否是正确的事情。</p>
<p>这个答案的目的是帮助新用户理解迭代不一定是所有问题的解决方案，可能存在更好、更快和更惯用的解决方案，值得花时间去探索它们。我并不是要开始一场迭代与矢量化的战争，但我希望新用户在使用这个库开发问题解决方案时得到通知。</p>
<p><br><br><a href="../how-to-iterate-over-rows-in-a-dataframe-in-pandas/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dataframe/" rel="tag">dataframe</a></li>
            <li><a class="tag p-category" href="../../categories/pandas/" rel="tag">pandas</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../fu-dian-shu-xue-pi-liao-ma/" rel="prev" title="浮点数学坏了吗？">Previous post</a>
            </li>
            <li class="next">
                <a href="../jiang-xian-you-de-wei-ti-jiao-de-gong-zuo-yi-dong-dao-git-zhong-de-xin-fen-zhi/" rel="next" title="将现有的、未提交的工作移动到 Git 中的新分支">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
