<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>When to use LinkedList over ArrayList in Java? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/when-to-use-linkedlist-over-arraylist-in-java/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-is-dependency-injection/" title="What is dependency injection?" type="text/html">
<link rel="next" href="../how-do-i-loop-through-or-enumerate-a-javascript-object/" title="How do I loop through or enumerate a JavaScript object?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="When to use LinkedList over ArrayList in Java?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/when-to-use-linkedlist-over-arraylist-in-java/">
<meta property="og:description" content="I've always been one to simply use:
List&lt;String&gt; names = new ArrayList&lt;&gt;();


I use the interface as the type name for portability , so that when I ask
questions such as this, I can rework my code.
Wh">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T19:33:45+08:00">
<meta property="article:tag" content="arraylist">
<meta property="article:tag" content="collections">
<meta property="article:tag" content="java">
<meta property="article:tag" content="linked-list">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">When to use LinkedList over ArrayList in Java?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:33:45+08:00" itemprop="datePublished" title="2023-02-16 19:33">2023-02-16 19:33</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I've always been one to simply use:</p>
<div class="code"><pre class="code literal-block">List&lt;String&gt; names = new ArrayList&lt;&gt;();
</pre></div>

<p>I use the interface as the type name for <em>portability</em> , so that when I ask
questions such as this, I can rework my code.</p>
<p>When should <code>LinkedList</code> be used over <code>ArrayList</code> and vice-versa?</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Summary</strong> <code>ArrayList</code> with <code>ArrayDeque</code> are preferable in <em>many</em> more use-
cases than <code>LinkedList</code>. If you're not sure — just start with <code>ArrayList</code>.</p>
<hr>
<p>TLDR, in <code>ArrayList</code> accessing an element takes constant time [O(1)] and
adding an element takes O(n) time [worst case]. In <code>LinkedList</code> inserting an
element takes O(n) time and accessing also takes O(n) time but <code>LinkedList</code>
uses more memory than <code>ArrayList</code>.</p>
<p><code>LinkedList</code> and <code>ArrayList</code> are two different implementations of the <code>List</code>
interface. <code>LinkedList</code> implements it with a doubly-linked list. <code>ArrayList</code>
implements it with a dynamically re-sizing array.</p>
<p>As with standard linked list and array operations, the various methods will
have different algorithmic runtimes.</p>
<p>For <code>LinkedList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code> is <em>O(n)</em> (with <em>n/4</em> steps on average), but <em>O(1)</em> when <code>index = 0</code> or <code>index = list.size() - 1</code> (in this case, you can also use <code>getFirst()</code> and <code>getLast()</code>). <strong>One of the main benefits of</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>add(int index, E element)</code> is <em>O(n)</em> (with <em>n/4</em> steps on average), but <em>O(1)</em> when <code>index = 0</code> or <code>index = list.size() - 1</code> (in this case, you can also use <code>addFirst()</code> and <code>addLast()</code>/<code>add()</code>). <strong>One of the main benefits of</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>remove(int index)</code> is <em>O(n)</em> (with <em>n/4</em> steps on average), but <em>O(1)</em> when <code>index = 0</code> or <code>index = list.size() - 1</code> (in this case, you can also use <code>removeFirst()</code> and <code>removeLast()</code>). <strong>One of the main benefits of</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>Iterator.remove()</code> is <em>O(1)</em>. <strong>One of the main benefits of</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>ListIterator.add(E element)</code> is <em>O(1)</em>. <strong>One of the main benefits of</strong> <code>LinkedList&lt;E&gt;</code>
</li>
</ul>
<p>Note: Many of the operations need <em>n/4</em> steps on average, <em>constant</em> number of
steps in the best case (e.g. index = 0), and <em>n/2</em> steps in worst case (middle
of list)</p>
<p>For <code>ArrayList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code> is <em>O(1)</em>. <strong>Main benefit of</strong> <code>ArrayList&lt;E&gt;</code>
</li>
<li>
<code>add(E element)</code> is <em>O(1)</em> amortized, but <em>O(n)</em> worst-case since the array must be resized and copied</li>
<li>
<code>add(int index, E element)</code> is <em>O(n)</em> (with <em>n/2</em> steps on average)</li>
<li>
<code>remove(int index)</code> is <em>O(n)</em> (with <em>n/2</em> steps on average)</li>
<li>
<code>Iterator.remove()</code> is <em>O(n)</em> (with <em>n/2</em> steps on average)</li>
<li>
<code>ListIterator.add(E element)</code> is <em>O(n)</em> (with <em>n/2</em> steps on average)</li>
</ul>
<p>Note: Many of the operations need <em>n/2</em> steps on average, <em>constant</em> number of
steps in the best case (end of list), <em>n</em> steps in the worst case (start of
list)</p>
<p><code>LinkedList&lt;E&gt;</code> allows for constant-time insertions or removals <em>using
iterators</em> , but only sequential access of elements. In other words, you can
walk the list forwards or backwards, but finding a position in the list takes
time proportional to the size of the list. Javadoc says <em>"operations that
index into the list will traverse the list from the beginning or the end,
whichever is closer"</em> , so those methods are <em>O(n)</em> ( <em>n/4</em> steps) on average,
though <em>O(1)</em> for <code>index = 0</code>.</p>
<p><code>ArrayList&lt;E&gt;</code>, on the other hand, allow fast random read access, so you can
grab any element in constant time. But adding or removing from anywhere but
the end requires shifting all the latter elements over, either to make an
opening or fill the gap. Also, if you add more elements than the capacity of
the underlying array, a new array (1.5 times the size) is allocated, and the
old array is copied to the new one, so adding to an <code>ArrayList</code> is <em>O(n)</em> in
the worst case but constant on average.</p>
<p>So depending on the operations you intend to do, you should choose the
implementations accordingly. Iterating over either kind of List is practically
equally cheap. (Iterating over an <code>ArrayList</code> is technically faster, but
unless you're doing something really performance-sensitive, you shouldn't
worry about this -- they're both constants.)</p>
<p>The main benefits of using a <code>LinkedList</code> arise when you re-use existing
iterators to insert and remove elements. These operations can then be done in
<em>O(1)</em> by changing the list locally only. In an array list, the remainder of
the array needs to be <em>moved</em> (i.e. copied). On the other side, seeking in a
<code>LinkedList</code> means following the links in <em>O(n)</em> ( <em>n/2</em> steps) for worst
case, whereas in an <code>ArrayList</code> the desired position can be computed
mathematically and accessed in <em>O(1)</em>.</p>
<p>Another benefit of using a <code>LinkedList</code> arises when you add or remove from the
head of the list, since those operations are <em>O(1)</em> , while they are <em>O(n)</em>
for <code>ArrayList</code>. Note that <code>ArrayDeque</code> may be a good alternative to
<code>LinkedList</code> for adding and removing from the head, but it is not a <code>List</code>.</p>
<p>Also, if you have large lists, keep in mind that memory usage is also
different. Each element of a <code>LinkedList</code> has more overhead since pointers to
the next and previous elements are also stored. <code>ArrayLists</code> don't have this
overhead. However, <code>ArrayLists</code> take up as much memory as is allocated for the
capacity, regardless of whether elements have actually been added.</p>
<p>The default initial capacity of an <code>ArrayList</code> is pretty small (10 from Java
1.4 - 1.8). But since the underlying implementation is an array, the array
must be resized if you add a lot of elements. To avoid the high cost of
resizing when you know you're going to add a lot of elements, construct the
<code>ArrayList</code> with a higher initial capacity.</p>
<p>If the data structures perspective is used to understand the two structures, a
LinkedList is basically a sequential data structure which contains a head
Node. The Node is a wrapper for two components : a value of type T [accepted
through generics] and another reference to the Node linked to it. So, we can
assert it is a recursive data structure (a Node contains another Node which
has another Node and so on...). Addition of elements takes linear time in
LinkedList as stated above.</p>
<p>An ArrayList is a growable array. It is just like a regular array. Under the
hood, when an element is added, and the ArrayList is already full to capacity,
it creates another array with a size which is greater than previous size. The
elements are then copied from previous array to new one and the elements that
are to be added are also placed at the specified indices.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Thus far, nobody seems to have addressed the memory footprint of each of these
lists besides the general consensus that a <code>LinkedList</code> is "lots more" than an
<code>ArrayList</code> so I did some number crunching to demonstrate exactly how much
both lists take up for N null references.</p>
<p>Since references are either 32 or 64 bits (even when null) on their relative
systems, I have included 4 sets of data for 32 and 64 bit <code>LinkedLists</code> and
<code>ArrayLists</code>.</p>
<p><strong>Note:</strong> The sizes shown for the <code>ArrayList</code> lines are for <em>trimmed lists</em> -
In practice, the capacity of the backing array in an <code>ArrayList</code> is generally
larger than its current element count.</p>
<p><strong>Note 2:</strong> <em>(thanks BeeOnRope)</em> As CompressedOops is default now from mid
JDK6 and up, the values below for 64-bit machines will basically match their
32-bit counterparts, unless of course you specifically turn it off.</p>
<hr>
<p><img alt="Graph of LinkedList and ArrayList No. of Elements x
Bytes" src="https://i.imgur.com/f83xDyz.png"></p>
<hr>
<p>The result clearly shows that <code>LinkedList</code> is a whole lot more than
<code>ArrayList</code>, especially with a very high element count. If memory is a factor,
steer clear of <code>LinkedLists</code>.</p>
<p>The formulas I used follow, let me know if I have done anything wrong and I
will fix it up. 'b' is either 4 or 8 for 32 or 64 bit systems, and 'n' is the
number of elements. Note the reason for the mods is because all objects in
java will take up a multiple of 8 bytes space regardless of whether it is all
used or not.</p>
<p><strong>ArrayList:</strong></p>
<p><code>ArrayList object header + size integer + modCount integer + array reference +
(array oject header + b * n) + MOD(array oject, 8) + MOD(ArrayList object, 8)
== 8 + 4 + 4 + b + (12 + b * n) + MOD(12 + b * n, 8) + MOD(8 + 4 + 4 + b + (12
+ b * n) + MOD(12 + b * n, 8), 8)</code></p>
<p><strong>LinkedList:</strong></p>
<p><code>LinkedList object header + size integer + modCount integer + reference to
header + reference to footer + (node object overhead + reference to previous
element + reference to next element + reference to element) * n) + MOD(node
object, 8) * n + MOD(LinkedList object, 8) == 8 + 4 + 4 + 2 * b + (8 + 3 * b)
* n + MOD(8 + 3 * b, 8) * n + MOD(8 + 4 + 4 + 2 * b + (8 + 3 * b) * n + MOD(8
+ 3 * b, 8) * n, 8)</code></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/arraylist/" rel="tag">arraylist</a></li>
            <li><a class="tag p-category" href="../../categories/collections/" rel="tag">collections</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/linked-list/" rel="tag">linked-list</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-is-dependency-injection/" rel="prev" title="What is dependency injection?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-loop-through-or-enumerate-a-javascript-object/" rel="next" title="How do I loop through or enumerate a JavaScript object?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
