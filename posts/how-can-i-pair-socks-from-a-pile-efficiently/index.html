<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How can I pair socks from a pile efficiently? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-can-i-pair-socks-from-a-pile-efficiently/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-is-restful-programming/" title="What is RESTful programming?" type="text/html">
<link rel="next" href="../iterating-over-dictionaries-using-for-loops/" title="Iterating over dictionaries using 'for' loops" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How can I pair socks from a pile efficiently?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-can-i-pair-socks-from-a-pile-efficiently/">
<meta property="og:description" content='Yesterday I was pairing the socks from the clean laundry and figured out the
way I was doing it is not very efficient. I was doing a naive search — picking
one sock and "iterating" the pile in order t'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T19:09:13+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="language-agnostic">
<meta property="article:tag" content="matching">
<meta property="article:tag" content="sorting">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How can I pair socks from a pile efficiently?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:09:13+08:00" itemprop="datePublished" title="2023-02-16 19:09">2023-02-16 19:09</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Yesterday I was pairing the socks from the clean laundry and figured out the
way I was doing it is not very efficient. I was doing a naive search — picking
one sock and "iterating" the pile in order to find its pair. This requires
iterating over n/2 * n/4 = n2/8 socks on average.</p>
<p>As a computer scientist I was thinking what I could do? Sorting (according to
size/color/...) of course came to mind to achieve an O(NlogN) solution.</p>
<p>Hashing or other not-in-place solutions are not an option, because I am not
able to duplicate my socks (though it could be nice if I could).</p>
<p><strong>So, the question is basically:</strong></p>
<p>Given a pile of <code>n</code> pairs of socks, containing <code>2n</code> elements (assume each sock
has exactly one matching pair), what is the best way to pair them up
efficiently with up to logarithmic extra space? (I believe I can remember that
amount of info if needed.)</p>
<p>I will appreciate an answer that addresses the following aspects:</p>
<ul>
<li>A general <em>theoretical</em> solution for a huge number of socks.</li>
<li>The actual number of socks is not that large, I don't believe my spouse and I have more than 30 pairs. (And it is fairly easy to distinguish between my socks and hers; can this be used as well?)</li>
<li>Is it equivalent to the element distinctness problem?</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p>Sorting solutions have been proposed, but <strong>sorting is a little too much</strong> :
We don't need order; <strong>we just need equality groups</strong>.</p>
<p>So <strong>hashing</strong> would be enough (and faster).</p>
<ol>
<li>For each color of socks, <strong>form a pile</strong>. Iterate over all socks in your input basket <strong>and distribute them onto the color piles</strong>.</li>
<li>Iterate over each pile and <strong>distribute it by some other metric</strong> (e.g. pattern) into the second set of piles</li>
<li>
<strong>Recursively apply this scheme</strong> until you have distributed all socks onto <strong>very small piles that you can visually process immediately</strong>
</li>
</ol>
<p>This kind of recursive hash partitioning is actually being done by SQL Server
when it needs to hash join or hash aggregate over huge data sets. It
distributes its build input stream into many partitions which are independent.
This scheme scales to arbitrary amounts of data and multiple CPUs linearly.</p>
<p>You don't need recursive partitioning if you can find a distribution key (hash
key) that <strong>provides enough buckets</strong> that each bucket is small enough to be
processed very quickly. Unfortunately, I don't think socks have such a
property.</p>
<p>If each sock had an integer called "PairID" one could easily distribute them
into 10 buckets according to <code>PairID % 10</code> (the last digit).</p>
<p>The best real-world partitioning I can think of is creating a <strong>rectangle of
piles</strong> : one dimension is color, the other is the pattern. Why a rectangle?
Because we need O(1) random-access to piles. (A 3D cuboid would also work, but
that is not very practical.)</p>
<hr>
<p>Update:</p>
<p>What about <strong>parallelism</strong>? Can multiple humans match the socks faster?</p>
<ol>
<li>The simplest parallelization strategy is to have multiple workers take from the input basket and put the socks onto the piles. This only scales up so much - imagine 100 people fighting over 10 piles. <strong>The synchronization costs</strong> (manifesting themselves as hand-collisions and human communication) <strong>destroy efficiency and speed-up</strong> (see the Universal Scalability Law!). Is this prone to <strong>deadlocks</strong>? No, because each worker only needs to access one pile at a time. With just one "lock" there cannot be a deadlock. <strong>Livelocks</strong> might be possible depending on how the humans coordinate access to piles. They might just use random backoff like network cards do that on a physical level to determine what card can exclusively access the network wire. If it works for NICs, it should work for humans as well.</li>
<li>It scales nearly indefinitely if <strong>each worker has its own set of piles</strong>. Workers can then take big chunks of socks from the input basket (very little contention as they are doing it rarely) and they do not need to synchronise when distributing the socks at all (because they have thread-local piles). At the end, all workers need to union their pile-sets. I believe that can be done in O(log (worker count * piles per worker)) if the workers form an <strong>aggregation tree</strong>.</li>
</ol>
<p>What about the element distinctness problem? As the article states, the
element distinctness problem can be solved in <code>O(N)</code>. This is the same for the
socks problem (also <code>O(N)</code>, if you need only one distribution step (I proposed
multiple steps only because humans are bad at calculations - one step is
enough if you distribute on <code>md5(color, length, pattern, ...)</code>, i.e. a
<strong>perfect hash</strong> of all attributes)).</p>
<p>Clearly, one cannot go faster than <code>O(N)</code>, so we have reached the <strong>optimal
lower bound</strong>.</p>
<p>Although the outputs are not exactly the same (in one case, just a boolean. In
the other case, the pairs of socks), the asymptotic complexities are the same.</p>
<p><br></p>
<h3>Suggest</h3>
<p>As the architecture of the human brain is completely different than a modern
CPU, this question makes no practical sense.</p>
<p>Humans can win over CPU algorithms using the fact that "finding a matching
pair" can be one operation for a set that isn't too big.</p>
<p>My algorithm:</p>
<div class="code"><pre class="code literal-block"><span class="nv">spread_all_socks_on_flat_surface</span><span class="ss">()</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">socks_left_on_a_surface</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="nv">Thanks</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">human</span><span class="w"> </span><span class="nv">visual</span><span class="w"> </span><span class="nv">SIMD</span>,<span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">one</span>,<span class="w"> </span><span class="nv">quick</span><span class="w"> </span><span class="nv">operation</span>.
<span class="w">     </span><span class="nv">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">notice_any_matching_pair</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">     </span><span class="nv">remove_socks_pair_from_surface</span><span class="ss">(</span><span class="nv">pair</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>At least this is what I am using in real life, and I find it very efficient.
The downside is it requires a flat surface, but it's usually abundant.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/language-agnostic/" rel="tag">language-agnostic</a></li>
            <li><a class="tag p-category" href="../../categories/matching/" rel="tag">matching</a></li>
            <li><a class="tag p-category" href="../../categories/sorting/" rel="tag">sorting</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-is-restful-programming/" rel="prev" title="What is RESTful programming?">Previous post</a>
            </li>
            <li class="next">
                <a href="../iterating-over-dictionaries-using-for-loops/" rel="next" title="Iterating over dictionaries using 'for' loops">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
