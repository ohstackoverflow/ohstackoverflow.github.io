<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>C++ 容器的迭代器失效规则 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/c-rong-qi-de-die-dai-qi-shi-xiao-gui-ze/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-shi-yong-sql-server-2008-da-kai-he-guan-bi-identity-insert/" title="如何使用 SQL Server 2008 打开和关闭 IDENTITY_INSERT？" type="text/html">
<link rel="next" href="../ru-he-hen-hao-di-jiang-fu-dian-shu-ge-shi-hua-wei-mei-you-bu-bi-yao-de-shi-jin-zhi-0-de-zi-fu-chuan/" title="如何很好地将浮点数格式化为没有不必要的十进制 0 的字符串" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="C++ 容器的迭代器失效规则">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/c-rong-qi-de-die-dai-qi-shi-xiao-gui-ze/">
<meta property="og:description" content="这个问题的答案是 社区的努力。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。
C++容器的迭代器失效规则是什么？
（ 注意： 这个问答是Stack Overflow 的 C++
FAQ中的一个条目。关于问题本身的元讨论应该发布在开始所有这些的元问题上，而不是在这里。）

解答
C++17 （所有参考资料均来自 CPP17 - n4659的最终工作草案）

插入
序列容器


vector">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T01:20:24+08:00">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="cPlusPlus-faq">
<meta property="article:tag" content="cPlusPlus-standard-library">
<meta property="article:tag" content="iterator">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">C++ 容器的迭代器失效规则</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:20:24+08:00" itemprop="datePublished" title="2023-02-18 01:20">2023-02-18 01:20</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>C++容器的迭代器失效规则是什么？</p>
<p>（ <strong>注意：</strong> 这个问答是Stack Overflow 的 C++
FAQ中的一个条目。关于问题本身的元讨论应该发布在开始所有这些的元问题上，而不是在这里。）</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>C++17 （所有参考资料均来自 CPP17 -</strong> n4659的最终工作草案）</p>
<hr>
<h2>插入</h2>
<p><em>序列容器</em></p>
<ul>
<li>
<p><code>vector</code>: The functions <code>insert</code>, <code>emplace_back</code>, <code>emplace</code>, <code>push_back</code> cause reallocation if the new size is greater than the old capacity. Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence. If no reallocation happens, all the iterators and references before the insertion point remain valid. [26.3.11.5/1]<br>
With respect to the <code>reserve</code> function, reallocation invalidates all the
references, pointers, and iterators referring to the elements in the sequence.
No reallocation shall take place during insertions that happen after a call to
<code>reserve()</code> until the time when an insertion would make the size of the vector
greater than the value of <code>capacity()</code>. [26.3.11.3/6]</p>
</li>
<li>
<p><code>deque</code>: An insertion in the middle of the deque invalidates all the iterators and references to elements of the deque. An insertion at either end of the deque invalidates all the iterators to the deque, but has no effect on the validity of references to elements of the deque. [26.3.8.4/1]</p>
</li>
<li>
<p><code>list</code>: Does not affect the validity of iterators and references. If an exception is thrown there are no effects. [26.3.10.4/1].<br>
The <code>insert</code>, <code>emplace_front</code>, <code>emplace_back</code>, <code>emplace</code>, <code>push_front</code>,
<code>push_back</code> functions are covered under this rule.</p>
</li>
<li>
<p><code>forward_list</code>: None of the overloads of <code>insert_after</code> shall affect the validity of iterators and references [26.3.9.5/1]</p>
</li>
<li>
<p><code>array</code>: As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.</p>
</li>
</ul>
<p><em>Associative Containers</em></p>
<ul>
<li>
<code>All Associative Containers</code>: The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators and references to the container [26.2.6/9]</li>
</ul>
<p><em>Unordered Associative Containers</em></p>
<ul>
<li>
<p><code>All Unordered Associative Containers</code>: Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. [26.2.7/9]<br>
The <code>insert</code> and <code>emplace</code> members shall not affect the validity of references
to container elements, but may invalidate all iterators to the container.
[26.2.7/14]<br>
The <code>insert</code> and <code>emplace</code> members shall not affect the validity of iterators
if <code>(N+n) &lt;= z * B</code>, where <code>N</code> is the number of elements in the container
prior to the insert operation, <code>n</code> is the number of elements inserted, <code>B</code> is
the container’s bucket count, and <code>z</code> is the container’s maximum load factor.
[26.2.7/15]</p>
</li>
<li>
<p><code>All Unordered Associative Containers</code>: In case of a merge operation (e.g., <code>a.merge(a2)</code>), iterators referring to the transferred elements and all iterators referring to <code>a</code> will be invalidated, but iterators to elements remaining in <code>a2</code> will remain valid. (Table 91 — Unordered associative container requirements)</p>
</li>
</ul>
<p><em>Container Adaptors</em></p>
<ul>
<li>
<code>stack</code>: inherited from underlying container</li>
<li>
<code>queue</code>: inherited from underlying container</li>
<li>
<code>priority_queue</code>: inherited from underlying container</li>
</ul>
<hr>
<h2>Erasure</h2>
<p><em>Sequence Containers</em></p>
<ul>
<li>
<p><code>vector</code>: The functions <code>erase</code> and <code>pop_back</code> invalidate iterators and references at or after the point of the erase. [26.3.11.5/3]</p>
</li>
<li>
<p><code>deque</code>: An erase operation that erases the last element of a <code>deque</code> invalidates only the past-the-end iterator and all iterators and references to the erased elements. An erase operation that erases the first element of a <code>deque</code> but not the last element invalidates only iterators and references to the erased elements. An erase operation that erases neither the first element nor the last element of a <code>deque</code> invalidates the past-the-end iterator and all iterators and references to all the elements of the <code>deque</code>. [ Note: <code>pop_front</code> and <code>pop_back</code> are erase operations. —end note ] [26.3.8.4/4]</p>
</li>
<li>
<p><code>list</code>: Invalidates only the iterators and references to the erased elements. [26.3.10.4/3]. This applies to <code>erase</code>, <code>pop_front</code>, <code>pop_back</code>, <code>clear</code> functions.<br><code>remove</code> and <code>remove_if</code> member functions: Erases all the elements in the list
referred by a list iterator <code>i</code> for which the following conditions hold: <code>*i
== value</code>, <code>pred(*i) != false</code>. Invalidates only the iterators and references
to the erased elements [26.3.10.5/15].<br><code>unique</code> member function - Erases all but the first element from every
consecutive group of equal elements referred to by the iterator <code>i</code> in the
range <code>[first + 1, last)</code> for which <code>*i == *(i-1)</code> (for the version of unique
with no arguments) or <code>pred(*i, *(i - 1))</code> (for the version of unique with a
predicate argument) holds. Invalidates only the iterators and references to
the erased elements. [26.3.10.5/19]</p>
</li>
<li>
<p><code>forward_list</code>: <code>erase_after</code> shall invalidate only iterators and references to the erased elements. [26.3.9.5/1].<br><code>remove</code> and <code>remove_if</code> member functions - Erases all the elements in the
list referred by a list iterator i for which the following conditions hold:
<code>*i == value</code> (for <code>remove()</code>), <code>pred(*i)</code> is true (for <code>remove_if()</code>).
Invalidates only the iterators and references to the erased elements.
[26.3.9.6/12].<br><code>unique</code> member function - Erases all but the first element from every
consecutive group of equal elements referred to by the iterator i in the range
[first + 1, last) for which <code>*i == *(i-1)</code> (for the version with no arguments)
or <code>pred(*i, *(i - 1))</code> (for the version with a predicate argument) holds.
Invalidates only the iterators and references to the erased elements.
[26.3.9.6/16]</p>
</li>
<li>
<p><code>All Sequence Containers</code>: <code>clear</code> invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator (Table 87 — Sequence container requirements). But for <code>forward_list</code>, <code>clear</code> does not invalidate past-the-end iterators. [26.3.9.5/32]</p>
</li>
<li>
<p><code>All Sequence Containers</code>: <code>assign</code> invalidates all references, pointers and iterators referring to the elements of the container. For <code>vector</code> and <code>deque</code>, also invalidates the past-the-end iterator. (Table 87 — Sequence container requirements)</p>
</li>
</ul>
<p><em>Associative Containers</em></p>
<ul>
<li>
<p><code>All Associative Containers</code>: The <code>erase</code> members shall invalidate only iterators and references to the erased elements [26.2.6/9]</p>
</li>
<li>
<p><code>All Associative Containers</code>: The <code>extract</code> members invalidate only iterators to the removed element; pointers and references to the removed element remain valid [26.2.6/10]</p>
</li>
</ul>
<p><em>Container Adaptors</em></p>
<ul>
<li>
<code>stack</code>: inherited from underlying container</li>
<li>
<code>queue</code>: inherited from underlying container</li>
<li>
<code>priority_queue</code>: inherited from underlying container</li>
</ul>
<hr>
<p><strong>General container requirements relating to iterator invalidation:</strong></p>
<ul>
<li>
<p>Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container. [26.2.1/12]</p>
</li>
<li>
<p>no <code>swap()</code> function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be invalidated. —end note ] [26.2.1/(11.6)]</p>
</li>
</ul>
<p><em>As examples of the above requirements:</em></p>
<ul>
<li>
<p><code>transform</code> algorithm: The <code>op</code> and <code>binary_op</code> functions shall not invalidate iterators or subranges, or modify elements in the ranges [28.6.4/1]</p>
</li>
<li>
<p><code>accumulate</code> algorithm: In the range [first, last], <code>binary_op</code> shall neither modify elements nor invalidate iterators or subranges [29.8.2/1]</p>
</li>
<li>
<p><code>reduce</code> algorithm: binary_op shall neither invalidate iterators or subranges, nor modify elements in the range [first, last]. [29.8.3/5]</p>
</li>
</ul>
<p>and so on...</p>
<p><br></p>
<h3>更多建议</h3>
<p><strong>C++11</strong> （来源：迭代器失效规则（C++0x））</p>
<hr>
<h2>插入</h2>
<p><em>序列容器</em></p>
<ul>
<li>
<code>vector</code>：插入点之前的所有迭代器和引用不受影响，除非新容器大小大于以前的容量（在这种情况下所有迭代器和引用都无效）[23.3.6.5/1]</li>
<li>
<code>deque</code>：所有迭代器和引用都无效，除非插入的成员位于双端队列的末端（前面或后面）（在这种情况下所有迭代器都无效，但对元素的引用不受影响）[23.3.3.4/1]</li>
<li>
<code>list</code>: 所有迭代器和引用不受影响 [23.3.5.4/1]</li>
<li>
<code>forward_list</code>：所有迭代器和引用不受影响 <em>（适用于<code>insert_after</code>）</em> [23.3.4.5/1]</li>
<li>
<code>array</code>：（ <em>不适用）</em>
</li>
</ul>
<p><em>关联容器</em></p>
<ul>
<li>
<code>[multi]{set,map}</code>：所有迭代器和引用不受影响 [23.2.4/9]</li>
</ul>
<p><em>未排序的关联容器</em></p>
<ul>
<li>
<code>unordered_[multi]{set,map}</code>：当重新散列发生时，所有迭代器都失效，但引用不受影响 [23.2.5/8]。如果插入不会导致容器的大小超过最大负载因子和当前桶数，则不会发生<code>z * B</code>重新<code>z</code>散列<code>B</code>。[23.2.5/14]</li>
</ul>
<p><em>容器适配器</em></p>
<ul>
<li>
<code>stack</code>: 继承自底层容器</li>
<li>
<code>queue</code>: 继承自底层容器</li>
<li>
<code>priority_queue</code>: 继承自底层容器</li>
</ul>
<hr>
<h2>擦除</h2>
<p><em>序列容器</em></p>
<ul>
<li>
<code>vector</code>：擦除点处或擦除点之后的每个迭代器和引用都无效 [23.3.6.5/3]</li>
<li>
<code>deque</code>：擦除最后一个元素只会使迭代器和对已擦除元素的引用以及尾后迭代器无效；擦除第一个元素只会使迭代器和对已擦除元素的引用无效；擦除任何其他元素会使所有迭代器和引用无效（包括尾后迭代器）[23.3.3.4/4]</li>
<li>
<code>list</code>：只有对已擦除元素的迭代器和引用无效 [23.3.5.4/3]</li>
<li>
<code>forward_list</code>：只有对被擦除元素的迭代器和引用无效 <em>（适用于<code>erase_after</code>）</em> [23.3.4.5/1]</li>
<li>
<code>array</code>：（ <em>不适用）</em>
</li>
</ul>
<p><em>关联容器</em></p>
<ul>
<li>
<code>[multi]{set,map}</code>：只有迭代器和对已擦除元素的引用无效 [23.2.4/9]</li>
</ul>
<p><em>无序关联容器</em></p>
<ul>
<li>
<code>unordered_[multi]{set,map}</code>：只有对已擦除元素的迭代器和引用无效 [23.2.5/13]</li>
</ul>
<p><em>容器适配器</em></p>
<ul>
<li>
<code>stack</code>: 继承自底层容器</li>
<li>
<code>queue</code>: 继承自底层容器</li>
<li>
<code>priority_queue</code>: 继承自底层容器</li>
</ul>
<hr>
<h2>调整大小</h2>
<ul>
<li>
<code>vector</code>：根据插入/擦除 [23.3.6.5/12]</li>
<li>
<code>deque</code>：根据插入/擦除 [23.3.3.3/3]</li>
<li>
<code>list</code>：根据插入/擦除 [23.3.5.3/1]</li>
<li>
<code>forward_list</code>：根据插入/擦除 [23.3.4.5/25]</li>
<li>
<code>array</code>：（不适用）</li>
</ul>
<hr>
<h3>注1</h3>
<blockquote>
<p><strong>除非另有规定</strong> （明确或通过根据其他函数定义函数），调用容器成员函数或将容器作为参数传递给 <strong>库函数不应使迭代器无效</strong> 或更改容器内对象的值.
[23.2.1/11]</p>
</blockquote>
<h3>笔记2</h3>
<blockquote>
<p><strong><em>*没有 swap() 函数会使引用被交换容器元素的 </em>*任何引用、指针或迭代器无效。</strong> [ 注意： <strong>end() 迭代器</strong>
不引用任何元素，因此它 <strong>可能无效</strong> 。——尾注] [23.2.1/10]</p>
</blockquote>
<h3>注3</h3>
<p>除了上述警告外<code>swap()</code>，尚不清楚“结束”迭代器是否受制于上面列出的每个容器规则；无论如何，您应该假设它们是。</p>
<h3>注 4</h3>
<p><code>vector</code>并且所有 <em>无序关联容器都</em> 支持<code>reserve(n)</code>，这保证至少在容器的大小增长到之前不会发生自动调整大小<code>n</code>。应谨慎使用
<em>无序关联容器</em> ，因为未来的提议将允许指定最小加载因子，这将允许<code>insert</code>在足够的<code>erase</code>操作将容器大小减小到最小值以下后进行重新散列；在 .
之后，担保应被视为可能无效<code>erase</code>。</p>
<p><br><br><a href="../iterator-invalidation-rules-for-c-containers/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus-faq/" rel="tag">cPlusPlus-faq</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus-standard-library/" rel="tag">cPlusPlus-standard-library</a></li>
            <li><a class="tag p-category" href="../../categories/iterator/" rel="tag">iterator</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-shi-yong-sql-server-2008-da-kai-he-guan-bi-identity-insert/" rel="prev" title="如何使用 SQL Server 2008 打开和关闭 IDENTITY_INSERT？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-hen-hao-di-jiang-fu-dian-shu-ge-shi-hua-wei-mei-you-bu-bi-yao-de-shi-jin-zhi-0-de-zi-fu-chuan/" rel="next" title="如何很好地将浮点数格式化为没有不必要的十进制 0 的字符串">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
