<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么是枚举，它们为什么有用？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-mei-ju-ta-men-wei-shi-yao-you-yong/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-zai-shell-jiao-ben-zhong-jin-xing-zheng-shu-bi-jiao-de-luo-ji-huo-yun-suan/" title="如何在 shell 脚本中进行整数比较的逻辑或运算？" type="text/html">
<link rel="next" href="../he-bing-ya-suo-lai-zi-ling-yi-ge-fen-zhi-de-suo-you-geng-gai-zuo-wei-dan-ge-ti-jiao/" title="合并（压缩）来自另一个分支的所有更改作为单个提交" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么是枚举，它们为什么有用？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-mei-ju-ta-men-wei-shi-yao-you-yong/">
<meta property="og:description" content="今天，我浏览了该站点上的一些问题，发现有人提到enum 在单例模式中使用了这种解决方案的线程安全优势。
我从未使用过enums，现在我已经使用 Java 编程多年了。显然，他们改变了很多。现在他们甚至在自己内部全面支持 OOP。
现在为什么以及我应该在日常编程中使用枚举？

解答
当变量（尤其是方法参数）只能从一小组可能值中取一个时，您应该始终使用枚举。例如类型常量（合同状态：“永久”、“临时”、">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T01:32:39+08:00">
<meta property="article:tag" content="enums">
<meta property="article:tag" content="java">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么是枚举，它们为什么有用？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:32:39+08:00" itemprop="datePublished" title="2023-02-18 01:32">2023-02-18 01:32</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>今天，我浏览了该站点上的一些问题，发现有人提到<code>enum</code> 在单例模式中使用了这种解决方案的线程安全优势。</p>
<p>我从未使用过<code>enum</code>s，现在我已经使用 Java 编程多年了。显然，他们改变了很多。现在他们甚至在自己内部全面支持 OOP。</p>
<h4>现在为什么以及我应该在日常编程中使用枚举？</h4>
<p><br><br></p>
<h2>解答</h2>
<p>当变量（尤其是方法参数）只能从一小组可能值中取一个时，您应该始终使用枚举。例如类型常量（合同状态：“永久”、“临时”、“学徒”）或标志（“立即执行”、“延迟执行”）。</p>
<p>如果您使用枚举而不是整数（或字符串代码），您会增加编译时检查并避免因传递无效常量而导致的错误，并且您会记录哪些值可以合法使用。</p>
<p>顺便说一句，过度使用枚举可能意味着你的方法做的太多（最好有几个单独的方法，而不是一个方法采用多个标志来修改它的作用），但是如果你必须使用标志或类型代码，枚举是要走的路。</p>
<p>举个例子，哪个更好？</p>
<div class="code"><pre class="code literal-block"><span class="o">/**</span><span class="w"> </span><span class="n">Counts</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="p">.</span>
<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">@</span><span class="n">param</span><span class="w"> </span><span class="nb">type</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">count</span><span class="p">.</span><span class="w"> </span><span class="n">Can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="mi">1</span><span class="p">=</span><span class="n">green</span><span class="w"> </span><span class="n">foobangs</span><span class="p">,</span>
<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">=</span><span class="n">wrinkled</span><span class="w"> </span><span class="n">foobangs</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">=</span><span class="n">sweet</span><span class="w"> </span><span class="n">foobangs</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">=</span><span class="n">all</span><span class="w"> </span><span class="n">types</span><span class="p">.</span>
<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">@</span><span class="k">return</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb">type</span>
<span class="w"> </span><span class="o">*/</span>
<span class="n">public</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">countFoobangs</span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="nb">type</span><span class="p">)</span>
</pre></div>

<p>相对</p>
<div class="code"><pre class="code literal-block"><span class="o">/**</span><span class="w"> </span><span class="n">Types</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="o">.</span><span class="w"> </span><span class="o">*/</span>
<span class="n">public</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">FB_TYPE</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">GREEN</span><span class="p">,</span><span class="w"> </span><span class="n">WRINKLED</span><span class="p">,</span><span class="w"> </span><span class="n">SWEET</span><span class="p">,</span><span class="w"> </span>
<span class="w"> </span><span class="o">/**</span><span class="w"> </span><span class="n">special</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">combined</span><span class="w"> </span><span class="o">*/</span>
<span class="w"> </span><span class="n">ALL</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">/**</span><span class="w"> </span><span class="n">Counts</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="o">.</span>
<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">@</span><span class="n">param</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">count</span>
<span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">@</span><span class="k">return</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foobangs</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span>
<span class="w"> </span><span class="o">*/</span>
<span class="n">public</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">countFoobangs</span><span class="p">(</span><span class="n">FB_TYPE</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
</pre></div>

<p>方法调用如下：</p>
<div class="code"><pre class="code literal-block">int sweetFoobangCount = countFoobangs(3);
</pre></div>

<p>然后变成：</p>
<div class="code"><pre class="code literal-block">int sweetFoobangCount = countFoobangs(FB_TYPE.SWEET);
</pre></div>

<hr>
<p>在第二个示例中，可以立即清楚哪些类型是允许的，文档和实现不能不同步，并且编译器可以强制执行此操作。另外，无效的调用如</p>
<div class="code"><pre class="code literal-block">int sweetFoobangCount = countFoobangs(99);
</pre></div>

<p>不再可能。</p>
<p><br></p>
<h3>更多建议</h3>
<p>为什么要使用任何编程语言功能？我们拥有语言的原因是</p>
<ol>
<li>程序员以计算机可以使用的形式有效和 <em>正确地表达算法。</em>
</li>
<li>维护者理解其他人编写的算法并 <em>正确地</em> 进行更改。</li>
</ol>
<p>枚举提高了正确性和可读性的可能性，而无需编写大量样板。如果您愿意编写样板文件，那么您可以“模拟”枚举：</p>
<div class="code"><pre class="code literal-block">public class Color {
    private Color() {} // Prevent others from making colors.
    public static final Color RED = new Color();
    public static final Color AMBER = new Color();
    public static final Color GREEN = new Color();
}
</pre></div>

<p>现在你可以写：</p>
<div class="code"><pre class="code literal-block">Color trafficLightColor = Color.RED;
</pre></div>

<p>上面的样板与</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nb nb-Type">Color</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">RED</span><span class="p">,</span><span class="w"> </span><span class="n">AMBER</span><span class="p">,</span><span class="w"> </span><span class="n">GREEN</span><span class="w"> </span><span class="p">};</span>
</pre></div>

<p>两者都提供来自编译器的相同级别的检查帮助。样板只是更多的打字。但是节省大量的输入可以让程序员更有 <em>效率</em> （见 1），所以这是一个有价值的特性。</p>
<p>至少还有一个原因是值得的：</p>
<p><strong>开关语句</strong></p>
<p><code>static final</code>上面的枚举模拟 <em>没有</em> 给你的一件事是很好的<code>switch</code>案例。对于枚举类型，Java
开关使用其变量的类型来推断枚举案例的范围，因此对于上面<code>enum Color</code>你只需要说：</p>
<div class="code"><pre class="code literal-block"><span class="nt">Color</span><span class="w"> </span><span class="nt">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">;</span>
<span class="nt">switch</span><span class="w"> </span><span class="o">(</span><span class="nt">color</span><span class="o">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">case</span><span class="w"> </span><span class="n">RED</span><span class="p">:</span>
<span class="w">        </span><span class="o">...</span>
<span class="w">        </span><span class="n">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>请注意，它不在<code>Color.RED</code>案例中。如果您不使用枚举，则使用命名数量的唯一方法<code>switch</code>是：</p>
<div class="code"><pre class="code literal-block">public Class Color {
    public static final int RED = 0;
    public static final int AMBER = 1;
    public static final int GREEN = 2;
}
</pre></div>

<p>但是现在保存颜色的变量必须有类型<code>int</code>。枚举和<code>static final</code>模拟的良好编译器检查消失了。不开心。</p>
<p>折衷方案是在模拟中使用标量值成员：</p>
<div class="code"><pre class="code literal-block">public class Color {
    public static final int RED_TAG = 1;
    public static final int AMBER_TAG = 2;
    public static final int GREEN_TAG = 3;

    public final int tag;

    private Color(int tag) { this.tag = tag; } 
    public static final Color RED = new Color(RED_TAG);
    public static final Color AMBER = new Color(AMBER_TAG);
    public static final Color GREEN = new Color(GREEN_TAG);
}
</pre></div>

<p>现在：</p>
<div class="code"><pre class="code literal-block"><span class="nt">Color</span><span class="w"> </span><span class="nt">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">;</span>
<span class="nt">switch</span><span class="w"> </span><span class="o">(</span><span class="nt">color</span><span class="p">.</span><span class="nc">tag</span><span class="o">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">case</span><span class="w"> </span><span class="err">Color.</span><span class="n">RED_TAG</span><span class="p">:</span>
<span class="w">        </span><span class="o">...</span>
<span class="w">        </span><span class="n">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>但请注意，还有更多样板文件！</p>
<p><strong>使用枚举作为单例</strong></p>
<p>从上面的样板文件中，您可以看出为什么枚举提供了一种实现单例的方法。而不是写：</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">final</span><span class="w"> </span><span class="nv">void</span><span class="w"> </span><span class="nv">INSTANCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">private</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="ss">()</span><span class="w"> </span>{}

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">methods</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">instance</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">here</span>
}
</pre></div>

<p>然后访问它</p>
<div class="code"><pre class="code literal-block">SingletonClass.INSTANCE
</pre></div>

<p>我们只能说</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">SingletonClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">INSTANCE</span><span class="p">;</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">here</span>
<span class="p">}</span>
</pre></div>

<p>这给了我们同样的东西。我们可以避开这个问题，因为 Java 枚举 <em>是</em>
作为完整的类实现的，只是在顶部撒了一点语法糖。这又是一个较少的样板文件，但除非您熟悉这个成语，否则它并不明显。我也不喜欢这样一个事实，即你得到了各种枚举函数，即使它们对单例没有多大意义：<code>ord</code>和<code>values</code>等。<code>Color
extends Integer</code>清楚地表明为什么<code>enum</code>是一个更好的主意。）</p>
<p><strong>线程安全</strong></p>
<p>只有在没有锁定的情况下懒惰地创建单例时，线程安全才是一个潜在的问题。</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">private</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="w"> </span><span class="nv">INSTANCE</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">private</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="ss">()</span><span class="w"> </span>{}
<span class="w">    </span><span class="nv">public</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="w"> </span><span class="nv">getInstance</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">INSTANCE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">null</span><span class="ss">)</span><span class="w"> </span><span class="nv">INSTANCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">SingletonClass</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">INSTANCE</span><span class="c1">;</span>
<span class="w">    </span>}

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">methods</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">instance</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">here</span>
}
</pre></div>

<p>如果许多线程<code>getInstance</code>同时调用，而<code>INSTANCE</code>仍然是
null，则可以创建任意数量的实例。这不好。唯一的解决方案是添加<code>synchronized</code>访问权限以保护变量<code>INSTANCE</code>。</p>
<p>但是，<code>static final</code>上面的代码没有这个问题。它在类加载时急切地创建实例。类加载是同步的。</p>
<p>单<code>enum</code>例实际上是惰性的，因为它直到第一次使用才被初始化。Java 初始化也是同步的，所以多个线程不能初始化多个<code>INSTANCE</code>.
您将获得一个代码很少的惰性初始化单例。唯一的缺点是相当晦涩的语法。您需要知道这个惯用语或彻底了解类加载和初始化的工作原理才能知道发生了什么。</p>
<p><br><br><a href="../what-are-enums-and-why-are-they-useful/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/enums/" rel="tag">enums</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-zai-shell-jiao-ben-zhong-jin-xing-zheng-shu-bi-jiao-de-luo-ji-huo-yun-suan/" rel="prev" title="如何在 shell 脚本中进行整数比较的逻辑或运算？">Previous post</a>
            </li>
            <li class="next">
                <a href="../he-bing-ya-suo-lai-zi-ling-yi-ge-fen-zhi-de-suo-you-geng-gai-zuo-wei-dan-ge-ti-jiao/" rel="next" title="合并（压缩）来自另一个分支的所有更改作为单个提交">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
