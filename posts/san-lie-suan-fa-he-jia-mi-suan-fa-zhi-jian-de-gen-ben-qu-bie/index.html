<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>散列算法和加密算法之间的根本区别 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/san-lie-suan-fa-he-jia-mi-suan-fa-zhi-jian-de-gen-ben-qu-bie/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../wei-shi-yao-javade-mainfang-fa-shi-jing-tai-de/" title="为什么Java的main方法是静态的？" type="text/html">
<link rel="next" href="../ru-he-bei-fen-mysqlshu-ju-ku-zhong-de-dan-ge-biao/" title="如何备份MySQL数据库中的单个表？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="散列算法和加密算法之间的根本区别">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/san-lie-suan-fa-he-jia-mi-suan-fa-zhi-jian-de-gen-ben-qu-bie/">
<meta property="og:description" content="我发现哈希和加密算法之间存在很多混淆，我想听听更多关于以下方面的专家建议：


何时使用哈希与加密


什么使散列或加密算法不同（从理论/数学水平）即什么使散列不可逆（没有彩虹树的帮助）


以下是一些 类似的 SO 问题，但没有像我所寻找的那样详细：
混淆、散列和加密之间有什么区别？
加密和哈希之间的区别

解答
好吧，你可以在维基百科上查找它......但是既然你想要一个解释，我会在这里尽力而">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T06:11:58+08:00">
<meta property="article:tag" content="cryptography">
<meta property="article:tag" content="encryption">
<meta property="article:tag" content="hash">
<meta property="article:tag" content="security">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">散列算法和加密算法之间的根本区别</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T06:11:58+08:00" itemprop="datePublished" title="2023-02-18 06:11">2023-02-18 06:11</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我发现哈希和加密算法之间存在很多混淆，我想听听更多关于以下方面的专家建议：</p>
<ol>
<li>
<p>何时使用哈希与加密</p>
</li>
<li>
<p>什么使散列或加密算法不同（从理论/数学水平）即什么使散列不可逆（没有彩虹树的帮助）</p>
</li>
</ol>
<p>以下是一些 <em>类似的</em> SO 问题，但没有像我所寻找的那样详细：</p>
<p>混淆、散列和加密之间有什么区别？<br>
加密和哈希之间的区别</p>
<p><br><br></p>
<h2>解答</h2>
<p>好吧，你可以在维基百科上查找它......但是既然你想要一个解释，我会在这里尽力而为：</p>
<h3>哈希函数</h3>
<p>它们提供任意长度输入和（通常）固定长度（或更小长度）输出之间的映射。它可以是任何东西，从简单的 crc32 到完整的加密哈希函数，例如 MD5 或
SHA1/2/256/512。关键是正在进行单向映射。它始终是多对一映射（意味着总会有冲突），因为每个函数产生的输出都小于它能够输入的输出（如果将每个可能的
1mb 文件都提供给 MD5，就会发生大量冲突）。</p>
<p>它们难以（或实际上不可能）逆转的原因是它们的内部运作方式。大多数加密哈希函数会多次迭代输入集以产生输出。因此，如果我们查看每个固定长度的输入块（取决于算法），散列函数将调用它的当前状态。然后它将迭代状态并将其更改为新状态并将其用作自身的反馈（MD5
对每个 512 位数据块执行此操作 64 次）。然后它以某种方式将所有这些迭代的结果状态重新组合在一起以形成结果哈希。</p>
<p>现在，如果你想解码散列，你首先需要弄清楚如何将给定的散列拆分成它的迭代状态（一种可能性是输入小于数据块的大小，很多是更大的输入）。然后你需要反转每个状态的迭代。现在，要解释为什么这非常困难，请想象一下尝试从以下公式中推导出<code>a</code>和：
。有 10 种正向组合和可以起作用。现在循环多次：<code>b``10 = a + b``a``b``tmp = a + b; a = b; b = tmp</code>.
对于 64 次迭代，您可以尝试超过 10^64 种可能性。这只是一个简单的添加，其中一些状态在迭代之间被保留。真正的散列函数执行的操作远不止 1 次（MD5
对 4 个状态变量执行大约 15
次操作）。由于下一次迭代取决于前一次的状态，而前一次在创建当前状态时被破坏，因此几乎不可能确定导致给定输出状态的输入状态（对于每次迭代都不少）。将其与所涉及的大量可能性相结合，即使是
MD5 解码也将占用近乎无限（但不是无限）的资源量。这么多的资源，它'</p>
<h3>加密功能</h3>
<p>它们提供任意长度输入和输出之间的 1:1 映射。而且它们总是可逆的。需要注意的重要一点是，使用某种方法它是可逆的。对于给定的密钥，它始终是
1:1。现在，有多个输入：密钥对可能会生成相同的输出（实际上通常有，具体取决于加密功能）。良好的加密数据与随机噪声无法区分。这与始终具有一致格式的良好哈希输出不同。</p>
<h3>用例</h3>
<p>当您想要比较一个值但不能存储普通表示（出于多种原因）时，请使用哈希函数。密码应该非常适合这种用例，因为出于安全原因您不想（也不应该）将它们存储为纯文本。但是，如果您想检查文件系统中的盗版音乐文件怎么办？每个音乐文件存储
3 MB 是不切实际的。因此，取而代之的是获取文件的哈希值并存储它（md5 将存储 16 个字节而不是
3mb）。这样，您只需散列每个文件并与存储的散列数据库进行比较（由于重新编码、更改文件头等，这在实践中效果不佳，但这是一个示例用例）。</p>
<p>在检查输入数据的有效性时使用散列函数。这就是它们的设计目的。如果您有 2
个输入，并且想检查它们是否相同，请通过哈希函数运行两者。对于小的输入大小（假设一个好的散列函数），发生碰撞的概率在天文数字上很低。这就是为什么建议使用密码。对于最多
32 个字符的密码，md5 有 4 倍的输出空间。SHA1 有 6 倍的输出空间（大约）。SHA512 有大约 16 倍的输出空间。您并不真正关心密码
<em>是</em> 什么，您关心的是它是否与存储的密码相同。这就是为什么您应该使用哈希作为密码。</p>
<p>每当您需要取回输入数据时使用加密。 <strong>注意需要</strong>
这个词。如果您正在存储信用卡号码，您需要在某个时候将它们取回，但又不想以纯文本形式存储它们。因此，相反，存储加密版本并尽可能保持密钥安全。</p>
<p>哈希函数也非常适合签名数据。例如，如果您使用的是 HMAC，则可以通过获取与已知但未传输的值（秘密值）连接的数据的散列来签署一段数据。因此，您发送纯文本和
HMAC 哈希。然后，接收方简单地使用已知值对提交的数据进行哈希处理，并检查它是否与传输的 HMAC
匹配。如果相同，则您知道它没有被没有秘密值的一方篡改。这通常用于 HTTP 框架的安全 cookie 系统，以及通过 HTTP
进行的数据消息传输，您需要在其中确保数据的完整性。</p>
<h3>关于密码哈希的说明：</h3>
<p>加密散列函数的一个关键特征是它们的创建速度应该非常快，并且逆向 <strong>非常困难/缓慢（以至于几乎不可能）。</strong>
这会带来密码问题。如果你存储<code>sha512(password)</code>，你就没有做任何事情来防止彩虹表或暴力攻击。请记住，哈希函数是为提高速度而设计的。因此，对于攻击者来说，只需通过哈希函数运行字典并测试每个结果是微不足道的。</p>
<p>添加盐会有所帮助，因为它会向散列中添加一些未知数据。因此，他们不需要找到任何匹配的东西<code>md5(foo)</code>，而是需要找到添加到已知盐中会产生的东西<code>md5(foo.salt)</code>（这很难做到）。但它仍然没有解决速度问题，因为如果他们知道盐分，那只是通过字典运行的问题。</p>
<p>因此，有一些方法可以解决这个问题。一种流行的方法称为键加强（或键拉伸）。基本上，您多次迭代哈希（通常为数千次）。这有两件事。首先，它显着减慢了哈希算法的运行时间。其次，如果实施得当（在每次迭代中将输入和盐传回）实际上会增加输出的熵（可用空间），从而减少碰撞的机会。一个简单的实现是：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="nb">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">salt</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sha512</span><span class="p">(</span><span class="nb">hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">salt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>还有其他更标准的实现，例如PBKDF2、BCrypt。但是这种技术被相当多的安全相关系统使用（例如 PGP、WPA、Apache 和 OpenSSL）。</p>
<p>归根结底，<code>hash(password)</code>还不够好。<code>hash(password +
salt)</code>更好，但仍然不够好......使用扩展哈希机制来生成你的密码哈希......</p>
<h3>关于琐碎拉伸的另一个注意事项</h3>
<p><strong>在任何情况下都不要将一个散列的输出直接反馈给散列函数</strong> ：</p>
<div class="code"><pre class="code literal-block"><span class="nv">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sha512</span><span class="ss">(</span><span class="nv">password</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">salt</span><span class="ss">)</span><span class="c1">; </span>
<span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; 1000; i++) {</span>
<span class="w">    </span><span class="nv">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sha512</span><span class="ss">(</span><span class="nv">hash</span><span class="ss">)</span><span class="c1">; // &lt;-- Do NOT do this!</span>
}
</pre></div>

<p>其原因与碰撞有关。请记住，所有哈希函数都会发生冲突，因为可能的输出空间（可能输出的数量）小于输入空间。要了解原因，让我们看看会发生什么。作为序言，让我们假设有
0.001% 的碰撞几率<code>sha1()</code>（在现实中要低 <strong>得多</strong> ，但出于演示目的）。</p>
<div class="code"><pre class="code literal-block">hash1 = sha1(password + salt);
</pre></div>

<p>现在，<code>hash1</code>碰撞概率为 0.001%。但是当我们做下一步时<code>hash2 = sha1(hash1);</code>，
<strong>所有的碰撞<code>hash1</code>自动变成碰撞<code>hash2</code></strong>。所以现在，我们的 hash1 的利率为
0.001%，第二次<code>sha1()</code>调用增加了这一点。所以现在，<code>hash2</code>碰撞概率为
0.002%。那是两倍的机会！每次迭代都会<code>0.001%</code>为结果增加另一个碰撞机会。因此，经过 1000 次迭代，碰撞的几率从微不足道的 0.001%
跃升至 1%。现在，退化是线性的，实际概率要 <strong>小得多</strong> ，但效果是相同的（单次碰撞概率的估计<code>md5</code>约为 1/(2 128 ) 或 1/(3x10
38). 虽然这看起来很小，但由于生日攻击，它并不像看起来那么小）。</p>
<p>相反，通过每次重新附加盐和密码，您将数据重新引入哈希函数。因此，任何特定回合的任何碰撞都不再是下一轮的碰撞。所以：</p>
<div class="code"><pre class="code literal-block"><span class="nv">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sha512</span><span class="ss">(</span><span class="nv">password</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">salt</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; 1000; i++) {</span>
<span class="w">    </span><span class="nv">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sha512</span><span class="ss">(</span><span class="nv">hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">password</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">salt</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>与本机函数具有相同的碰撞机会<code>sha512</code>。这就是你想要的。改用那个。</p>
<p><br></p>
<h3>更多建议</h3>
<p>哈希函数可以被认为与烤一条面包相同。您从输入（面粉、水、酵母等）开始，在应用哈希函数（混合 + 烘焙）后，您最终得到一个输出：一条面包。</p>
<p>走另一条路是非常困难的——你不能真正把面包重新分成面粉、水、酵母——其中一些在烘焙过程中丢失了，你永远无法确切地说出用了多少水、面粉或酵母。一个特定的面包，因为该信息被散列函数（又名烤箱）破坏了。</p>
<p>理论上，输入的许多不同变体会产生相同的面包（例如，2 杯水和 1 茶匙酵母产生的面包与 2.1 杯水和 0.9
茶匙酵母产生的面包完全相同），但是给定其中一个面包，您无法分辨究竟是什么输入组合产生了它。</p>
<p>另一方面，加密可以看作是一个保险箱。无论你放在那里什么都会回来，只要你拥有最初用来锁定它的钥匙。这是一个对称操作。给定一个键和一些输入，你会得到一个特定的输出。鉴于该输出和相同的密钥，您将取回原始输入。这是一个
1:1 的映射。</p>
<p><br><br><a href="../fundamental-difference-between-hashing-and-encryption-algorithms/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cryptography/" rel="tag">cryptography</a></li>
            <li><a class="tag p-category" href="../../categories/encryption/" rel="tag">encryption</a></li>
            <li><a class="tag p-category" href="../../categories/hash/" rel="tag">hash</a></li>
            <li><a class="tag p-category" href="../../categories/security/" rel="tag">security</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../wei-shi-yao-javade-mainfang-fa-shi-jing-tai-de/" rel="prev" title="为什么Java的main方法是静态的？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-bei-fen-mysqlshu-ju-ku-zhong-de-dan-ge-biao/" rel="next" title="如何备份MySQL数据库中的单个表？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
