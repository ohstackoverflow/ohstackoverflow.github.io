<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>__slots__ 的使用？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/slots-de-shi-yong/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-tong-guo-ti-jiao-xiao-xi-sou-suo-git-cun-chu-ku/" title="如何通过提交消息搜索 Git 存储库？" type="text/html">
<link rel="next" href="../ru-he-zai-div-kuai-nei-jiang-wen-ben-shui-ping-he-chui-zhi-ju-zhong/" title="如何在 div 块内将文本（水平和垂直）居中？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="__slots__ 的使用？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/slots-de-shi-yong/">
<meta property="og:description" content="在 Python 中的目的是什么__slots__——特别是关于我什么时候想使用它，什么时候不想使用它？

解答

在 Python 中，这样做的目的是什么__slots__，在什么情况下应该避免这样做？

TLDR：
特殊属性__slots__允许您明确说明您希望对象实例具有哪些实例属性，以及预期的结果：

更快的 属性访问。
*节省内存 *空间。

空间节省来自

将值引用存储在槽中而不是__">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:11:28+08:00">
<meta property="article:tag" content="oop">
<meta property="article:tag" content="python">
<meta property="article:tag" content="python-internals">
<meta property="article:tag" content="slots">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">__slots__ 的使用？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:11:28+08:00" itemprop="datePublished" title="2023-02-17 05:11">2023-02-17 05:11</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>在 Python 中的目的是什么<code>__slots__</code>——特别是关于我什么时候想使用它，什么时候不想使用它？</p>
<p><br><br></p>
<h2>解答</h2>
<blockquote>
<h2>在 Python 中，这样做的目的是什么<code>__slots__</code>，在什么情况下应该避免这样做？</h2>
</blockquote>
<h3>TLDR：</h3>
<p>特殊属性<code>__slots__</code>允许您明确说明您希望对象实例具有哪些实例属性，以及预期的结果：</p>
<ol>
<li>
<strong>更快的</strong> 属性访问。</li>
<li><strong><em>*节省内存 </em>*空间。</strong></li>
</ol>
<p>空间节省来自</p>
<ol>
<li>将值引用存储在槽中而不是<code>__dict__</code>.</li>
<li>如果父类拒绝它们并且您声明，则拒绝<code>__dict__</code>和创建。<code>__weakref__``__slots__</code>
</li>
</ol>
<h4>快速警告</h4>
<p>小警告，你应该只在继承树中声明一个特定的插槽一次。例如：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Base:</span>
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>

<span class="k">class</span> <span class="n">Right</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = <span class="s">'baz'</span>,

<span class="k">class</span> <span class="n">Wrong</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>, <span class="s">'baz'</span>        <span class="c1"># redundant foo and bar</span>
</pre></div>

<p>当你弄错时 Python 不会反对（它可能应该），问题可能不会以其他方式表现出来，但你的对象将占用比它们应该占用的空间更多的空间。Python 3.8：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">getsizeof</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">Right</span><span class="p">()),</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">Wrong</span><span class="p">())</span>
<span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">)</span>
</pre></div>

<p>这是因为 Base 的插槽描述符有一个与 Wrong 的插槽分开的插槽。这通常不应该出现，但它可以：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; w = Wrong()
&gt;&gt;&gt; w.foo = 'foo'
&gt;&gt;&gt; Base.foo.__get__(w)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: foo
&gt;&gt;&gt; Wrong.foo.__get__(w)
'foo'
</pre></div>

<p>最大的警告是多重继承 - 不能组合多个“具有非空插槽的父类”。</p>
<p>为了适应这一限制，请遵循最佳实践：除一个或所有父类之外的所有抽象，他们的具体类和您的新具体类将共同从中继承 - 给抽象空槽（就像抽象基类中的标准库）。</p>
<p>有关示例，请参见下面的多重继承部分。</p>
<h4>要求：</h4>
<ul>
<li>
<p>要将名为 in 的属性<code>__slots__</code>实际存储在槽中而不是 a 中<code>__dict__</code>，类必须继承自<code>object</code>（在 Python 3 中是自动的，但在 Python 2 中必须是显式的）。</p>
</li>
<li>
<p>要防止创建 a <code>__dict__</code>，您必须继承自<code>object</code>并且继承中的所有类都必须声明<code>__slots__</code>并且它们都不能有<code>'__dict__'</code>条目。</p>
</li>
</ul>
<p>如果您想继续阅读，这里有很多细节。</p>
<h3>为什么使用<code>__slots__</code>：更快的属性访问。</h3>
<p>Python 的创建者 Guido van Rossum表示，他实际上是<code>__slots__</code>为了更快的属性访问而创建的。</p>
<p>证明可测量的显着更快的访问是微不足道的：</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">timeit</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">'foo'</span><span class="p">,</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">slotted</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">not_slotted</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">get_set_delete_fn</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_set_delete</span><span class="p">():</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">'foo'</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
        <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
    <span class="k">return</span> <span class="n">get_set_delete</span>
</pre></div>

<p>和</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(slotted)))
0.2846834529991611
&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(not_slotted)))
0.3664822799983085
</pre></div>

<p>在 Ubuntu 上的 Python 3.5 中，时隙访问快了近 30%。</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; 0.3664822799983085 / 0.2846834529991611
1.2873325658284342
</pre></div>

<p>在 Windows 上的 Python 2 中，我测得它快了大约 15%。</p>
<h3>为什么使用<code>__slots__</code>：内存节省</h3>
<p>的另一个目的<code>__slots__</code>是减少每个对象实例在内存中占用的空间。</p>
<p>我自己对文档的贡献清楚地说明了这背后的原因：</p>
<blockquote>
<p>通过使用节省的空间<code>__dict__</code>可能很重要。</p>
</blockquote>
<p>SQLAlchemy 将大量内存节省归功于<code>__slots__</code>.</p>
<p>为了验证这一点，在 Ubuntu Linux 上使用 Python 2.7 的 Anaconda 发行版，带有<code>guppy.hpy</code>（又名
heapy）和<code>sys.getsizeof</code>，没有声明的类实例的大小<code>__slots__</code>，没有别的，是 64 字节。这 <em>不</em> 包括<code>__dict__</code>.
再次感谢 Python
的惰性求值，<code>__dict__</code>显然在被引用之前不会被调用，但是没有数据的类通常是无用的。当调用存在时，该<code>__dict__</code>属性至少为 280 字节。</p>
<p>相比之下，一个<code>__slots__</code>声明为<code>()</code>（无数据）的类实例只有 16 个字节，槽中有一项的总字节数为 56，槽中有项的总字节数为 64。</p>
<p>对于 64 位 Python，我说明了 Python 2.7 和 3.6 中的内存消耗（<code>__slots__</code>以字节为单位<code>__dict__</code>），对于
3.6 中 dict 增长的每个点（没有定义插槽）（0、1 和 2 属性除外）：</p>
<div class="code"><pre class="code literal-block"><span class="w">       </span><span class="nv">Python</span><span class="w"> </span><span class="mi">2</span>.<span class="mi">7</span><span class="w">             </span><span class="nv">Python</span><span class="w"> </span><span class="mi">3</span>.<span class="mi">6</span>
<span class="nv">attrs</span><span class="w">  </span><span class="nv">__slots__</span><span class="w">  </span><span class="nv">__dict__</span><span class="o">*</span><span class="w">   </span><span class="nv">__slots__</span><span class="w">  </span><span class="nv">__dict__</span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="ss">(</span><span class="nv">no</span><span class="w"> </span><span class="nv">slots</span><span class="w"> </span><span class="nv">defined</span><span class="ss">)</span>
<span class="nv">none</span><span class="w">   </span><span class="mi">16</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span>†<span class="w">   </span><span class="mi">16</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>†<span class="w"> </span><span class="o">|</span><span class="w"> </span>†<span class="k">if</span><span class="w"> </span><span class="nv">__dict__</span><span class="w"> </span><span class="nv">referenced</span>
<span class="nv">one</span><span class="w">    </span><span class="mi">48</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span><span class="w">    </span><span class="mi">48</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>
<span class="nv">two</span><span class="w">    </span><span class="mi">56</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span><span class="w">    </span><span class="mi">56</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>
<span class="nv">six</span><span class="w">    </span><span class="mi">88</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1040</span><span class="w">   </span><span class="mi">88</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">152</span>
<span class="mi">11</span><span class="w">     </span><span class="mi">128</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1040</span><span class="w">   </span><span class="mi">128</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">240</span>
<span class="mi">22</span><span class="w">     </span><span class="mi">216</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3344</span><span class="w">   </span><span class="mi">216</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">408</span><span class="w">     </span>
<span class="mi">43</span><span class="w">     </span><span class="mi">384</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3344</span><span class="w">   </span><span class="mi">384</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">752</span>
</pre></div>

<p>因此，尽管 Python 3 中的字典更小，但我们可以看到<code>__slots__</code>实例的扩展性如何很好地节省我们的内存，这是您想要使用<code>__slots__</code>.</p>
<p>只是为了我的笔记的完整性，请注意，在 Python 2 中类的命名空间中每个槽有一次性成本，在 Python 2 中为 64 字节，在 Python 3
中为 72 字节，因为槽使用称为“成员”的属性之类的数据描述符。</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; Foo.foo
&lt;member 'foo' of 'Foo' objects&gt;
&gt;&gt;&gt; type(Foo.foo)
&lt;class 'member_descriptor'&gt;
&gt;&gt;&gt; getsizeof(Foo.foo)
72
</pre></div>

<h3>示范<code>__slots__</code>：</h3>
<p>要拒绝创建 a <code>__dict__</code>，您必须子类化<code>object</code>。Python 3 中的所有子类<code>object</code>，但在 Python 2 中你必须明确：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Base</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = ()
</pre></div>

<p>现在：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; b = Base()
&gt;&gt;&gt; b.a = 'a'
Traceback (most recent call last):
  File "&lt;pyshell#38&gt;", line 1, in &lt;module&gt;
    b.a = 'a'
AttributeError: 'Base' object has no attribute 'a'
</pre></div>

<p>或者子类化另一个定义的类<code>__slots__</code></p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Child</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = (<span class="s">'a'</span>,)
</pre></div>

<p>现在：</p>
<div class="code"><pre class="code literal-block">c = Child()
c.a = 'a'
</pre></div>

<p>但：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c.b = 'b'
Traceback (most recent call last):
  File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt;
    c.b = 'b'
AttributeError: 'Child' object has no attribute 'b'
</pre></div>

<p>要<code>__dict__</code>在子类化带槽对象时允许创建，只需添加<code>'__dict__'</code>到<code>__slots__</code>（注意槽是有序的，你不应该重复已经在父类中的槽）：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">SlottedWithDict</span>(<span class="n">Child</span>): 
    <span class="n">__slots__</span> = (<span class="s">'__dict__'</span>, <span class="s">'b'</span>)

<span class="n">swd</span> = <span class="n">SlottedWithDict</span>()
<span class="n">swd</span>.<span class="n">a</span> = <span class="s">'a'</span>
<span class="n">swd</span>.<span class="n">b</span> = <span class="s">'b'</span>
<span class="n">swd</span>.<span class="n">c</span> = <span class="s">'c'</span>
</pre></div>

<p>和</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; swd.__dict__
{'c': 'c'}
</pre></div>

<p>或者你甚至不需要<code>__slots__</code>在你的子类中声明，你仍然会使用来自父母的插槽，但不限制创建一个<code>__dict__</code>：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">NoSlots</span>(<span class="n">Child</span>): <span class="nb">pass</span>
<span class="n">ns</span> = <span class="n">NoSlots</span>()
<span class="n">ns</span>.<span class="n">a</span> = <span class="s">'a'</span>
<span class="n">ns</span>.<span class="n">b</span> = <span class="s">'b'</span>
</pre></div>

<p>和：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; ns.__dict__
{'b': 'b'}
</pre></div>

<p>但是，<code>__slots__</code>可能会导致多重继承问题：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">BaseA</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = (<span class="s">'a'</span>,)

<span class="k">class</span> <span class="n">BaseB</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = (<span class="s">'b'</span>,)
</pre></div>

<p>因为从具有两个非空插槽的父类创建子类失败：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; class Child(BaseA, BaseB): __slots__ = ()
Traceback (most recent call last):
  File "&lt;pyshell#68&gt;", line 1, in &lt;module&gt;
    class Child(BaseA, BaseB): __slots__ = ()
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict
</pre></div>

<p>如果你遇到这个问题，你 <em>可以</em><code>__slots__</code>从父母那里移除，或者如果你控制了父母，给他们空槽，或者重构为抽象：</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>

<span class="k">class</span> <span class="nc">AbstractA</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">BaseA</span><span class="p">(</span><span class="n">AbstractA</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,)</span>

<span class="k">class</span> <span class="nc">AbstractB</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">BaseB</span><span class="p">(</span><span class="n">AbstractB</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">AbstractA</span><span class="p">,</span> <span class="n">AbstractB</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span> <span class="c1"># no problem!</span>
</pre></div>

<h4>Add <code>'__dict__'</code> to <code>__slots__</code> to get dynamic assignment:</h4>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>):
    <span class="n">__slots__</span> = <span class="s">'bar'</span>, <span class="s">'baz'</span>, <span class="s">'__dict__'</span>
</pre></div>

<p>and now:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.boink = 'boink'
</pre></div>

<p>So with <code>'__dict__'</code> in slots we lose some of the size benefits with the
upside of having dynamic assignment and still having slots for the names we do
expect.</p>
<p>When you inherit from an object that isn't slotted, you get the same sort of
semantics when you use <code>__slots__</code> - names that are in <code>__slots__</code> point to
slotted values, while any other values are put in the instance's <code>__dict__</code>.</p>
<p>Avoiding <code>__slots__</code> because you want to be able to add attributes on the fly
is actually not a good reason - just add <code>"__dict__"</code> to your <code>__slots__</code> if
this is required.</p>
<p>You can similarly add <code>__weakref__</code> to <code>__slots__</code> explicitly if you need that
feature.</p>
<h4>Set to empty tuple when subclassing a namedtuple:</h4>
<p>The namedtuple builtin make immutable instances that are very lightweight
(essentially, the size of tuples) but to get the benefits, you need to do it
yourself if you subclass them:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="k">class</span> <span class="nc">MyNT</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">'MyNT'</span><span class="p">,</span> <span class="s1">'bar baz'</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">"""MyNT is an immutable and lightweight object"""</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>

<p>usage:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; nt = MyNT('bar', 'baz')
&gt;&gt;&gt; nt.bar
'bar'
&gt;&gt;&gt; nt.baz
'baz'
</pre></div>

<p>And trying to assign an unexpected attribute raises an <code>AttributeError</code>
because we have prevented the creation of <code>__dict__</code>:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; nt.quux = 'quux'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'MyNT' object has no attribute 'quux'
</pre></div>

<p>You <em>can</em> allow <code>__dict__</code> creation by leaving off <code>__slots__ = ()</code>, but you
can't use non-empty <code>__slots__</code> with subtypes of tuple.</p>
<h3>Biggest Caveat: Multiple inheritance</h3>
<p>Even when non-empty slots are the same for multiple parents, they cannot be
used together:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>
<span class="k">class</span> <span class="n">Bar</span>(<span class="n">object</span>):
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span> <span class="c1"># alas, would work if empty, i.e. ()</span>

&gt;&gt;&gt; <span class="k">class</span> <span class="n">Baz</span>(<span class="n">Foo</span>, <span class="n">Bar</span>): <span class="nb">pass</span>
<span class="n">Traceback</span> (<span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="nb">last</span>):
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span>, <span class="nb">line</span> <span class="mi">1</span>, <span class="nb">in</span> <span class="s">&lt;module&gt;</span>
<span class="n">TypeError:</span> <span class="n">Error</span> <span class="k">when</span> <span class="n">calling</span> <span class="n">the</span> <span class="n">metaclass</span> <span class="n">bases</span>
    <span class="n">multiple</span> <span class="n">bases</span> <span class="n">have</span> <span class="n">instance</span> <span class="n">lay-out</span> <span class="n">conflict</span>
</pre></div>

<p>Using an empty <code>__slots__</code> in the parent seems to provide the most
flexibility, <strong>allowing the child to choose to prevent or allow</strong> (by adding
<code>'__dict__'</code> to get dynamic assignment, see section above) <strong>the creation of
a<code>__dict__</code></strong>:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>): <span class="n">__slots__</span> = ()
<span class="k">class</span> <span class="n">Bar</span>(<span class="n">object</span>): <span class="n">__slots__</span> = ()
<span class="k">class</span> <span class="n">Baz</span>(<span class="n">Foo</span>, <span class="n">Bar</span>): <span class="n">__slots__</span> = (<span class="s">'foo'</span>, <span class="s">'bar'</span>)
<span class="n">b</span> = <span class="n">Baz</span>()
<span class="n">b</span>.<span class="n">foo</span>, <span class="n">b</span>.<span class="n">bar</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>
</pre></div>

<p>You don't <em>have</em> to have slots - so if you add them, and remove them later, it
shouldn't cause any problems.</p>
<p><strong>Going out on a limb here</strong> : If you're composing mixins or using abstract
base classes, which aren't intended to be instantiated, an empty <code>__slots__</code>
in those parents seems to be the best way to go in terms of flexibility for
subclassers.</p>
<p>To demonstrate, first, let's create a class with code we'd like to use under
multiple inheritance</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">AbstractBase:</span>
    <span class="n">__slots__</span> = ()
    <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">a</span>, <span class="n">b</span>):
        <span class="nb">self</span>.<span class="n">a</span> = <span class="n">a</span>
        <span class="nb">self</span>.<span class="n">b</span> = <span class="n">b</span>
    <span class="n">def</span> <span class="n">__repr__</span>(<span class="nb">self</span>):
        <span class="k">return</span> <span class="n">f'</span>{<span class="nb">type</span>(<span class="nb">self</span>).<span class="n">__name__</span>}({<span class="k">repr</span>(<span class="nb">self</span>.<span class="n">a</span>)}, {<span class="k">repr</span>(<span class="nb">self</span>.<span class="n">b</span>)})'
</pre></div>

<p>We could use the above directly by inheriting and declaring the expected
slots:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">AbstractBase</span>):
    <span class="n">__slots__</span> = <span class="s">'a'</span>, <span class="s">'b'</span>
</pre></div>

<p>But we don't care about that, that's trivial single inheritance, we need
another class we might also inherit from, maybe with a noisy attribute:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nl">AbstractBaseC</span><span class="p">:</span>
<span class="w">    </span><span class="n">__slots__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="nv">@property</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="s1">'getting c!'</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_c</span>
<span class="w">    </span><span class="nv">@c</span><span class="p">.</span><span class="n">setter</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="s1">'setting c!'</span><span class="p">)</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span>
</pre></div>

<p>Now if both bases had nonempty slots, we couldn't do the below. (In fact, if
we wanted, we could have given <code>AbstractBase</code> nonempty slots a and b, and left
them out of the below declaration - leaving them in would be wrong):</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Concretion</span>(<span class="n">AbstractBase</span>, <span class="n">AbstractBaseC</span>):
    <span class="n">__slots__</span> = <span class="s">'a b _c'</span>.<span class="nb">split</span>()
</pre></div>

<p>And now we have functionality from both via multiple inheritance, and can
still deny <code>__dict__</code> and <code>__weakref__</code> instantiation:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c = Concretion('a', 'b')
&gt;&gt;&gt; c.c = c
setting c!
&gt;&gt;&gt; c.c
getting c!
Concretion('a', 'b')
&gt;&gt;&gt; c.d = 'd'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Concretion' object has no attribute 'd'
</pre></div>

<h3>Other cases to avoid slots:</h3>
<ul>
<li>Avoid them when you want to perform <code>__class__</code> assignment with another class that doesn't have them (and you can't add them) unless the slot layouts are identical. (I am very interested in learning who is doing this and why.)</li>
<li>Avoid them if you want to subclass variable length builtins like long, tuple, or str, and you want to add attributes to them.</li>
<li>Avoid them if you insist on providing default values via class attributes for instance variables.</li>
</ul>
<p>You may be able to tease out further caveats from the rest of the <code>__slots__</code>
documentation (the 3.7 dev docs are the most current), which I have made
significant recent contributions to.</p>
<h3>Critiques of other answers</h3>
<p>The current top answers cite outdated information and are quite hand-wavy and
miss the mark in some important ways.</p>
<h4>Do not "only use <code>__slots__</code> when instantiating lots of objects"</h4>
<p>I quote:</p>
<blockquote>
<p>"You would want to use <code>__slots__</code> if you are going to instantiate a lot
(hundreds, thousands) of objects of the same class."</p>
</blockquote>
<p>Abstract Base Classes, for example, from the <code>collections</code> module, are not
instantiated, yet <code>__slots__</code> are declared for them.</p>
<p>Why?</p>
<p>If a user wishes to deny <code>__dict__</code> or <code>__weakref__</code> creation, those things
must not be available in the parent classes.</p>
<p><code>__slots__</code> contributes to reusability when creating interfaces or mixins.</p>
<p>It is true that many Python users aren't writing for reusability, but when you
are, having the option to deny unnecessary space usage is valuable.</p>
<h4>
<code>__slots__</code> doesn't break pickling</h4>
<p>When pickling a slotted object, you may find it complains with a misleading
<code>TypeError</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="n">TypeError</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">__slots__</span><span class="w"> </span><span class="n">without</span><span class="w"> </span><span class="n">defining</span><span class="w"> </span><span class="n">__getstate__</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">pickled</span>
</pre></div>

<p>This is actually incorrect. This message comes from the oldest protocol, which
is the default. You can select the latest protocol with the <code>-1</code> argument. In
Python 2.7 this would be <code>2</code> (which was introduced in 2.3), and in 3.6 it is
<code>4</code>.</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>in Python 2.7:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>in Python 3.6</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>So I would keep this in mind, as it is a solved problem.</p>
<h3>Critique of the (until Oct 2, 2016) accepted answer</h3>
<p>The first paragraph is half short explanation, half predictive. Here's the
only part that actually answers the question</p>
<blockquote>
<p>The proper use of <code>__slots__</code> is to save space in objects. Instead of having
a dynamic dict that allows adding attributes to objects at anytime, there is
a static structure which does not allow additions after creation. This saves
the overhead of one dict for every object that uses slots</p>
</blockquote>
<p>The second half is wishful thinking, and off the mark:</p>
<blockquote>
<p>While this is sometimes a useful optimization, it would be completely
unnecessary if the Python interpreter was dynamic enough so that it would
only require the dict when there actually were additions to the object.</p>
</blockquote>
<p>Python actually does something similar to this, only creating the <code>__dict__</code>
when it is accessed, but creating lots of objects with no data is fairly
ridiculous.</p>
<p>The second paragraph oversimplifies and misses actual reasons to avoid
<code>__slots__</code>. The below is <em>not</em> a real reason to avoid slots (for <em>actual</em>
reasons, see the rest of my answer above.):</p>
<blockquote>
<p>They change the behavior of the objects that have slots in a way that can be
abused by control freaks and static typing weenies.</p>
</blockquote>
<p>It then goes on to discuss other ways of accomplishing that perverse goal with
Python, not discussing anything to do with <code>__slots__</code>.</p>
<p>The third paragraph is more wishful thinking. Together it is mostly off-the-
mark content that the answerer didn't even author and contributes to
ammunition for critics of the site.</p>
<h2>Memory usage evidence</h2>
<p>Create some normal objects and slotted objects:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; class Foo(object): pass
&gt;&gt;&gt; class Bar(object): __slots__ = ()
</pre></div>

<p>Instantiate a million of them:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">foos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">Foo</span><span class="ss">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">xrange</span><span class="ss">(</span><span class="mi">1000000</span><span class="ss">)</span>]
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">bars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">Bar</span><span class="ss">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">xrange</span><span class="ss">(</span><span class="mi">1000000</span><span class="ss">)</span>]
</pre></div>

<p>Inspect with <code>guppy.hpy().heap()</code>:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; guppy.hpy().heap()
Partition of a set of 2028259 objects. Total size = 99763360 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0 1000000  49 64000000  64  64000000  64 __main__.Foo
     1     169   0 16281480  16  80281480  80 list
     2 1000000  49 16000000  16  96281480  97 __main__.Bar
     3   12284   1   987472   1  97268952  97 str
...
</pre></div>

<p>Access the regular objects and their <code>__dict__</code> and inspect again:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">foos</span>:
...<span class="w">     </span><span class="nv">f</span>.<span class="nv">__dict__</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">guppy</span>.<span class="nv">hpy</span><span class="ss">()</span>.<span class="nv">heap</span><span class="ss">()</span>
<span class="nv">Partition</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">set</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">3028258</span><span class="w"> </span><span class="nv">objects</span>.<span class="w"> </span><span class="nv">Total</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">379763480</span><span class="w"> </span><span class="nv">bytes</span>.
<span class="w"> </span><span class="nv">Index</span><span class="w">  </span><span class="nv">Count</span><span class="w">   </span><span class="o">%</span><span class="w">      </span><span class="nv">Size</span><span class="w">    </span><span class="o">%</span><span class="w"> </span><span class="nv">Cumulative</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="nv">Kind</span><span class="w"> </span><span class="ss">(</span><span class="nv">class</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nv">dict</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">class</span><span class="ss">)</span>
<span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w"> </span><span class="mi">280000000</span><span class="w">  </span><span class="mi">74</span><span class="w"> </span><span class="mi">280000000</span><span class="w">  </span><span class="mi">74</span><span class="w"> </span><span class="nv">dict</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Foo</span>
<span class="w">     </span><span class="mi">1</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w">  </span><span class="mi">64000000</span><span class="w">  </span><span class="mi">17</span><span class="w"> </span><span class="mi">344000000</span><span class="w">  </span><span class="mi">91</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Foo</span>
<span class="w">     </span><span class="mi">2</span><span class="w">     </span><span class="mi">169</span><span class="w">   </span><span class="mi">0</span><span class="w">  </span><span class="mi">16281480</span><span class="w">   </span><span class="mi">4</span><span class="w"> </span><span class="mi">360281480</span><span class="w">  </span><span class="mi">95</span><span class="w"> </span><span class="nv">list</span>
<span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w">  </span><span class="mi">16000000</span><span class="w">   </span><span class="mi">4</span><span class="w"> </span><span class="mi">376281480</span><span class="w">  </span><span class="mi">99</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Bar</span>
<span class="w">     </span><span class="mi">4</span><span class="w">   </span><span class="mi">12284</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="mi">987472</span><span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="mi">377268952</span><span class="w">  </span><span class="mi">99</span><span class="w"> </span><span class="nv">str</span>
...
</pre></div>

<p>This is consistent with the history of Python, from Unifying types and classes
in Python 2.2</p>
<blockquote>
<p>If you subclass a built-in type, extra space is automatically added to the
instances to accomodate <code>__dict__</code> and <code>__weakrefs__</code>. (The <code>__dict__</code> is
not initialized until you use it though, so you shouldn't worry about the
space occupied by an empty dictionary for each instance you create.) If you
don't need this extra space, you can add the phrase "<code>__slots__ = []</code>" to
your class.</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p>引用雅各布·哈伦的话：</p>
<blockquote>
<p>正确使用<code>__slots__</code>是为了节省对象的空间。不是有一个允许随时向对象添加属性的动态字典，而是有一个不允许在创建后添加的静态结构。[这种使用<code>__slots__</code>为每个对象消除了一个
dict 的开销。]虽然这有时是一个有用的优化，但如果 Python 解释器足够动态，它就完全没有必要目的。</p>
<p>不幸的是，插槽有副作用。它们以一种可以被控制狂和静态类型怪人滥用的方式改变具有插槽的对象的行为。这很糟糕，因为控制狂应该滥用元类，而静态类型专家应该滥用装饰器，因为在
Python 中，做某事应该只有一种明显的方法。</p>
<p>使 CPython 足够智能以节省空间<code>__slots__</code>是一项艰巨的任务，这可能是它不在 P3k 更改列表中的原因（目前）。</p>
</blockquote>
<p><br><br><a href="../usage-of-slots/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/python-internals/" rel="tag">python-internals</a></li>
            <li><a class="tag p-category" href="../../categories/slots/" rel="tag">slots</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-tong-guo-ti-jiao-xiao-xi-sou-suo-git-cun-chu-ku/" rel="prev" title="如何通过提交消息搜索 Git 存储库？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-zai-div-kuai-nei-jiang-wen-ben-shui-ping-he-chui-zhi-ju-zhong/" rel="next" title="如何在 div 块内将文本（水平和垂直）居中？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
