<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>if __name__ == "__main__": 做什么？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/if-name-main-zuo-shi-yao/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-qian-chu-yuan-cheng-git-fen-zhi/" title="如何签出远程 Git 分支？" type="text/html">
<link rel="next" href="../ru-he-cong-dang-qian-git-gong-zuo-shu-zhong-shan-chu-ben-di-wei-gen-zong-wen-jian/" title="如何从当前 Git 工作树中删除本地（未跟踪）文件？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content='if __name__ == "__main__": 做什么？'>
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/if-name-main-zuo-shi-yao/">
<meta property="og:description" content='这是做什么的，为什么要包含该if声明？
if __name__ == "__main__":
    print("Hello, World!")



如果你试图关闭一个问题，其中有人应该使用这个惯用语而不是，请考虑作为Why is Python running my module when I
import it, and how do I stop it?
的副本关闭。反而。如果有人根本没有'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T18:20:26+08:00">
<meta property="article:tag" content="idioms">
<meta property="article:tag" content="namespaces">
<meta property="article:tag" content="program-entry-point">
<meta property="article:tag" content="python">
<meta property="article:tag" content="python-module">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">if __name__ == "__main__": 做什么？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:20:26+08:00" itemprop="datePublished" title="2023-02-16 18:20">2023-02-16 18:20</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>这是做什么的，为什么要包含该<code>if</code>声明？</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="nv">__name__</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"__main__"</span>:
<span class="w">    </span><span class="nv">print</span><span class="ss">(</span><span class="s2">"Hello, World!"</span><span class="ss">)</span>
</pre></div>

<hr>
<p>如果你试图关闭一个问题，其中有人应该使用这个惯用语而不是，请考虑作为Why is Python running my module when I
import it, and how do I stop it?
的副本关闭。反而。如果有人根本没有调用任何函数，或者错误地期望一个名为的函数<code>main</code>自动用作入口点的问题，请使用Why doesn't the
main() function run when I start a Python script? 脚本从哪里开始运行？.</p>
<p><br><br></p>
<h2>解答</h2>
<h2>简答</h2>
<p>它是样板代码，可防止用户在他们不希望的情况下意外调用脚本。以下是脚本中省略守卫时的一些常见问题：</p>
<ul>
<li>
<p>如果您在另一个脚本（例如）中导入无保护脚本<code>import my_script_without_a_name_eq_main_guard</code>，则后一个脚本将触发前者 <em>在导入时</em> 运行并 <em>使用第二个脚本的命令行参数</em> 。这几乎总是一个错误。</p>
</li>
<li>
<p>如果您在 guardless 脚本中有一个自定义类并将其保存到 pickle 文件中，那么在另一个脚本中将其取消 pickle 将触发导入 ​​guardless 脚本，这会产生与上一条中所述相同的问题。</p>
</li>
</ul>
<h2>长答案</h2>
<p>为了更好地理解这为何重要以及如何重要，我们需要退后一步，了解 Python 如何初始化脚本以及这如何与其模块导入机制交互。</p>
<p>每当 Python 解释器读取源文件时，它都会做两件事：</p>
<ul>
<li>
<p>它设置了一些特殊变量，例如<code>__name__</code>，然后</p>
</li>
<li>
<p>它执行文件中找到的所有代码。</p>
</li>
</ul>
<p>让我们看看它是如何工作的，以及它与您关于<code>__name__</code>我们在 Python 脚本中经常看到的检查的问题有何关系。</p>
<h3>代码示例</h3>
<p>让我们使用稍微不同的代码示例来探索导入和脚本的工作原理。假设以下内容在一个名为<code>foo.py</code>.</p>
<div class="code"><pre class="code literal-block"><span class="c1"># Suppose this is foo.py.</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"before import"</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"before function_a"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">function_a</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Function A"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"before function_b"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">function_b</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Function B </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"before __name__ guard"</span><span class="p">)</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">function_a</span><span class="p">()</span>
    <span class="n">function_b</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"after __name__ guard"</span><span class="p">)</span>
</pre></div>

<h3>特殊变量</h3>
<p>当 Python 解释器读取源文件时，它首先定义了一些特殊变量。在这种情况下，我们关心变量<code>__name__</code>。</p>
<p><strong>当你的模块是主程序时</strong></p>
<p>如果您将模块（源文件）作为主程序运行，例如</p>
<div class="code"><pre class="code literal-block">python foo.py
</pre></div>

<p>解释器会将硬编码的字符串分配给<code>"__main__"</code>变量<code>__name__</code>，即</p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">It</span><span class="err">'s as if the interpreter inserts this at the top</span>
<span class="err"># of your module when run as the main program.</span>
<span class="err">__name__ = "__main__"</span>
</pre></div>

<p><strong>当您的模块被另一个模块导入时</strong></p>
<p>另一方面，假设其他一些模块是主程序并且它导入了您的模块。这意味着在主程序或主程序导入的其他模块中有这样的语句：</p>
<div class="code"><pre class="code literal-block"><span class="c1"># Suppose this is in some other main program.</span>
<span class="kn">import</span> <span class="nn">foo</span>
</pre></div>

<p>解释器将搜索您的文件（以及搜索其他一些变体），并且在执行该模块之前，它将import
语句中的<code>foo.py</code>名称分配给变量，即<code>"foo"``__name__</code></p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">It</span><span class="err">'s as if the interpreter inserts this at the top</span>
#<span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">your</span><span class="w"> </span><span class="nv">module</span><span class="w"> </span><span class="nv">when</span><span class="w"> </span><span class="nv">it</span><span class="err">'s imported from another module.</span>
<span class="err">__name__ = "foo"</span>
</pre></div>

<h3>执行模块的代码</h3>
<p>设置特殊变量后，解释器执行模块中的所有代码，一次一条语句。您可能想在显示代码示例的一侧打开另一个窗口，以便您可以按照此说明进行操作。</p>
<p><strong>总是</strong></p>
<ol>
<li>
<p>它打印字符串<code>"before import"</code>（不带引号）。</p>
</li>
<li>
<p>它加载<code>math</code>模块并将其分配给一个名为<code>math</code>. 这相当于替换<code>import math</code>为以下内容（请注意，这<code>__import__</code>是 Python 中的一个低级函数，它接受一个字符串并触发实际导入）：</p>
<h2>Find and load a module given its string name, "math",</h2>
<h2>then assign it to a local variable called math.</h2>
<p>math = <strong>import</strong>("math")</p>
</li>
<li>
<p>它打印字符串<code>"before function_a"</code>。</p>
</li>
<li>
<p>它执行<code>def</code>块，创建一个函数对象，然后将该函数对象分配给一个名为 的变量<code>function_a</code>。</p>
</li>
<li>
<p>它打印字符串<code>"before function_b"</code>。</p>
</li>
<li>
<p>它执行第二个<code>def</code>块，创建另一个函数对象，然后将其分配给一个名为<code>function_b</code>.</p>
</li>
<li>
<p>它打印字符串<code>"before __name__ guard"</code>。</p>
</li>
</ol>
<p><strong>仅当您的模块是主程序时</strong></p>
<ol>
<li>如果你的模块是主程序，那么它会看到它<code>__name__</code>确实被设置为<code>"__main__"</code>并调用这两个函数，打印字符串<code>"Function A"</code>和<code>"Function B 10.0"</code>。</li>
</ol>
<p><strong>仅当您的模块被另一个模块导入时</strong></p>
<ol>
<li>（ <strong>相反</strong> ）如果您的模块不是主程序而是由另一个程序导入的，则<code>__name__</code>will be <code>"foo"</code>， not <code>"__main__"</code>，并且它将跳过语句的主体<code>if</code>。</li>
</ol>
<p><strong>总是</strong></p>
<ol>
<li>它将在两种情况下打印字符串<code>"after __name__ guard"</code>。</li>
</ol>
<p><em><strong>概括</strong></em></p>
<p>总之，这是在这两种情况下打印的内容：</p>
<div class="code"><pre class="code literal-block"><span class="p">#</span><span class="w"> </span><span class="n">What</span><span class="w"> </span><span class="n">gets</span><span class="w"> </span><span class="n">printed</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="n">program</span>
<span class="n">before</span><span class="w"> </span><span class="n">import</span>
<span class="n">before</span><span class="w"> </span><span class="n">function_a</span>
<span class="n">before</span><span class="w"> </span><span class="n">function_b</span>
<span class="n">before</span><span class="w"> </span><span class="n">__name__</span><span class="w"> </span><span class="n">guard</span>
<span class="n">Function</span><span class="w"> </span><span class="n">A</span>
<span class="n">Function</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="mf">10.0</span>
<span class="n">after</span><span class="w"> </span><span class="n">__name__</span><span class="w"> </span><span class="n">guard</span>



<span class="p">#</span><span class="w"> </span><span class="n">What</span><span class="w"> </span><span class="n">gets</span><span class="w"> </span><span class="n">printed</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">imported</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">regular</span><span class="w"> </span><span class="k">module</span>
<span class="n">before</span><span class="w"> </span><span class="n">import</span>
<span class="n">before</span><span class="w"> </span><span class="n">function_a</span>
<span class="n">before</span><span class="w"> </span><span class="n">function_b</span>
<span class="n">before</span><span class="w"> </span><span class="n">__name__</span><span class="w"> </span><span class="n">guard</span>
<span class="n">after</span><span class="w"> </span><span class="n">__name__</span><span class="w"> </span><span class="n">guard</span>
</pre></div>

<h3>为什么它以这种方式工作？</h3>
<p>您可能很自然地想知道为什么有人会想要这个。好吧，有时您想编写一个<code>.py</code>既可以被其他程序和/或模块用作模块又可以作为主程序本身运行的文件。例子：</p>
<ul>
<li>
<p>您的模块是一个库，但您希望有一个脚本模式，它可以运行一些单元测试或演示。</p>
</li>
<li>
<p>您的模块仅用作主程序，但它有一些单元测试，测试框架通过导入<code>.py</code>脚本等文件并运行特殊测试功能来工作。您不希望它仅仅因为导入模块而尝试运行脚本。</p>
</li>
<li>
<p>您的模块主要用作主程序，但它也为高级用户提供对程序员友好的 API。</p>
</li>
</ul>
<p>除了这些示例之外，在 Python 中运行脚本只是设置一些魔法变量并导入脚本是很优雅的。“运行”脚本是导入脚本模块的副作用。</p>
<h3>精神食粮</h3>
<ul>
<li>
<p>问题：我可以有多个<code>__name__</code>检查块吗？答：这样做很奇怪，但语言不会阻止你。</p>
</li>
<li>
<p>假设以下内容在<code>foo2.py</code>. <code>python foo2.py</code>如果你在命令行上说会发生什么？为什么？</p>
<h2>Suppose this is foo2.py.</h2>
<p>import os, sys; sys.path.insert(0, os.path.dirname(<strong>file</strong>)) # needed for some interpreters</p>
<p>def function_a():
    print("a1")
    from foo2 import function_b
    print("a2")
    function_b()
    print("a3")</p>
<p>def function_b():
    print("b")</p>
<p>print("t1")
if <strong>name</strong> == "<strong>main</strong>":
    print("m1")
    function_a()
    print("m2")
print("t2")</p>
</li>
<li>
<p>现在，弄清楚如果您删除<code>__name__</code>签入会发生什么<code>foo3.py</code>：</p>
<h2>Suppose this is foo3.py.</h2>
<p>import os, sys; sys.path.insert(0, os.path.dirname(<strong>file</strong>)) # needed for some interpreters</p>
<p>def function_a():
    print("a1")
    from foo3 import function_b
    print("a2")
    function_b()
    print("a3")</p>
<p>def function_b():
    print("b")</p>
<p>print("t1")
print("m1")
function_a()
print("m2")
print("t2")</p>
</li>
<li>
<p>当用作脚本时，它会做什么？何时作为模块导入？</p>
<h2>Suppose this is in foo4.py</h2>
<p><strong>name</strong> = "<strong>main</strong>"</p>
<p>def bar():
    print("bar")</p>
<p>print("before <strong>name</strong> guard")
if <strong>name</strong> == "<strong>main</strong>":
    bar()
print("after <strong>name</strong> guard")</p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>当您的脚本通过将其作为命令传递给 Python 解释器来运行时，</p>
<div class="code"><pre class="code literal-block">python myscript.py
</pre></div>

<p>缩进级别为 0
的所有代码都将被执行。已定义的函数和类确实已定义，但它们的代码均未运行。与其他语言不同，没有<code>main()</code>自动运行的函数——<code>main()</code>函数隐含地是顶层的所有代码。</p>
<p>在这种情况下，顶级代码是一个<code>if</code>块。<code>__name__</code>是一个内置变量，计算结果为当前模块的名称。但是，如果模块直接运行（如上所示<code>myscript.py</code>），则<code>__name__</code>改为设置为
string <code>"__main__"</code>。因此，您可以通过测试来测试您的脚本是直接运行还是被其他东西导入</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="nv">__name__</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"__main__"</span>:
<span class="w">    </span>...
</pre></div>

<p>如果你的脚本被导入到另一个模块中，它的各种函数和类定义将被导入并且它的顶级代码将被执行，但是上面子句的 then-body
中的代码将不会运行，因为条件<code>if</code>是没见过。作为一个基本示例，请考虑以下两个脚本：</p>
<div class="code"><pre class="code literal-block"><span class="c1"># file one.py</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"func() in one.py"</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"top-level in one.py"</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"one.py is being run directly"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"one.py is being imported into another module"</span><span class="p">)</span>



<span class="c1"># file two.py</span>
<span class="kn">import</span> <span class="nn">one</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"top-level in two.py"</span><span class="p">)</span>
<span class="n">one</span><span class="o">.</span><span class="n">func</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"two.py is being run directly"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"two.py is being imported into another module"</span><span class="p">)</span>
</pre></div>

<p>现在，如果您将解释器调用为</p>
<div class="code"><pre class="code literal-block">python one.py
</pre></div>

<p>输出将是</p>
<div class="code"><pre class="code literal-block">top-level in one.py
one.py is being run directly
</pre></div>

<p>如果你<code>two.py</code>改为运行：</p>
<div class="code"><pre class="code literal-block">python two.py
</pre></div>

<p>你得到</p>
<div class="code"><pre class="code literal-block">top-level in one.py
one.py is being imported into another module
top-level in two.py
func() in one.py
two.py is being run directly
</pre></div>

<p>因此，当<code>one</code>加载模块时，它<code>__name__</code>等于<code>"one"</code>而不是<code>"__main__"</code>.</p>
<p><br><br><a href="../what-does-if-name-main-do/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/idioms/" rel="tag">idioms</a></li>
            <li><a class="tag p-category" href="../../categories/namespaces/" rel="tag">namespaces</a></li>
            <li><a class="tag p-category" href="../../categories/program-entry-point/" rel="tag">program-entry-point</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/python-module/" rel="tag">python-module</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-qian-chu-yuan-cheng-git-fen-zhi/" rel="prev" title="如何签出远程 Git 分支？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-cong-dang-qian-git-gong-zuo-shu-zhong-shan-chu-ben-di-wei-gen-zong-wen-jian/" rel="next" title="如何从当前 Git 工作树中删除本地（未跟踪）文件？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
