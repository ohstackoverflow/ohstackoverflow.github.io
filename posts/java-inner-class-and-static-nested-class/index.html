<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java inner class and static nested class | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/java-inner-class-and-static-nested-class/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../why-is-using-for-in-for-array-iteration-a-bad-idea/" title='Why is using "for...in" for array iteration a bad idea?' type="text/html">
<link rel="next" href="../why-is-it-string-join-list-instead-of-list-join-string/" title="Why is it string.join(list) instead of list.join(string)?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Java inner class and static nested class">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/java-inner-class-and-static-nested-class/">
<meta property="og:description" content="What is the main difference between an inner class and a static nested class
in Java? Does design / implementation play a role in choosing one of these?

Answer
From the Java Tutorial:

Nested classes">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T23:01:30+08:00">
<meta property="article:tag" content="inner-classes">
<meta property="article:tag" content="java">
<meta property="article:tag" content="static-classes">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java inner class and static nested class</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:01:30+08:00" itemprop="datePublished" title="2023-02-16 23:01">2023-02-16 23:01</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What is the main difference between an inner class and a static nested class
in Java? Does design / implementation play a role in choosing one of these?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>From the Java Tutorial:</p>
<blockquote>
<p>Nested classes are divided into two categories: static and non-static.
Nested classes that are declared static are simply called static nested
classes. Non-static nested classes are called inner classes.</p>
</blockquote>
<p>Static nested classes are accessed using the enclosing class name:</p>
<div class="code"><pre class="code literal-block">OuterClass.StaticNestedClass
</pre></div>

<p>For example, to create an object for the static nested class, use this syntax:</p>
<div class="code"><pre class="code literal-block">OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
</pre></div>

<p>Objects that are instances of an inner class exist within an instance of the
outer class. Consider the following classes:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">OuterClass</span> {
    ...
    <span class="k">class</span> <span class="n">InnerClass</span> {
        ...
    }
}
</pre></div>

<p>An instance of InnerClass can exist only within an instance of OuterClass and
has direct access to the methods and fields of its enclosing instance.</p>
<p>To instantiate an inner class, you must first instantiate the outer class.
Then, create the inner object within the outer object with this syntax:</p>
<div class="code"><pre class="code literal-block">OuterClass outerObject = new OuterClass()
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
</pre></div>

<p>see: Java Tutorial - Nested Classes</p>
<p>For completeness note that there is also such a thing as an inner class
<em>without</em> an enclosing instance:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">A</span> {
  <span class="n">int</span> <span class="nb">t</span>() { <span class="k">return</span> <span class="mi">1</span>; }
  <span class="n">static</span> <span class="n">A</span> <span class="n">a</span> =  <span class="nb">new</span> <span class="n">A</span>() { <span class="n">int</span> <span class="nb">t</span>() { <span class="k">return</span> <span class="mi">2</span>; } };
}
</pre></div>

<p>Here, <code>new A() { ... }</code> is an <em>inner class defined in a static context</em> and
does not have an enclosing instance.</p>
<p><br></p>
<h3>Suggest</h3>
<p>The Java tutorial says:</p>
<blockquote>
<p>Terminology: Nested classes are divided into two categories: static and non-
static. Nested classes that are declared static are simply called static
nested classes. Non-static nested classes are called inner classes.</p>
</blockquote>
<p>In common parlance, the terms "nested" and "inner" are used interchangeably by
most programmers, but I'll use the correct term "nested class" which covers
both inner and static.</p>
<p>Classes can be nested <em>ad infinitum</em> , e.g. class A can contain class B which
contains class C which contains class D, etc. However, more than one level of
class nesting is rare, as it is generally bad design.</p>
<p>There are three reasons you might create a nested class:</p>
<ul>
<li>organization: sometimes it seems most sensible to sort a class into the namespace of another class, especially when it won't be used in any other context</li>
<li>access: nested classes have special access to the variables/fields of their containing classes (precisely which variables/fields depends on the kind of nested class, whether inner or static).</li>
<li>convenience: having to create a new file for every new type is bothersome, again, especially when the type will only be used in one context</li>
</ul>
<p>There are <strong>four kinds of nested class in Java</strong>. In brief, they are:</p>
<ul>
<li>
<strong>static class</strong> : declared as a static member of another class</li>
<li>
<strong>inner class</strong> : declared as an instance member of another class</li>
<li>
<strong>local inner class</strong> : declared inside an instance method of another class</li>
<li>
<strong>anonymous inner class</strong> : like a local inner class, but written as an expression which returns a one-off object</li>
</ul>
<p>Let me elaborate in more details.</p>
<h3>Static Classes</h3>
<p>Static classes are the easiest kind to understand because they have nothing to
do with instances of the containing class.</p>
<p>A static class is a class declared as a static member of another class. Just
like other static members, such a class is really just a hanger on that uses
the containing class as its namespace, <em>e.g.</em> the class <em>Goat</em> declared as a
static member of class <em>Rhino</em> in the package <em>pizza</em> is known by the name
<em>pizza.Rhino.Goat</em>.</p>
<div class="code"><pre class="code literal-block">package pizza;

public class Rhino {

    ...

    public static class Goat {
        ...
    }
}
</pre></div>

<p>Frankly, static classes are a pretty worthless feature because classes are
already divided into namespaces by packages. The only real conceivable reason
to create a static class is that such a class has access to its containing
class's private static members, but I find this to be a pretty lame
justification for the static class feature to exist.</p>
<h3>Inner Classes</h3>
<p>An inner class is a class declared as a non-static member of another class:</p>
<div class="code"><pre class="code literal-block">package pizza;

public class Rhino {

    public class Goat {
        ...
    }

    private void jerry() {
        Goat g = new Goat();
    }
}
</pre></div>

<p>Like with a static class, the inner class is known as qualified by its
containing class name, <em>pizza.Rhino.Goat</em> , but inside the containing class,
it can be known by its simple name. However, every instance of an inner class
is tied to a particular instance of its containing class: above, the <em>Goat</em>
created in <em>jerry</em> , is implicitly tied to the <em>Rhino</em> instance <em>this</em> in
<em>jerry</em>. Otherwise, we make the associated <em>Rhino</em> instance explicit when we
instantiate <em>Goat</em> :</p>
<div class="code"><pre class="code literal-block">Rhino rhino = new Rhino();
Rhino.Goat goat = rhino.new Goat();
</pre></div>

<p>(Notice you refer to the inner type as just <em>Goat</em> in the weird <em>new</em> syntax:
Java infers the containing type from the <em>rhino</em> part. And, yes <em>new
rhino.Goat()</em> would have made more sense to me too.)</p>
<p>So what does this gain us? Well, the inner class instance has access to the
instance members of the containing class instance. These enclosing instance
members are referred to inside the inner class <em>via</em> just their simple names,
not <em>via</em> <em>this</em> ( <em>this</em> in the inner class refers to the inner class
instance, not the associated containing class instance):</p>
<div class="code"><pre class="code literal-block">public class Rhino {

    private String barry;

    public class Goat {
        public void colin() {
            System.out.println(barry);
        }
    }
}
</pre></div>

<p>In the inner class, you can refer to <em>this</em> of the containing class as
<em>Rhino.this</em> , and you can use <em>this</em> to refer to its members, <em>e.g.
Rhino.this.barry</em>.</p>
<h3>Local Inner Classes</h3>
<p>A local inner class is a class declared in the body of a method. Such a class
is only known within its containing method, so it can only be instantiated and
have its members accessed within its containing method. The gain is that a
local inner class instance is tied to and can access the final local variables
of its containing method. When the instance uses a final local of its
containing method, the variable retains the value it held at the time of the
instance's creation, even if the variable has gone out of scope (this is
effectively Java's crude, limited version of closures).</p>
<p>Because a local inner class is neither the member of a class or package, it is
not declared with an access level. (Be clear, however, that its own members
have access levels like in a normal class.)</p>
<p>If a local inner class is declared in an instance method, an instantiation of
the inner class is tied to the instance held by the containing method's <em>this</em>
at the time of the instance's creation, and so the containing class's instance
members are accessible like in an instance inner class. A local inner class is
instantiated simply <em>via</em> its name, <em>e.g.</em> local inner class <em>Cat</em> is
instantiated as <em>new Cat()</em> , not new this.Cat() as you might expect.</p>
<h3>Anonymous Inner Classes</h3>
<p>An anonymous inner class is a syntactically convenient way of writing a local
inner class. Most commonly, a local inner class is instantiated at most just
once each time its containing method is run. It would be nice, then, if we
could combine the local inner class definition and its single instantiation
into one convenient syntax form, and it would also be nice if we didn't have
to think up a name for the class (the fewer unhelpful names your code
contains, the better). An anonymous inner class allows both these things:</p>
<div class="code"><pre class="code literal-block"><span class="n">new</span><span class="w"> </span><span class="o">*</span><span class="n">ParentClassName</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">constructorArgs</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="o">*</span><span class="n">members</span><span class="o">*</span><span class="p">}</span>
</pre></div>

<p>This is an expression returning a new instance of an unnamed class which
extends <em>ParentClassName</em>. You cannot supply your own constructor; rather, one
is implicitly supplied which simply calls the super constructor, so the
arguments supplied must fit the super constructor. (If the parent contains
multiple constructors, the “simplest” one is called, “simplest” as determined
by a rather complex set of rules not worth bothering to learn in detail--just
pay attention to what NetBeans or Eclipse tell you.)</p>
<p>Alternatively, you can specify an interface to implement:</p>
<div class="code"><pre class="code literal-block">new *InterfaceName*() {*members*}
</pre></div>

<p>Such a declaration creates a new instance of an unnamed class which extends
Object and implements <em>InterfaceName</em>. Again, you cannot supply your own
constructor; in this case, Java implicitly supplies a no-arg, do-nothing
constructor (so there will never be constructor arguments in this case).</p>
<p>Even though you can't give an anonymous inner class a constructor, you can
still do any setup you want using an initializer block (a {} block placed
outside any method).</p>
<p>Be clear that an anonymous inner class is simply a less flexible way of
creating a local inner class with one instance. If you want a local inner
class which implements multiple interfaces or which implements interfaces
while extending some class other than <em>Object</em> or which specifies its own
constructor, you're stuck creating a regular named local inner class.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/inner-classes/" rel="tag">inner-classes</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/static-classes/" rel="tag">static-classes</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../why-is-using-for-in-for-array-iteration-a-bad-idea/" rel="prev" title='Why is using "for...in" for array iteration a bad idea?'>Previous post</a>
            </li>
            <li class="next">
                <a href="../why-is-it-string-join-list-instead-of-list-join-string/" rel="next" title="Why is it string.join(list) instead of list.join(string)?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
