<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Map vs Object in JavaScript | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/map-vs-object-in-javascript/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../iterating-each-character-in-a-string-using-python/" title="Iterating each character in a string using Python" type="text/html">
<link rel="next" href="../what-algorithms-compute-directions-from-point-a-to-point-b-on-a-map/" title="What algorithms compute directions from point A to point B on a map?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Map vs Object in JavaScript">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/map-vs-object-in-javascript/">
<meta property="og:description" content="I just discovered this feature:

Map: Map objects are simple key/value maps.

That confused me. Regular JavaScript objects are dictionaries, so how is a
Map different from a dictionary? Conceptually, ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T03:55:42+08:00">
<meta property="article:tag" content="dictionary">
<meta property="article:tag" content="ecmascript-6">
<meta property="article:tag" content="javascript">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Map vs Object in JavaScript</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T03:55:42+08:00" itemprop="datePublished" title="2023-02-18 03:55">2023-02-18 03:55</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I just discovered this feature:</p>
<blockquote>
<p>Map: Map objects are simple key/value maps.</p>
</blockquote>
<p>That confused me. Regular JavaScript objects are dictionaries, so how is a
<code>Map</code> different from a dictionary? Conceptually, they're identical (according
to another question on Stack Overflow)</p>
<p>The documentation doesn't help either:</p>
<blockquote>
<p>Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript language values. A distinct key value may
only occur in one key/value pair within the Map’s collection. Distinct key
values as discriminated using the a comparision algorithm that is selected
when the Map is created.</p>
<p>A Map object can iterate its elements in insertion order. Map object must be
implemented using either hash tables or other mechanisms that, on average,
provide access times that are sublinear on the number of elements in the
collection. The data structures used in this Map objects specification is
only intended to describe the required observable semantics of Map objects.
It is not intended to be a viable implementation model.</p>
</blockquote>
<p>…still sounds like an object to me, so clearly I've missed something.</p>
<p>Why is JavaScript gaining a (well-supported) <code>Map</code> object? What does it do?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>According to MDN:</p>
<blockquote>
<p>A Map object can iterate its elements in insertion order - a <code>for..of</code> loop
will return an array of [key, value] for each iteration.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Objects are similar to Maps in that both let you set keys to values,
retrieve those values, delete keys, and detect whether something is stored
at a key. Because of this, Objects have been used as Maps historically;
however, there are important differences between Objects and Maps that make
using a Map better.</p>
<p>An Object has a prototype, so there are default keys in the map. However,
this can be bypassed using map = Object.create(null). The keys of an Object
are Strings, where they can be any value for a Map. You can get the size of
a Map easily while you have to manually keep track of size for an Object.</p>
</blockquote>
<p><em>Map</em></p>
<p>The iterability-in-order is a feature that has long been wanted by developers,
in part because it ensures the same performance in all browsers. So to me
that's a big one.</p>
<p>The <code>myMap.has(key)</code> method will be especially handy, and also the
<code>myMap.size</code> property.</p>
<p><br></p>
<h3>Suggest</h3>
<p>The key difference is that Objects only support string and Symbol keys where
as Maps support more or less any key type.</p>
<p>If I do <code>obj[123] = true</code> and then <code>Object.keys(obj)</code> then I will get
<code>["123"]</code> rather than <code>[123]</code>. A Map would preserve the type of the key and
return <code>[123]</code> which is great. Maps also allow you to use Objects as keys.
Traditionally to do this you would have to give objects some kind of unique
identifier to hash them (I don't think I've ever seen anything like
<code>getObjectId</code> in JavaScript as part of the standard). Maps also guarantee
preservation of order so are all round better for preservation and can
sometimes save you needing to do a few sorts.</p>
<p>Between maps and objects in practice there are several pros and cons. Objects
gain both advantages and disadvantages being very tightly integrated into the
core of JavaScript which sets them apart from significantly Map beyond the
difference in key support.</p>
<p>An immediate advantage is that you have syntactical support for Objects making
it easy to access elements. You also have direct support for it with JSON.
When used as a hash it's annoying to get an object without any properties at
all. By default if you want to use Objects as a hash table they will be
polluted and you will often have to call <code>hasOwnProperty</code> on them when
accessing properties. You can see here how by default Objects are polluted and
how to create hopefully unpolluted objects for use as hashes:</p>
<div class="code"><pre class="code literal-block"><span class="p">({}).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">native</span><span class="w"> </span><span class="n">code</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
<span class="n">JSON</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="err">'</span><span class="p">{}</span><span class="err">'</span><span class="p">).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">native</span><span class="w"> </span><span class="n">code</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
<span class="p">(</span><span class="n">Object</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">null</span><span class="p">)).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">undefined</span>
<span class="n">JSON</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="err">'</span><span class="p">{}</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">typeof</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="err">'</span><span class="n">object</span><span class="err">'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Object</span><span class="p">.</span><span class="n">setPrototypeOf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">null</span><span class="p">)</span><span class="w"> </span><span class="p">,</span><span class="n">v</span><span class="p">)).</span><span class="n">toString</span>
<span class="w">    </span><span class="n">undefined</span>
</pre></div>

<p>Pollution on objects is not only something that makes code more annoying,
slower, etc., but can also have potential consequences for security.</p>
<p>Objects are not pure hash tables, but they are trying to do more. You have
headaches like <code>hasOwnProperty</code>, not being able to get the length easily
(<code>Object.keys(obj).length</code>) and so on. Objects are not meant to purely be used
as hash maps, but as dynamic extensible Objects as well and so when you use
them as pure hash tables problems arise.</p>
<p>Comparison/List of various common operations:</p>
<div class="code"><pre class="code literal-block"><span class="k">Object</span><span class="err">:</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="p">;</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="k">create</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="w">   </span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">   </span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="n">o</span><span class="o">[</span><span class="n">k</span><span class="o">]++</span><span class="p">;</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">Object</span><span class="p">.</span><span class="k">values</span><span class="p">(</span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="s1">'key'</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">o</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="s1">'key'</span><span class="p">));</span>
<span class="w">   </span><span class="k">delete</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="k">key</span><span class="p">);</span>
<span class="w">   </span><span class="k">Object</span><span class="p">.</span><span class="n">keys</span><span class="p">(</span><span class="n">o</span><span class="p">).</span><span class="n">length</span>
<span class="k">Map</span><span class="err">:</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">Map</span><span class="p">();</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="s1">'key'</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s1">'key'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="n">foreach</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="nf">var</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">values</span><span class="p">())</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">has</span><span class="p">(</span><span class="s1">'key'</span><span class="p">));</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">'key'</span><span class="p">);</span>
<span class="w">   </span><span class="n">m</span><span class="p">.</span><span class="k">size</span><span class="p">();</span>
</pre></div>

<p>There are a few other options, approaches, methodologies, etc. with varying
ups and downs (performance, terse, portable, extendable, etc.). Objects are a
bit strange being core to the language so you have a lot of static methods for
working with them.</p>
<p>Besides the advantage of Maps preserving key types as well as being able to
support things like objects as keys they are isolated from the side effects
that objects much have. A Map is a pure hash, there's no confusion about
trying to be an object at the same time. Maps can also be easily extended with
proxy functions. Object's currently have a Proxy class however performance and
memory usage is grim, in fact creating your own proxy that looks like Map for
Objects currently performs better than Proxy.</p>
<p>A substantial disadvantage for Maps is that they are not supported with JSON
directly. Parsing is possible, but it has several hangups:</p>
<div class="code"><pre class="code literal-block"><span class="n">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nf">str</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="s1">'object'</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="k">Map</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="err">}</span><span class="p">);</span>
</pre></div>

<p>The above will introduce a serious performance hit and will also not support
any string keys. JSON encoding is even more difficult and problematic (this is
one of many approaches):</p>
<div class="code"><pre class="code literal-block"><span class="c1">// An alternative to this it to use a replacer in JSON.stringify.</span>
<span class="n">Map</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">toJSON</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">JSON</span><span class="p">.</span><span class="n">stringify</span><span class="p">({</span>
<span class="w">        </span><span class="n">keys</span><span class="p">:</span><span class="w"> </span><span class="n">Array</span><span class="p">.</span><span class="n">from</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">keys</span><span class="p">()),</span>
<span class="w">        </span><span class="n">values</span><span class="p">:</span><span class="w"> </span><span class="n">Array</span><span class="p">.</span><span class="n">from</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">};</span>
</pre></div>

<p>This is not so bad if you're purely using Maps, but it will have problems when
you are mixing types or using non-scalar values as keys (not that JSON is
perfect with that kind of issue as it is, IE circular object reference). I
haven't tested it, but chances are that it will severely hurt performance
compared to stringify.</p>
<p>Other scripting languages often don't have such problems as they have explicit
non-scalar types for Map, Object and Array. Web development is often a pain
with non-scalar types where you have to deal with things like PHP merges
Array/Map with Object using A/M for properties and JavaScript merges
Map/Object with Array extending M/O. Merging complex types is the devil's bane
of high level scripting languages.</p>
<p>So far these are largely issues around implementation, but performance for
basic operations is important as well. Performance is also complex because it
depends on engine and usage. Take my tests with a grain of salt as I cannot
rule out any mistake (I have to rush this). You should also run your own tests
to confirm as mine examine only very specific simple scenarios to give a rough
indication only. According to tests in Chrome for very large objects/maps the
performance for objects is worse because of delete which is apparently somehow
proportionate to the number of keys rather than O(1):</p>
<div class="code"><pre class="code literal-block">Object Set Took: 146
Object Update Took: 7
Object Get Took: 4
Object Delete Took: 8239
Map Set Took: 80
Map Update Took: 51
Map Get Took: 40
Map Delete Took: 2
</pre></div>

<p>Chrome clearly has a strong advantage with getting and updating, but the
delete performance is horrific. Maps use a tiny amount more memory in this
case (overhead), but with only one Object/Map being tested with millions of
keys the impact of overhead for maps is not expressed well. With memory
management objects also do seem to free earlier if I am reading the profile
correctly which might be one benefit in favor of objects.</p>
<p>In Firefox for this particular benchmark it is a different story:</p>
<div class="code"><pre class="code literal-block">Object Set Took: 435
Object Update Took: 126
Object Get Took: 50
Object Delete Took: 2
Map Set Took: 63
Map Update Took: 59
Map Get Took: 33
Map Delete Took: 1
</pre></div>

<p>I should immediately point out that in this particular benchmark deleting from
objects in Firefox is not causing any problems, however in other benchmarks it
has caused problems especially when there are many keys just as in Chrome.
Maps are clearly superior in Firefox for large collections.</p>
<p>However this is not the end of the story, what about many small objects or
maps? I have done a quick benchmark of this, but not an exhaustive one
(setting/getting) of which performs best with a small number of keys in the
above operations. This test is more about memory and initialization.</p>
<div class="code"><pre class="code literal-block">Map Create: 69    // new Map
Object Create: 34 // {}
</pre></div>

<p>Again these figures vary, but basically Object has a good lead. In some cases
the lead for Objects over maps is extreme (~10 times better), but on average
it was around 2-3 times better. It seems extreme performance spikes can work
both ways. I only tested this in Chrome and creation to profile memory usage
and overhead. I was quite surprised to see that in Chrome it appears that Maps
with one key use around 30 times more memory than Objects with one key.</p>
<p>For testing many small objects with all the above operations (4 keys):</p>
<div class="code"><pre class="code literal-block">Chrome Object Took: 61
Chrome Map Took: 67
Firefox Object Took: 54
Firefox Map Took: 139
</pre></div>

<p>In terms of memory allocation these behaved the same in terms of freeing/GC,
but Map used five times more memory. This test used four keys where as in the
last test I only set one key so this would explain the reduction in memory
overhead. I ran this test a few times and Map/Object are more or less neck and
neck overall for Chrome in terms of overall speed. In Firefox for small
Objects there is a definite performance advantage over maps overall.</p>
<p>This of course doesn't include the individual options which could vary wildly.
I would not advice micro-optimizing with these figures. What you can get out
of this is that as a rule of thumb, consider Maps more strongly for very large
key value stores and objects for small key value stores.</p>
<p>Beyond that the best strategy with these two it to implement it and just make
it work first. When profiling it is important to keep in mind that sometimes
things that you wouldn't think would be slow when looking at them can be
incredibly slow because of engine quirks as seen with the object key deletion
case.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dictionary/" rel="tag">dictionary</a></li>
            <li><a class="tag p-category" href="../../categories/ecmascript-6/" rel="tag">ecmascript-6</a></li>
            <li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../iterating-each-character-in-a-string-using-python/" rel="prev" title="Iterating each character in a string using Python">Previous post</a>
            </li>
            <li class="next">
                <a href="../what-algorithms-compute-directions-from-point-a-to-point-b-on-a-map/" rel="next" title="What algorithms compute directions from point A to point B on a map?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
