<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Getting started with Haskell | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/getting-started-with-haskell/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../understanding-checked-vs-unchecked-exceptions-in-java/" title="Understanding checked vs unchecked exceptions in Java" type="text/html">
<link rel="next" href="../git-push-error-insufficient-permission-for-adding-an-object-to-repository-database/" title="Git Push Error: insufficient permission for adding an object to repository database" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Getting started with Haskell">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/getting-started-with-haskell/">
<meta property="og:description" content="This question's answers are a community effort. Edit existing answers to
improve this post. It is not currently accepting new answers or interactions.
For a few days I've tried to wrap my head around ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T15:13:38+08:00">
<meta property="article:tag" content="functional-programming">
<meta property="article:tag" content="haskell">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Getting started with Haskell</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:13:38+08:00" itemprop="datePublished" title="2023-02-17 15:13">2023-02-17 15:13</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p><strong>This question's answers are a community effort</strong>. Edit existing answers to
improve this post. It is not currently accepting new answers or interactions.</p>
<p>For a few days I've tried to wrap my head around the functional programming
paradigm in Haskell. I've done this by reading tutorials and watching
screencasts, but nothing really seems to stick. Now, in learning various
imperative/OO languages (like C, Java, PHP), exercises have been a good way
for me to go. But since I don't really know what Haskell is capable of and
because there are many new concepts to utilize, I haven't known where to
start.</p>
<p>So, how did you learn Haskell? What made you really "break the ice"? Also, any
good ideas for beginning exercises?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I'm going to order this guide by the level of skill you have in Haskell, going
from an absolute beginner right up to an expert. Note that this process will
take many months (years?), so it is rather long.</p>
<p><strong>Absolute Beginner</strong></p>
<p>Firstly, Haskell is capable of anything, with enough skill. It is very fast
(behind only C and C++ in my experience), and can be used for anything from
simulations to servers, guis and web applications.</p>
<p>However there are some problems that are easier to write for a beginner in
Haskell than others. Mathematical problems and list process programs are good
candidates for this, as they only require the most basic of Haskell knowledge
to be able to write.</p>
<p>Some good guides to learning the very basics of Haskell are the Happy Learn
Haskell Tutorial and the first 6 chapters of Learn You a Haskell for Great
Good (or its JupyterLab adaptation). While reading these, it is a very good
idea to also be solving simple problems with what you know.</p>
<p>Another two good resources are Haskell Programming from first principles, and
Programming in Haskell. They both come with exercises for each chapter, so you
have small simple problems matching what you learned on the last few pages.</p>
<p>A good list of problems to try is the haskell 99 problems page. These start
off very basic, and get more difficult as you go on. It is very good practice
doing a lot of those, as they let you practice your skills in recursion and
higher order functions. I would recommend skipping any problems that require
randomness as that is a bit more difficult in Haskell. Check this SO question
in case you want to test your solutions with QuickCheck (see <em>Intermediate</em>
below).</p>
<p>Once you have done a few of those, you could move on to doing a few of the
Project Euler problems. These are sorted by how many people have completed
them, which is a fairly good indication of difficulty. These test your logic
and Haskell more than the previous problems, but you should still be able to
do the first few. A big advantage Haskell has with these problems is Integers
aren't limited in size. To complete some of these problems, it will be useful
to have read chapters 7 and 8 of learn you a Haskell as well.</p>
<p><strong>Beginner</strong></p>
<p>After that you should have a fairly good handle on recursion and higher order
functions, so it would be a good time to start doing some more real world
problems. A very good place to start is Real World Haskell (online book, you
can also purchase a hard copy). I found the first few chapters introduced too
much too quickly for someone who has never done functional programming/used
recursion before. However with the practice you would have had from doing the
previous problems you should find it perfectly understandable.</p>
<p>Working through the problems in the book is a great way of learning how to
manage abstractions and building reusable components in Haskell. This is vital
for people used to object-orientated (oo) programming, as the normal oo
abstraction methods (oo classes) don't appear in Haskell (Haskell has type
classes, but they are very different to oo classes, more like oo interfaces).
I don't think it is a good idea to skip chapters, as each introduces a lot new
ideas that are used in later chapters.</p>
<p>After a while you will get to chapter 14, the dreaded monads chapter (dum dum
dummmm). Almost everyone who learns Haskell has trouble understanding monads,
due to how abstract the concept is. I can't think of any concept in another
language that is as abstract as monads are in functional programming. Monads
allows many ideas (such as IO operations, computations that might fail,
parsing,...) to be unified under one idea. So don't feel discouraged if after
reading the monads chapter you don't really understand them. I found it useful
to read many different explanations of monads; each one gives a new
perspective on the problem. Here is a very good list of monad tutorials. I
highly recommend the All About Monads, but the others are also good.</p>
<p>Also, it takes a while for the concepts to truly sink in. This comes through
use, but also through time. I find that sometimes sleeping on a problem helps
more than anything else! Eventually, the idea will click, and you will wonder
why you struggled to understand a concept that in reality is incredibly
simple. It is awesome when this happens, and when it does, you might find
Haskell to be your favorite imperative programming language :)</p>
<p>To make sure that you are understanding Haskell type system perfectly, you
should try to solve 20 intermediate haskell exercises. Those exercises using
fun names of functions like "furry" and "banana" and helps you to have a good
understanding of some basic functional programming concepts if you don't have
them already. Nice way to spend your evening with a bunch of papers covered
with arrows, unicorns, sausages and furry bananas.</p>
<p><strong>Intermediate</strong></p>
<p>Once you understand Monads, I think you have made the transition from a
beginner Haskell programmer to an intermediate haskeller. So where to go from
here? The first thing I would recommend (if you haven't already learnt them
from learning monads) is the various types of monads, such as Reader, Writer
and State. Again, Real world Haskell and All about monads gives great coverage
of this. To complete your monad training learning about monad transformers is
a must. These let you combine different types of Monads (such as a Reader and
State monad) into one. This may seem useless to begin with, but after using
them for a while you will wonder how you lived without them.</p>
<p>Now you can finish the real world Haskell book if you want. Skipping chapters
now doesn't really matter, as long as you have monads down pat. Just choose
what you are interested in.</p>
<p>With the knowledge you would have now, you should be able to use most of the
packages on cabal (well the documented ones at least...), as well as most of
the libraries that come with Haskell. A list of interesting libraries to try
would be:</p>
<ul>
<li>
<p>Parsec: for parsing programs and text. Much better than using regexps. Excellent documentation, also has a real world Haskell chapter.</p>
</li>
<li>
<p>QuickCheck: A very cool testing program. What you do is write a predicate that should always be true (eg <code>length (reverse lst) == length lst</code>). You then pass the predicate the QuickCheck, and it will generate a lot of random values (in this case lists) and test that the predicate is true for all results. See also the online manual.</p>
</li>
<li>
<p>HUnit: Unit testing in Haskell.</p>
</li>
<li>
<p>gtk2hs: The most popular gui framework for Haskell, lets you write gtk applications.</p>
</li>
<li>
<p>happstack: A web development framework for Haskell. Doesn't use databases, instead a data type store. Pretty good docs (other popular frameworks would be snap and yesod).</p>
</li>
</ul>
<p>Also, there are many concepts (like the Monad concept) that you should
eventually learn. This will be easier than learning Monads the first time, as
your brain will be used to dealing with the level of abstraction involved. A
very good overview for learning about these high level concepts and how they
fit together is the Typeclassopedia.</p>
<ul>
<li>
<p>Applicative: An interface like Monads, but less powerful. Every Monad is Applicative, but not vice versa. This is useful as there are some types that are Applicative but are not Monads. Also, code written using the Applicative functions is often more composable than writing the equivalent code using the Monad functions. See Functors, Applicative Functors and Monoids from the learn you a haskell guide.</p>
</li>
<li>
<p>Foldable,Traversable: Typeclasses that abstract many of the operations of lists, so that the same functions can be applied to other container types. See also the haskell wiki explanation.</p>
</li>
<li>
<p>Monoid: A Monoid is a type that has a zero (or mempty) value, and an operation, notated <code>&lt;&gt;</code> that joins two Monoids together, such that <code>x &lt;&gt; mempty = mempty &lt;&gt; x = x</code> and <code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z</code>. These are called identity and associativity laws. Many types are Monoids, such as numbers, with <code>mempty = 0</code> and <code>&lt;&gt; = +</code>. This is useful in many situations.</p>
</li>
<li>
<p>Arrows: Arrows are a way of representing computations that take an input and return an output. A function is the most basic type of arrow, but there are many other types. The library also has many very useful functions for manipulating arrows - they are very useful even if only used with plain old Haskell functions.</p>
</li>
<li>
<p>Arrays: the various mutable/immutable arrays in Haskell.</p>
</li>
<li>
<p>ST Monad: lets you write code with a mutable state that runs very quickly, while still remaining pure outside the monad. See the link for more details.</p>
</li>
<li>
<p>FRP: Functional Reactive Programming, a new, experimental way of writing code that handles events, triggers, inputs and outputs (such as a gui). I don't know much about this though. Paul Hudak's talk about yampa is a good start.</p>
</li>
</ul>
<p>There are a lot of new language features you should have a look at. I'll just
list them, you can find lots of info about them from google, the haskell
wikibook, the haskellwiki.org site and ghc documentation.</p>
<ul>
<li>Multiparameter type classes/functional dependencies</li>
<li>Type families</li>
<li>Existentially quantified types</li>
<li>Phantom types</li>
<li>GADTS</li>
<li>others...</li>
</ul>
<p>A lot of Haskell is based around category theory, so you may want to look into
that. A good starting point is Category Theory for Computer Scientist. If you
don't want to buy the book, the author's related article is also excellent.</p>
<p>Finally you will want to learn more about the various Haskell tools. These
include:</p>
<ul>
<li>ghc (and all its features)</li>
<li>cabal: the Haskell package system</li>
<li>darcs: a distributed version control system written in Haskell, very popular for Haskell programs.</li>
<li>haddock: a Haskell automatic documentation generator</li>
</ul>
<p>While learning all these new libraries and concepts, it is very useful to be
writing a moderate-sized project in Haskell. It can be anything (e.g. a small
game, data analyser, website, compiler). Working on this will allow you to
apply many of the things you are now learning. You stay at this level for ages
(this is where I'm at).</p>
<p><strong>Expert</strong></p>
<p>It will take you years to get to this stage (hello from 2009!), but from here
I'm guessing you start writing phd papers, new ghc extensions, and coming up
with new abstractions.</p>
<p><strong>Getting Help</strong></p>
<p>Finally, while at any stage of learning, there are multiple places for getting
information. These are:</p>
<ul>
<li>the #haskell irc channel</li>
<li>the mailing lists. These are worth signing up for just to read the discussions that take place - some are very interesting.</li>
<li>other places listed on the haskell.org home page</li>
</ul>
<p><strong>Conclusion</strong></p>
<p>Well this turned out longer than I expected... Anyway, I think it is a very
good idea to become proficient in Haskell. It takes a long time, but that is
mainly because you are learning a completely new way of thinking by doing so.
It is not like learning Ruby after learning Java, but like learning Java after
learning C. Also, I am finding that my object-orientated programming skills
have improved as a result of learning Haskell, as I am seeing many new ways of
abstracting ideas.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Some colleague of mine had good experience with Learn You a Haskell for Great
Good!.</p>
<blockquote>
<p>Tutorial aimed at people who have experience in imperative programming
languages but haven't programmed in a functional language before.</p>
</blockquote>
<p>And check the answers here too</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/functional-programming/" rel="tag">functional-programming</a></li>
            <li><a class="tag p-category" href="../../categories/haskell/" rel="tag">haskell</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../understanding-checked-vs-unchecked-exceptions-in-java/" rel="prev" title="Understanding checked vs unchecked exceptions in Java">Previous post</a>
            </li>
            <li class="next">
                <a href="../git-push-error-insufficient-permission-for-adding-an-object-to-repository-database/" rel="next" title="Git Push Error: insufficient permission for adding an object to repository database">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
