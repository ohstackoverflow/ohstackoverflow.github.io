<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript 闭包是如何工作的？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/javascript-bi-bao-shi-ru-he-gong-zuo-de/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../python-you-san-yuan-tiao-jian-yun-suan-fu-ma/" title="Python 有三元条件运算符吗？" type="text/html">
<link rel="next" href="../ru-he-jiang-git-cun-chu-ku-hui-fu-wei-zhi-qian-de-ti-jiao/" title="如何将 Git 存储库恢复为之前的提交？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="JavaScript 闭包是如何工作的？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/javascript-bi-bao-shi-ru-he-gong-zuo-de/">
<meta property="og:description" content="这个问题的答案是 社区的努力。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。
您如何向了解闭包所包含的概念（例如函数、变量等）但不了解闭包本身的人解释 JavaScript 闭包？
我看过维基百科上给出的Scheme 示例，但不幸的是它没有帮助。

解答
闭包是一对：

一个函数和
对该函数的外部范围（词法环境）的引用

词法环境是每个执行上下文（堆栈框架）的一部分，并且是标识符（即局部">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T18:24:18+08:00">
<meta property="article:tag" content="closures">
<meta property="article:tag" content="function">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="scope">
<meta property="article:tag" content="variables">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">JavaScript 闭包是如何工作的？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:24:18+08:00" itemprop="datePublished" title="2023-02-16 18:24">2023-02-16 18:24</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>您如何向了解闭包所包含的概念（例如函数、变量等）但不了解闭包本身的人解释 JavaScript 闭包？</p>
<p>我看过维基百科上给出的Scheme 示例，但不幸的是它没有帮助。</p>
<p><br><br></p>
<h2>解答</h2>
<p>闭包是一对：</p>
<ol>
<li>一个函数和</li>
<li>对该函数的外部范围（词法环境）的引用</li>
</ol>
<p>词法环境是每个执行上下文（堆栈框架）的一部分，并且是标识符（即局部变量名）和值之间的映射。</p>
<p>JavaScript
中的每个函数都维护对其外部词法环境的引用。此引用用于配置调用函数时创建的执行上下文。此引用使函数内部的代码能够“查看”在函数外部声明的变量，而不管函数何时何地被调用。</p>
<p>如果一个函数被一个函数调用，而这个函数又被另一个函数调用，那么就会创建一个指向外部词法环境的引用链。这个链称为作用域链。</p>
<p>在下面的代码中，用调用<code>inner</code>时创建的执行上下文的词法环境形成一个闭包， <em>关闭</em> 变量：<code>foo</code> __<code>secret</code></p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="n">const</span><span class="w"> </span><span class="n">secret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="k">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">inner</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n n-Quoted">`The secret number is ${secret}.`</span><span class="p">)</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
<span class="n">const</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`secret`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="k">accessible</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n n-Quoted">`foo`</span>
<span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">retrieve</span><span class="w"> </span><span class="n n-Quoted">`secret`</span><span class="p">,</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">invoke</span><span class="w"> </span><span class="n n-Quoted">`f`</span>
</pre></div>

<p>换句话说：在 JavaScript
中，函数带有对私有“状态框”的引用，只有它们（以及在同一词法环境中声明的任何其他函数）才能访问它。这个状态框对函数的调用者是不可见的，为数据隐藏和封装提供了一个很好的机制。</p>
<p>请记住：JavaScript 中的函数可以像变量一样传递（一等函数），这意味着这些功能和状态的配对可以在您的程序中传递：类似于您在 C++
中传递类实例的方式。</p>
<p>如果 JavaScript 没有闭包，则必须在函数之间显式传递更多状态 <em>，</em> 从而使参数列表更长且代码更嘈杂。</p>
<p>因此，如果您希望函数始终可以访问私有状态，则可以使用闭包。</p>
<p>...而且我们经常 <em>希望</em> 将状态与功能相关联。例如，在 Java 或 C++ 中，当您向类添加私有实例变量和方法时，您将状态与功能相关联。</p>
<p>在 C 和大多数其他常见语言中，函数返回后，所有局部变量都不再可访问，因为堆栈框架已被破坏。在 JavaScript
中，如果你在另一个函数中声明一个函数，那么外部函数的局部变量在从它返回后仍然可以访问。这样，在上面的代码中，函数对象在从返回
<em>后</em><code>secret</code>仍然可用。<code>inner</code> __<code>foo</code></p>
<h3>闭包的使用</h3>
<p>当您需要与函数关联的私有状态时，闭包很有用。这是一个非常常见的场景 - 请记住：JavaScript 直到 2015
年才具有类语法，并且它仍然没有私有字段语法。闭包满足了这种需求。</p>
<h4>私有实例变量</h4>
<p>在下面的代码中，该函数<code>toString</code>关闭了汽车的详细信息。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">Car</span><span class="p">(</span><span class="n">manufacturer</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="err">`</span><span class="o">$</span><span class="p">{</span><span class="n">manufacturer</span><span class="p">}</span><span class="w"> </span><span class="o">$</span><span class="p">{</span><span class="n">model</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="p">{</span><span class="n">year</span><span class="p">},</span><span class="w"> </span><span class="o">$</span><span class="p">{</span><span class="n">color</span><span class="p">})</span><span class="err">`</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Car</span><span class="p">(</span><span class="s1">'Aston Martin'</span><span class="p">,</span><span class="w"> </span><span class="s1">'V8 Vantage'</span><span class="p">,</span><span class="w"> </span><span class="s1">'2012'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Quantum Silver'</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">car</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>

<h4>函数式编程</h4>
<p>在下面的代码中，函数<code>inner</code>关闭了<code>fn</code>和<code>args</code>。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">curry</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">inner</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">fn</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="o">...</span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="n">args</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">inner</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">function</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">curriedAdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curry</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">curriedAdd</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)())</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<h4>面向事件的编程</h4>
<p>在下面的代码中，函数<code>onClick</code>关闭了变量<code>BACKGROUND_COLOR</code>。</p>
<div class="code"><pre class="code literal-block">const<span class="w"> </span>$<span class="w"> </span>=<span class="w"> </span>document.querySelector.bind(document)
const<span class="w"> </span>BACKGROUND_COLOR<span class="w"> </span>=<span class="w"> </span>'rgba(200,<span class="w"> </span>200,<span class="w"> </span>242,<span class="w"> </span>1)'

function<span class="w"> </span>onClick()<span class="w"> </span>{
<span class="w">  </span>$('body').style.background<span class="w"> </span>=<span class="w"> </span>BACKGROUND_COLOR
}

$('button').addEventListener('click',<span class="w"> </span>onClick)


<span class="nt">&lt;button&gt;</span>Set<span class="w"> </span>background<span class="w"> </span>color<span class="nt">&lt;/button&gt;</span>
</pre></div>

<h4>模块化</h4>
<p>在下面的例子中，所有的实现细节都隐藏在一个立即执行的函数表达式中。函数<code>tick</code>并<code>toString</code>关闭他们完成工作所需的私有状态和函数。闭包使我们能够模块化和封装我们的代码。</p>
<div class="code"><pre class="code literal-block"><span class="n">let</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">tick</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">numbers</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">Math</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">n</span><span class="o">.</span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tick</span><span class="p">,</span>
<span class="w">    </span><span class="n">toString</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}(</span><span class="n">namespace</span><span class="p">))</span>

<span class="k">const</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">namespace</span><span class="o">.</span><span class="n">counter</span>
<span class="n">counter</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
<span class="n">counter</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
</pre></div>

<h3>例子</h3>
<h4>示例 1</h4>
<p>这个例子表明局部变量没有被复制到闭包中：闭包维护了对原始变量 <em>本身的</em> 引用。就好像即使在外部函数退出后，堆栈框架仍然存在于内存中。</p>
<div class="code"><pre class="code literal-block"><span class="nv">function</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span>
<span class="w">  </span><span class="nv">let</span><span class="w"> </span><span class="nv">inner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nv">console</span>.<span class="nv">log</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>
<span class="w">  </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">inner</span>
}

<span class="nv">foo</span><span class="ss">()()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nv">logs</span><span class="w"> </span><span class="mi">43</span>
</pre></div>

<h4>示例 2</h4>
<p>在下面的代码中，三个方法<code>log</code>, <code>increment</code>, 和<code>update</code>都关闭了相同的词法环境。</p>
<p>每次<code>createObject</code>调用时，都会创建一个新的执行上下文（堆栈框架）和一个全新的变量，并创建<code>x</code>一组新的函数（等），这些函数会关闭这个新变量。<code>log</code></p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">log</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="n">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">43</span>
<span class="n">o</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">o</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">5</span>
<span class="k">const</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createObject</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">42</span>
</pre></div>

<h4>示例 3</h4>
<p>If you are using variables declared using <code>var</code>, be careful you understand
which variable you are closing over. Variables declared using <code>var</code> are
hoisted. This is much less of a problem in modern JavaScript due to the
introduction of <code>let</code> and <code>const</code>.</p>
<p>In the following code, each time around the loop, a new function <code>inner</code> is
created, which closes over <code>i</code>. But because <code>var i</code> is hoisted outside the
loop, all of these inner functions close over the same variable, meaning that
the final value of <code>i</code> (3) is printed, three times.</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="nf">var</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">[]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">result</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">function</span><span class="w"> </span><span class="k">inner</span><span class="p">()</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="err">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">result</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="k">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">print</span><span class="w"> </span><span class="err">`</span><span class="mi">3</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="n">times</span><span class="p">...</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="k">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">()</span><span class="w"> </span>
<span class="err">}</span>
</pre></div>

<h3>Final points:</h3>
<ul>
<li>Whenever a function is declared in JavaScript closure is created.</li>
<li>Returning a <code>function</code> from inside another function is the classic example of closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.</li>
<li>Whenever you use <code>eval()</code> inside a function, a closure is used. The text you <code>eval</code> can reference local variables of the function, and in the non-strict mode, you can even create new local variables by using <code>eval('var foo = …')</code>.</li>
<li>When you use <code>new Function(…)</code> (the Function constructor) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.</li>
<li>A closure in JavaScript is like keeping a reference ( <strong>NOT</strong> a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.</li>
<li>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</li>
<li>A new set of local variables is created every time a function is called.</li>
</ul>
<h3>Links</h3>
<ul>
<li>Douglas Crockford's simulated private attributes and private methods for an object, using closures.</li>
<li>A great explanation of how closures can cause memory leaks in IE if you are not careful.</li>
<li>MDN documentation on JavaScript Closures.</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>JavaScript 中的每个函数都维护到其外部词法环境的链接。词法环境是范围内所有名称（例如变量、参数）及其值的映射。</p>
<p>因此，只要您看到<code>function</code>关键字，该函数内的代码就可以访问在函数外声明的变量。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">  </span><span class="n">function</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">tmp</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="nb">log</span><span class="w"> </span><span class="mi">16</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>

<p>这将记录下来<code>16</code>，因为函数<code>bar</code>关闭了参数<code>x</code>和变量<code>tmp</code>，这两者都存在于外部函数的词法环境中<code>foo</code>。</p>
<p>Function<code>bar</code>连同它与 function 的词法环境的链接<code>foo</code>是一个闭包。</p>
<p>函数不必为了创建闭包而 <em>返回。</em> 仅仅凭借其声明，每个函数都关闭其封闭的词法环境，形成一个闭包。</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">tmp</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="nb">log</span><span class="w"> </span><span class="mi">16</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">16</span>
<span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">17</span>
</pre></div>

<p>上面的函数也会记录 16，因为里面的代码<code>bar</code>仍然可以引用 argument<code>x</code>和 variable <code>tmp</code>，即使它们不再直接在范围内。</p>
<p>但是，由于<code>tmp</code>is 仍然在 的闭包内徘徊<code>bar</code>，因此可以对其进行递增。每次调用时它都会递增<code>bar</code>。</p>
<p>闭包最简单的例子是这样的：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="n">function</span><span class="w"> </span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="mi">6</span>
<span class="p">}</span>
<span class="k">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="n">test</span><span class="p">();</span>
</pre></div>

<p>调用 JavaScript
函数时，<code>ec</code>会创建一个新的执行上下文。与函数参数和目标对象一起，此执行上下文还接收到调用执行上下文的词法环境的链接，这意味着在外部词法环境中声明的变量（在上面的示例中，
和 ）都<code>a</code>可以<code>b</code>从<code>ec</code>.</p>
<p>每个函数都会创建一个闭包，因为每个函数都有一个到其外部词法环境的链接。</p>
<p>请注意，变量 <em>本身</em> 在闭包中是可见的， <em>而不是</em> 副本。</p>
<p><br><br><a href="../how-do-javascript-closures-work/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/closures/" rel="tag">closures</a></li>
            <li><a class="tag p-category" href="../../categories/function/" rel="tag">function</a></li>
            <li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
            <li><a class="tag p-category" href="../../categories/scope/" rel="tag">scope</a></li>
            <li><a class="tag p-category" href="../../categories/variables/" rel="tag">variables</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../python-you-san-yuan-tiao-jian-yun-suan-fu-ma/" rel="prev" title="Python 有三元条件运算符吗？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-jiang-git-cun-chu-ku-hui-fu-wei-zhi-qian-de-ti-jiao/" rel="next" title="如何将 Git 存储库恢复为之前的提交？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
