<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么时候在 Java 中使用 LinkedList 而不是 ArrayList？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-hou-zai-java-zhong-shi-yong-linkedlist-er-bu-shi-arraylist/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../shi-yao-shi-yi-lai-zhu-ru/" title="什么是依赖注入？" type="text/html">
<link rel="next" href="../ru-he-xun-huan-bian-li-huo-mei-ju-javascript-dui-xiang/" title="如何循环遍历或枚举 JavaScript 对象？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么时候在 Java 中使用 LinkedList 而不是 ArrayList？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-hou-zai-java-zhong-shi-yong-linkedlist-er-bu-shi-arraylist/">
<meta property="og:description" content="我一直是一个简单使用的人：
List&lt;String&gt; names = new ArrayList&lt;&gt;();


我使用接口作为 可移植性 的类型名称，这样当我提出这样的问题时，我可以重新编写我的代码。
什么时候应该LinkedList结束使用ArrayList，反之亦然？

解答
Summary ArrayList withArrayDeque在 更多 用例中比LinkedList.
如果你不确定">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T19:34:08+08:00">
<meta property="article:tag" content="arraylist">
<meta property="article:tag" content="collections">
<meta property="article:tag" content="java">
<meta property="article:tag" content="linked-list">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么时候在 Java 中使用 LinkedList 而不是 ArrayList？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T19:34:08+08:00" itemprop="datePublished" title="2023-02-16 19:34">2023-02-16 19:34</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我一直是一个简单使用的人：</p>
<div class="code"><pre class="code literal-block">List&lt;String&gt; names = new ArrayList&lt;&gt;();
</pre></div>

<p>我使用接口作为 <em>可移植性</em> 的类型名称，这样当我提出这样的问题时，我可以重新编写我的代码。</p>
<p>什么时候应该<code>LinkedList</code>结束使用<code>ArrayList</code>，反之亦然？</p>
<p><br><br></p>
<h2>解答</h2>
<p><strong>Summary</strong> <code>ArrayList</code> with<code>ArrayDeque</code>在 <em>更多</em> 用例中比<code>LinkedList</code>.
如果你不确定——就从<code>ArrayList</code>.</p>
<hr>
<p>TLDR，<code>ArrayList</code>访问一个元素需要常数时间 [O(1)] 并且添加一个元素需要 O(n) 时间
[最坏情况]。插入<code>LinkedList</code>一个元素需要 O(n) 时间，访问也需要 O(n)
时间，但<code>LinkedList</code>使用的内存比<code>ArrayList</code>.</p>
<p><code>LinkedList</code>并且<code>ArrayList</code>是接口的两个不同实现<code>List</code>。<code>LinkedList</code>用双向链表实现它。<code>ArrayList</code>使用动态调整大小的数组来实现它。</p>
<p>与标准链表和数组操作一样，各种方法将具有不同的算法运行时间。</p>
<p>为了<code>LinkedList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> when <code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>getFirst()</code>and <code>getLast()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>add(int index, E element)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> 时<code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>addFirst()</code>and <code>addLast()</code>/ <code>add()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>remove(int index)</code>是 <em>O(n)</em> （平均有 <em>n/4步），但</em> <em>O(1)</em> when <code>index = 0</code>or <code>index = list.size() - 1</code>（在这种情况下，您也可以使用<code>removeFirst()</code>and <code>removeLast()</code>）。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>Iterator.remove()</code>是 <em>O(1)</em> 。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
<li>
<code>ListIterator.add(E element)</code>是 <em>O(1)</em> 。 <strong>的主要好处之一</strong> <code>LinkedList&lt;E&gt;</code>
</li>
</ul>
<p>注意：许多操作平均需要 <em>n/4</em> 步，最佳情况下的步数 <em>不变（例如索引 = 0），最坏情况下的</em> <em>n/2</em> 步（列表中间）</p>
<p>为了<code>ArrayList&lt;E&gt;</code></p>
<ul>
<li>
<code>get(int index)</code>是 <em>O(1)</em> 。 <strong>的主要好处</strong> <code>ArrayList&lt;E&gt;</code>
</li>
<li>
<code>add(E element)</code>是 <em>O(1)</em> 摊销，但 <em>O(n)</em> 最坏的情况，因为数组必须调整大小和复制</li>
<li>
<code>add(int index, E element)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>remove(int index)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>Iterator.remove()</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
<li>
<code>ListIterator.add(E element)</code>是 <em>O(n)</em> （平均有 <em>n/2 个步骤）</em>
</li>
</ul>
<p>注意：许多操作平均需要 <em>n/2</em> 步，最佳情况下（列表末尾）的步数 <em>不变</em> ，最坏情况下的 <em>n步（列表开始）</em></p>
<p><code>LinkedList&lt;E&gt;</code> <em>允许使用迭代器</em>
进行恒定时间的插入或删除，但只能顺序访问元素。换句话说，您可以向前或向后遍历列表，但在列表中找到一个位置所花费的时间与列表的大小成正比。Javadoc 说
<em>“索引到列表中的操作将从开头或结尾遍历列表，以更接近者为准”</em> ，因此这些方法平均为 <em>O(n)</em> （ <em>n/4步</em> <em>）</em> ，尽管<code>index =
0</code>.</p>
<p><code>ArrayList&lt;E&gt;</code>，另一方面，允许快速随机读取访问，因此您可以在恒定时间内抓取任何元素。但是从除结尾以外的任何地方添加或删除都需要将后面的所有元素移过来，以形成一个开口或填补空白。此外，如果添加的元素多于底层数组的容量，则会分配一个新数组（大小的
1.5 倍），并将旧数组复制到新数组中，因此添加到 an 最坏情况下是 O ( <code>ArrayList</code>n <em>)</em> 情况但平均不变。</p>
<p>因此，根据您打算执行的操作，您应该相应地选择实现。遍历任何一种 List 实际上都同样便宜。（迭代
an<code>ArrayList</code>在技术上更快，但除非你正在做一些真正对性能敏感的事情，否则你不应该担心这一点——它们都是常量。）</p>
<p><code>LinkedList</code>当您重新使用现有的迭代器来插入和删除元素时，使用 a 的主要好处就会出现。然后可以通过仅在本地更改列表来在 <em>O(1)</em>
中完成这些操作。在数组列表中，数组的其余部分需要移动 <em>（</em> 即复制）。另一方面，在最坏的情况<code>LinkedList</code>下，在 <em>O(n)</em> （
<em>n/2步）中寻找一种方法，而在</em> <em>O(1)</em><code>ArrayList</code>中可以通过数学计算和访问所需的位置。 __</p>
<p><code>LinkedList</code>当您从列表的头部添加或删除时，使用 a 的另一个好处是，因为这些操作是 <em>O(1)</em> ，而它们是 <em>O(n)</em> for
<code>ArrayList</code>。请注意，这<code>ArrayDeque</code>可能是<code>LinkedList</code>从头部添加和删除的一个很好的替代方法，但它不是<code>List</code>.</p>
<p>此外，如果您有大列表，请记住内存使用量也不同。a
的每个元素<code>LinkedList</code>都有更多的开销，因为还存储了指向下一个和前一个元素的指针。<code>ArrayLists</code>没有这个开销。但是，<code>ArrayLists</code>无论是否实际添加了元素，都会占用为容量分配的内存。</p>
<p>an 的默认初始容量<code>ArrayList</code>非常小（Java 1.4 - 1.8 为
10）。但是由于底层实现是一个数组，如果你添加了很多元素，就必须调整数组的大小。当您知道要添加大量元素时，为避免调整大小的高成本，请<code>ArrayList</code>使用更高的初始容量构建
。</p>
<p>如果从数据结构的角度来理解这两种结构，LinkedList 基本上是一个包含头节点的顺序数据结构。Node 是两个组件的包装器：一个 T 类型的值
[通过泛型接受] 和另一个对链接到它的 Node
的引用。所以，我们可以断言它是一个递归数据结构（一个节点包含另一个节点，另一个节点有另一个节点等等......）。如上所述，在 LinkedList
中添加元素需要线性时间。</p>
<p>ArrayList 是一个可增长的数组。它就像一个常规数组。在引擎盖下，当添加一个元素并且 ArrayList
已经满载时，它会创建另一个数组，其大小大于以前的大小。然后将元素从先前的数组复制到新的数组，并且要添加的元素也放置在指定的索引处。</p>
<p><br></p>
<h3>更多建议</h3>
<p><code>LinkedList</code>到目前为止，除了 a比 an
“多得多”这一普遍共识之外，似乎没有人解决过这些列表中的每一个的内存占用问题，<code>ArrayList</code>因此我进行了一些数字运算以证明这两个列表究竟占用了多少
N 个空引用。</p>
<p>由于引用在其相关系统上是 32 位或 64 位（即使为空），因此我包含了 4 组 32 位和 64
位数据<code>LinkedLists</code>以及<code>ArrayLists</code>.</p>
<p><strong>注意：</strong> 显示的行大小<code>ArrayList</code>是针对 <em>经过修剪的列表</em> - 实际上，支持数组的容量<code>ArrayList</code>通常大于其当前元素数。</p>
<p><strong>注意 2：（</strong> <em>感谢 BeeOnRope）</em> 由于 CompressedOops 现在是 JDK6 中期及更高版本的默认设置，下面针对 64
位机器的值将基本上匹配它们的 32 位对应值，当然除非您特别将其关闭。</p>
<hr>
<p><img alt="LinkedList 和 ArrayList 图的元素数 x 字节" src="https://i.imgur.com/f83xDyz.png"></p>
<hr>
<p>结果清楚地表明<code>LinkedList</code>比 多很多<code>ArrayList</code>，尤其是在元素数非常高的情况下。如果内存是一个因素，请避开<code>LinkedLists</code>.</p>
<p>我使用的公式如下，如果我做错了什么，请告诉我，我会修复它。对于 32 位或 64 位系统，'b' 是 4 或 8，'n'
是元素的数量。注意mods的原因是因为java中的所有对象无论是否全部使用都会占用8字节空间的倍数。</p>
<p><strong>数组列表：</strong></p>
<p><code>ArrayList object header + size integer + modCount integer + array reference +
(array oject header + b * n) + MOD(array oject, 8) + MOD(ArrayList object, 8)
== 8 + 4 + 4 + b + (12 + b * n) + MOD(12 + b * n, 8) + MOD(8 + 4 + 4 + b + (12
+ b * n) + MOD(12 + b * n, 8), 8)</code></p>
<p><strong>链表：</strong></p>
<p><code>LinkedList object header + size integer + modCount integer + reference to
header + reference to footer + (node object overhead + reference to previous
element + reference to next element + reference to element) * n) + MOD(node
object, 8) * n + MOD(LinkedList object, 8) == 8 + 4 + 4 + 2 * b + (8 + 3 * b)
* n + MOD(8 + 3 * b, 8) * n + MOD(8 + 4 + 4 + 2 * b + (8 + 3 * b) * n + MOD(8
+ 3 * b, 8) * n, 8)</code></p>
<p><br><br><a href="../when-to-use-linkedlist-over-arraylist-in-java/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/arraylist/" rel="tag">arraylist</a></li>
            <li><a class="tag p-category" href="../../categories/collections/" rel="tag">collections</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/linked-list/" rel="tag">linked-list</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../shi-yao-shi-yi-lai-zhu-ru/" rel="prev" title="什么是依赖注入？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-xun-huan-bian-li-huo-mei-ju-javascript-dui-xiang/" rel="next" title="如何循环遍历或枚举 JavaScript 对象？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
