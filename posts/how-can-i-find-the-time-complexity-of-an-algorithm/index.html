<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How can I find the time complexity of an algorithm? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-can-i-find-the-time-complexity-of-an-algorithm/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-are-the-rules-about-using-an-underscore-in-a-c-identifier/" title="What are the rules about using an underscore in a C++ identifier?" type="text/html">
<link rel="next" href="../git-workflow-and-rebase-vs-merge-questions/" title="Git workflow and rebase vs merge questions" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How can I find the time complexity of an algorithm?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-can-i-find-the-time-complexity-of-an-algorithm/">
<meta property="og:description" content="I have gone through Google and Stack Overflow search, but nowhere I was able
to find a clear and straightforward explanation for how to calculate time
complexity.
What do I know already?
Say for code ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T07:08:21+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="complexity-theory">
<meta property="article:tag" content="time-complexity">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How can I find the time complexity of an algorithm?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:08:21+08:00" itemprop="datePublished" title="2023-02-17 07:08">2023-02-17 07:08</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I have gone through Google and Stack Overflow search, but nowhere I was able
to find a clear and straightforward explanation for how to calculate time
complexity.</p>
<h4>What do I know already?</h4>
<p>Say for code as simple as the one below:</p>
<div class="code"><pre class="code literal-block">char h = 'y'; // This will be executed 1 time
int abc = 0; // This will be executed 1 time
</pre></div>

<p>Say for a loop like the one below:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; N; i++) {</span>
<span class="w">    </span><span class="nv">Console</span>.<span class="nv">Write</span><span class="ss">(</span><span class="s1">'Hello, World!!'</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<ul>
<li>
<code>int i=0;</code> This will be executed only <strong>once</strong>.</li>
</ul>
<p>The time is actually calculated to <code>i=0</code> and not the declaration.</p>
<ul>
<li>
<code>i &lt; N;</code> This will be executed <strong>N+1</strong> times</li>
<li>
<code>i++</code> This will be executed <strong>N</strong> times</li>
</ul>
<p>So the number of operations required by this loop are <strong>{1+(N+1)+N} = 2N+2</strong>.
(But this still may be wrong, as I am not confident about my understanding.)</p>
<p>OK, so these small basic calculations I think I know, but in most cases I have
seen the time complexity as <strong>O(N), O(n^2), O(log n), O(n!)</strong> , and many
others.</p>
<p><br><br></p>
<h2>Answer</h2>
<blockquote>
<p>How to find time complexity of an algorithm</p>
</blockquote>
<p>You add up how many machine instructions it will execute as a function of the
size of its input, and then simplify the expression to the largest (when N is
very large) term and can include any simplifying constant factor.</p>
<p>For example, lets see how we simplify <code>2N + 2</code> machine instructions to
describe this as just <code>O(N)</code>.</p>
<p><strong>Why do we remove the two<code>2</code>s ?</strong></p>
<p>We are interested in the performance of the algorithm as N becomes large.</p>
<p>Consider the two terms 2N and 2.</p>
<p>What is the relative influence of these two terms as N becomes large? Suppose
N is a million.</p>
<p>Then the first term is 2 million and the second term is only 2.</p>
<p>For this reason, we drop all but the largest terms for large N.</p>
<p>So, now we have gone from <code>2N + 2</code> to <code>2N</code>.</p>
<p>Traditionally, we are only interested in performance <em>up to constant factors</em>.</p>
<p>This means that we don't really care if there is some constant multiple of
difference in performance when N is large. The unit of 2N is not well-defined
in the first place anyway. So we can multiply or divide by a constant factor
to get to the simplest expression.</p>
<p>So <code>2N</code> becomes just <code>N</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>This is an excellent article: <em>Time complexity of algorithm</em></p>
<p><strong>The below answer is copied from above (in case the excellent link goes
bust)</strong></p>
<p>The most common metric for calculating time complexity is Big O notation. This
removes all constant factors so that the running time can be estimated in
relation to N as N approaches infinity. In general you can think of it like
this:</p>
<div class="code"><pre class="code literal-block">statement;
</pre></div>

<p>Is constant. The running time of the statement will not change in relation to
N.</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; N; i++ )</span>
<span class="w">     </span><span class="nv">statement</span><span class="c1">;</span>
</pre></div>

<p>Is linear. The running time of the loop is directly proportional to N. When N
doubles, so does the running time.</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; N; i++ ) {</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; j &lt; N; j++ )</span>
<span class="w">    </span><span class="nv">statement</span><span class="c1">;</span>
}
</pre></div>

<p>Is quadratic. The running time of the two loops is proportional to the square
of N. When N doubles, the running time increases by N * N.</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>Is logarithmic. The running time of the algorithm is proportional to the
number of times N can be divided by 2. This is because the algorithm divides
the working area in half with each iteration.</p>
<div class="code"><pre class="code literal-block">void quicksort (int list[], int left, int right)
{
  int pivot = partition (list, left, right);
  quicksort(list, left, pivot - 1);
  quicksort(list, pivot + 1, right);
}
</pre></div>

<p>Is N * log (N). The running time consists of N loops (iterative or recursive)
that are logarithmic, thus the algorithm is a combination of linear and
logarithmic.</p>
<p>In general, doing something with every item in one dimension is linear, doing
something with every item in two dimensions is quadratic, and dividing the
working area in half is logarithmic. There are other Big O measures such as
cubic, exponential, and square root, but they're not nearly as common. Big O
notation is described as <code>O ( &lt;type&gt; )</code> where <code>&lt;type&gt;</code> is the measure. The
quicksort algorithm would be described as <code>O (N * log(N ))</code>.</p>
<p>Note that none of this has taken into account best, average, and worst case
measures. Each would have its own Big O notation. Also note that this is a
VERY simplistic explanation. Big O is the most common, but it's also more
complex that I've shown. There are also other notations such as big omega,
little o, and big theta. You probably won't encounter them outside of an
algorithm analysis course. ;)</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/complexity-theory/" rel="tag">complexity-theory</a></li>
            <li><a class="tag p-category" href="../../categories/time-complexity/" rel="tag">time-complexity</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-are-the-rules-about-using-an-underscore-in-a-c-identifier/" rel="prev" title="What are the rules about using an underscore in a C++ identifier?">Previous post</a>
            </li>
            <li class="next">
                <a href="../git-workflow-and-rebase-vs-merge-questions/" rel="next" title="Git workflow and rebase vs merge questions">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
