<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How do you convert a byte array to a hexadecimal string, and vice versa? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-add-a-class-to-a-given-element/" title="How to add a class to a given element?" type="text/html">
<link rel="next" href="../use-different-python-version-with-virtualenv/" title="Use different Python version with virtualenv" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How do you convert a byte array to a hexadecimal string, and vice vers">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa/">
<meta property="og:description" content="How can you convert a byte array to a hexadecimal string and vice versa?

Answer
You can use Convert.ToHexString starting with .NET 5.
There's also a method for the reverse operation: Convert.FromHexS">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T01:19:24+08:00">
<meta property="article:tag" content=".net-c#">
<meta property="article:tag" content="arrays">
<meta property="article:tag" content="hex">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How do you convert a byte array to a hexadecimal string, and vice versa?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T01:19:24+08:00" itemprop="datePublished" title="2023-02-17 01:19">2023-02-17 01:19</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>How can you convert a byte array to a hexadecimal string and vice versa?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>You can use <code>Convert.ToHexString</code> starting with .NET 5.<br>
There's also a method for the reverse operation: <code>Convert.FromHexString</code>.</p>
<hr>
<p>For older versions of .NET you can either use:</p>
<div class="code"><pre class="code literal-block"><span class="nt">public</span><span class="w"> </span><span class="nt">static</span><span class="w"> </span><span class="nt">string</span><span class="w"> </span><span class="nt">ByteArrayToString</span><span class="o">(</span><span class="nt">byte</span><span class="cp">[]</span><span class="w"> </span><span class="nt">ba</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="err">StringBuilder</span><span class="w"> </span><span class="err">hex</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">StringBuilder(ba.Length</span><span class="w"> </span><span class="err">*</span><span class="w"> </span><span class="err">2)</span><span class="p">;</span>
<span class="w">  </span><span class="err">foreach</span><span class="w"> </span><span class="err">(byte</span><span class="w"> </span><span class="err">b</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">ba)</span>
<span class="w">    </span><span class="err">hex.AppendFormat("{0:x2</span><span class="p">}</span><span class="err">"</span><span class="o">,</span><span class="w"> </span><span class="nt">b</span><span class="o">);</span>
<span class="w">  </span><span class="nt">return</span><span class="w"> </span><span class="nt">hex</span><span class="p">.</span><span class="nc">ToString</span><span class="o">();</span>
<span class="err">}</span>
</pre></div>

<p>or:</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">string</span><span class="w"> </span><span class="nv">ByteArrayToString</span><span class="ss">(</span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">ba</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">BitConverter</span>.<span class="nv">ToString</span><span class="ss">(</span><span class="nv">ba</span><span class="ss">)</span>.<span class="nv">Replace</span><span class="ss">(</span><span class="s2">"-"</span>,<span class="s2">""</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>There are even more variants of doing it, for example here.</p>
<p>The reverse conversion would go like this:</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">StringToByteArray</span><span class="ss">(</span><span class="nv">String</span><span class="w"> </span><span class="nv">hex</span><span class="ss">)</span>
{
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">NumberChars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">hex</span>.<span class="nv">Length</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">byte</span>[]<span class="w"> </span><span class="nv">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">byte</span>[<span class="nv">NumberChars</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>]<span class="c1">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; NumberChars; i += 2)</span>
<span class="w">    </span><span class="nv">bytes</span>[<span class="nv">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Convert</span>.<span class="nv">ToByte</span><span class="ss">(</span><span class="nv">hex</span>.<span class="nv">Substring</span><span class="ss">(</span><span class="nv">i</span>,<span class="w"> </span><span class="mi">2</span><span class="ss">)</span>,<span class="w"> </span><span class="mi">16</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">bytes</span><span class="c1">;</span>
}
</pre></div>

<hr>
<p>Using <code>Substring</code> is the best option in combination with <code>Convert.ToByte</code>. See
this answer for more information. If you need better performance, you must
avoid <code>Convert.ToByte</code> before you can drop <code>SubString</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<h3>Performance Analysis</h3>
<p><em>Note: new leader as of 2015-08-20.</em></p>
<p>I ran each of the various conversion methods through some crude <code>Stopwatch</code>
performance testing, a run with a random sentence (n=61, 1000 iterations) and
a run with a Project Gutenburg text (n=1,238,957, 150 iterations). Here are
the results, roughly from fastest to slowest. All measurements are in ticks
(10,000 ticks = 1 ms) and all relative notes are compared to the [slowest]
<code>StringBuilder</code> implementation. For the code used, see below or the test
framework repo where I now maintain the code for running this.</p>
<h3>Disclaimer</h3>
<p><em>WARNING: Do not rely on these stats for anything concrete; they are simply a
sample run of sample data. If you really need top-notch performance, please
test these methods in an environment representative of your production needs
with data representative of what you will use.</em></p>
<h3>Results</h3>
<ul>
<li>Lookup by byte <code>unsafe</code> (via CodesInChaos) (added to test repo by airbreather) <ul>
<li>Text: 4,727.85 (105.2X)</li>
<li>Sentence: 0.28 (99.7X)</li>
</ul>
</li>
<li>Lookup by byte (via CodesInChaos) <ul>
<li>Text: 10,853.96 (45.8X faster)</li>
<li>Sentence: 0.65 (42.7X faster)</li>
</ul>
</li>
<li>Byte Manipulation 2 (via CodesInChaos) <ul>
<li>Text: 12,967.69 (38.4X faster)</li>
<li>Sentence: 0.73 (37.9X faster)</li>
</ul>
</li>
<li>Byte Manipulation (via Waleed Eissa) <ul>
<li>Text: 16,856.64 (29.5X faster)</li>
<li>Sentence: 0.70 (39.5X faster)</li>
</ul>
</li>
<li>Lookup/Shift (via Nathan Moinvaziri) <ul>
<li>Text: 23,201.23 (21.4X faster)</li>
<li>Sentence: 1.24 (22.3X faster)</li>
</ul>
</li>
<li>Lookup by nibble (via Brian Lambert) <ul>
<li>Text: 23,879.41 (20.8X faster)</li>
<li>Sentence: 1.15 (23.9X faster)</li>
</ul>
</li>
<li>
<code>BitConverter</code> (via Tomalak) <ul>
<li>Text: 113,269.34 (4.4X faster)</li>
<li>Sentence: 9.98 (2.8X faster)</li>
</ul>
</li>
<li>
<code>{SoapHexBinary}.ToString</code> (via Mykroft) <ul>
<li>Text: 178,601.39 (2.8X faster)</li>
<li>Sentence: 10.68 (2.6X faster)</li>
</ul>
</li>
<li>
<code>{byte}.ToString("X2")</code> (using <code>foreach</code>) (derived from Will Dean's answer) <ul>
<li>Text: 308,805.38 (2.4X faster)</li>
<li>Sentence: 16.89 (2.4X faster)</li>
</ul>
</li>
<li>
<code>{byte}.ToString("X2")</code> (using <code>{IEnumerable}.Aggregate</code>, requires System.Linq) (via Mark) <ul>
<li>Text: 352,828.20 (2.1X faster)</li>
<li>Sentence: 16.87 (2.4X faster)</li>
</ul>
</li>
<li>
<code>Array.ConvertAll</code> (using <code>string.Join</code>) (via Will Dean) <ul>
<li>Text: 675,451.57 (1.1X faster)</li>
<li>Sentence: 17.95 (2.2X faster)</li>
</ul>
</li>
<li>
<code>Array.ConvertAll</code> (using <code>string.Concat</code>, requires .NET 4.0) (via Will Dean) <ul>
<li>Text: 752,078.70 (1.0X faster)</li>
<li>Sentence: 18.28 (2.2X faster)</li>
</ul>
</li>
<li>
<code>{StringBuilder}.AppendFormat</code> (using <code>foreach</code>) (via Tomalak) <ul>
<li>Text: 672,115.77 (1.1X faster)</li>
<li>Sentence: 36.82 (1.1X faster)</li>
</ul>
</li>
<li>
<code>{StringBuilder}.AppendFormat</code> (using <code>{IEnumerable}.Aggregate</code>, requires System.Linq) (derived from Tomalak's answer) <ul>
<li>Text: 718,380.63 (1.0X faster)</li>
<li>Sentence: 39.71 (1.0X faster)</li>
</ul>
</li>
</ul>
<p>Lookup tables have taken the lead over byte manipulation. Basically, there is
some form of precomputing what any given nibble or byte will be in hex. Then,
as you rip through the data, you simply look up the next portion to see what
hex string it would be. That value is then added to the resulting string
output in some fashion. For a long time byte manipulation, potentially harder
to read by some developers, was the top-performing approach.</p>
<p>Your best bet is still going to be finding some representative data and trying
it out in a production-like environment. If you have different memory
constraints, you may prefer a method with fewer allocations to one that would
be faster but consume more memory.</p>
<h3>Testing Code</h3>
<p>Feel free to play with the testing code I used. A version is included here but
feel free to clone the repo and add your own methods. Please submit a pull
request if you find anything interesting or want to help improve the testing
framework it uses.</p>
<ol>
<li>Add the new static method (<code>Func&lt;byte[], string&gt;</code>) to /Tests/ConvertByteArrayToHexString/Test.cs.</li>
<li>Add that method's name to the <code>TestCandidates</code> return value in that same class.</li>
<li>Make sure you are running the input version you want, sentence or text, by toggling the comments in <code>GenerateTestInput</code> in that same class.</li>
<li>
<p>Hit <code>F5</code> and wait for the output (an HTML dump is also generated in the /bin folder).</p>
<p>static string ByteArrayToHexStringViaStringJoinArrayConvertAll(byte[] bytes) {
    return string.Join(string.Empty, Array.ConvertAll(bytes, b =&gt; b.ToString("X2")));
}
static string ByteArrayToHexStringViaStringConcatArrayConvertAll(byte[] bytes) {
    return string.Concat(Array.ConvertAll(bytes, b =&gt; b.ToString("X2")));
}
static string ByteArrayToHexStringViaBitConverter(byte[] bytes) {
    string hex = BitConverter.ToString(bytes);
    return hex.Replace("-", "");
}
static string ByteArrayToHexStringViaStringBuilderAggregateByteToString(byte[] bytes) {
    return bytes.Aggregate(new StringBuilder(bytes.Length * 2), (sb, b) =&gt; sb.Append(b.ToString("X2"))).ToString();
}
static string ByteArrayToHexStringViaStringBuilderForEachByteToString(byte[] bytes) {
    StringBuilder hex = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes)
        hex.Append(b.ToString("X2"));
    return hex.ToString();
}
static string ByteArrayToHexStringViaStringBuilderAggregateAppendFormat(byte[] bytes) {
    return bytes.Aggregate(new StringBuilder(bytes.Length * 2), (sb, b) =&gt; sb.AppendFormat("{0:X2}", b)).ToString();
}
static string ByteArrayToHexStringViaStringBuilderForEachAppendFormat(byte[] bytes) {
    StringBuilder hex = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes)
        hex.AppendFormat("{0:X2}", b);
    return hex.ToString();
}
static string ByteArrayToHexViaByteManipulation(byte[] bytes) {
    char[] c = new char[bytes.Length * 2];
    byte b;
    for (int i = 0; i &lt; bytes.Length; i++) {
        b = ((byte)(bytes[i] &gt;&gt; 4));
        c[i * 2] = (char)(b &gt; 9 ? b + 0x37 : b + 0x30);
        b = ((byte)(bytes[i] &amp; 0xF));
        c[i * 2 + 1] = (char)(b &gt; 9 ? b + 0x37 : b + 0x30);
    }
    return new string(c);
}
static string ByteArrayToHexViaByteManipulation2(byte[] bytes) {
    char[] c = new char[bytes.Length * 2];
    int b;
    for (int i = 0; i &lt; bytes.Length; i++) {
        b = bytes[i] &gt;&gt; 4;
        c[i * 2] = (char)(55 + b + (((b - 10) &gt;&gt; 31) &amp; -7));
        b = bytes[i] &amp; 0xF;
        c[i * 2 + 1] = (char)(55 + b + (((b - 10) &gt;&gt; 31) &amp; -7));
    }
    return new string(c);
}
static string ByteArrayToHexViaSoapHexBinary(byte[] bytes) {
    SoapHexBinary soapHexBinary = new SoapHexBinary(bytes);
    return soapHexBinary.ToString();
}
static string ByteArrayToHexViaLookupAndShift(byte[] bytes) {
    StringBuilder result = new StringBuilder(bytes.Length * 2);
    string hexAlphabet = "0123456789ABCDEF";
    foreach (byte b in bytes) {
        result.Append(hexAlphabet[(int)(b &gt;&gt; 4)]);
        result.Append(hexAlphabet[(int)(b &amp; 0xF)]);
    }
    return result.ToString();
}
static readonly uint<em> _lookup32UnsafeP = (uint</em>)GCHandle.Alloc(_Lookup32, GCHandleType.Pinned).AddrOfPinnedObject();
static string ByteArrayToHexViaLookup32UnsafeDirect(byte[] bytes) {
    var lookupP = _lookup32UnsafeP;
    var result = new string((char)0, bytes.Length * 2);
    fixed (byte<em> bytesP = bytes)
    fixed (char</em> resultP = result) {
        uint<em> resultP2 = (uint</em>)resultP;
        for (int i = 0; i &lt; bytes.Length; i++) {
            resultP2[i] = lookupP[bytesP[i]];
        }
    }
    return result;
}
static uint[] _Lookup32 = Enumerable.Range(0, 255).Select(i =&gt; {
    string s = i.ToString("X2");
    return ((uint)s[0]) + ((uint)s[1] &lt;&lt; 16);
}).ToArray();
static string ByteArrayToHexViaLookupPerByte(byte[] bytes) {
    var result = new char[bytes.Length * 2];
    for (int i = 0; i &lt; bytes.Length; i++)
    {
        var val = _Lookup32[bytes[i]];
        result[2<em>i] = (char)val;
        result[2</em>i + 1] = (char) (val &gt;&gt; 16);
    }
    return new string(result);
}
static string ByteArrayToHexViaLookup(byte[] bytes) {
    string[] hexStringTable = new string[] {
        "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
        "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
        "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
        "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
        "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
        "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
        "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
        "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
        "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
        "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
        "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
        "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
        "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
        "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
        "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
        "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF",
    };
    StringBuilder result = new StringBuilder(bytes.Length * 2);
    foreach (byte b in bytes) {
        result.Append(hexStringTable[b]);
    }
    return result.ToString();
}</p>
</li>
</ol>
<h4>Update (2010-01-13)</h4>
<p>Added Waleed's answer to analysis. Quite fast.</p>
<h4>Update (2011-10-05)</h4>
<p>Added <code>string.Concat</code> <code>Array.ConvertAll</code> variant for completeness (requires
.NET 4.0). On par with <code>string.Join</code> version.</p>
<h4>Update (2012-02-05)</h4>
<p>Test repo includes more variants such as
<code>StringBuilder.Append(b.ToString("X2"))</code>. None upset the results any.
<code>foreach</code> is faster than <code>{IEnumerable}.Aggregate</code>, for instance, but
<code>BitConverter</code> still wins.</p>
<h4>Update (2012-04-03)</h4>
<p>Added Mykroft's <code>SoapHexBinary</code> answer to analysis, which took over third
place.</p>
<h4>Update (2013-01-15)</h4>
<p>Added CodesInChaos's byte manipulation answer, which took over first place (by
a large margin on large blocks of text).</p>
<h4>Update (2013-05-23)</h4>
<p>Added Nathan Moinvaziri's lookup answer and the variant from Brian Lambert's
blog. Both rather fast, but not taking the lead on the test machine I used
(AMD Phenom 9750).</p>
<h4>Update (2014-07-31)</h4>
<p>Added @CodesInChaos's new byte-based lookup answer. It appears to have taken
the lead on both the sentence tests and the full-text tests.</p>
<h4>Update (2015-08-20)</h4>
<p>Added airbreather's optimizations and <code>unsafe</code> variant to this answer's repo.
If you want to play in the unsafe game, you can get some huge performance
gains over any of the prior top winners on both short strings and large texts.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/net-c/" rel="tag">.net-c#</a></li>
            <li><a class="tag p-category" href="../../categories/arrays/" rel="tag">arrays</a></li>
            <li><a class="tag p-category" href="../../categories/hex/" rel="tag">hex</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-add-a-class-to-a-given-element/" rel="prev" title="How to add a class to a given element?">Previous post</a>
            </li>
            <li class="next">
                <a href="../use-different-python-version-with-virtualenv/" rel="next" title="Use different Python version with virtualenv">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
