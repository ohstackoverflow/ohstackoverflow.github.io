<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Getting the closest string match | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/getting-the-closest-string-match/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../remove-the-last-line-from-a-file-in-bash/" title="Remove the last line from a file in Bash" type="text/html">
<link rel="next" href="../way-to-ng-repeat-defined-number-of-times-instead-of-repeating-over-array/" title="Way to ng-repeat defined number of times instead of repeating over array?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Getting the closest string match">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/getting-the-closest-string-match/">
<meta property="og:description" content="I need a way to compare multiple strings to a test string and return the
string that closely resembles it:
TEST STRING: THE BROWN FOX JUMPED OVER THE RED COW

CHOICE A   : THE RED COW JUMPED OVER THE ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T14:05:35+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="language-agnostic">
<meta property="article:tag" content="levenshtein-distance">
<meta property="article:tag" content="string-comparison">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Getting the closest string match</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T14:05:35+08:00" itemprop="datePublished" title="2023-03-03 14:05">2023-03-03 14:05</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I need a way to compare multiple strings to a test string and return the
string that closely resembles it:</p>
<div class="code"><pre class="code literal-block">TEST STRING: THE BROWN FOX JUMPED OVER THE RED COW

CHOICE A   : THE RED COW JUMPED OVER THE GREEN CHICKEN
CHOICE B   : THE RED COW JUMPED OVER THE RED COW
CHOICE C   : THE RED FOX JUMPED OVER THE BROWN COW
</pre></div>

<p>(If I did this correctly) The closest string to the "TEST STRING" should be
"CHOICE C". What is the easiest way to do this?</p>
<p>I plan on implementing this into multiple languages including VB.net, Lua, and
JavaScript. At this point, pseudo code is acceptable. If you can provide an
example for a specific language, this is appreciated too!</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I was presented with this problem about a year ago when it came to looking up
user entered information about a oil rig in a database of miscellaneous
information. The goal was to do some sort of fuzzy string search that could
identify the database entry with the most common elements.</p>
<p>Part of the research involved implementing the Levenshtein distance algorithm,
which determines how many changes must be made to a string or phrase to turn
it into another string or phrase.</p>
<p>The implementation I came up with was relatively simple, and involved a
weighted comparison of the length of the two phrases, the number of changes
between each phrase, and whether each word could be found in the target entry.</p>
<p>The article is on a private site so I'll do my best to append the relevant
contents here:</p>
<hr>
<p>Fuzzy String Matching is the process of performing a human-like estimation of
the similarity of two words or phrases. In many cases, it involves identifying
words or phrases which are most similar to each other. This article describes
an in-house solution to the fuzzy string matching problem and its usefulness
in solving a variety of problems which can allow us to automate tasks which
previously required tedious user involvement.</p>
<p><strong>Introduction</strong></p>
<p>The need to do fuzzy string matching originally came about while developing
the Gulf of Mexico Validator tool. What existed was a database of known gulf
of Mexico oil rigs and platforms, and people buying insurance would give us
some badly typed out information about their assets and we had to match it to
the database of known platforms. When there was very little information given,
the best we could do is rely on an underwriter to "recognize" the one they
were referring to and call up the proper information. This is where this
automated solution comes in handy.</p>
<p>I spent a day researching methods of fuzzy string matching, and eventually
stumbled upon the very useful Levenshtein distance algorithm on Wikipedia.</p>
<p><strong>Implementation</strong></p>
<p>After reading about the theory behind it, I implemented and found ways to
optimize it. This is how my code looks like in VBA:</p>
<div class="code"><pre class="code literal-block"><span class="err">'Calculate the Levenshtein Distance between two strings (the number of insertions,</span>
<span class="err">'deletions, and substitutions needed to transform the first string into the second)</span>
<span class="err">Public Function LevenshteinDistance(ByRef S1 As String, ByVal S2 As String) As Long</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">L1</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">L2</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">D</span><span class="ss">()</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span><span class="w"> </span><span class="err">'Length of input strings and distance matrix</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">cost</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span><span class="w"> </span><span class="err">'loop counters and cost of substitution for current letter</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">cI</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">cD</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">cS</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span><span class="w"> </span><span class="err">'cost of next Insertion, Deletion and Substitution</span>
<span class="err">    L1 = Len(S1): L2 = Len(S2)</span>
<span class="err">    ReDim D(0 To L1, 0 To L2)</span>
<span class="err">    For i = 0 To L1: D(i, 0) = i: Next i</span>
<span class="err">    For j = 0 To L2: D(0, j) = j: Next j</span>

<span class="err">    For j = 1 To L2</span>
<span class="err">        For i = 1 To L1</span>
<span class="err">            cost = Abs(StrComp(Mid$(S1, i, 1), Mid$(S2, j, 1), vbTextCompare))</span>
<span class="err">            cI = D(i - 1, j) + 1</span>
<span class="err">            cD = D(i, j - 1) + 1</span>
<span class="err">            cS = D(i - 1, j - 1) + cost</span>
<span class="w">            </span><span class="k">If</span><span class="w"> </span><span class="nv">cI</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nv">cD</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="err">'Insertion or Substitution</span>
<span class="err">                If cI &lt;= cS Then D(i, j) = cI Else D(i, j) = cS</span>
<span class="w">            </span><span class="k">Else</span><span class="w"> </span><span class="err">'Deletion or Substitution</span>
<span class="err">                If cD &lt;= cS Then D(i, j) = cD Else D(i, j) = cS</span>
<span class="err">            End If</span>
<span class="err">        Next i</span>
<span class="err">    Next j</span>
<span class="err">    LevenshteinDistance = D(L1, L2)</span>
<span class="err">End Function</span>
</pre></div>

<p>Simple, speedy, and a very useful metric. Using this, I created two separate
metrics for evaluating the similarity of two strings. One I call "valuePhrase"
and one I call "valueWords". valuePhrase is just the Levenshtein distance
between the two phrases, and valueWords splits the string into individual
words, based on delimiters such as spaces, dashes, and anything else you'd
like, and compares each word to each other word, summing up the shortest
Levenshtein distance connecting any two words. Essentially, it measures
whether the information in one 'phrase' is really contained in another, just
as a word-wise permutation. I spent a few days as a side project coming up
with the most efficient way possible of splitting a string based on
delimiters.</p>
<p>valueWords, valuePhrase, and Split function:</p>
<div class="code"><pre class="code literal-block"><span class="nv">Public</span><span class="w"> </span><span class="nv">Function</span><span class="w"> </span><span class="nv">valuePhrase</span>#<span class="ss">(</span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">S1</span>$,<span class="w"> </span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">S2</span>$<span class="ss">)</span>
<span class="w">    </span><span class="nv">valuePhrase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">LevenshteinDistance</span><span class="ss">(</span><span class="nv">S1</span>,<span class="w"> </span><span class="nv">S2</span><span class="ss">)</span>
<span class="k">End</span><span class="w"> </span><span class="nv">Function</span>

<span class="nv">Public</span><span class="w"> </span><span class="nv">Function</span><span class="w"> </span><span class="nv">valueWords</span>#<span class="ss">(</span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">S1</span>$,<span class="w"> </span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">S2</span>$<span class="ss">)</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">wordsS1</span>$<span class="ss">()</span>,<span class="w"> </span><span class="nv">wordsS2</span>$<span class="ss">()</span>
<span class="w">    </span><span class="nv">wordsS1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">SplitMultiDelims</span><span class="ss">(</span><span class="nv">S1</span>,<span class="w"> </span><span class="s2">" _-"</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">wordsS2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">SplitMultiDelims</span><span class="ss">(</span><span class="nv">S2</span>,<span class="w"> </span><span class="s2">" _-"</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">word1</span><span class="o">%</span>,<span class="w"> </span><span class="nv">word2</span><span class="o">%</span>,<span class="w"> </span><span class="nv">thisD</span>#,<span class="w"> </span><span class="nv">wordbest</span>#
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">wordsTotal</span>#
<span class="w">    </span><span class="k">For</span><span class="w"> </span><span class="nv">word1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">LBound</span><span class="ss">(</span><span class="nv">wordsS1</span><span class="ss">)</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">UBound</span><span class="ss">(</span><span class="nv">wordsS1</span><span class="ss">)</span>
<span class="w">        </span><span class="nv">wordbest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Len</span><span class="ss">(</span><span class="nv">S2</span><span class="ss">)</span>
<span class="w">        </span><span class="k">For</span><span class="w"> </span><span class="nv">word2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">LBound</span><span class="ss">(</span><span class="nv">wordsS2</span><span class="ss">)</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">UBound</span><span class="ss">(</span><span class="nv">wordsS2</span><span class="ss">)</span>
<span class="w">            </span><span class="nv">thisD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">LevenshteinDistance</span><span class="ss">(</span><span class="nv">wordsS1</span><span class="ss">(</span><span class="nv">word1</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">wordsS2</span><span class="ss">(</span><span class="nv">word2</span><span class="ss">))</span>
<span class="w">            </span><span class="k">If</span><span class="w"> </span><span class="nv">thisD</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nv">wordbest</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="nv">wordbest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">thisD</span>
<span class="w">            </span><span class="k">If</span><span class="w"> </span><span class="nv">thisD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="k">GoTo</span><span class="w"> </span><span class="nl">foundbest</span>
<span class="w">        </span><span class="k">Next</span><span class="w"> </span><span class="nv">word2</span>
<span class="nv">foundbest</span>:
<span class="w">        </span><span class="nv">wordsTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">wordsTotal</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">wordbest</span>
<span class="w">    </span><span class="k">Next</span><span class="w"> </span><span class="nv">word1</span>
<span class="w">    </span><span class="nv">valueWords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">wordsTotal</span>
<span class="k">End</span><span class="w"> </span><span class="nv">Function</span>

<span class="s1">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
<span class="err">' SplitMultiDelims</span>
<span class="err">' This function splits Text into an array of substrings, each substring</span>
<span class="err">' delimited by any character in DelimChars. Only a single character</span>
<span class="err">' may be a delimiter between two substrings, but DelimChars may</span>
<span class="err">' contain any number of delimiter characters. It returns a single element</span>
<span class="err">' array containing all of text if DelimChars is empty, or a 1 or greater</span>
<span class="err">' element array if the Text is successfully split into substrings.</span>
<span class="err">' If IgnoreConsecutiveDelimiters is true, empty array elements will not occur.</span>
<span class="s1">' If Limit greater than 0, the function will only split Text into '</span><span class="nv">Limit</span><span class="err">'</span>
<span class="err">' array elements or less. The last element will contain the rest of Text.</span>
<span class="s1">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
<span class="nv">Function</span><span class="w"> </span><span class="nv">SplitMultiDelims</span><span class="ss">(</span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">Text</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">String</span>,<span class="w"> </span><span class="nv">ByRef</span><span class="w"> </span><span class="nv">DelimChars</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">String</span>,<span class="w"> </span><span class="nv">_</span>
<span class="w">        </span><span class="nv">Optional</span><span class="w"> </span><span class="nv">ByVal</span><span class="w"> </span><span class="nv">IgnoreConsecutiveDelimiters</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">False</span>,<span class="w"> </span><span class="nv">_</span>
<span class="w">        </span><span class="nv">Optional</span><span class="w"> </span><span class="nv">ByVal</span><span class="w"> </span><span class="nv">Limit</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">String</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">ElemStart</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">N</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">M</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">Elements</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">lDelims</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>,<span class="w"> </span><span class="nv">lText</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">Long</span>
<span class="w">    </span><span class="nv">Dim</span><span class="w"> </span><span class="nv">Arr</span><span class="ss">()</span><span class="w"> </span><span class="nv">As</span><span class="w"> </span><span class="nv">String</span>

<span class="w">    </span><span class="nv">lText</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Len</span><span class="ss">(</span><span class="nv">Text</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">lDelims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Len</span><span class="ss">(</span><span class="nv">DelimChars</span><span class="ss">)</span>
<span class="w">    </span><span class="k">If</span><span class="w"> </span><span class="nv">lDelims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">Or</span><span class="w"> </span><span class="nv">lText</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">Or</span><span class="w"> </span><span class="nv">Limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">Then</span>
<span class="w">        </span><span class="nv">ReDim</span><span class="w"> </span><span class="nv">Arr</span><span class="ss">(</span><span class="mi">0</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span>
<span class="w">        </span><span class="nv">Arr</span><span class="ss">(</span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Text</span>
<span class="w">        </span><span class="nv">SplitMultiDelims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Arr</span>
<span class="w">        </span><span class="k">Exit</span><span class="w"> </span><span class="nv">Function</span>
<span class="w">    </span><span class="k">End</span><span class="w"> </span><span class="k">If</span>
<span class="w">    </span><span class="nv">ReDim</span><span class="w"> </span><span class="nv">Arr</span><span class="ss">(</span><span class="mi">0</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">IIf</span><span class="ss">(</span><span class="nv">Limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>,<span class="w"> </span><span class="nv">lText</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">Limit</span><span class="ss">))</span>

<span class="w">    </span><span class="nv">Elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>:<span class="w"> </span><span class="nv">ElemStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">For</span><span class="w"> </span><span class="nv">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">lText</span>
<span class="w">        </span><span class="k">If</span><span class="w"> </span><span class="nv">InStr</span><span class="ss">(</span><span class="nv">DelimChars</span>,<span class="w"> </span><span class="nv">Mid</span><span class="ss">(</span><span class="nv">Text</span>,<span class="w"> </span><span class="nv">N</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">))</span><span class="w"> </span><span class="k">Then</span>
<span class="w">            </span><span class="nv">Arr</span><span class="ss">(</span><span class="nv">Elements</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Mid</span><span class="ss">(</span><span class="nv">Text</span>,<span class="w"> </span><span class="nv">ElemStart</span>,<span class="w"> </span><span class="nv">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">ElemStart</span><span class="ss">)</span>
<span class="w">            </span><span class="k">If</span><span class="w"> </span><span class="nv">IgnoreConsecutiveDelimiters</span><span class="w"> </span><span class="k">Then</span>
<span class="w">                </span><span class="k">If</span><span class="w"> </span><span class="nv">Len</span><span class="ss">(</span><span class="nv">Arr</span><span class="ss">(</span><span class="nv">Elements</span><span class="ss">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="nv">Elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Elements</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">Else</span>
<span class="w">                </span><span class="nv">Elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Elements</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">End</span><span class="w"> </span><span class="k">If</span>
<span class="w">            </span><span class="nv">ElemStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">If</span><span class="w"> </span><span class="nv">Elements</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Limit</span><span class="w"> </span><span class="k">Then</span><span class="w"> </span><span class="k">Exit</span><span class="w"> </span><span class="k">For</span>
<span class="w">        </span><span class="k">End</span><span class="w"> </span><span class="k">If</span>
<span class="w">    </span><span class="k">Next</span><span class="w"> </span><span class="nv">N</span>
<span class="w">    </span><span class="err">'Get the last token terminated by the end of the string into the array</span>
<span class="err">    If ElemStart &lt;= lText Then Arr(Elements) = Mid(Text, ElemStart)</span>
<span class="w">    </span><span class="err">'Since the end of string counts as the terminating delimiter, if the last character</span>
<span class="w">    </span><span class="err">'was also a delimiter, we treat the two as consecutive, and so ignore the last elemnent</span>
<span class="err">    If IgnoreConsecutiveDelimiters Then If Len(Arr(Elements)) = 0 Then Elements = Elements - 1</span>

<span class="w">    </span><span class="nv">ReDim</span><span class="w"> </span><span class="nv">Preserve</span><span class="w"> </span><span class="nv">Arr</span><span class="ss">(</span><span class="mi">0</span><span class="w"> </span><span class="nv">To</span><span class="w"> </span><span class="nv">Elements</span><span class="ss">)</span><span class="w"> </span><span class="err">'Chop off unused array elements</span>
<span class="err">    SplitMultiDelims = Arr</span>
<span class="err">End Function</span>
</pre></div>

<p><strong>Measures of Similarity</strong></p>
<p>Using these two metrics, and a third which simply computes the distance
between two strings, I have a series of variables which I can run an
optimization algorithm to achieve the greatest number of matches. Fuzzy string
matching is, itself, a fuzzy science, and so by creating linearly independent
metrics for measuring string similarity, and having a known set of strings we
wish to match to each other, we can find the parameters that, for our specific
styles of strings, give the best fuzzy match results.</p>
<p>Initially, the goal of the metric was to have a low search value for for an
exact match, and increasing search values for increasingly permuted measures.
In an impractical case, this was fairly easy to define using a set of well
defined permutations, and engineering the final formula such that they had
increasing search values results as desired.</p>
<p><img alt="Fuzzy String Matching Permutations" src="../../images/ltCIu.png"></p>
<p>In the above screenshot, I tweaked my heuristic to come up with something that
I felt scaled nicely to my perceived difference between the search term and
result. The heuristic I used for <code>Value Phrase</code> in the above spreadsheet was
<code>=valuePhrase(A2,B2)-0.8*ABS(LEN(B2)-LEN(A2))</code>. I was effectively reducing the
penalty of the Levenstein distance by 80% of the difference in the length of
the two "phrases". This way, "phrases" that have the same length suffer the
full penalty, but "phrases" which contain 'additional information' (longer)
but aside from that still mostly share the same characters suffer a reduced
penalty. I used the <code>Value Words</code> function as is, and then my final
<code>SearchVal</code> heuristic was defined as <code>=MIN(D2,E2)*0.8+MAX(D2,E2)*0.2</code> - a
weighted average. Whichever of the two scores was lower got weighted 80%, and
20% of the higher score. This was just a heuristic that suited my use case to
get a good match rate. These weights are something that one could then tweak
to get the best match rate with their test data.</p>
<p><img alt="Fuzzy String Matching Value Phrase" src="../../images/inSyO.png"></p>
<p><img alt="Fuzzy String Matching Value Words" src="../../images/kCrqF.png"></p>
<p>As you can see, the last two metrics, which are fuzzy string matching metrics,
already have a natural tendency to give low scores to strings that are meant
to match (down the diagonal). This is very good.</p>
<p><strong>Application</strong> To allow the optimization of fuzzy matching, I weight each
metric. As such, every application of fuzzy string match can weight the
parameters differently. The formula that defines the final score is a simply
combination of the metrics and their weights:</p>
<div class="code"><pre class="code literal-block">value = Min(phraseWeight*phraseValue, wordsWeight*wordsValue)*minWeight
      + Max(phraseWeight*phraseValue, wordsWeight*wordsValue)*maxWeight
      + lengthWeight*lengthValue
</pre></div>

<p>Using an optimization algorithm (neural network is best here because it is a
discrete, multi-dimentional problem), the goal is now to maximize the number
of matches. I created a function that detects the number of correct matches of
each set to each other, as can be seen in this final screenshot. A column or
row gets a point if the lowest score is assigned the the string that was meant
to be matched, and partial points are given if there is a tie for the lowest
score, and the correct match is among the tied matched strings. I then
optimized it. You can see that a green cell is the column that best matches
the current row, and a blue square around the cell is the row that best
matches the current column. The score in the bottom corner is roughly the
number of successful matches and this is what we tell our optimization problem
to maximize.</p>
<p><img alt="Fuzzy String Matching Optimized Metric" src="../../images/XPglZ.png"></p>
<p>The algorithm was a wonderful success, and the solution parameters say a lot
about this type of problem. You'll notice the optimized score was 44, and the
best possible score is 48. The 5 columns at the end are decoys, and do not
have any match at all to the row values. The more decoys there are, the harder
it will naturally be to find the best match.</p>
<p>In this particular matching case, the length of the strings are irrelevant,
because we are expecting abbreviations that represent longer words, so the
optimal weight for length is -0.3, which means we do not penalize strings
which vary in length. We reduce the score in anticipation of these
abbreviations, giving more room for partial word matches to supersede non-word
matches that simply require less substitutions because the string is shorter.</p>
<p>The word weight is 1.0 while the phrase weight is only 0.5, which means that
we penalize whole words missing from one string and value more the entire
phrase being intact. This is useful because a lot of these strings have one
word in common (the peril) where what really matters is whether or not the
combination (region and peril) are maintained.</p>
<p>Finally, the min weight is optimized at 10 and the max weight at 1. What this
means is that if the best of the two scores (value phrase and value words)
isn't very good, the match is greatly penalized, but we don't greatly penalize
the worst of the two scores. Essentially, this puts emphasis on requiring
<em>either</em> the valueWord or valuePhrase to have a good score, but not both. A
sort of "take what we can get" mentality.</p>
<p>It's really fascinating what the optimized value of these 5 weights say about
the sort of fuzzy string matching taking place. For completely different
practical cases of fuzzy string matching, these parameters are very different.
I've used it for 3 separate applications so far.</p>
<p>While unused in the final optimization, a benchmarking sheet was established
which matches columns to themselves for all perfect results down the diagonal,
and lets the user change parameters to control the rate at which scores
diverge from 0, and note innate similarities between search phrases (which
could in theory be used to offset false positives in the results)</p>
<p><img alt="Fuzzy String Matching Benchmark" src="../../images/XV5Wp.png"></p>
<p><strong>Further Applications</strong></p>
<p>This solution has potential to be used anywhere where the user wishes to have
a computer system identify a string in a set of strings where there is no
perfect match. (Like an approximate match vlookup for strings).</p>
<hr>
<p>So what you should take from this, is that you probably want to use a
combination of high level heuristics (finding words from one phrase in the
other phrase, length of both phrases, etc) along with the implementation of
the Levenshtein distance algorithm. Because deciding which is the "best" match
is a heuristic (fuzzy) determination - you'll have to come up with a set of
weights for any metrics you come up with to determine similarity.</p>
<p>With the appropriate set of heuristics and weights, you'll have your
comparison program quickly making the decisions that you would have made.</p>
<p><br></p>
<h3>Suggest</h3>
<p>This problem turns up all the time in bioinformatics. The accepted answer
above (which was great by the way) is known in bioinformatics as the
Needleman-Wunsch (compare two strings) and Smith-Waterman (find an approximate
substring in a longer string) algorithms. They work great and have been
workhorses for decades.</p>
<p><strong>But what if you have a million strings to compare?</strong> That's a trillion
pairwise comparisons, each of which is O(n*m)! Modern DNA sequencers easily
generate a <em>billion</em> short DNA sequences, each about 200 DNA "letters" long.
Typically, we want to find, for each such string, the best match against the
human genome (3 billion letters). Clearly, the Needleman-Wunsch algorithm and
its relatives will not do.</p>
<p>This so-called "alignment problem" is a field of active research. The most
popular algorithms are currently able to find inexact matches between 1
billion short strings and the human genome in a matter of hours on reasonable
hardware (say, eight cores and 32 GB RAM).</p>
<p>Most of these algorithms work by quickly finding short exact matches (seeds)
and then extending these to the full string using a slower algorithm (for
example, the Smith-Waterman). The reason this works is that we are really only
interested in a few close matches, so it pays off to get rid of the 99.9...%
of pairs that have nothing in common.</p>
<p>How does finding exact matches help finding <em>inexact</em> matches? Well, say we
allow only a single difference between the query and the target. It is easy to
see that this difference must occur in either the right or left half of the
query, and so the other half must match exactly. This idea can be extended to
multiple mismatches and is the basis for the ELAND algorithm commonly used
with Illumina DNA sequencers.</p>
<p>There are many very good algorithms for doing exact string matching. Given a
query string of length 200, and a target string of length 3 billion (the human
genome), we want to find any place in the target where there is a substring of
length k that matches a substring of the query exactly. A simple approach is
to begin by indexing the target: take all k-long substrings, put them in an
array and sort them. Then take each k-long substring of the query and search
the sorted index. <del>Sort and</del> search can be done in O(log n) time.</p>
<p>But storage can be a problem. An index of the 3 billion letter target would
need to hold 3 billion pointers and 3 billion k-long words. It would seem hard
to fit this in less than several tens of gigabytes of RAM. But amazingly we
can greatly compress the index, using the Burrows-Wheeler transform, and it
will still be efficiently queryable. An index of the human genome can fit in
less than 4 GB RAM. This idea is the basis of popular sequence aligners such
as Bowtie and BWA.</p>
<p>Alternatively, we can use a suffix array, which stores only the pointers, yet
represents a simultaneous index of all suffixes in the target string
(essentially, a simultaneous index for all possible values of k; the same is
true of the Burrows-Wheeler transform). A suffix array index of the human
genome will take 12 GB of RAM if we use 32-bit pointers.</p>
<p>The links above contain a wealth of information and links to primary research
papers. The ELAND link goes to a PDF with useful figures illustrating the
concepts involved, and shows how to deal with insertions and deletions.</p>
<p>Finally, while these algorithms have basically solved the problem of
(re)sequencing single human genomes (a billion short strings), DNA sequencing
technology improves even faster than Moore's law, and we are fast approaching
trillion-letter datasets. For example, there are currently projects underway
to sequence the genomes of 10,000 vertebrate species, each a billion letters
long or so. Naturally, we will want to do pairwise inexact string matching on
the data...</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/language-agnostic/" rel="tag">language-agnostic</a></li>
            <li><a class="tag p-category" href="../../categories/levenshtein-distance/" rel="tag">levenshtein-distance</a></li>
            <li><a class="tag p-category" href="../../categories/string-comparison/" rel="tag">string-comparison</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../remove-the-last-line-from-a-file-in-bash/" rel="prev" title="Remove the last line from a file in Bash">Previous post</a>
            </li>
            <li class="next">
                <a href="../way-to-ng-repeat-defined-number-of-times-instead-of-repeating-over-array/" rel="next" title="Way to ng-repeat defined number of times instead of repeating over array?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
