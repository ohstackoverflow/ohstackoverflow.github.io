<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>函数式编程会取代 GoF 设计模式吗？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/han-shu-shi-bian-cheng-hui-qu-dai-gof-she-ji-mo-shi-ma/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/" title="分组函数（tapply、by、aggregate）和 *apply 系列" type="text/html">
<link rel="next" href="../ru-he-dao-hang-hui-dao-visual-studio-code-zhong-de-zui-hou-yi-ge-guang-biao-wei-zhi/" title="如何导航回到 Visual Studio Code 中的最后一个光标位置？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="函数式编程会取代 GoF 设计模式吗？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/han-shu-shi-bian-cheng-hui-qu-dai-gof-she-ji-mo-shi-ma/">
<meta property="og:description" content="自从我去年开始学习F#和OCaml以来，我阅读了大量文章，这些文章坚持认为设计模式（尤其是在 Java
中）是命令式语言中缺失功能的变通方法。我发现的一篇文章提出了相当强烈的主张：

我遇到的大多数人都读过四人帮 (GoF)
的《设计模式》一书。任何有自尊心的程序员都会告诉您，这本书与语言无关，并且这些模式通常适用于软件工程，无论您使用哪种语言。这是一个崇高的主张。不幸的是，它与事实相去甚远。
函">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:24:49+08:00">
<meta property="article:tag" content="design-patterns">
<meta property="article:tag" content="functional-programming">
<meta property="article:tag" content="oop">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">函数式编程会取代 GoF 设计模式吗？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:24:49+08:00" itemprop="datePublished" title="2023-02-17 05:24">2023-02-17 05:24</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>自从我去年开始学习F#和OCaml以来，我阅读了大量文章，这些文章坚持认为设计模式（尤其是在 Java
中）是命令式语言中缺失功能的变通方法。我发现的一篇文章提出了相当强烈的主张：</p>
<blockquote>
<p>我遇到的大多数人都读过四人帮 (GoF)
的《设计模式》一书。任何有自尊心的程序员都会告诉您，这本书与语言无关，并且这些模式通常适用于软件工程，无论您使用哪种语言。这是一个崇高的主张。不幸的是，它与事实相去甚远。</p>
<p>函数式语言极具表现力。 <strong>在函数式语言中，不需要设计模式，因为该语言可能是如此高级，以至于您最终会在完全消除设计模式的概念中进行编程。</strong></p>
</blockquote>
<p>函数式编程 (FP) 的主要特征包括作为一流值的函数、currying、不可变值等。在我看来，OO 设计模式与这些特征中的任何一个近似并不明显。</p>
<p>此外，在支持 OOP 的函数式语言中（例如 F# 和 OCaml），在我看来很明显，使用这些语言的程序员将使用与其他所有 OOP
语言相同的设计模式。事实上，现在我每天都使用 F# 和 OCaml，我在这些语言中使用的模式与我在用 Java 编写时使用的模式之间没有显着差异。</p>
<p>函数式编程消除了对 OOP 设计模式的需求的说法是否属实？如果是这样，您能否发布或链接到典型的 OOP 设计模式及其功能等价物的示例？</p>
<p><br><br></p>
<h2>解答</h2>
<p>您引用的博客文章有点夸大了它的说法。FP 并没有 <em>消除</em> 对设计模式的需求。“设计模式”一词并未广泛用于描述 FP
语言中的同一事物。但它们存在。函数式语言有很多最佳实践规则，形式为“当您遇到问题 X 时，使用看起来像 Y 的代码”，这基本上就是设计模式。</p>
<p>然而，大多数特定于 OOP 的设计模式与函数式语言几乎无关，这是正确的。</p>
<p>我认为说设计模式 <em>通常</em>
只是为了修补语言中的缺陷而存在的说法应该不会引起特别的争议。如果另一种语言可以轻松解决同样的问题，那么另一种语言就不需要设计模式了。该语言的用户甚至可能没有意识到问题的
<em>存在</em> ，因为，好吧，这不是该语言的问题。</p>
<p>对于这个问题，四人帮是这么说的：</p>
<blockquote>
<p>编程语言的选择很重要，因为它会影响一个人的观点。我们的模式采用 Smalltalk/C++
级别的语言特性，而这种选择决定了哪些可以轻松实现，哪些不能轻松实现。如果我们假设过程语言，我们可能已经包括称为“继承”、“封装”和“多态性”的设计模式。同样，我们的一些模式直接由不太常见的面向对象语言支持。例如，CLOS
有多种方法，可以减少对 Visitor 等模式的需求。事实上，Smalltalk 和 C++
之间有足够多的差异，这意味着某些模式可以用一种语言比另一种语言更容易表达。（例如，参见迭代器。）</p>
</blockquote>
<p>（以上引用自《设计模式简介》一书第 4 页第 3 段）</p>
<blockquote>
<p>函数式编程的主要特征包括作为一流值的函数、柯里化、不可变值等。在我看来，OO 设计模式与这些特征中的任何一个近似并不明显。</p>
</blockquote>
<p>如果不是一等函数的近似，那么命令模式是什么？:) 在 FP 语言中，您只需将一个函数作为参数传递给另一个函数。在 OOP
语言中，您必须将函数包装在一个类中，您可以实例化该类，然后将该对象传递给另一个函数。效果是一样的，但在 OOP
中它被称为设计模式，它需要更多的代码。如果不是柯里化，抽象工厂模式是什么？一次一点地将参数传递给一个函数，以配置当你最终调用它时它吐出什么样的值。</p>
<p>所以是的，一些 GoF 设计模式在 FP 语言中变得多余，因为存在更强大和更易于使用的替代方案。</p>
<p>但当然还有一些设计模式是FP 语言无法解决的 <em>。</em> 单例的 FP 等价物是什么？（暂时忽略单例通常是一种糟糕的使用模式。）</p>
<p>它也可以双向工作。正如我所说，FP 也有它的设计模式；人们只是通常不这么认为。</p>
<p>但是您可能遇到过 monad。如果不是“处理全局状态”的设计模式，它们是什么？这个问题在 OOP 语言中非常简单，以至于那里不存在等效的设计模式。</p>
<p>我们不需要“增加静态变量”或“从该套接字读取”的设计模式，因为它就是您要做 <em>的</em> 。</p>
<p>说 monad 是一种设计模式就像说具有常规操作的整数和零元素是一种设计模式一样荒谬。不，monad 是一种 <strong>数学模式</strong> ，而不是设计模式。</p>
<p>在（纯）函数式语言中，副作用和可变状态是不可能的，除非您使用 monad“设计模式”或任何其他允许相同事情的方法来解决它。</p>
<blockquote>
<p>此外，在支持 OOP 的函数式语言中（例如 F# 和 OCaml），在我看来很明显，使用这些语言的程序员将使用与其他所有 OOP
语言相同的设计模式。事实上，现在我每天都使用 F# 和 OCaml，我在这些语言中使用的模式与我在用 Java 编写时使用的模式之间没有显着差异。</p>
</blockquote>
<p>或许是因为你还在用命令式的方式思考？很多人在一生中都与命令式语言打交道之后，在尝试使用函数式语言时很难改掉这种习惯。（我在 F#
上看到了一些非常有趣的尝试，其中 <em>每个</em> 函数实际上只是一串“let”语句，基本上就像您使用 C 程序一样，并将所有分号替换为“let”。:)）</p>
<p>但另一种可能性是您只是没有意识到您正在简单地解决问题，这需要 OOP 语言中的设计模式。</p>
<p>当您使用柯里化或将一个函数作为参数传递给另一个函数时，请停下来想想您将如何使用 OOP 语言来做到这一点。</p>
<blockquote>
<p>函数式编程消除了对 OOP 设计模式的需求的说法是否属实？</p>
</blockquote>
<p>是的。:) 当您使用 FP 语言工作时，您不再需要特定于 OOP 的设计模式。但是您仍然需要一些通用设计模式，例如 MVC 或其他非 OOP
特定的东西，并且您需要一些新的特定于 FP 的“设计模式”。所有语言都有其缺点，而设计模式通常是我们解决这些缺点的方式。</p>
<p>无论如何，您可能会发现尝试使用“更干净”的 FP 语言很有趣，例如ML（我个人最喜欢的，至少出于学习目的）或Haskell，当您在这些语言中没有 OOP
拐杖可以依靠时面对新事物。</p>
<hr>
<p>正如预期的那样，一些人反对我将设计模式定义为“修补语言中的缺点”，所以这是我的理由：</p>
<p>如前所述，大多数设计模式特定于一种编程范式，有时甚至特定于一种特定语言。 <em>通常，他们解决仅存在于</em> 该范式中的问题（参见 FP 的 monad，或 OOP
的抽象工厂）。</p>
<p>为什么FP中没有抽象工厂模式？因为它试图解决的问题在那里并不存在。</p>
<p>因此，如果 OOP 语言中存在问题，而 FP 语言中不存在问题，那么显然这是 OOP
语言的缺点。问题可以解决，但是你的语言没有这样做，而是需要你提供一堆样板代码来解决它。理想情况下，我们希望我们的编程语言能够神奇地解决 <em>所有</em>
问题。任何仍然存在的问题原则上都是语言的缺陷。;)</p>
<p><br></p>
<h3>更多建议</h3>
<blockquote>
<p>函数式编程消除了对 OOP 设计模式的需求的说法是否属实？</p>
</blockquote>
<p>函数式编程与面向对象编程不同。面向对象的设计模式不适用于函数式编程。相反，您拥有函数式编程设计模式。</p>
<p>对于函数式编程，您不会阅读 OO 设计模式书籍；您将阅读有关 FP 设计模式的其他书籍。</p>
<blockquote>
<p>语言不可知论者</p>
</blockquote>
<p>不完全是。仅与 OO 语言无关。设计模式根本不适用于过程语言。它们在关系数据库设计上下文中几乎没有意义。它们在设计电子表格时不适用。</p>
<blockquote>
<p>典型的 OOP 设计模式及其等效功能？</p>
</blockquote>
<p>以上不应该存在。这就像要求将一段程序代码重写为 OO 代码一样。嗯... 如果我将原始的 Fortran（或 C）翻译成
Java，我除了翻译它什么也没做。如果我将它完全重写为 OO 范例，它看起来将不再像原始的 Fortran 或 C —— 将无法识别。</p>
<p>没有从 OO 设计到功能设计的简单映射。他们看待问题的方式非常不同。</p>
<p>函数式编程（像 <em>所有</em>
编程风格一样）具有设计模式。关系型数据库有设计模式，OO有设计模式，过程式编程有设计模式。任何事物都有设计模式，即使是建筑物的结构。</p>
<p>设计模式——作为一个概念——是一种永恒的构建方式，与技术或问题领域无关。但是，特定的设计模式适用于特定的问题领域和技术。</p>
<p>每个思考他们正在做的事情的人都会发现设计模式。</p>
<p><br><br><a href="../does-functional-programming-replace-gof-design-patterns/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/design-patterns/" rel="tag">design-patterns</a></li>
            <li><a class="tag p-category" href="../../categories/functional-programming/" rel="tag">functional-programming</a></li>
            <li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/" rel="prev" title="分组函数（tapply、by、aggregate）和 *apply 系列">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-dao-hang-hui-dao-visual-studio-code-zhong-de-zui-hou-yi-ge-guang-biao-wei-zhi/" rel="next" title="如何导航回到 Visual Studio Code 中的最后一个光标位置？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
