<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Why does modern Perl avoid UTF-8 by default? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/why-does-modern-perl-avoid-utf-8-by-default/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../c-how-to-create-a-guid-value/" title="C# how to create a Guid value?" type="text/html">
<link rel="next" href="../how-to-handle-command-line-arguments-in-powershell/" title="How to handle command-line arguments in PowerShell" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Why does modern Perl avoid UTF-8 by default?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/why-does-modern-perl-avoid-utf-8-by-default/">
<meta property="og:description" content="I wonder why most modern solutions built using Perl don't enable UTF-8 by
default.
I understand there are many legacy problems for core Perl scripts, where it
may break things. But, from my point of v">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T01:43:29+08:00">
<meta property="article:tag" content="perl">
<meta property="article:tag" content="unicode">
<meta property="article:tag" content="utf-8">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Why does modern Perl avoid UTF-8 by default?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T01:43:29+08:00" itemprop="datePublished" title="2023-02-18 01:43">2023-02-18 01:43</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I wonder why most modern solutions built using Perl don't enable UTF-8 by
default.</p>
<p>I understand there are many legacy problems for core Perl scripts, where it
may break things. But, from my point of view, in the 21st century, big new
projects (or projects with a big perspective) should make their software UTF-8
proof from scratch. Still I don't see it happening. For example, Moose enables
strict and warnings, but not Unicode. Modern::Perl reduces boilerplate too,
but no UTF-8 handling.</p>
<p>Why? Are there some reasons to avoid UTF-8 in modern Perl projects in the year
2011?</p>
<hr>
<p>Commenting @tchrist got too long, so I'm adding it here.</p>
<p>It seems that I did not make myself clear. Let me try to add some things.</p>
<p><strong>tchrist</strong> and I see situation pretty similarly, but our conclusions are
completely in opposite ends. I agree, the situation with Unicode is
complicated, but this is why we (Perl users and coders) need some layer (or
pragma) which makes UTF-8 handling as easy as it must be nowadays.</p>
<p><strong>tchrist</strong> pointed to many aspects to cover, I will read and think about them
for days or even weeks. Still, this is not my point. <strong>tchrist</strong> tries to
prove that there is not one single way "to enable UTF-8". I have not so much
knowledge to argue with that. So, I stick to live examples.</p>
<p>I played around with Rakudo and UTF-8 was just there <strong>as I needed</strong>. I didn't
have any problems, it just worked. Maybe there are some limitation somewhere
deeper, but at start, all I tested worked as I expected.</p>
<p>Shouldn't that be a goal in modern Perl 5 too? I stress it more: I'm not
suggesting UTF-8 as the default character set for core Perl, I suggest the
possibility to trigger it <strong>with a snap</strong> for those who develop <strong>new</strong>
projects.</p>
<p>Another example, but with a more negative tone. Frameworks should make
development easier. Some years ago, I tried web frameworks, but just threw
them away because "enabling UTF-8" was so obscure. I did not find how and
where to hook Unicode support. It was so time-consuming that I found it easier
to go the old way. Now I saw here there was a bounty to deal with the same
problem with Mason 2: <em>How to make Mason2 UTF-8 clean?</em>. So, it is pretty new
framework, but using it with UTF-8 needs deep knowledge of its internals. It
is like a big red sign: STOP, don't use me!</p>
<p>I really like Perl. But dealing with Unicode is painful. I still find myself
running against walls. Some way <strong>tchrist</strong> is right and answers my questions:
new projects don't attract UTF-8 because it is too complicated in Perl 5.</p>
<p><br><br></p>
<h2>Answer</h2>
<h2>𝙎𝙞𝙢𝙥𝙡𝙚𝙨𝙩 <em>℞</em> : 𝟕 𝘿𝙞𝙨𝙘𝙧𝙚𝙩𝙚 𝙍𝙚𝙘𝙤𝙢𝙢𝙚𝙣𝙙𝙖𝙩𝙞𝙤𝙣𝙨</h2>
<ol>
<li>
<p>Set your <code>PERL_UNICODE</code> envariable to <code>AS</code>. This makes all Perl scripts decode <code>@ARGV</code> as UTF‑8 strings, and sets the encoding of all three of stdin, stdout, and stderr to UTF‑8. Both these are global effects, not lexical ones.</p>
</li>
<li>
<p>At the top of your source file (program, module, library, <code>do</code>hickey), prominently assert that you are running perl version 5.12 or better via:</p>
<div class="code"><pre class="code literal-block"><span class="nv">use</span><span class="w"> </span><span class="nv">v5</span>.<span class="mi">12</span><span class="c1">;  # minimal for unicode string feature</span>
</pre></div>

<p>use v5.14;  # optimal for unicode string feature</p>
</li>
<li>
<p>Enable warnings, since the previous declaration only enables strictures and features, not warnings. I also suggest promoting Unicode warnings into exceptions, so use both these lines, not just one of them. Note however that under v5.14, the <code>utf8</code> warning class comprises three other subwarnings which can all be separately enabled: <code>nonchar</code>, <code>surrogate</code>, and <code>non_unicode</code>. These you may wish to exert greater control over.</p>
<div class="code"><pre class="code literal-block">use warnings;
</pre></div>

<p>use warnings qw( FATAL utf8 );</p>
</li>
<li>
<p>Declare that this source unit is encoded as UTF‑8. Although once upon a time this pragma did other things, it now serves this one singular purpose alone and no other:</p>
<div class="code"><pre class="code literal-block">use utf8;
</pre></div>

</li>
<li>
<p>Declare that anything that opens a filehandle <em>within this lexical scope but not elsewhere</em> is to assume that that stream is encoded in UTF‑8 unless you tell it otherwise. That way you do not affect other module’s or other program’s code.</p>
<div class="code"><pre class="code literal-block">use open qw( :encoding(UTF-8) :std );
</pre></div>

</li>
<li>
<p>Enable named characters via <code>\N{CHARNAME}</code>.</p>
<div class="code"><pre class="code literal-block">use charnames qw( :full :short );
</pre></div>

</li>
<li>
<p>If you have a <code>DATA</code> handle, you must explicitly set its encoding. If you want this to be UTF‑8, then say:</p>
<div class="code"><pre class="code literal-block">binmode(DATA, ":encoding(UTF-8)");
</pre></div>

</li>
</ol>
<p>There is of course no end of other matters with which you may eventually find
yourself concerned, but these will suffice to approximate the state goal to
“make everything just work with UTF‑8”, albeit for a somewhat weakened sense
of those terms.</p>
<p>One other pragma, although it is not Unicode related, is:</p>
<div class="code"><pre class="code literal-block">      use autodie;
</pre></div>

<p>It is strongly recommended.</p>
<p>🌴 🐪🐫🐪 🌞 <em>𝕲𝖔 𝕿𝖍𝖔𝖚 𝖆𝖓𝖉 𝕯𝖔 𝕷𝖎𝖐𝖊𝖜𝖎𝖘𝖊</em> 🌞 🐪🐫🐪 🐁</p>
<hr>
<h3>🎁 🐪 𝕭𝖔𝖎𝖑𝖊𝖗⸗𝖕𝖑𝖆𝖙𝖊 𝖋𝖔𝖗 𝖀𝖓𝖎𝖈𝖔𝖉𝖊⸗𝕬𝖜𝖆𝖗𝖊 𝕮𝖔𝖉𝖊 🐪 🎁</h3>
<hr>
<p>My own boilerplate these days tends to look like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">use</span><span class="w"> </span><span class="mf">5.014</span><span class="p">;</span>

<span class="k">use</span><span class="w"> </span><span class="n">utf8</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">strict</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">warnings</span><span class="p">;</span><span class="w"> </span>
<span class="k">use</span><span class="w"> </span><span class="n">warnings</span><span class="w">    </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">FATAL</span><span class="w">  </span><span class="n">utf8</span><span class="w">     </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="k">open</span><span class="w">        </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="err">:</span><span class="n">std</span><span class="w">  </span><span class="err">:</span><span class="n">utf8</span><span class="w">     </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">charnames</span><span class="w">   </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="err">:</span><span class="k">full</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">feature</span><span class="w">     </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">unicode_strings</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">use</span><span class="w"> </span><span class="k">File</span><span class="o">::</span><span class="n">Basename</span><span class="w">      </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">basename</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">Carp</span><span class="w">                </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">carp</span><span class="w"> </span><span class="n">croak</span><span class="w"> </span><span class="n">confess</span><span class="w"> </span><span class="n">cluck</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">Encode</span><span class="w">              </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">encode</span><span class="w"> </span><span class="n">decode</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="nf">Unicode</span><span class="o">::</span><span class="k">Normalize</span><span class="w">  </span><span class="n">qw</span><span class="o">&lt;</span><span class="w"> </span><span class="n">NFD</span><span class="w"> </span><span class="n">NFC</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">END</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">close</span><span class="w"> </span><span class="n">STDOUT</span><span class="w"> </span><span class="err">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grep</span><span class="w"> </span><span class="o">/</span><span class="err">\</span><span class="n">P</span><span class="err">{</span><span class="nf">ASCII</span><span class="err">}</span><span class="o">/</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nv">@ARGV</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"> </span>
<span class="w">   </span><span class="nv">@ARGV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">map</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">decode</span><span class="p">(</span><span class="ss">"UTF-8"</span><span class="p">,</span><span class="w"> </span><span class="err">$</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="w"> </span><span class="nv">@ARGV</span><span class="p">;</span>
<span class="err">}</span>

<span class="err">$</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basename</span><span class="p">(</span><span class="err">$</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">shorter</span><span class="w"> </span><span class="n">messages</span>
<span class="err">$</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="n">binmode</span><span class="p">(</span><span class="k">DATA</span><span class="p">,</span><span class="w"> </span><span class="ss">":utf8"</span><span class="p">);</span>

<span class="err">#</span><span class="w"> </span><span class="n">give</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">full</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">dump</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="n">untrapped</span><span class="w"> </span><span class="n">exceptions</span>
<span class="k">local</span><span class="w"> </span><span class="err">$</span><span class="n">SIG</span><span class="err">{</span><span class="n">__DIE__</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">confess</span><span class="w"> </span><span class="ss">"Uncaught exception: @_"</span><span class="w"> </span><span class="n">unless</span><span class="w"> </span><span class="err">$</span><span class="o">^</span><span class="n">S</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span>

<span class="err">#</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">promote</span><span class="w"> </span><span class="n">run</span><span class="o">-</span><span class="nc">time</span><span class="w"> </span><span class="n">warnings</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">stack</span><span class="o">-</span><span class="n">dumped</span>
<span class="err">#</span><span class="w">   </span><span class="n">exceptions</span><span class="w"> </span><span class="o">*</span><span class="n">unless</span><span class="o">*</span><span class="w"> </span><span class="n">we</span><span class="err">'</span><span class="n">re</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span>
<span class="err">#</span><span class="w">   </span><span class="n">which</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="n">cluck</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">dump</span><span class="w"> </span><span class="n">instead</span>
<span class="k">local</span><span class="w"> </span><span class="err">$</span><span class="n">SIG</span><span class="err">{</span><span class="n">__WARN__</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="err">$</span><span class="o">^</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">cluck</span><span class="w">   </span><span class="ss">"Trapped warning: @_"</span><span class="w"> </span><span class="err">}</span><span class="w"> </span>
<span class="w">    </span><span class="k">else</span><span class="w">     </span><span class="err">{</span><span class="w"> </span><span class="n">confess</span><span class="w"> </span><span class="ss">"Deadly warning: @_"</span><span class="w">  </span><span class="err">}</span>
<span class="err">}</span><span class="p">;</span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span><span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">chomp</span><span class="p">;</span>
<span class="w">    </span><span class="err">$</span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NFD</span><span class="p">(</span><span class="err">$</span><span class="n">_</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="err">}</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">say</span><span class="w"> </span><span class="n">NFC</span><span class="p">(</span><span class="err">$</span><span class="n">_</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">__END__</span>
</pre></div>

<hr>
<h2>🎅 𝕹 𝖔 𝕸 𝖆 𝖌 𝖎 𝖈 𝕭 𝖚 𝖑 𝖑 𝖊 𝖙 🎅</h2>
<hr>
<p>Saying that “Perl should [ <strong>somehow!</strong> ] enable Unicode by default” doesn’t
even start to begin to think about getting around to saying enough to be even
marginally useful in some sort of rare and isolated case. Unicode is much much
more than just a larger character repertoire; it’s also how those characters
all interact in many, many ways.</p>
<p>Even the simple-minded minimal measures that (some) people seem to think they
want are guaranteed to miserably break millions of lines of code, code that
has no chance to “upgrade” to your spiffy new <em>Brave New World</em> modernity.</p>
<p>It is way way way more complicated than people pretend. I’ve thought about
this a huge, whole lot over the past few years. I would love to be shown that
I am wrong. But I don’t think I am. Unicode is fundamentally more complex than
the model that you would like to impose on it, and there is complexity here
that you can never sweep under the carpet. If you try, you’ll break either
your own code or somebody else’s. At some point, you simply have to break down
and learn what Unicode is about. You cannot pretend it is something it is not.</p>
<p>🐪 goes out of its way to make Unicode easy, far more than anything else I’ve
ever used. If you think this is bad, try something else for a while. Then come
back to 🐪: either you will have returned to a better world, or else you will
bring knowledge of the same with you so that we can make use of your new
knowledge to make 🐪 better at these things.</p>
<hr>
<h3>💡 𝕴𝖉𝖊𝖆𝖘 𝖋𝖔𝖗 𝖆 𝖀𝖓𝖎𝖈𝖔𝖉𝖊 ⸗ 𝕬𝖜𝖆𝖗𝖊 🐪 𝕷𝖆𝖚𝖓𝖉𝖗𝖞 𝕷𝖎𝖘𝖙 💡</h3>
<hr>
<p>At a minimum, here are some things that would appear to be required for 🐪 to
“enable Unicode by default”, as you put it:</p>
<ol>
<li>
<p>All 🐪 source code should be in UTF-8 by default. You can get that with <code>use utf8</code> or <code>export PERL5OPTS=-Mutf8</code>.</p>
</li>
<li>
<p>The 🐪 <code>DATA</code> handle should be UTF-8. You will have to do this on a per-package basis, as in <code>binmode(DATA, ":encoding(UTF-8)")</code>.</p>
</li>
<li>
<p>Program arguments to 🐪 scripts should be understood to be UTF-8 by default. <code>export PERL_UNICODE=A</code>, or <code>perl -CA</code>, or <code>export PERL5OPTS=-CA</code>.</p>
</li>
<li>
<p>The standard input, output, and error streams should default to UTF-8. <code>export PERL_UNICODE=S</code> for all of them, or <code>I</code>, <code>O</code>, and/or <code>E</code> for just some of them. This is like <code>perl -CS</code>.</p>
</li>
<li>
<p>Any other handles opened by 🐪 should be considered UTF-8 unless declared otherwise; <code>export PERL_UNICODE=D</code> or with <code>i</code> and <code>o</code> for particular ones of these; <code>export PERL5OPTS=-CD</code> would work. That makes <code>-CSAD</code> for all of them.</p>
</li>
<li>
<p>Cover both bases plus all the streams you open with <code>export PERL5OPTS=-Mopen=:utf8,:std</code>. See <em>uniquote</em>.</p>
</li>
<li>
<p>You don’t want to miss UTF-8 encoding errors. Try <code>export PERL5OPTS=-Mwarnings=FATAL,utf8</code>. And make sure your input streams are always <code>binmode</code>d to <code>:encoding(UTF-8)</code>, not just to <code>:utf8</code>.</p>
</li>
<li>
<p>Code points between 128–255 should be understood by 🐪 to be the corresponding Unicode code points, not just unpropertied binary values. <code>use feature "unicode_strings"</code> or <code>export PERL5OPTS=-Mfeature=unicode_strings</code>. That will make <code>uc("\xDF") eq "SS"</code> and <code>"\xE9" =~ /\w/</code>. A simple <code>export PERL5OPTS=-Mv5.12</code> or better will also get that.</p>
</li>
<li>
<p>Named Unicode characters are not by default enabled, so add <code>export PERL5OPTS=-Mcharnames=:full,:short,latin,greek</code> or some such. See <em>uninames</em> and tcgrep.</p>
</li>
<li>
<p>You almost always need access to the functions from the standard <code>Unicode::Normalize</code> module various types of decompositions. <code>export PERL5OPTS=-MUnicode::Normalize=NFD,NFKD,NFC,NFKD</code>, and then always run incoming stuff through NFD and outbound stuff from NFC. There’s no I/O layer for these yet that I’m aware of, but see <em>nfc</em> , <em>nfd</em> , <em>nfkd</em> , and <em>nfkc</em>.</p>
</li>
<li>
<p>String comparisons in 🐪 using <code>eq</code>, <code>ne</code>, <code>lc</code>, <code>cmp</code>, <code>sort</code>, &amp;c&amp;cc are always wrong. So instead of <code>@a = sort @b</code>, you need <code>@a = Unicode::Collate-&gt;new-&gt;sort(@b)</code>. Might as well add that to your <code>export PERL5OPTS=-MUnicode::Collate</code>. You can cache the key for binary comparisons.</p>
</li>
<li>
<p>🐪 built-ins like <code>printf</code> and <code>write</code> do the wrong thing with Unicode data. You need to use the <code>Unicode::GCString</code> module for the former, and both that and also the <code>Unicode::LineBreak</code> module as well for the latter. See <em>uwc</em> and <em>unifmt</em>.</p>
</li>
<li>
<p>If you want them to count as integers, then you are going to have to run your <code>\d+</code> captures through the <code>Unicode::UCD::num</code> function because 🐪’s built-in <em>atoi</em> (3) isn’t currently clever enough.</p>
</li>
<li>
<p>You are going to have filesystem issues on 👽 filesystems. Some filesystems silently enforce a conversion to NFC; others silently enforce a conversion to NFD. And others do something else still. Some even ignore the matter altogether, which leads to even greater problems. So you have to do your own NFC/NFD handling to keep sane.</p>
</li>
<li>
<p>All your 🐪 code involving <code>a-z</code> or <code>A-Z</code> and such <strong>MUST BE CHANGED</strong> , including <code>m//</code>, <code>s///</code>, and <code>tr///</code>. It’s should stand out as a screaming red flag that your code is broken. But it is not clear how it must change. Getting the right properties, and understanding their casefolds, is harder than you might think. I use <em>unichars</em> and <em>uniprops</em> every single day.</p>
</li>
<li>
<p>Code that uses <code>\p{Lu}</code> is almost as wrong as code that uses <code>[A-Za-z]</code>. You need to use <code>\p{Upper}</code> instead, and know the reason why. Yes, <code>\p{Lowercase}</code> and <code>\p{Lower}</code> are different from <code>\p{Ll}</code> and <code>\p{Lowercase_Letter}</code>.</p>
</li>
<li>
<p>Code that uses <code>[a-zA-Z]</code> is even worse. And it can’t use <code>\pL</code> or <code>\p{Letter}</code>; it needs to use <code>\p{Alphabetic}</code>. Not all alphabetics are letters, you know!</p>
</li>
<li>
<p>If you are looking for 🐪 variables with <code>/[\$\@\%]\w+/</code>, then you have a problem. You need to look for <code>/[\$\@\%]\p{IDS}\p{IDC}*/</code>, and even that isn’t thinking about the punctuation variables or package variables.</p>
</li>
<li>
<p>If you are checking for whitespace, then you should choose between <code>\h</code> and <code>\v</code>, depending. And you should never use <code>\s</code>, since it <strong>DOES NOT MEAN</strong> <code>[\h\v]</code>, contrary to popular belief.</p>
</li>
<li>
<p>If you are using <code>\n</code> for a line boundary, or even <code>\r\n</code>, then you are doing it wrong. You have to use <code>\R</code>, which is not the same!</p>
</li>
<li>
<p>If you don’t know when and whether to call Unicode::Stringprep, then you had better learn.</p>
</li>
<li>
<p>Case-insensitive comparisons need to check for whether two things are the same letters no matter their diacritics and such. The easiest way to do that is with the standard Unicode::Collate module. <code>Unicode::Collate-&gt;new(level =&gt; 1)-&gt;cmp($a, $b)</code>. There are also <code>eq</code> methods and such, and you should probably learn about the <code>match</code> and <code>substr</code> methods, too. These are have distinct advantages over the 🐪 built-ins.</p>
</li>
<li>
<p>Sometimes that’s still not enough, and you need the Unicode::Collate::Locale module instead, as in <code>Unicode::Collate::Locale-&gt;new(locale =&gt; "de__phonebook", level =&gt; 1)-&gt;cmp($a, $b)</code> instead. Consider that <code>Unicode::Collate::-&gt;new(level =&gt; 1)-&gt;eq("d", "ð")</code> is true, but <code>Unicode::Collate::Locale-&gt;new(locale=&gt;"is",level =&gt; 1)-&gt;eq("d", " ð")</code> is false. Similarly, "ae" and "æ" are <code>eq</code> if you don’t use locales, or if you use the English one, but they are different in the Icelandic locale. Now what? It’s tough, I tell you. You can play with <em>ucsort</em> to test some of these things out.</p>
</li>
<li>
<p>Consider how to match the pattern CVCV (consonsant, vowel, consonant, vowel) in the string “ <em>niño</em> ”. Its NFD form — which you had darned well better have remembered to put it in — becomes “nin\x{303}o”. Now what are you going to do? Even pretending that a vowel is <code>[aeiou]</code> (which is wrong, by the way), you won’t be able to do something like <code>(?=[aeiou])\X)</code> either, because even in NFD a code point like ‘ø’ <strong>does not decompose</strong>! However, it will test equal to an ‘o’ using the UCA comparison I just showed you. You can’t rely on NFD, you have to rely on UCA. </p>
</li>
</ol>
<hr>
<h3>💩 𝔸 𝕤 𝕤 𝕦 𝕞 𝕖 𝔹 𝕣 𝕠 𝕜 𝕖 𝕟 𝕟 𝕖 𝕤 𝕤 💩</h3>
<hr>
<p>And that’s not all. There are a million broken assumptions that people make
about Unicode. Until they understand these things, their 🐪 code will be
broken.</p>
<ol>
<li>
<p>Code that assumes it can open a text file without specifying the encoding is broken.</p>
</li>
<li>
<p>Code that assumes the default encoding is some sort of native platform encoding is broken.</p>
</li>
<li>
<p>Code that assumes that web pages in Japanese or Chinese take up less space in UTF‑16 than in UTF‑8 is wrong.</p>
</li>
<li>
<p>Code that assumes Perl uses UTF‑8 internally is wrong.</p>
</li>
<li>
<p>Code that assumes that encoding errors will always raise an exception is wrong.</p>
</li>
<li>
<p>Code that assumes Perl code points are limited to 0x10_FFFF is wrong.</p>
</li>
<li>
<p>Code that assumes you can set <code>$/</code> to something that will work with any valid line separator is wrong.</p>
</li>
<li>
<p>Code that assumes roundtrip equality on casefolding, like <code>lc(uc($s)) eq $s</code> or <code>uc(lc($s)) eq $s</code>, is completely broken and wrong. Consider that the <code>uc("σ")</code> and <code>uc("ς")</code> are both <code>"Σ"</code>, but <code>lc("Σ")</code> cannot possibly return both of those.</p>
</li>
<li>
<p>Code that assumes every lowercase code point has a distinct uppercase one, or vice versa, is broken. For example, <code>"ª"</code> is a lowercase letter with no uppercase; whereas both <code>"ᵃ"</code> and <code>"ᴬ"</code> are letters, but they are not lowercase letters; however, they are both lowercase code points without corresponding uppercase versions. Got that? They are <strong>not</strong> <code>\p{Lowercase_Letter}</code>, despite being both <code>\p{Letter}</code> and <code>\p{Lowercase}</code>.</p>
</li>
<li>
<p>Code that assumes changing the case doesn’t change the length of the string is broken.</p>
</li>
<li>
<p>Code that assumes there are only two cases is broken. There’s also titlecase.</p>
</li>
<li>
<p>Code that assumes only letters have case is broken. Beyond just letters, it turns out that numbers, symbols, and even marks have case. In fact, changing the case can even make something change its main general category, like a <code>\p{Mark}</code> turning into a <code>\p{Letter}</code>. It can also make it switch from one script to another.</p>
</li>
<li>
<p>Code that assumes that case is never locale-dependent is broken.</p>
</li>
<li>
<p>Code that assumes Unicode gives a fig about POSIX locales is broken.</p>
</li>
<li>
<p>Code that assumes you can remove diacritics to get at base ASCII letters is evil, still, broken, brain-damaged, wrong, and justification for capital punishment.</p>
</li>
<li>
<p>Code that assumes that diacritics <code>\p{Diacritic}</code> and marks <code>\p{Mark}</code> are the same thing is broken.</p>
</li>
<li>
<p>Code that assumes <code>\p{GC=Dash_Punctuation}</code> covers as much as <code>\p{Dash}</code> is broken.</p>
</li>
<li>
<p>Code that assumes dash, hyphens, and minuses are the same thing as each other, or that there is only one of each, is broken and wrong.</p>
</li>
<li>
<p>Code that assumes every code point takes up no more than one print column is broken.</p>
</li>
<li>
<p>Code that assumes that all <code>\p{Mark}</code> characters take up zero print columns is broken.</p>
</li>
<li>
<p>Code that assumes that characters which look alike <em>are</em> alike is broken.</p>
</li>
<li>
<p>Code that assumes that characters which do <em>not</em> look alike are <em>not</em> alike is broken.</p>
</li>
<li>
<p>Code that assumes there is a limit to the number of code points in a row that just one <code>\X</code> can match is wrong.</p>
</li>
<li>
<p>Code that assumes <code>\X</code> can never start with a <code>\p{Mark}</code> character is wrong.</p>
</li>
<li>
<p>Code that assumes that <code>\X</code> can never hold two non-<code>\p{Mark}</code> characters is wrong.</p>
</li>
<li>
<p>Code that assumes that it cannot use <code>"\x{FFFF}"</code> is wrong.</p>
</li>
<li>
<p>Code that assumes a non-BMP code point that requires two UTF-16 (surrogate) code units will encode to two separate UTF-8 characters, one per code unit, is wrong. It doesn’t: it encodes to single code point.</p>
</li>
<li>
<p>Code that transcodes from UTF‐16 or UTF‐32 with leading BOMs into UTF‐8 is broken if it puts a BOM at the start of the resulting UTF-8. This is so stupid the engineer should have their eyelids removed.</p>
</li>
<li>
<p>Code that assumes the CESU-8 is a valid UTF encoding is wrong. Likewise, code that thinks encoding U+0000 as <code>"\xC0\x80"</code> is UTF-8 is broken and wrong. These guys also deserve the eyelid treatment.</p>
</li>
<li>
<p>Code that assumes characters like <code>&gt;</code> always points to the right and <code>&lt;</code> always points to the left are wrong — because they in fact do not.</p>
</li>
<li>
<p>Code that assumes if you first output character <code>X</code> and then character <code>Y</code>, that those will show up as <code>XY</code> is wrong. Sometimes they don’t.</p>
</li>
<li>
<p><strong>Code that assumes that ASCII is good enough for writing English properly is stupid, shortsighted, illiterate, broken, evil, and wrong.</strong> Off with their heads! If that seems too extreme, we can compromise: henceforth they may type only with their big toe from one foot. (The rest will be duct taped.)</p>
</li>
<li>
<p>Code that assumes that all <code>\p{Math}</code> code points are visible characters is wrong.</p>
</li>
<li>
<p>Code that assumes <code>\w</code> contains only letters, digits, and underscores is wrong.</p>
</li>
<li>
<p>Code that assumes that <code>^</code> and <code>~</code> are punctuation marks is wrong.</p>
</li>
<li>
<p>Code that assumes that <code>ü</code> has an umlaut is wrong.</p>
</li>
<li>
<p>Code that believes things like <code>₨</code> contain any letters in them is wrong.</p>
</li>
<li>
<p>Code that believes <code>\p{InLatin}</code> is the same as <code>\p{Latin}</code> is heinously broken. </p>
</li>
<li>
<p>Code that believe that <code>\p{InLatin}</code> is almost ever useful is almost certainly wrong.</p>
</li>
<li>
<p>Code that believes that given <code>$FIRST_LETTER</code> as the first letter in some alphabet and <code>$LAST_LETTER</code> as the last letter in that same alphabet, that <code>[${FIRST_LETTER}-${LAST_LETTER}]</code> has any meaning whatsoever is almost always complete broken and wrong and meaningless.</p>
</li>
<li>
<p>Code that believes someone’s name can only contain certain characters is stupid, offensive, and wrong.</p>
</li>
<li>
<p>Code that tries to reduce Unicode to ASCII is not merely wrong, its perpetrator should never be allowed to work in programming again. Period. I’m not even positive they should even be allowed to see again, since it obviously hasn’t done them much good so far.</p>
</li>
<li>
<p>Code that believes there’s some way to pretend textfile encodings don’t exist is broken and dangerous. Might as well poke the other eye out, too.</p>
</li>
<li>
<p>Code that converts unknown characters to <code>?</code> is broken, stupid, braindead, and runs contrary to the standard recommendation, which says <strong>NOT TO DO THAT!</strong> RTFM for why not.</p>
</li>
<li>
<p>Code that believes it can reliably guess the encoding of an unmarked textfile is guilty of a fatal mélange of hubris and naïveté that only a lightning bolt from Zeus will fix.</p>
</li>
<li>
<p>Code that believes you can use 🐪 <code>printf</code> widths to pad and justify Unicode data is broken and wrong.</p>
</li>
<li>
<p>Code that believes once you successfully create a file by a given name, that when you run <code>ls</code> or <code>readdir</code> on its enclosing directory, you’ll actually find that file with the name you created it under is buggy, broken, and wrong. Stop being surprised by this!</p>
</li>
<li>
<p>Code that believes UTF-16 is a fixed-width encoding is stupid, broken, and wrong. Revoke their programming licence.</p>
</li>
<li>
<p>Code that treats code points from one plane one whit differently than those from any other plane is <em>ipso facto</em> broken and wrong. Go back to school.</p>
</li>
<li>
<p>Code that believes that stuff like <code>/s/i</code> can only match <code>"S"</code> or <code>"s"</code> is broken and wrong. You’d be surprised.</p>
</li>
<li>
<p>Code that uses <code>\PM\pM*</code> to find grapheme clusters instead of using <code>\X</code> is broken and wrong.</p>
</li>
<li>
<p>People who want to go back to the ASCII world should be whole-heartedly encouraged to do so, and in honor of their glorious upgrade they should be provided <em>gratis</em> with a pre-electric manual typewriter for all their data-entry needs. Messages sent to them should be sent via an ᴀʟʟᴄᴀᴘs telegraph at 40 characters per line and hand-delivered by a courier. STOP.</p>
</li>
</ol>
<hr>
<h2>😱 𝕾 𝖀 𝕸 𝕸 𝕬 𝕽 𝖄 😱</h2>
<hr>
<p>I don’t know how much more “default Unicode in 🐪” you can get than what I’ve
written. Well, yes I do: you should be using <code>Unicode::Collate</code> and
<code>Unicode::LineBreak</code>, too. And probably more.</p>
<p>As you see, there are far too many Unicode things that you really <em>do</em> have to
worry about for there to <em>ever</em> exist any such thing as “default to Unicode”.</p>
<p>What you’re going to discover, just as we did back in 🐪 5.8, that it is simply
impossible to impose all these things on code that hasn’t been designed right
from the beginning to account for them. Your well-meaning selfishness just
broke the entire world.</p>
<p>And even once you do, there are still critical issues that require a great
deal of thought to get right. There is no switch you can flip. Nothing but
brain, and I mean <em>real brain</em> , will suffice here. There’s a heck of a lot of
stuff you have to learn. Modulo the retreat to the manual typewriter, you
simply cannot hope to sneak by in ignorance. This is the 21ˢᵗ century, and you
cannot wish Unicode away by willful ignorance.</p>
<p>You have to learn it. Period. It will never be so easy that “everything just
works,” because that will guarantee that a lot of things <strong>don’t</strong> work —
which invalidates the assumption that there can ever be a way to “make it all
work.”</p>
<p>You may be able to get a few reasonable defaults for a very few and very
limited operations, but not without thinking about things a whole lot more
than I think you have.</p>
<p>As just one example, canonical ordering is going to cause some real headaches.
😭<code>"\x{F5}"</code> <strong>‘õ’</strong> , <code>"o\x{303}"</code> <strong>‘õ’</strong> , <code>"o\x{303}\x{304}"</code> <strong>‘ȭ’</strong> , and
<code>"o\x{304}\x{303}"</code> <strong>‘ō̃’</strong> should all match <strong>‘õ’</strong> , but how in the world
are you going to do that? This is harder than it looks, but it’s something you
need to account for. 💣</p>
<p>If there’s one thing I know about Perl, it is what its Unicode bits do and do
not do, and this thing I promise you: <strong>“ ̲ᴛ̲ʜ̲ᴇ̲ʀ̲ᴇ̲ ̲ɪ̲s̲ ̲ɴ̲ᴏ̲
̲U̲ɴ̲ɪ̲ᴄ̲ᴏ̲ᴅ̲ᴇ̲ ̲ᴍ̲ᴀ̲ɢ̲ɪ̲ᴄ̲ ̲ʙ̲ᴜ̲ʟ̲ʟ̲ᴇ̲ᴛ̲ ̲ ”</strong> 😞</p>
<p>You cannot just change some defaults and get smooth sailing. It’s true that I
run 🐪 with <code>PERL_UNICODE</code> set to <code>"SA"</code>, but that’s all, and even that is
mostly for command-line stuff. For real work, I go through all the many steps
outlined above, and I do it very, <strong> very</strong> carefully.</p>
<hr>
<h2>😈 ¡ƨdləɥ ƨᴉɥʇ ədoɥ puɐ ʻλɐp əɔᴉu ɐ əʌɐɥ ʻʞɔnl poo⅁ 😈</h2>
<p><br></p>
<h3>Suggest</h3>
<p>There are two stages to processing Unicode text. The first is "how can I input
it and output it without losing information". The second is "how do I treat
text according to local language conventions".</p>
<p>tchrist's post covers both, but the second part is where 99% of the text in
his post comes from. Most programs don't even handle I/O correctly, so it's
important to understand that before you even begin to worry about
normalization and collation.</p>
<p>This post aims to solve that first problem</p>
<p>When you read data into Perl, it doesn't care what encoding it is. It
allocates some memory and stashes the bytes away there. If you say <code>print
$str</code>, it just blits those bytes out to your terminal, which is probably set
to assume everything that is written to it is UTF-8, and your text shows up.</p>
<p>Marvelous.</p>
<p>Except, it's not. If you try to treat the data as text, you'll see that
Something Bad is happening. You need go no further than <code>length</code> to see that
what Perl thinks about your string and what you think about your string
disagree. Write a one-liner like: <code>perl -E 'while(&lt;&gt;){ chomp; say length }'</code>
and type in <code>文字化け</code> and you get 12... not the correct answer, 4.</p>
<p>That's because Perl assumes your string is not text. You have to tell it that
it's text before it will give you the right answer.</p>
<p>That's easy enough; the Encode module has the functions to do that. The
generic entry point is <code>Encode::decode</code> (or <code>use Encode qw(decode)</code>, of
course). That function takes some string from the outside world (what we'll
call "octets", a fancy of way of saying "8-bit bytes"), and turns it into some
text that Perl will understand. The first argument is a character encoding
name, like "UTF-8" or "ASCII" or "EUC-JP". The second argument is the string.
The return value is the Perl scalar containing the text.</p>
<p>(There is also <code>Encode::decode_utf8</code>, which assumes UTF-8 for the encoding.)</p>
<p>If we rewrite our one-liner:</p>
<div class="code"><pre class="code literal-block"><span class="nv">perl</span><span class="w"> </span><span class="o">-</span><span class="nv">MEncode</span><span class="o">=</span><span class="nv">decode</span><span class="w"> </span><span class="o">-</span><span class="nv">E</span><span class="w"> </span><span class="s1">'while(&lt;&gt;){ chomp; say length decode("UTF-8", $_) }'</span>
</pre></div>

<p>We type in 文字化け and get "4" as the result. Success.</p>
<p>That, right there, is the solution to 99% of Unicode problems in Perl.</p>
<p>The key is, whenever any text comes into your program, you must decode it. The
Internet cannot transmit characters. Files cannot store characters. There are
no characters in your database. There are only octets, and you can't treat
octets as characters in Perl. You must decode the encoded octets into Perl
characters with the Encode module.</p>
<p>The other half of the problem is getting data out of your program. That's easy
to; you just say <code>use Encode qw(encode)</code>, decide what the encoding your data
will be in (UTF-8 to terminals that understand UTF-8, UTF-16 for files on
Windows, etc.), and then output the result of <code>encode($encoding, $data)</code>
instead of just outputting <code>$data</code>.</p>
<p>This operation converts Perl's characters, which is what your program operates
on, to octets that can be used by the outside world. It would be a lot easier
if we could just send characters over the Internet or to our terminals, but we
can't: octets only. So we have to convert characters to octets, otherwise the
results are undefined.</p>
<p>To summarize: encode all outputs and decode all inputs.</p>
<p>Now we'll talk about three issues that make this a little challenging. The
first is libraries. Do they handle text correctly? The answer is... they try.
If you download a web page, LWP will give you your result back as text. If you
call the right method on the result, that is (and that happens to be
<code>decoded_content</code>, not <code>content</code>, which is just the octet stream that it got
from the server.) Database drivers can be flaky; if you use DBD::SQLite with
just Perl, it will work out, but if some other tool has put text stored as
some encoding other than UTF-8 in your database... well... it's not going to
be handled correctly until you write code to handle it correctly.</p>
<p>Outputting data is usually easier, but if you see "wide character in print",
then you know you're messing up the encoding somewhere. That warning means
"hey, you're trying to leak Perl characters to the outside world and that
doesn't make any sense". Your program appears to work (because the other end
usually handles the raw Perl characters correctly), but it is very broken and
could stop working at any moment. Fix it with an explicit <code>Encode::encode</code>!</p>
<p>The second problem is UTF-8 encoded source code. Unless you say <code>use utf8</code> at
the top of each file, Perl will not assume that your source code is UTF-8.
This means that each time you say something like <code>my $var = 'ほげ'</code>, you're
injecting garbage into your program that will totally break everything
horribly. You don't have to "use utf8", but if you don't, you <em>must</em> not use
any non-ASCII characters in your program.</p>
<p>The third problem is how Perl handles The Past. A long time ago, there was no
such thing as Unicode, and Perl assumed that everything was Latin-1 text or
binary. So when data comes into your program and you start treating it as
text, Perl treats each octet as a Latin-1 character. That's why, when we asked
for the length of "文字化け", we got 12. Perl assumed that we were operating on
the Latin-1 string "æå­åã" (which is 12 characters, some of which are non-
printing).</p>
<p>This is called an "implicit upgrade", and it's a perfectly reasonable thing to
do, but it's not what you want if your text is not Latin-1. That's why it's
critical to explicitly decode input: if you don't do it, Perl will, and it
might do it wrong.</p>
<p>People run into trouble where half their data is a proper character string,
and some is still binary. Perl will interpret the part that's still binary as
though it's Latin-1 text and then combine it with the correct character data.
This will make it look like handling your characters correctly broke your
program, but in reality, you just haven't fixed it enough.</p>
<p>Here's an example: you have a program that reads a UTF-8-encoded text file,
you tack on a Unicode <code>PILE OF POO</code> to each line, and you print it out. You
write it like:</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="ss">(</span><span class="o">&lt;&gt;</span><span class="ss">)</span>{
<span class="w">    </span><span class="nv">chomp</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">say</span><span class="w"> </span><span class="s2">"$_ 💩"</span><span class="c1">;</span>
}
</pre></div>

<p>And then run on some UTF-8 encoded data, like:</p>
<div class="code"><pre class="code literal-block">perl poo.pl input-data.txt
</pre></div>

<p>It prints the UTF-8 data with a poo at the end of each line. Perfect, my
program works!</p>
<p>But nope, you're just doing binary concatenation. You're reading octets from
the file, removing a <code>\n</code> with chomp, and then tacking on the bytes in the
UTF-8 representation of the <code>PILE OF POO</code> character. When you revise your
program to decode the data from the file and encode the output, you'll notice
that you get garbage ("ð©") instead of the poo. This will lead you to believe
that decoding the input file is the wrong thing to do. It's not.</p>
<p>The problem is that the poo is being implicitly upgraded as latin-1. If you
<code>use utf8</code> to make the literal text instead of binary, then it will work
again!</p>
<p>(That's the number one problem I see when helping people with Unicode. They
did part right and that broke their program. That's what's sad about undefined
results: you can have a working program for a long time, but when you start to
repair it, it breaks. Don't worry; if you are adding encode/decode statements
to your program and it breaks, it just means you have more work to do. Next
time, when you design with Unicode in mind from the beginning, it will be much
easier!)</p>
<p>That's really all you need to know about Perl and Unicode. If you tell Perl
what your data is, it has the best Unicode support among all popular
programming languages. If you assume it will magically know what sort of text
you are feeding it, though, then you're going to trash your data irrevocably.
Just because your program works today on your UTF-8 terminal doesn't mean it
will work tomorrow on a UTF-16 encoded file. So make it safe now, and save
yourself the headache of trashing your users' data!</p>
<p>The easy part of handling Unicode is encoding output and decoding input. The
hard part is finding all your input and output, and determining which encoding
it is. But that's why you get the big bucks :)</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/perl/" rel="tag">perl</a></li>
            <li><a class="tag p-category" href="../../categories/unicode/" rel="tag">unicode</a></li>
            <li><a class="tag p-category" href="../../categories/utf-8/" rel="tag">utf-8</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../c-how-to-create-a-guid-value/" rel="prev" title="C# how to create a Guid value?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-to-handle-command-line-arguments-in-powershell/" rel="next" title="How to handle command-line arguments in PowerShell">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
