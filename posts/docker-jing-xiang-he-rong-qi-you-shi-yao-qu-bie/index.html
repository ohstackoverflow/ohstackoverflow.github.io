<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Docker 镜像和容器有什么区别？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/docker-jing-xiang-he-rong-qi-you-shi-yao-qu-bie/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-xiu-jian-yuan-cheng-bu-zai-cun-zai-de-ben-di-gen-zong-fen-zhi/" title="如何修剪远程不再存在的本地跟踪分支？" type="text/html">
<link rel="next" href="../c-zhong-de-gong-gong-si-you-he-shou-bao-hu-ji-cheng-you-shi-yao-qu-bie/" title="C++ 中的公共、私有和受保护继承有什么区别？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Docker 镜像和容器有什么区别？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/docker-jing-xiang-he-rong-qi-you-shi-yao-qu-bie/">
<meta property="og:description" content="使用 Docker 时，我们从基础镜像开始。我们启动它，创建更改并将这些更改保存在形成另一个图像的层中。
因此，最终我得到了我的 PostgreSQL 实例的图像和我的 Web 应用程序的图像，对它们的更改不断被保留。
什么是容器？

解答
图像的实例称为容器。您有一个图像，它是您描述的一组图层。如果你启动这个镜像，你就有了这个镜像的运行容器。您可以有多个运行相同图像的容器。
您可以使用 来查看所">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T04:34:23+08:00">
<meta property="article:tag" content="docker">
<meta property="article:tag" content="docker-container">
<meta property="article:tag" content="docker-image">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Docker 镜像和容器有什么区别？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:34:23+08:00" itemprop="datePublished" title="2023-02-17 04:34">2023-02-17 04:34</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>使用 Docker 时，我们从基础镜像开始。我们启动它，创建更改并将这些更改保存在形成另一个图像的层中。</p>
<p>因此，最终我得到了我的 PostgreSQL 实例的图像和我的 Web 应用程序的图像，对它们的更改不断被保留。</p>
<p>什么是容器？</p>
<p><br><br></p>
<h2>解答</h2>
<p>图像的实例称为容器。您有一个图像，它是您描述的一组图层。如果你启动这个镜像，你就有了这个镜像的运行容器。您可以有多个运行相同图像的容器。</p>
<p>您可以使用 来查看所有图像，<code>docker images</code>而您可以使用 来查看正在运行的容器<code>docker ps</code>（并且您可以使用
来查看所有容器<code>docker ps -a</code>）。</p>
<p>因此，图像的运行实例是一个容器。</p>
<p><br></p>
<h3>更多建议</h3>
<p>来自我关于自动化 Docker 部署的文章（已存档）：</p>
<h3>Docker 镜像与容器</h3>
<p>在 Dockerland 中，有 <strong>图像</strong> ，也有 <strong>容器</strong> 。两者密切相关，但又截然不同。对我来说，掌握这种二分法极大地阐明了 Docker。</p>
<h4>什么是图像？</h4>
<p>镜像是一种惰性的、不可变的文件，本质上是容器的快照。图像是使用build命令创建的，它们将在使用run启动时生成一个容器。图像存储在 Docker
注册表中，例如registry.hub.docker.com。因为它们可以变得非常大，图像被设计成由其他图像层组成，允许在通过网络传输图像时发送最少量的数据。</p>
<p>可以通过运行列出本地图像<code>docker images</code>：</p>
<div class="code"><pre class="code literal-block">REPOSITORY                TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                    13.10               5e019ab7bf6d        2 months ago        180 MB
ubuntu                    14.04               99ec81b80c55        2 months ago        266 MB
ubuntu                    latest              99ec81b80c55        2 months ago        266 MB
ubuntu                    trusty              99ec81b80c55        2 months ago        266 MB
&lt;none&gt;                    &lt;none&gt;              4ab0d9120985        3 months ago        486.5 MB
</pre></div>

<p><strong>一些注意事项：</strong></p>
<ol>
<li>IMAGE ID 是图像真实标识符的前 12 个字符。您可以为给定图像创建多个标签，但它们的 ID 都将相同（如上）。</li>
<li>VIRTUAL SIZE 是 <em>虚拟的</em> ，因为它将所有不同底层的大小相加。这意味着该列中所有值的总和可能比所有这些图像使用的磁盘空间大得多。</li>
<li>REPOSITORY 列中的值来自命令<code>-t</code>的标志<code>docker build</code>，或来自<code>docker tag</code>-ing 现有图像。您可以使用对您有意义的命名法来自由标记图像，但要知道 docker 会将标记用作 或 中的注册表<code>docker push</code>位置<code>docker pull</code>。</li>
<li>标签的完整形式是<code>[REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>. 对于<code>ubuntu</code>上述内容，REGISTRYHOST 被推断为<code>registry.hub.docker.com</code>. 因此，如果您计划将您的图像存储<code>my-application</code>在注册表中<code>docker.example.com</code>，您应该标记该图像<code>docker.example.com/my-application</code>。</li>
<li>
<em>TAG 列只是完整</em> 标记的 [:TAG] 部分。这是不幸的术语。</li>
<li>该<code>latest</code>标签并不神奇，它只是您不指定标签时的默认标签。</li>
<li>您可以让未标记的图像只能通过其图像 ID 进行识别。这些将获得<code>&lt;none&gt;</code>TAG 和 REPOSITORY。很容易忘记他们。</li>
</ol>
<p>有关图像的更多信息，请参阅Docker 文档和词汇表。</p>
<h4>什么是容器？</h4>
<p>用编程比喻来说，如果图像是一个类，那么容器就是一个类的实例——一个运行时对象。希望容器是您使用 Docker
的原因；它们是运行应用程序的环境的轻量级和可移植封装。</p>
<p>查看本地运行的容器<code>docker ps</code>：</p>
<div class="code"><pre class="code literal-block"><span class="n">CONTAINER</span><span class="w"> </span><span class="n">ID</span><span class="w">        </span><span class="n">IMAGE</span><span class="w">                               </span><span class="n">COMMAND</span><span class="w">                </span><span class="n">CREATED</span><span class="w">             </span><span class="n">STATUS</span><span class="w">              </span><span class="n">PORTS</span><span class="w">                    </span><span class="n">NAMES</span>
<span class="n">f2ff1af05450</span><span class="w">        </span><span class="n">samalba</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="nl">registry:</span><span class="n">latest</span><span class="w">      </span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span><span class="w"> </span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="p">'</span><span class="n">exec</span><span class="w"> </span><span class="n">doc</span><span class="w">   </span><span class="mh">4</span><span class="w"> </span><span class="n">months</span><span class="w"> </span><span class="n">ago</span><span class="w">        </span><span class="n">Up</span><span class="w"> </span><span class="mh">12</span><span class="w"> </span><span class="n">weeks</span><span class="w">         </span><span class="mf">0.0.0.0</span><span class="o">:</span><span class="mh">5000</span><span class="o">-&gt;</span><span class="mh">5000</span><span class="o">/</span><span class="n">tcp</span><span class="w">   </span><span class="n">docker</span><span class="o">-</span><span class="n">registry</span>
</pre></div>

<p>在这里，我正在运行 docker registry 的 dockerized 版本，这样我就有了一个私人的地方来存储我的图像。再次，一些需要注意的事项：</p>
<ol>
<li>与 IMAGE ID 一样，CONTAINER ID 是容器的真实标识符。它具有相同的形式，但它标识不同种类的对象。</li>
<li>
<code>docker ps</code>只输出 <em>正在运行的</em> 容器。您可以使用查看所有容器（ <em>正在运行</em> 或 <em>已停止</em> ）<code>docker ps -a</code>。</li>
<li>NAMES 可用于通过<code>--name</code>标志标识已启动的容器。</li>
</ol>
<h4>如何避免图像和容器堆积</h4>
<p>我早期对 Docker 的挫败感之一是 <strong>未标记的图像和停止的容器看似不断堆积</strong>
。在少数情况下，这种累积会导致硬盘驱动器用尽，从而降低我的笔记本电脑的速度或停止我的自动构建管道。谈论“到处都是容器”！</p>
<p>我们可以通过结合<code>docker rmi</code>最近的<code>dangling=true</code>查询来删除所有未标记的图像：</p>
<div class="code"><pre class="code literal-block">docker images -q --filter "dangling=true" | xargs docker rmi
</pre></div>

<p>Docker 将无法删除现有容器后面的图像，因此您可能必须先删除已停止的容器<code>docker rm</code>：</p>
<div class="code"><pre class="code literal-block">docker rm `docker ps --no-trunc -aq`
</pre></div>

<p>这些是Docker 的已知痛点，可能会在未来的版本中得到解决。然而，通过对图像和容器的清晰理解，这些情况可以通过一些实践来避免：</p>
<ol>
<li>始终使用 . 删除无用的、停止的容器<code>docker rm [CONTAINER_ID]</code>。</li>
<li>总是删除一个无用的、停止的容器后面的图像<code>docker rmi [IMAGE_ID]</code>。</li>
</ol>
<p><br><br><a href="../what-is-the-difference-between-a-docker-image-and-a-container/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/docker/" rel="tag">docker</a></li>
            <li><a class="tag p-category" href="../../categories/docker-container/" rel="tag">docker-container</a></li>
            <li><a class="tag p-category" href="../../categories/docker-image/" rel="tag">docker-image</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-xiu-jian-yuan-cheng-bu-zai-cun-zai-de-ben-di-gen-zong-fen-zhi/" rel="prev" title="如何修剪远程不再存在的本地跟踪分支？">Previous post</a>
            </li>
            <li class="next">
                <a href="../c-zhong-de-gong-gong-si-you-he-shou-bao-hu-ji-cheng-you-shi-yao-qu-bie/" rel="next" title="C++ 中的公共、私有和受保护继承有什么区别？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
