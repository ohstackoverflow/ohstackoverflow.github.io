<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>“this”关键字是如何工作的，应该在什么时候使用？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/this-guan-jian-zi-shi-ru-he-gong-zuo-de-ying-gai-zai-shi-yao-shi-hou-shi-yong/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-zai-bu-chuang-jian-xin-mi-yao-de-qing-kuang-xia-shan-chu-ssh-mi-yao-de-mi-ma/" title="如何在不创建新密钥的情况下删除 SSH 密钥的密码？" type="text/html">
<link rel="next" href="../ru-he-zai-typescript-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-shu-zi/" title="如何在 TypeScript 中将字符串转换为数字？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="“this”关键字是如何工作的，应该在什么时候使用？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/this-guan-jian-zi-shi-ru-he-gong-zuo-de-ying-gai-zai-shi-yao-shi-hou-shi-yong/">
<meta property="og:description" content="我希望找到关于“this”关键字的作用以及如何正确使用它的清晰解释。
它似乎表现得很奇怪，我不完全明白为什么。
它是如何this工作的，应该在什么时候使用？

解答
this是 JavaScript 中的关键字，它是执行上下文的属性。它的主要用途是在函数和构造函数中。的规则this非常简单（如果您坚持最佳实践）。
this规范中的技术描述
ECMAScript标准this通过抽象操作（缩写为 AO">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T02:07:01+08:00">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="this">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">“this”关键字是如何工作的，应该在什么时候使用？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:07:01+08:00" itemprop="datePublished" title="2023-02-17 02:07">2023-02-17 02:07</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我希望找到关于“this”关键字的作用以及如何正确使用它的清晰解释。</p>
<p>它似乎表现得很奇怪，我不完全明白为什么。</p>
<p>它是如何<code>this</code>工作的，应该在什么时候使用？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>this</code>是 JavaScript 中的关键字，它是执行上下文的属性。它的主要用途是在函数和构造函数中。的规则<code>this</code>非常简单（如果您坚持最佳实践）。</p>
<h3>
<code>this</code>规范中的技术描述</h3>
<p>ECMAScript标准<code>this</code>通过抽象操作（缩写为 <em>AO</em> ）定义ResolveThisBinding：</p>
<blockquote>
<p>[AO] ResolveThisBinding […] 使用正在运行的执行上下文<code>this</code>的
LexicalEnvironment确定关键字的绑定。[脚步]：</p>
<ol>
<li>令 <em>envRec</em> 为GetThisEnvironment ()。</li>
<li>返回 ？ <em>envRec.GetThisBinding</em> ()。
</li>
</ol>
</blockquote>
<p>Global Environment Records、模块 Environment Records和函数 Environment
Records每个都有自己的 GetThisBinding 方法。</p>
<p>GetThisEnvironment AO 找到当前运行的执行上下文的 LexicalEnvironment 并找到最近的具有 <em>this</em> 绑定（即
HasThisBinding 返回 <strong>true</strong> ）的上行环境记录（通过迭代访问它们的 [[OuterEnv]]
属性）。此过程以三种环境记录类型之一结束。 __ ****</p>
<p>的值<code>this</code>通常取决于代码是否处于严格模式。</p>
<p>GetThisBinding
的返回值反映了当前执行上下文的值<code>this</code>，因此无论何时建立新的执行上下文，<code>this</code>都会解析为不同的值。当当前执行上下文被修改时，也会发生这种情况。以下小节列出了可能发生这种情况的五种情况。</p>
<p>您可以将代码示例放在AST 资源管理器中，以跟随规范详细信息。</p>
<h4>1. 脚本中的全局执行上下文</h4>
<p>这是在顶层评估的脚本代码，例如直接在 a 中<code>&lt;script&gt;</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;script&gt;</span>
//<span class="w"> </span>Global<span class="w"> </span>context
console.log(this);<span class="w"> </span>//<span class="w"> </span>Logs<span class="w"> </span>global<span class="w"> </span>object.

setTimeout(function(){
<span class="w">  </span>console.log("Not<span class="w"> </span>global<span class="w"> </span>context");
});
<span class="nt">&lt;/script&gt;</span>
</pre></div>

<p>在脚本的初始全局执行上下文中，评估<code>this</code>会导致GetThisBinding采取以下步骤：</p>
<blockquote>
<p><em>全局环境记录envRec</em> […] [这样做]的 GetThisBinding 具体方法：</p>
<ol>
<li>返回 <em>envRec</em> .[[GlobalThisValue]]。
</li>
</ol>
</blockquote>
<p>全局环境记录的 [[GlobalThisValue]] 属性始终设置为主机定义的全局对象，可通过<code>globalThis</code>（<code>window</code>在 Web
上，<code>global</code>在 Node.js 上；文档在 MDN 上）访问。按照InitializeHostDefinedRealm的步骤了解
[[GlobalThisValue]] 属性是如何产生的。</p>
<h4>2.模块中的全局执行上下文</h4>
<p>ECMAScript 2015 中引入了模块。</p>
<p>这适用于模块，例如，当直接在一个 内部时<code>&lt;script type="module"&gt;</code>，而不是一个简单的<code>&lt;script&gt;</code>.</p>
<p>在模块的初始全局执行上下文中，评估<code>this</code>会导致GetThisBinding采取以下步骤：</p>
<blockquote>
<p>模块环境记录的 GetThisBinding 具体方法 [...] [这样做]：</p>
<ol>
<li>返回 <strong>未定义</strong> 。
</li>
</ol>
</blockquote>
<p>在模块中，的值<code>this</code>始终<code>undefined</code>在全局上下文中。模块隐含地处于严格模式。</p>
<h4>3.输入评估码</h4>
<p>调用有两种<code>eval</code>：直接调用和间接调用。这种区别自 ECMAScript 第 5 版以来就存在。</p>
<ul>
<li>直接<code>eval</code>呼叫通常看起来像<code>eval(</code>……<code>);</code>或<code>(eval)(</code>…… <code>);</code>（或<code>((eval))(</code>……<code>);</code>等）。1仅当调用表达式适合窄模式时才是 <em>直接的。</em> 2个</li>
<li>间接调用涉及以任何其他方式<code>eval</code>调用函数引用。<code>eval</code>它可能是<code>eval?.(</code>…… <code>)</code>、<code>(</code>…… <code>, eval)(</code>、…… 、 ……等。鉴于，它也将<code>)</code>是…… 、…… 。另外，给定，调用……也是间接的。<code>window.eval(``)``eval.call(``,``)``const aliasEval1 = eval; window.aliasEval2 = eval;``aliasEval1(``)``aliasEval2(``)``const originalEval = eval; window.eval = (x) =&gt; originalEval(x);``eval(``)</code>
</li>
</ul>
<p>请参阅chuckj 对 <em>“(1, eval)('this') vs eval('this') in JavaScript?”的回答。</em>
和德米特里·索什尼科夫 (Dmitry Soshnikov) 的 ECMA-262-5 的详细信息——第 2
章：严格模式（已存档），适用于您可能会使用间接<code>eval()</code>调用的情况。</p>
<p>PerformEval执行<code>eval</code>代码。它创建一个新的声明性环境记录作为其
LexicalEnvironment，这是GetThisEnvironment从中获取<code>this</code>值的地方。</p>
<p>然后，如果代码<code>this</code>中出现，则调用GetThisEnvironment<code>eval</code>找到的Environment
Record的GetThisBinding方法并返回其值。</p>
<p>而创建的声明式环境记录取决于<code>eval</code>调用是直接调用还是间接调用：</p>
<ul>
<li>在直接评估中，它将基于当前运行的执行上下文的 LexicalEnvironment。</li>
<li>在间接评估中，它将基于执行间接评估的领域记录的 [[GlobalEnv]] 属性（全局环境记录） 。</li>
</ul>
<p>意思是：</p>
<ul>
<li>在直接评估中，<code>this</code>值不会改变；它取自名为<code>eval</code>.</li>
<li>在间接求值中，<code>this</code>值是全局对象 ( <code>globalThis</code>)。</li>
</ul>
<p><em>怎么样<code>new Function</code>？</em> — <code>new
Function</code>类似于<code>eval</code>，但它不会立即调用代码；它创建了一个函数。this绑定不适用于此处的任何地方，除非函数被调用时正常工作，如下一小节所述
<em>。</em></p>
<h4>4、输入功能码</h4>
<p>输入函数代码发生在 <em>调用</em> 函数时。</p>
<p>调用函数有四种语法类别。</p>
<ul>
<li>针对这三个执行EvaluateCall AO ：3<ul>
<li>正常函数调用</li>
<li>可选的链接调用</li>
<li>标记模板</li>
</ul>
</li>
<li>并为此执行EvaluateNew ： 3<ul>
<li>构造函数调用</li>
</ul>
</li>
</ul>
<p>实际的函数调用发生在Call AO 处，它是用上下文确定的 <em>thisValue</em>
调用的；这个参数在一长串与调用相关的调用中传递。Call调用函数的[[Call]]内部槽。这会调用PrepareForOrdinaryCall
，其中会创建一个新的函数环境记录：</p>
<blockquote>
<p>函数 <em>环境记录</em> 是声明性环境记录，用于表示函数的顶级范围，如果函数不是 ArrowFunction <em>，</em> 则提供<code>this</code>绑定。如果函数不是
<em>ArrowFunction</em> 函数并引用<code>super</code>，则其函数 Environment Record
还包含用于<code>super</code>从函数内执行方法调用的状态。</p>
</blockquote>
<p>此外，在函数环境记录中还有 [[ThisValue]] 字段：</p>
<blockquote>
<p>这是<code>this</code>用于此函数调用的值。</p>
</blockquote>
<p>NewFunctionEnvironment调用还设置函数环境的 [[ThisBindingStatus]] 属性。</p>
<p>[[Call]]还调用OrdinaryCallBindThis，其中适当的 <em>thisArgument</em> 是根据以下条件确定的：</p>
<ul>
<li>原始参考，</li>
<li>功能的种类，以及</li>
<li>代码是否处于严格模式。</li>
</ul>
<p>一旦确定，对新创建的函数 Environment Record 的BindThisValue方法的最终调用实际上将 [[ThisValue]] 字段设置为
<em>thisArgument</em> 。</p>
<p>最后，这个字段是函数 Environment Record 的 GetThisBinding AO 从中获取值的地方<code>this</code>：</p>
<blockquote>
<p>函数 Environment Record <em>envRec</em> […] [do this] 的 GetThisBinding 具体方法：</p>
<p>[…]<br>
3. 返回 <em>envRec</em> .[[ThisValue]]。</p>
</blockquote>
<p>同样，如何准确地确定 <em>this</em> 值取决于许多因素；这只是一般概述。有了这个技术背景，让我们检查所有的具体例子。</p>
<h5>箭头函数</h5>
<p>评估箭头函数时，函数对象的 [[ThisMode]] 内部槽在OrdinaryFunctionCreate中设置为 <em>“词法”</em> 。</p>
<p>在OrdinaryCallBindThis中，它接受一个函数 <em>F</em> ：</p>
<blockquote>
<ol>
<li>设 <em>thisMode</em> 为 <em>F</em> .[[ThisMode]]。</li>
<li>如果 <em>thisMode</em> 是 <em>词法的</em> ，则返回 NormalCompletion( <code>undefined</code>)。[…]
</li>
</ol>
</blockquote>
<p><em>这仅意味着绑定此</em> 算法的其余部分将被跳过。箭头函数不绑定自己的 <em>this</em> 值。</p>
<p><code>this</code>那么，箭头函数里面有什么？回顾一下ResolveThisBinding和GetThisEnvironment，HasThisBinding
方法显式返回 <strong>false</strong> 。</p>
<blockquote>
<p>HasThisBinding 函数 Environment Record <em>envRec</em> […] [does this] 的具体方法：</p>
<ol>
<li>如果 <em>envRec</em> .[[ThisBindingStatus]] 是 <em>词法的</em> ，则返回 <strong>false</strong> ；否则，返回
<strong>true</strong> 。
</li>
</ol>
</blockquote>
<p>因此，而是迭代地查找外部环境。该过程将在具有 <em>this</em> 绑定的三个环境之一中结束。</p>
<p>这只是意味着， <strong>在箭头函数体中，<code>this</code>来自箭头函数的词法范围</strong>，或者换句话说（来自箭头函数 vs
函数声明/表达式：它们是等价的/可交换的吗？）：</p>
<blockquote>
<p>箭头函数没有自己的<code>this</code>[...] 绑定。相反，[此标识符] 像任何其他变量一样在词法范围内解析。这意味着在箭头函数内部， [指的是] 在箭头函数
<em>定义的</em> 环境中（即箭头函数“外部”）中的<code>this</code>[value of ]。<code>this</code> __</p>
</blockquote>
<h5>函数属性</h5>
<p>In normal functions (<code>function</code>, methods), <code>this</code> is determined <strong>by how the
function is called</strong>.</p>
<p>This is where these “syntax variants” come in handy.</p>
<p>Consider this object containing a function:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">refObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">func</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">      </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<p>Alternatively:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">refObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">func</span><span class="p">(){</span>
<span class="w">      </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<p>In any of the following function calls, the <code>this</code> value inside <code>func</code> will be
<code>refObj</code>.1</p>
<ul>
<li><code>refObj.func()</code></li>
<li><code>refObj["func"]()</code></li>
<li><code>refObj?.func()</code></li>
<li><code>refObj.func?.()</code></li>
<li>`refObj.func```</li>
</ul>
<p>If the called function is syntactically a property of a base object, then this
base will be the “reference” of the call, which, in usual cases, will be the
value of <code>this</code>. This is explained by the evaluation steps linked above; for
example, in <code>refObj.func()</code> (or <code>refObj["func"]()</code>), the
<em>CallMemberExpression</em> is the entire expression <code>refObj.func()</code>, which
consists of the <em>MemberExpression</em> <code>refObj.func</code> and the <em>Arguments</em> <code>()</code>.</p>
<p>But also, <code>refObj.func</code> and <code>refObj</code> play three roles, each:</p>
<ul>
<li>they’re both expressions,</li>
<li>they’re both references, and</li>
<li>they’re both values.</li>
</ul>
<p><code>refObj.func</code> as a <em>value</em> is the callable function object; the corresponding
<em>reference</em> is used to determine the <code>this</code> binding.</p>
<p>The optional chaining and tagged template examples work very similarly:
basically, the reference is everything before the <code>?.()</code>, before the <code>```, or
before the</code>()`.</p>
<p>EvaluateCall uses IsPropertyReference of that reference to determine if it is
a property of an object, syntactically. It’s trying to get the [[Base]]
property of the reference (which is e.g. <code>refObj</code>, when applied to
<code>refObj.func</code>; or <code>foo.bar</code> when applied to <code>foo.bar.baz</code>). If it is written
as a property, then GetThisValue will get this [[Base]] property and use it as
the <em>this</em> value.</p>
<p>Note: Getters / Setters work the same way as methods, regarding <code>this</code>. Simple
properties don’t affect the execution context, e.g. here, <code>this</code> is in global
scope:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="err">`</span><span class="n">globalThis</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="o">.</span>
<span class="w">    </span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">]:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Refers</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="err">`</span><span class="n">globalThis</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="o">.</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<h5>Calls without base reference, strict mode, and <code>with</code>
</h5>
<p>A call without a base reference is usually a function that isn’t called as a
property. For example:</p>
<div class="code"><pre class="code literal-block">func(); // As opposed to `refObj.func();`.
</pre></div>

<p>This also happens when passing or assigning methods, or using the comma
operator. This is where the difference between Reference Record and Value is
relevant.</p>
<p>Note function <code>j</code>: following the specification, you will notice that <code>j</code> can
only return the function object (Value) itself, but not a Reference Record.
Therefore the base reference <code>refObj</code> is lost.</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="k">const</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">;</span>

<span class="n">g</span><span class="p">(</span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">);</span>
<span class="n">h</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="n">j</span><span class="p">()();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">)();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Another</span><span class="w"> </span><span class="n">common</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
</pre></div>

<dl>
<dt>EvaluateCall calls Call with a <em>thisValue</em> of <strong>undefined</strong> here. This makes a</dt>
<dt>difference in OrdinaryCallBindThis ( <em>F</em> : the function object; <em>thisArgument</em>
</dt>
<dd>the <em>thisValue</em> passed to Call):</dd>
</dl>
<blockquote>
<ol>
<li>Let <em>thisMode</em> be <em>F</em>.[[ThisMode]].
</li>
</ol>
<p>[…]</p>
<ol>
<li>If <em>thisMode</em> is <em>strict</em> , let <em>thisValue</em> be <em>thisArgument</em>.</li>
<li>Else,<ol>
<li>If <em>thisArgument</em> is <strong>undefined</strong> or <strong>null</strong> , then</li>
<li>Let <em>globalEnv</em> be <em>calleeRealm</em>.[[GlobalEnv]].</li>
<li>[…]</li>
<li>Let <em>thisValue</em> be <em>globalEnv</em>.[[GlobalThisValue]].</li>
<li>Else,</li>
<li>Let <em>thisValue</em> be ! ToObject(thisArgument).</li>
<li>NOTE: ToObject produces wrapper objects […].
</li>
</ol>
</li>
</ol>
<p>[…]</p>
</blockquote>
<p>Note: step 5 sets the actual value of <code>this</code> to the supplied <em>thisArgument</em> in
strict mode — <code>undefined</code> in this case. In “sloppy mode”, an undefined or null
<em>thisArgument</em> results in <code>this</code> being the global <em>this</em> value.</p>
<p>If IsPropertyReference returns <strong>false</strong> , then EvaluateCall takes these
steps:</p>
<blockquote>
<ol>
<li>Let <em>refEnv</em> be <em>ref</em>.[[Base]].</li>
<li>Assert: <em>refEnv</em> is an Environment Record.</li>
<li>Let <em>thisValue</em> be <em>refEnv</em>.WithBaseObject().
</li>
</ol>
</blockquote>
<p>This is where an undefined <em>thisValue</em> may come from:
<em>refEnv</em>.WithBaseObject() is always <strong>undefined</strong> , <em>except</em> in <code>with</code>
statements. In this case, <em>thisValue</em> will be the binding object.</p>
<p>There’s also <code>Symbol.unscopables</code> (Docs on MDN) to control the <code>with</code> binding
behavior.</p>
<p>To summarize, so far:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f1</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="k">function</span><span class="w"> </span><span class="n">f2</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="k">function</span><span class="w"> </span><span class="n">f3</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">f1</span><span class="p">,</span>
<span class="w">    </span><span class="n">f2</span><span class="p">,</span>
<span class="w">    </span><span class="err">[</span><span class="n">Symbol</span><span class="p">.</span><span class="n">unscopables</span><span class="err">]</span><span class="o">:</span><span class="w"> </span><span class="err">{</span>
<span class="w">      </span><span class="n">f2</span><span class="o">:</span><span class="w"> </span><span class="no">true</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">  </span><span class="err">}</span><span class="p">;</span>

<span class="n">f1</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>

<span class="k">with</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="err">{</span>
<span class="w">  </span><span class="n">f1</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`o`</span><span class="p">.</span>
<span class="w">  </span><span class="n">f2</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`f2`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">unscopable</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>
<span class="w">  </span><span class="n">f3</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`f3`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n n-Quoted">`o`</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>
<span class="err">}</span>
</pre></div>

<p>and:</p>
<div class="code"><pre class="code literal-block"><span class="s2">"use strict"</span><span class="p">;</span>

<span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`undefined`</span><span class="p">.</span>

<span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`with`</span><span class="w"> </span><span class="n">statements</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">allowed</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">strict</span><span class="o">-</span><span class="k">mode</span><span class="w"> </span><span class="k">code</span><span class="p">.</span>
</pre></div>

<p>Note that when evaluating <code>this</code>, <strong>it doesn’t matter <em>where</em> a normal
function is defined</strong>.</p>
<h5>
<code>.call</code>, <code>.apply</code>, <code>.bind</code>, <em>thisArg</em> , and primitives</h5>
<p>Another consequence of step 5 of OrdinaryCallBindThis, in conjunction with
step 6.2 (6.b in the spec), is that a primitive <em>this</em> value is coerced to an
object <em>only</em> in “sloppy” mode.</p>
<p>To examine this, let’s introduce another source for the <em>this</em> value: the
three methods that override the <em>this</em> binding:4</p>
<ul>
<li><code>Function.prototype.apply(thisArg, argArray)</code></li>
<li>
<code>Function.prototype.</code> {<code>call</code>, <code>bind</code>} <code>(thisArg, ...args)</code>
</li>
</ul>
<p><code>.bind</code> creates a bound function, whose <em>this</em> binding is set to <em>thisArg</em> and
cannot change again. <code>.call</code> and <code>.apply</code> call the function immediately, with
the <em>this</em> binding set to <em>thisArg</em>.</p>
<p><code>.call</code> and <code>.apply</code> map directly to Call, using the specified <em>thisArg</em>.
<code>.bind</code> creates a bound function with BoundFunctionCreate. These have <em>their
own</em> [[Call]] method which looks up the function object’s [[BoundThis]]
internal slot.</p>
<p>Examples of setting a custom <em>this</em> value:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">myObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myObj</span><span class="p">),</span>
<span class="w">  </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">();</span>

<span class="o">//</span><span class="w"> </span><span class="k">All</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`myObj`</span><span class="p">.</span>
<span class="n">g</span><span class="p">();</span>
<span class="n">f</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myObj</span><span class="p">)();</span>
<span class="n">f</span><span class="p">.</span><span class="k">call</span><span class="p">(</span><span class="n">myObj</span><span class="p">);</span>
<span class="n">h</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</pre></div>

<p>For objects, this is the same in strict and non-strict mode.</p>
<p>Now, try to supply a primitive value:</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">(){</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"s"</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>

<span class="n">g</span><span class="p">();</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="nb nb-Type">String</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"s"</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
<span class="n">f</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="nb nb-Type">String</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"s"</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>In non-strict mode, primitives are coerced to their object-wrapped form. It’s
the same kind of object you get when calling <code>Object("s")</code> or <code>new
String("s")</code>. In strict mode, you <em>can</em> use primitives:</p>
<div class="code"><pre class="code literal-block"><span class="s2">"use strict"</span><span class="p">;</span>

<span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">(){</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"s"</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>

<span class="n">g</span><span class="p">();</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="s2">"s"</span><span class="err">`</span><span class="o">.</span>
<span class="n">f</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="s2">"s"</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>Libraries make use of these methods, e.g. jQuery sets the <code>this</code> to the DOM
element selected here:</p>
<div class="code"><pre class="code literal-block">$("button").click(function(){
  console.log(this); // Logs the clicked button.
});
</pre></div>

<h5>Constructors, classes, and <code>new</code>
</h5>
<p>When calling a function as a constructor using the <code>new</code> operator, EvaluateNew
calls Construct, which calls the [[Construct]] method. If the function is a
base constructor (i.e. not a <code>class extends</code>…<code>{</code>…<code>}</code>), it sets <em>thisArgument</em>
to a new object created from the constructor’s prototype. Properties set on
<code>this</code> in the constructor will end up on the resulting instance object. <code>this</code>
is implicitly returned, unless you explicitly return your own non-primitive
value.</p>
<p>A <code>class</code> is a new way of creating constructor functions, introduced in
ECMAScript 2015.</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">Old</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
<span class="w">  </span><span class="n">this</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Old</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">o</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">Old</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>

<span class="k">class</span><span class="w"> </span><span class="n">New</span><span class="p">{</span>
<span class="w">  </span><span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">New</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">New</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>Class definitions are implicitly in strict mode:</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">A</span><span class="err">{</span>
<span class="w">  </span><span class="n">m1</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="n">m2</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>

<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">m1</span><span class="p">());</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>

<span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">().</span><span class="n">m2</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`undefined`</span><span class="p">.</span>
</pre></div>

<h5><code>super</code></h5>
<p>The exception to the behavior with <code>new</code> is <code>class extends</code>…<code>{</code>…<code>}</code>, as
mentioned above. Derived classes do not immediately set their <em>this</em> value
upon invocation; they only do so once the base class is reached through a
series of <code>super</code> calls (happens implicitly without an own <code>constructor</code>).
Using <code>this</code> before calling <code>super</code> is not allowed.</p>
<p>Calling <code>super</code> calls the super constructor with the <em>this</em> value of the
lexical scope (the function Environment Record) of the call. GetThisValue has
a special rule for <code>super</code> calls. It uses BindThisValue to set <code>this</code> to that
Environment Record.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">DerivedNew</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">New</span><span class="p">{</span>
<span class="w">  </span><span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">){</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Using</span><span class="w"> </span><span class="err">`</span><span class="n">this</span><span class="err">`</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="err">`</span><span class="n">super</span><span class="err">`</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">ReferenceError</span><span class="o">.</span>
<span class="w">    </span><span class="n">super</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">DerivedNew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">DerivedNew</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<h4>5. Evaluating class fields</h4>
<p>Instance fields and static fields were introduced in ECMAScript 2022.</p>
<p>When a <code>class</code> is evaluated, ClassDefinitionEvaluation is performed, modifying
the running execution context. For each <em>ClassElement</em> :</p>
<ul>
<li>if a field is static, then <code>this</code> refers to the class itself,</li>
<li>if a field is not static, then <code>this</code> refers to the instance.</li>
</ul>
<p>Private fields (e.g. <code>#x</code>) and methods are added to a PrivateEnvironment.</p>
<p>Static blocks are currently a TC39 stage 3 proposal. Static blocks work the
same as static fields and methods: <code>this</code> inside them refers to the class
itself.</p>
<p>Note that in methods and getters / setters, <code>this</code> works just like in normal
function properties.</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">Demo</span><span class="err">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="n">static</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="n">static</span><span class="w"> </span><span class="n">d</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Getters</span><span class="p">,</span><span class="w"> </span><span class="k">set</span><span class="n">ters</span><span class="p">,</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">modifiers</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">possible</span><span class="p">.</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">;</span>

<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">demo</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">demo</span><span class="p">.</span><span class="n">b</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Both</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`demo`</span><span class="p">.</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">Demo</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">Demo</span><span class="p">.</span><span class="n">d</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Both</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`Demo`</span><span class="p">.</span>
</pre></div>

<hr>
<p>1: <code>(o.f)()</code> is equivalent to <code>o.f()</code>; <code>(f)()</code> is equivalent to <code>f()</code>. This is
explained in this 2ality article (archived). Particularly see how a
<em>ParenthesizedExpression</em> is evaluated.</p>
<p>2: It must be a <em>MemberExpression</em> , must not be a property, must have a
[[ReferencedName]] of exactly <strong>"eval"</strong> , and must be the %eval% intrinsic
object.</p>
<p>3: Whenever the specification says <em>“Let</em> ref <em>be the result of evaluating</em>
X.”, then <em>X</em> is some expression that you need to find the evaluation steps
for. For example, evaluating a <em>MemberExpression</em> or <em>CallExpression</em> is the
result of one of these algorithms. Some of them result in a Reference Record.</p>
<p>4: There are also several other native and host methods that allow providing a
<em>this</em> value, notably <code>Array.prototype.map</code>, <code>Array.prototype.forEach</code>, etc.
that accept a <em>thisArg</em> as their second argument. Anyone can make their own
methods to alter <code>this</code> like <code>(func, thisArg) =&gt; func.bind(thisArg)</code>, <code>(func,
thisArg) =&gt; func.call(thisArg)</code>, etc. As always, MDN offers great
documentation.</p>
<hr>
<h3>Just for fun, test your understanding with some examples</h3>
<p>For each code snippet, answer the question: <em>“What is the value of<code>this</code> at
the marked line? Why?”</em>.</p>
<p><em>To reveal the answers, click the gray boxes.</em></p>
<ol>
<li>if(true){
      console.log(this); // What is <code>this</code> here?
    }</li>
</ol>
<blockquote>
<p><code>globalThis</code>. The marked line is evaluated in the initial global execution
context.</p>
</blockquote>
<ol>
<li>
<p>const obj = {};</p>
<p>function myFun(){
  return { // What is <code>this</code> here?
    "is obj": this === obj,
    "is globalThis": this === globalThis
  };
}</p>
<p>obj.method = myFun;</p>
<p>console.log(obj.method());</p>
</li>
</ol>
<blockquote>
<p><code>obj</code>. When calling a function as a property of an object, it is called with
the <em>this</em> binding set to the <em>base</em> of the reference <code>obj.method</code>, i.e.
<code>obj</code>.</p>
</blockquote>
<ol>
<li>
<p>const obj = {
        myMethod: function(){
          return { // What is <code>this</code> here?
            "is obj": this === obj,
            "is globalThis": this === globalThis
          };
        }
      },
      myFun = obj.myMethod;</p>
<p>console.log(myFun());</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. Since the function value <code>myFun</code> / <code>obj.myMethod</code> is not
called off of an object, as a property, the <em>this</em> binding will be
<code>globalThis</code>. This is different from Python, in which accessing a method
(<code>obj.myMethod</code>) creates a bound method object.</p>
</blockquote>
<ol>
<li>
<p>const obj = {
        myFun: () =&gt; ({ // What is <code>this</code> here?
          "is obj": this === obj,
          "is globalThis": this === globalThis
        })
      };</p>
<p>console.log(obj.myFun());</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. Arrow functions don’t create their own <em>this</em> binding. The
lexical scope is the same as the initial global scope, so <code>this</code> is
<code>globalThis</code>.</p>
</blockquote>
<ol>
<li>
<p>function myFun(){
      console.log(this); // What is <code>this</code> here?
    }</p>
<p>const obj = {
    myMethod: function(){
      eval("myFun()");
    }
  };</p>
<p>obj.myMethod();</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. When evaluating the direct eval call, <code>this</code> is <code>obj</code>.
However, in the eval code, <code>myFun</code> is not called off of an object, so the
<em>this</em> binding is set to the global object.</p>
</blockquote>
<ol>
<li>
<p>function myFun() {
      // What is <code>this</code> here?
      return {
        "is obj": this === obj,
        "is globalThis": this === globalThis
      };
    }</p>
<p>const obj = {};</p>
<p>console.log(myFun.call(obj));</p>
</li>
</ol>
<blockquote>
<p><code>obj</code>. The line <code>myFun.call(obj);</code> is invoking the special built-in function
<code>Function.prototype.call</code>, which accepts <code>thisArg</code> as the first argument.</p>
</blockquote>
<ol>
<li>
<p>class MyCls{
      arrow = () =&gt; ({ // What is <code>this</code> here?
        "is MyCls": this === MyCls,
        "is globalThis": this === globalThis,
        "is instance": this instanceof MyCls
      });
    }</p>
<p>console.log(new MyCls().arrow());</p>
</li>
</ol>
<blockquote>
<p>It’s the instance of <code>MyCls</code>. Arrow functions don’t change the <em>this</em>
binding, so it comes from lexical scope. Therefore, this is <em>exactly the
same</em> as with the class fields mentioned above, like <code>a = this;</code>. Try
changing it to <code>static arrow</code>. Do you get the result you expect?</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p><code>this</code>与其他语言相比，关键字在 JavaScript 中的行为不同。在面向对象的语言中，<code>this</code>关键字指的是类的当前实例。在 JavaScript
中， 的值<code>this</code>由函数 ( ) 的调用上下文 <em><code>context.function()</code></em> 和调用位置决定。</p>
<p><strong>1. 在全局上下文中使用时</strong></p>
<p>当您<code>this</code>在全局上下文中使用时，它会绑定到全局对象（<code>window</code>在浏览器中）</p>
<div class="code"><pre class="code literal-block"><span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="w">  </span><span class="c1">//[object Window]</span>
</pre></div>

<p>当您<code>this</code>在全局上下文中定义的函数内部使用时，<code>this</code>仍然绑定到全局对象，因为该函数实际上是全局上下文的方法。</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="nf">f1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">f1</span><span class="p">());</span><span class="w">  </span><span class="o">//</span><span class="p">[</span><span class="n">object</span><span class="w"> </span><span class="n">Window</span><span class="p">]</span>
</pre></div>

<p>以上<code>f1</code>是全局对象的方法。因此我们也可以在对象上调用它，<code>window</code>如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="p">[</span><span class="n">object</span><span class="w"> </span><span class="n">Window</span><span class="p">]</span>
</pre></div>

<p><strong>2.在对象方法内部使用时</strong></p>
<p><code>this</code>当您在对象方法中使用关键字时，<code>this</code>将绑定到“立即”封闭对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">f</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w">  </span><span class="c1">//[object Object]:obj</span>
</pre></div>

<p>上面我把立即这个词用双引号引起来了。它的意思是，如果将对象嵌套在另一个对象中，则<code>this</code>绑定到直接父对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj1"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">nestedobj</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nl">name</span><span class="p">:</span><span class="s">"nestedobj"</span><span class="p">,</span>
<span class="w">        </span><span class="nl">f</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w">            </span>
<span class="p">}</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">nestedobj</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Object]:nestedobj</span>
</pre></div>

<p>即使你将函数作为方法显式地添加到对象中，它仍然遵循上述规则，即<code>this</code>仍然指向直接父对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj1"</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">function</span><span class="w"> </span><span class="n">returnName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">obj1</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">returnName</span><span class="p">;</span><span class="w"> </span><span class="c1">//add method to object</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Object]:obj1</span>
</pre></div>

<p><strong>3.调用context-less函数时</strong></p>
<p>当您使用<code>this</code>在没有任何上下文（即不在任何对象上）的情况下调用的内部函数时，它会绑定到全局对象（<code>window</code>在浏览器中）（即使函数是在对象内部定义的）。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"global"</span><span class="p">;</span>

<span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="nl">context</span><span class="p">:</span><span class="w"> </span><span class="s">"object"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">method</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">                  </span>
<span class="w">        </span><span class="n">function</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"function"</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">context</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">//invoked without context</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">method</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Window]:global</span>
</pre></div>

<p><strong>用函数尝试一切</strong></p>
<p>我们也可以用函数尝试以上几点。但是，存在一些差异。</p>
<ul>
<li>上面我们使用对象字面量表示法向对象添加了成员​​。我们可以使用 向函数添加成员<code>this</code>。指定它们。</li>
<li>对象字面量符号创建了一个我们可以立即使用的对象实例。对于函数，我们可能需要首先使用<code>new</code>运算符创建它的实例。</li>
<li>同样在对象字面量方法中，我们可以使用点运算符显式地将成员添加到已定义的对象中。这只会添加到特定实例。但是，我已将变量添加到函数原型中，以便它反映在函数的所有实例中。</li>
</ul>
<p>下面我尝试了我们对 Object 及以上所做的所有事情<code>this</code>，但是首先创建函数而不是直接编写对象。</p>
<div class="code"><pre class="code literal-block"><span class="cm">/********************************************************************* </span>
<span class="cm">  1. When you add variable to the function using this keyword, it </span>
<span class="cm">     gets added to the function prototype, thus allowing all function </span>
<span class="cm">     instances to have their own copy of the variables added.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">function</span><span class="w"> </span><span class="nf">functionDef</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"ObjDefinition"</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">getName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span><span class="w">                </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">functionDef</span><span class="p">();</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//[object Object]:ObjDefinition</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   2. Members explicitly added to the function protorype also behave </span>
<span class="cm">      as above: all function instances have their own copy of the </span>
<span class="cm">      variable added.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">getVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">"v"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="p">;</span><span class="w"> </span><span class="c1">//see how this.version refers to the</span>
<span class="w">                             </span><span class="c1">//version variable added through </span>
<span class="w">                             </span><span class="c1">//prototype</span>
<span class="p">}</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   3. Illustrating that the function variables added by both above </span>
<span class="cm">      ways have their own copies across function instances</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">incrementVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">var</span><span class="w"> </span><span class="n">obj2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">functionDef</span><span class="p">();</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="n">obj2</span><span class="p">.</span><span class="n">incrementVersion</span><span class="p">();</span><span class="w">      </span><span class="c1">//incrementing version in obj2</span>
<span class="w">                              </span><span class="c1">//does not affect obj1 version</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v2</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   4. `this` keyword refers to the immediate parent object. If you </span>
<span class="cm">       nest the object through function prototype, then `this` inside </span>
<span class="cm">       object refers to the nested object not the function instance</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">nestedObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="err">'</span><span class="n">nestedObj</span><span class="err">'</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                    </span><span class="nl">getName1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">                                        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">                                    </span><span class="p">}</span><span class="w">                            </span>
<span class="w">                                  </span><span class="p">};</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">nestedObj</span><span class="p">.</span><span class="n">getName1</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//[object Object]:nestedObj</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   5. If the method is on an object's prototype chain, `this` refers </span>
<span class="cm">      to the object the method was called on, as if the method was on </span>
<span class="cm">      the object.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">var</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fun</span><span class="o">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<span class="n">var</span><span class="w"> </span><span class="n">obj3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Object</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">ProtoObj</span><span class="p">);</span><span class="w"> </span><span class="c1">//creating an object setting ProtoObj</span>
<span class="w">                                    </span><span class="c1">//as its prototype</span>
<span class="n">obj3</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="p">;</span><span class="w">                       </span><span class="c1">//adding instance member to obj3</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj3</span><span class="p">.</span><span class="n">fun</span><span class="p">()</span><span class="o">+</span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="c1">//999</span>
<span class="w">                                    </span><span class="c1">//calling obj3.fun() makes </span>
<span class="w">                                    </span><span class="c1">//ProtoObj.fun() to access obj3.a as </span>
<span class="w">                                    </span><span class="c1">//if fun() is defined on obj3</span>
</pre></div>

<p><strong>4.在构造函数内部使用时</strong> 。</p>
<p>当函数用作构造函数时（即使用<code>new</code>关键字调用时），<code>this</code>函数体内指向正在构造的新对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">myname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"global context"</span><span class="p">;</span>
<span class="k">function</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">()</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">myname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"simple function"</span><span class="p">;</span>
<span class="err">}</span>

<span class="n">var</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="n">adds</span><span class="w"> </span><span class="n">myname</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">obj1</span>
<span class="o">//</span><span class="mf">1.</span><span class="w"> </span><span class="n n-Quoted">`new`</span><span class="w"> </span><span class="n">causes</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">()</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">point</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span>
<span class="o">//</span><span class="w">   </span><span class="n">object</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">constructed</span><span class="w"> </span><span class="n">thus</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="k">any</span><span class="w"> </span><span class="k">member</span>
<span class="o">//</span><span class="w">   </span><span class="n">created</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">SimipleFun</span><span class="p">()</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">membername</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span>
<span class="o">//</span><span class="w">   </span><span class="n">object</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">constructed</span>
<span class="o">//</span><span class="mf">2.</span><span class="w"> </span><span class="k">And</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n n-Quoted">`new`</span><span class="w"> </span><span class="n">makes</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">newly</span><span class="w"> </span>
<span class="o">//</span><span class="w">   </span><span class="n">constructed</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">specified</span>

<span class="n">document</span><span class="p">.</span><span class="k">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">myname</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="k">simple</span><span class="w"> </span><span class="k">function</span>
</pre></div>

<p><strong>5. 在原型链上定义的函数内部使用时</strong></p>
<p>如果该方法在对象的原型链上，<code>this</code>则在该方法内部引用调用该方法的对象，就好像该方法是在该对象上定义的一样。</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fun</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="o">//</span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">create</span><span class="p">()</span><span class="w"> </span><span class="n">creates</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">its</span>
<span class="o">//</span><span class="n">prototype</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">assigns</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">obj3</span><span class="p">,</span><span class="w"> </span><span class="n">thus</span><span class="w"> </span><span class="n">making</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span>
<span class="o">//</span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">prototype</span><span class="w"> </span><span class="n">chain</span>

<span class="k">var</span><span class="w"> </span><span class="n">obj3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ProtoObj</span><span class="p">);</span>
<span class="n">obj3</span><span class="o">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="p">;</span>
<span class="n">document</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj3</span><span class="o">.</span><span class="n">fun</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="mi">999</span>

<span class="o">//</span><span class="n">Notice</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">obj3</span><span class="s1">'s prototype but </span>
<span class="o">//</span><span class="err">`</span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span><span class="n">retrieves</span><span class="w"> </span><span class="n">obj3</span><span class="o">.</span><span class="n">a</span>
</pre></div>

<p><strong>6. call()、apply() 和 bind() 函数内部</strong></p>
<ul>
<li>所有这些方法都定义在<code>Function.prototype</code>.</li>
<li>这些方法允许编写一次函数并在不同的上下文中调用它。换句话说，它们允许指定<code>this</code>在执行函数时将使用的值。它们还会在调用原始函数时采用任何参数传递给原始函数。</li>
<li>
<strong><code>fun.apply(obj1 [, argsArray])</code></strong> 设置为inside<code>obj1</code>的值并调用传递的元素作为其参数。<code>this``fun()``fun()``argsArray</code>
</li>
<li>
<strong><code>fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])</code></strong> - 设置为内部<code>obj1</code>的值并调用作为其参数传递。<code>this``fun()``fun()``arg1, arg2, arg3, ...</code>
</li>
<li>
<strong><code>fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])</code></strong><code>fun</code>- 返回对具有<code>this</code>内部 fun 绑定<code>obj1</code>和参数<code>fun</code>绑定到指定参数的函数的引用<code>arg1, arg2, arg3,...</code>。</li>
<li>
<p><code>apply</code>到现在，<code>call</code>和之间的区别<code>bind</code>一定已经很明显了。<code>apply</code>允许将参数指定为类似数组的对象，即具有数字<code>length</code>属性和相应的非负整数属性的对象。而<code>call</code>允许直接指定函数的参数。和<code>apply</code>都<code>call</code>在指定的上下文中使用指定的参数立即调用函数。另一方面，简单地返回绑定到指定值和参数的<code>bind</code>函数。<code>this</code>我们可以通过将它分配给一个变量来捕获对该返回函数的引用，然后我们可以随时调用它。</p>
<p>function add(inc1, inc2)
{
    return this.a + inc1 + inc2;
}</p>
<p>var o = { a : 4 };
document.write(add.call(o, 5, 6)+"<br>"); //15
      //above add.call(o,5,6) sets <code>this</code> inside
      //add() to <code>o</code> and calls add() resulting:
      // this.a + inc1 + inc2 = 
      // <code>o.a</code> i.e. 4 + 5 + 6 = 15
document.write(add.apply(o, [5, 6]) + "<br>"); //15
      // <code>o.a</code> i.e. 4 + 5 + 6 = 15</p>
<p>var g = add.bind(o, 5, 6);       //g: <code>o.a</code> i.e. 4 + 5 + 6
document.write(g()+"<br>");    //15</p>
<p>var h = add.bind(o, 5);          //h: <code>o.a</code> i.e. 4 + 5 + ?
document.write(h(6) + "<br>"); //15
      // 4 + 5 + 6 = 15
document.write(h() + "<br>");  //NaN
      //no parameter is passed to h()
      //thus inc2 inside add() is <code>undefined</code>
      //4 + 5 + undefined = NaN</p>
</li>
</ul>
<p><strong>7.<code>this</code>内部事件处理程序</strong></p>
<ul>
<li>When you assign function directly to event handlers of an element, use of <code>this</code> directly inside event handling function refers to the corresponding element. Such direct function assignment can be done using <code>addeventListener</code> method or through the traditional event registration methods like <code>onclick</code>.</li>
<li>Similarly, when you use <code>this</code> directly inside the event property (like <code>&lt;button onclick="...this..." &gt;</code>) of the element, it refers to the element.</li>
<li>However use of <code>this</code> indirectly through the other function called inside the event handling function or event property resolves to the global object <code>window</code>.</li>
<li>The same above behavior is achieved when we attach the function to the event handler using Microsoft's Event Registration model method <code>attachEvent</code>. Instead of assigning the function to the event handler (and the thus making the function method of the element), it calls the function on the event (effectively calling it in global context).</li>
</ul>
<p><em>I recommend to better try this in JSFiddle.</em></p>
<div class="code"><pre class="code literal-block"><span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span><span class="w"> </span>
<span class="w">    </span><span class="k">function</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">       </span><span class="n">alert</span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" : "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">tagName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" : "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span><span class="w"> </span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button1"</span><span class="p">).</span><span class="n">addEventListener</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">,</span><span class="w"> </span><span class="no">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button2"</span><span class="p">).</span><span class="n">onclick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">;</span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button5"</span><span class="p">).</span><span class="n">attachEvent</span><span class="p">(</span><span class="s1">'onclick'</span><span class="p">,</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">);</span><span class="w">   </span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="k">Using</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="s2">"directly"</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="k">handler</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button1"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"assigned"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">addEventListner</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button2"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"assigned"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button3"</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"alert(this+ ' : ' + this.tagName + ' : ' + this.id);"</span><span class="o">&gt;</span><span class="n">used</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">click</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="k">Using</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="s2">"indirectly"</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="k">handler</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"alert((function(){return this + ' : ' + this.tagName + ' : ' + this.id;})());"</span><span class="o">&gt;</span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">indirectly</span><span class="p">,</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>

<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button4"</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"clickedMe()"</span><span class="o">&gt;</span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">indirectly</span><span class="p">,</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>

<span class="n">IE</span><span class="w"> </span><span class="k">only</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button5"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"attached"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">attachEvent</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
</pre></div>

<p><strong>8.<code>this</code> in ES6 arrow function</strong></p>
<p>In an arrow function, <code>this</code> will behave like common variables: it will be
inherited from its lexical scope. The function's <code>this</code>, where the arrow
function is defined, will be the arrow function's <code>this</code>.</p>
<p>So, that's the same behavior as:</p>
<div class="code"><pre class="code literal-block">(function(){}).bind(this)
</pre></div>

<p>See the following code:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">globalArrowFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">globalArrowFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="k">const</span><span class="w"> </span><span class="n">contextObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">method1</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">},</span>
<span class="w">  </span><span class="n">method2</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextObject</span><span class="o">.</span><span class="n">method1</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="k">const</span><span class="w"> </span><span class="n">contextLessFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contextObject</span><span class="o">.</span><span class="n">method1</span><span class="p">;</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextLessFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextObject</span><span class="o">.</span><span class="n">method2</span><span class="p">()())</span><span class="w"> </span><span class="o">//</span><span class="n">contextObject</span>

<span class="k">const</span><span class="w"> </span><span class="n">innerArrowFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contextObject</span><span class="o">.</span><span class="n">method2</span><span class="p">();</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">innerArrowFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">contextObject</span>
</pre></div>

<p><br><br><a href="../how-does-the-this-keyword-work-and-when-should-it-be-used/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
            <li><a class="tag p-category" href="../../categories/this/" rel="tag">this</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-zai-bu-chuang-jian-xin-mi-yao-de-qing-kuang-xia-shan-chu-ssh-mi-yao-de-mi-ma/" rel="prev" title="如何在不创建新密钥的情况下删除 SSH 密钥的密码？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-zai-typescript-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-shu-zi/" rel="next" title="如何在 TypeScript 中将字符串转换为数字？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
