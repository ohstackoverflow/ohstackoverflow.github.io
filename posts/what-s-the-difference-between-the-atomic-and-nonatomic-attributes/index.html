<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What's the difference between the atomic and nonatomic attributes? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-s-the-difference-between-the-atomic-and-nonatomic-attributes/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-detect-a-mobile-device-using-jquery/" title="How to detect a mobile device using jQuery" type="text/html">
<link rel="next" href="../get-the-last-item-in-an-array/" title="Get the last item in an array" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What's the difference between the atomic and nonatomic attributes?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-s-the-difference-between-the-atomic-and-nonatomic-attributes/">
<meta property="og:description" content="What do atomic and nonatomic mean in property declarations?
@property(nonatomic, retain) UITextField *userName;
@property(atomic, retain) UITextField *userName;
@property(retain) UITextField *userName">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T23:30:58+08:00">
<meta property="article:tag" content="atomic">
<meta property="article:tag" content="ios">
<meta property="article:tag" content="nonatomic">
<meta property="article:tag" content="objective-c">
<meta property="article:tag" content="properties">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What's the difference between the atomic and nonatomic attributes?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:30:58+08:00" itemprop="datePublished" title="2023-02-16 23:30">2023-02-16 23:30</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What do <code>atomic</code> and <code>nonatomic</code> mean in property declarations?</p>
<div class="code"><pre class="code literal-block"><span class="nv">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="w"> </span><span class="n">retain</span><span class="p">)</span><span class="w"> </span><span class="n">UITextField</span><span class="w"> </span><span class="o">*</span><span class="n">userName</span><span class="p">;</span>
<span class="nv">@property</span><span class="p">(</span><span class="k">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">retain</span><span class="p">)</span><span class="w"> </span><span class="n">UITextField</span><span class="w"> </span><span class="o">*</span><span class="n">userName</span><span class="p">;</span>
<span class="nv">@property</span><span class="p">(</span><span class="n">retain</span><span class="p">)</span><span class="w"> </span><span class="n">UITextField</span><span class="w"> </span><span class="o">*</span><span class="n">userName</span><span class="p">;</span>
</pre></div>

<p>What is the operational difference between these three?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The last two are identical; "atomic" is the default behavior ( <del>note that it
is not actually a keyword; it is specified only by the absence of<code>nonatomic</code></del>
-- <code>atomic</code> was added as a keyword in recent versions of llvm/clang).</p>
<p>Assuming that you are @synthesizing the method implementations, atomic vs.
non-atomic changes the generated code. If you are writing your own
setter/getters, atomic/nonatomic/retain/assign/copy are merely advisory.
(Note: @synthesize is now the default behavior in recent versions of LLVM.
There is also no need to declare instance variables; they will be synthesized
automatically, too, and will have an <code>_</code> prepended to their name to prevent
accidental direct access).</p>
<p>With "atomic", the synthesized setter/getter will ensure that a <em>whole</em> value
is always returned from the getter or set by the setter, regardless of setter
activity on any other thread. That is, if thread A is in the middle of the
getter while thread B calls the setter, an actual viable value -- an
autoreleased object, most likely -- will be returned to the caller in A.</p>
<p>In <code>nonatomic</code>, no such guarantees are made. Thus, <code>nonatomic</code> is considerably
faster than "atomic".</p>
<p>What "atomic" does <strong>not</strong> do is make any guarantees about thread safety. If
thread A is calling the getter simultaneously with thread B and C calling the
setter with different values, thread A may get any one of the three values
returned -- the one prior to any setters being called or either of the values
passed into the setters in B and C. Likewise, the object may end up with the
value from B or C, no way to tell.</p>
<p>Ensuring data integrity -- one of the primary challenges of multi-threaded
programming -- is achieved by other means.</p>
<p>Adding to this:</p>
<p><code>atomicity</code> of a single property also cannot guarantee thread safety when
multiple dependent properties are in play.</p>
<p>Consider:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="nv">@property</span><span class="p">(</span><span class="k">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">copy</span><span class="p">)</span><span class="w"> </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
<span class="w"> </span><span class="nv">@property</span><span class="p">(</span><span class="k">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">copy</span><span class="p">)</span><span class="w"> </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
<span class="w"> </span><span class="nv">@property</span><span class="p">(</span><span class="n">readonly</span><span class="p">,</span><span class="w"> </span><span class="k">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">copy</span><span class="p">)</span><span class="w"> </span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">fullName</span><span class="p">;</span>
</pre></div>

<p>In this case, thread A could be renaming the object by calling <code>setFirstName:</code>
and then calling <code>setLastName:</code>. In the meantime, thread B may call <code>fullName</code>
in between thread A's two calls and will receive the new first name coupled
with the old last name.</p>
<p>To address this, you need a <em>transactional model</em>. I.e. some other kind of
synchronization and/or exclusion that allows one to exclude access to
<code>fullName</code> while the dependent properties are being updated.</p>
<p><br></p>
<h3>Suggest</h3>
<p>This is explained in Apple's documentation, but below are some examples of
what is actually happening.</p>
<p><del>Note that there is no "atomic" keyword, if you do not specify "nonatomic",
then the property is atomic, but specifying "atomic" explicitly will result in
an error.</del></p>
<p>If you do not specify "nonatomic", then the property is atomic, but you can
still specify "atomic" explicitly in recent versions if you want to.</p>
<div class="code"><pre class="code literal-block"><span class="c1">//@property(nonatomic, retain) UITextField *userName;</span>
<span class="c1">//Generates roughly</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">UITextField</span><span class="w"> </span><span class="o">*</span><span class="p">)</span> <span class="nf">userName</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">userName</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setUserName:</span><span class="p">(</span><span class="bp">UITextField</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">userName_</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="n">userName_</span><span class="w"> </span><span class="k">retain</span><span class="p">];</span>
<span class="w">    </span><span class="p">[</span><span class="n">userName</span><span class="w"> </span><span class="k">release</span><span class="p">];</span>
<span class="w">    </span><span class="n">userName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">userName_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Now, the atomic variant is a bit more complicated:</p>
<div class="code"><pre class="code literal-block"><span class="c1">//@property(retain) UITextField *userName;</span>
<span class="c1">//Generates roughly</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">UITextField</span><span class="w"> </span><span class="o">*</span><span class="p">)</span> <span class="nf">userName</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="bp">UITextField</span><span class="w"> </span><span class="o">*</span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">nil</span><span class="p">;</span>
<span class="w">    </span><span class="k">@synchronized</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="n">userName</span><span class="w"> </span><span class="k">retain</span><span class="p">]</span><span class="w"> </span><span class="n">autorelease</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setUserName:</span><span class="p">(</span><span class="bp">UITextField</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nv">userName_</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">@synchronized</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">[</span><span class="n">userName_</span><span class="w"> </span><span class="k">retain</span><span class="p">];</span>
<span class="w">      </span><span class="p">[</span><span class="n">userName</span><span class="w"> </span><span class="k">release</span><span class="p">];</span>
<span class="w">      </span><span class="n">userName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">userName_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Basically, the atomic version has to take a lock in order to guarantee thread
safety, and also is bumping the ref count on the object (and the autorelease
count to balance it) so that the object is guaranteed to exist for the caller,
otherwise there is a potential race condition if another thread is setting the
value, causing the ref count to drop to 0.</p>
<p>There are actually a large number of different variants of how these things
work depending on whether the properties are scalar values or objects, and how
retain, copy, readonly, nonatomic, etc interact. In general the property
synthesizers just know how to do the "right thing" for all combinations.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/atomic/" rel="tag">atomic</a></li>
            <li><a class="tag p-category" href="../../categories/ios/" rel="tag">ios</a></li>
            <li><a class="tag p-category" href="../../categories/nonatomic/" rel="tag">nonatomic</a></li>
            <li><a class="tag p-category" href="../../categories/objective-c/" rel="tag">objective-c</a></li>
            <li><a class="tag p-category" href="../../categories/properties/" rel="tag">properties</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-detect-a-mobile-device-using-jquery/" rel="prev" title="How to detect a mobile device using jQuery">Previous post</a>
            </li>
            <li class="next">
                <a href="../get-the-last-item-in-an-array/" rel="next" title="Get the last item in an array">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
