<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How do I remove duplicates from a list, while preserving order? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-do-i-remove-duplicates-from-a-list-while-preserving-order/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-do-i-check-the-versions-of-python-modules/" title="How do I check the versions of Python modules?" type="text/html">
<link rel="next" href="../how-do-i-use-optional-parameters-in-java/" title="How do I use optional parameters in Java?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How do I remove duplicates from a list, while preserving order?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-do-i-remove-duplicates-from-a-list-while-preserving-order/">
<meta property="og:description" content="How do I remove duplicates from a list, while preserving order? Using a set to
remove duplicates destroys the original order. Is there a built-in or a
Pythonic idiom?

Answer
Here you have some altern">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T08:07:35+08:00">
<meta property="article:tag" content="duplicates">
<meta property="article:tag" content="list">
<meta property="article:tag" content="list-comprehension">
<meta property="article:tag" content="python">
<meta property="article:tag" content="unique">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How do I remove duplicates from a list, while preserving order?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:07:35+08:00" itemprop="datePublished" title="2023-02-17 08:07">2023-02-17 08:07</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>How do I remove duplicates from a list, while preserving order? Using a set to
remove duplicates destroys the original order. Is there a built-in or a
Pythonic idiom?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Here you have some alternatives: http://www.peterbe.com/plog/uniqifiers-
benchmark</p>
<p>Fastest one:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">f7</span><span class="ss">(</span><span class="nv">seq</span><span class="ss">)</span>:
<span class="w">    </span><span class="nv">seen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">set</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">seen_add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">seen</span>.<span class="nv">add</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>[<span class="nv">x</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">seq</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="ss">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">seen</span><span class="w"> </span><span class="nv">or</span><span class="w"> </span><span class="nv">seen_add</span><span class="ss">(</span><span class="nv">x</span><span class="ss">))</span>]
</pre></div>

<p>Why assign <code>seen.add</code> to <code>seen_add</code> instead of just calling <code>seen.add</code>? Python
is a dynamic language, and resolving <code>seen.add</code> each iteration is more costly
than resolving a local variable. <code>seen.add</code> could have changed between
iterations, and the runtime isn't smart enough to rule that out. To play it
safe, it has to check the object each time.</p>
<p>If you plan on using this function a lot on the same dataset, perhaps you
would be better off with an ordered set:
http://code.activestate.com/recipes/528878/</p>
<p><em>O</em> (1) insertion, deletion and member-check per operation.</p>
<p>(Small additional note: <code>seen.add()</code> always returns <code>None</code>, so the <em><code>or</code></em>
above is there only as a way to attempt a set update, and not as an integral
part of the logical test.)</p>
<p><br></p>
<h3>Suggest</h3>
<p>The best solution varies by Python version and environment constraints:</p>
<h5>Python 3.7+ (and most interpreters supporting 3.6, as an implementation</h5>
<p>detail):</p>
<p>First introduced in PyPy 2.5.0, and adopted in CPython 3.6 as an
implementation detail, before being made a language guarantee in Python 3.7,
plain <code>dict</code> is insertion-ordered, and even more efficient than the (also C
implemented as of CPython 3.5) <code>collections.OrderedDict</code>. So the fastest
solution, by far, is also the simplest:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">0</span>,<span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">2</span>]
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">list</span><span class="ss">(</span><span class="nv">dict</span>.<span class="nv">fromkeys</span><span class="ss">(</span><span class="nv">items</span><span class="ss">))</span><span class="w">  </span>#<span class="w"> </span><span class="nv">Or</span><span class="w"> </span>[<span class="o">*</span><span class="nv">dict</span>.<span class="nv">fromkeys</span><span class="ss">(</span><span class="nv">items</span><span class="ss">)</span>]<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">prefer</span>
[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">0</span>,<span class="w"> </span><span class="mi">3</span>]
</pre></div>

<p>Like <code>list(set(items))</code> this pushes all the work to the C layer (on CPython),
but since <code>dict</code>s are insertion ordered, <code>dict.fromkeys</code> doesn't lose
ordering. It's slower than <code>list(set(items))</code> (takes 50-100% longer
typically), but <em>much</em> faster than any other order-preserving solution (takes
about half the time of hacks involving use of <code>set</code>s in a listcomp).</p>
<p><strong>Important note</strong> : The <code>unique_everseen</code> solution from <code>more_itertools</code> (see
below) has some unique advantages in terms of laziness and support for non-
hashable input items; if you need these features, it's the <em>only</em> solution
that will work.</p>
<h5>Python 3.5 (and all older versions if performance isn't <em>critical</em> )</h5>
<p>As Raymond pointed out, in CPython 3.5 where <code>OrderedDict</code> is implemented in
C, ugly list comprehension hacks are slower than <code>OrderedDict.fromkeys</code>
(unless you actually need the list at the end - and even then, only if the
input is very short). So on both performance and readability the best solution
for CPython 3.5 is the <code>OrderedDict</code> equivalent of the 3.6+ use of plain
<code>dict</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>

<p>On CPython 3.4 and earlier, this will be slower than some other solutions, so
if profiling shows you need a better solution, keep reading.</p>
<h5>Python 3.4 and earlier, if performance is critical and third-party</h5>
<p>modules are acceptable</p>
<p>As @abarnert notes, the <code>more_itertools</code> library (<code>pip install
more_itertools</code>) contains a <code>unique_everseen</code> function that is built to solve
this problem without any <strong>unreadable</strong> (<code>not seen.add</code>) <strong>mutations</strong> in list
comprehensions. This is the fastest solution too:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">more_itertools</span> <span class="kn">import</span> <span class="n">unique_everseen</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_everseen</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>

<p>Just one simple library import and no hacks.</p>
<p>The module is adapting the itertools recipe <code>unique_everseen</code> which looks
like:</p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">unique_everseen</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="o">=</span><span class="n">None</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="s">"List unique elements, preserving order. Remember all elements ever seen."</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">unique_everseen</span><span class="p">(</span><span class="s">'AAAABBBCCDAABBB'</span><span class="p">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">D</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">unique_everseen</span><span class="p">(</span><span class="s">'ABBCcAD'</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">lower</span><span class="p">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">D</span>
<span class="w">    </span><span class="n">seen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">set</span><span class="p">()</span>
<span class="w">    </span><span class="n">seen_add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seen</span><span class="p">.</span><span class="n">add</span>
<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">None</span><span class="o">:</span>
<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">filterfalse</span><span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">__contains__</span><span class="p">,</span><span class="w"> </span><span class="n">iterable</span><span class="p">)</span><span class="o">:</span>
<span class="w">            </span><span class="n">seen_add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="w">            </span><span class="n">yield</span><span class="w"> </span><span class="n">element</span>
<span class="w">    </span><span class="n">else</span><span class="o">:</span>
<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">iterable</span><span class="o">:</span>
<span class="w">            </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="w">            </span><span class="nf">if</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="kr">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">seen</span><span class="o">:</span>
<span class="w">                </span><span class="n">seen_add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="w">                </span><span class="n">yield</span><span class="w"> </span><span class="n">element</span>
</pre></div>

<p>but unlike the <code>itertools</code> recipe, it supports non-hashable items (at a
performance cost; if all elements in <code>iterable</code> are non-hashable, the
algorithm becomes <code>O(n²)</code>, vs. <code>O(n)</code> if they're all hashable).</p>
<p><strong>Important note</strong> : Unlike all the other solutions here, <code>unique_everseen</code>
can be used lazily; the peak memory usage will be the same (eventually, the
underlying <code>set</code> grows to the same size), but if you don't <code>list</code>ify the
result, you just iterate it, you'll be able to process unique items as they're
found, rather than waiting until the entire input has been deduplicated before
processing the first unique item.</p>
<h5>Python 3.4 and earlier, if performance is critical <em>and</em> third party</h5>
<p>modules are unavailable</p>
<p>You have two options:</p>
<ol>
<li>
<p>Copy and paste in the <code>unique_everseen</code> recipe to your code and use it per the <code>more_itertools</code> example above</p>
</li>
<li>
<p>Use ugly hacks to allow a single listcomp to both check and update a <code>set</code> to track what's been seen:</p>
<div class="code"><pre class="code literal-block">seen = set()
</pre></div>

<p>[x for x in seq if x not in seen and not seen.add(x)]</p>
</li>
</ol>
<p>at the expense of relying on the <strong>ugly hack</strong> :</p>
<div class="code"><pre class="code literal-block">     not seen.add(x)
</pre></div>

<p>which relies on the fact that <code>set.add</code> is an in-place method that always
returns <code>None</code> so <code>not None</code> evaluates to <code>True</code>.</p>
<p>Note that <em>all</em> of the solutions above are <code>O(n)</code> (save calling
<code>unique_everseen</code> on an iterable of non-hashable items, which is <code>O(n²)</code>,
while the others would fail immediately with a <code>TypeError</code>), so all solutions
are performant enough when they're not the hottest code path. Which one to use
depends on which versions of the language spec/interpreter/third-party modules
you can rely on, whether or not performance is critical (don't assume it is;
it usually isn't), and most importantly, readability (because if the person
who maintains this code later ends up in a murderous mood, your clever micro-
optimization probably wasn't worth it).</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/duplicates/" rel="tag">duplicates</a></li>
            <li><a class="tag p-category" href="../../categories/list/" rel="tag">list</a></li>
            <li><a class="tag p-category" href="../../categories/list-comprehension/" rel="tag">list-comprehension</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/unique/" rel="tag">unique</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-do-i-check-the-versions-of-python-modules/" rel="prev" title="How do I check the versions of Python modules?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-use-optional-parameters-in-java/" rel="next" title="How do I use optional parameters in Java?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
