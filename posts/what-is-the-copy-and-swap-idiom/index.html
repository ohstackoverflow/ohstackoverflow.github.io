<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What is the copy-and-swap idiom? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-is-the-copy-and-swap-idiom/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../postgresql-show-tables-in-postgresql/" title="PostgreSQL: Show tables in PostgreSQL" type="text/html">
<link rel="next" href="../how-do-i-check-if-an-object-has-an-attribute/" title="How do I check if an object has an attribute?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What is the copy-and-swap idiom?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-is-the-copy-and-swap-idiom/">
<meta property="og:description" content="What is the copy-and-swap idiom and when should it be used? What problems does
it solve? Does it change for C++11?
Related:

What are your favorite C++ Coding Style idioms: Copy-swap
Copy constructor ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T21:49:08+08:00">
<meta property="article:tag" content="assignment-operator">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="c++-faq">
<meta property="article:tag" content="copy-and-swap">
<meta property="article:tag" content="copy-constructor">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What is the copy-and-swap idiom?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T21:49:08+08:00" itemprop="datePublished" title="2023-02-16 21:49">2023-02-16 21:49</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What is the copy-and-swap idiom and when should it be used? What problems does
it solve? Does it change for C++11?</p>
<p>Related:</p>
<ul>
<li>What are your favorite C++ Coding Style idioms: Copy-swap</li>
<li>Copy constructor and = operator overload in C++: is a common function possible?</li>
<li>What is copy elision and how it optimizes copy-and-swap idiom</li>
<li>C++: dynamically allocating an array of objects?</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<h2>Overview</h2>
<h4>Why do we need the copy-and-swap idiom?</h4>
<p>Any class that manages a resource (a <em>wrapper</em> , like a smart pointer) needs
to implement The Big Three. While the goals and implementation of the copy-
constructor and destructor are straightforward, the copy-assignment operator
is arguably the most nuanced and difficult. How should it be done? What
pitfalls need to be avoided?</p>
<p>The <em>copy-and-swap idiom</em> is the solution, and elegantly assists the
assignment operator in achieving two things: avoiding code duplication, and
providing a strong exception guarantee.</p>
<h4>How does it work?</h4>
<p>Conceptually, it works by using the copy-constructor's functionality to create
a local copy of the data, then takes the copied data with a <code>swap</code> function,
swapping the old data with the new data. The temporary copy then destructs,
taking the old data with it. We are left with a copy of the new data.</p>
<p>In order to use the copy-and-swap idiom, we need three things: a working copy-
constructor, a working destructor (both are the basis of any wrapper, so
should be complete anyway), and a <code>swap</code> function.</p>
<p>A swap function is a <em>non-throwing</em> function that swaps two objects of a
class, member for member. We might be tempted to use <code>std::swap</code> instead of
providing our own, but this would be impossible; <code>std::swap</code> uses the copy-
constructor and copy-assignment operator within its implementation, and we'd
ultimately be trying to define the assignment operator in terms of itself!</p>
<p>(Not only that, but unqualified calls to <code>swap</code> will use our custom swap
operator, skipping over the unnecessary construction and destruction of our
class that <code>std::swap</code> would entail.)</p>
<hr>
<h2>An in-depth explanation</h2>
<h4>The goal</h4>
<p>Let's consider a concrete case. We want to manage, in an otherwise useless
class, a dynamic array. We start with a working constructor, copy-constructor,
and destructor:</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">algorithm</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">cstddef</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span>

<span class="k">class</span><span class="w"> </span><span class="n">dumb_array</span>
<span class="err">{</span>
<span class="k">public</span><span class="err">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="p">)</span><span class="w"> </span><span class="k">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="err">:</span><span class="w"> </span><span class="n">mSize</span><span class="p">(</span><span class="k">size</span><span class="p">),</span>
<span class="w">          </span><span class="n">mArray</span><span class="p">(</span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="p">()</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="o">-</span><span class="k">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="err">:</span><span class="w"> </span><span class="n">mSize</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mSize</span><span class="p">),</span>
<span class="w">          </span><span class="n">mArray</span><span class="p">(</span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">throwing</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">data</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">used</span><span class="p">;</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">attention</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">regards</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">exceptions</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="k">general</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">however</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mSize</span><span class="p">,</span><span class="w"> </span><span class="n">mArray</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">dumb_array</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span><span class="w"> </span><span class="n">mSize</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="o">*</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span>
</pre></div>

<p>This class almost manages the array successfully, but it needs <code>operator=</code> to
work correctly.</p>
<h4>A failed solution</h4>
<p>Here's how a naive implementation might look:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">hard</span><span class="w"> </span><span class="n">part</span>
<span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="k">get</span><span class="w"> </span><span class="n">rid</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">old</span><span class="w"> </span><span class="k">data</span><span class="p">...</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="n">mArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">see</span><span class="w"> </span><span class="n">footnote</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">rationale</span><span class="p">)</span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="p">...</span><span class="ow">and</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">new</span>
<span class="w">        </span><span class="n">mSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mSize</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="n">mArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mSize</span><span class="p">,</span><span class="w"> </span><span class="n">mArray</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>And we say we're finished; this now manages an array, without leaks. However,
it suffers from three problems, marked sequentially in the code as <code>(n)</code>.</p>
<ol>
<li>
<p>The first is the self-assignment test.<br>
This check serves two purposes: it's an easy way to prevent us from running
needless code on self-assignment, and it protects us from subtle bugs (such as
deleting the array only to try and copy it). But in all other cases it merely
serves to slow the program down, and act as noise in the code; self-assignment
rarely occurs, so most of the time this check is a waste.<br>
It would be better if the operator could work properly without it.</p>
</li>
<li>
<p>The second is that it only provides a basic exception guarantee. If <code>new int[mSize]</code> fails, <code>*this</code> will have been modified. (Namely, the size is wrong and the data is gone!)<br>
For a strong exception guarantee, it would need to be something akin to:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
</pre></div>

<p>{
     if (this != &amp;other) // (1)
     {
         // get the new data ready before we replace the old
         std::size_t newSize = other.mSize;
         int* newArray = newSize ? new int<a href=".">newSize</a> : nullptr; // (3)
         std::copy(other.mArray, other.mArray + newSize, newArray); // (3)</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1">// replace the old data (all are non-throwing)</span>
<span class="w">     </span><span class="nb">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="w">     </span><span class="n">mSize</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">newSize</span><span class="p">;</span>
<span class="w">     </span><span class="n">mArray</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">newArray</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
</pre></div>

<p>}</p>
</li>
<li>
<p>The code has expanded! Which leads us to the third problem: code duplication.</p>
</li>
</ol>
<p>Our assignment operator effectively duplicates all the code we've already
written elsewhere, and that's a terrible thing.</p>
<p>In our case, the core of it is only two lines (the allocation and the copy),
but with more complex resources this code bloat can be quite a hassle. We
should strive to never repeat ourselves.</p>
<p>(One might wonder: if this much code is needed to manage one resource
correctly, what if my class manages more than one?<br>
While this may seem to be a valid concern, and indeed it requires non-trivial
<code>try</code>/<code>catch</code> clauses, this is a non-issue.<br>
That's because a class should manage <em>one resource only</em>!)</p>
<h4>A successful solution</h4>
<p>As mentioned, the copy-and-swap idiom will fix all these issues. But right
now, we have all the requirements except one: a <code>swap</code> function. While The
Rule of Three successfully entails the existence of our copy-constructor,
assignment operator, and destructor, it should really be called "The Big Three
and A Half": any time your class manages a resource it also makes sense to
provide a <code>swap</code> function.</p>
<p>We need to add swap functionality to our class, and we do that as follows†:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">dumb_array</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>

<span class="w">    </span><span class="n">friend</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="n">dumb_array</span><span class="err">&amp;</span><span class="w"> </span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">dumb_array</span><span class="err">&amp;</span><span class="w"> </span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">nothrow</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="n">ADL</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">our</span><span class="w"> </span><span class="n">case</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">good</span><span class="w"> </span><span class="n">practice</span><span class="p">)</span>
<span class="w">        </span><span class="n">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">swapping</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">members</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">two</span><span class="w"> </span><span class="err">objects,</span>
<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">two</span><span class="w"> </span><span class="err">objects</span><span class="w"> </span><span class="err">are</span><span class="w"> </span><span class="err">effectively</span><span class="w"> </span><span class="err">swapped</span>
<span class="w">        </span><span class="err">swap(first.mSize,</span><span class="w"> </span><span class="err">second.mSize)</span><span class="p">;</span>
<span class="w">        </span><span class="err">swap(first.mArray,</span><span class="w"> </span><span class="err">second.mArray)</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>(Here is the explanation why <code>public friend swap</code>.) Now not only can we swap
our <code>dumb_array</code>'s, but swaps in general can be more efficient; it merely
swaps pointers and sizes, rather than allocating and copying entire arrays.
Aside from this bonus in functionality and efficiency, we are now ready to
implement the copy-and-swap idiom.</p>
<p>Without further ado, our assignment operator is:</p>
<div class="code"><pre class="code literal-block"><span class="nv">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="nv">operator</span><span class="o">=</span><span class="ss">(</span><span class="nv">dumb_array</span><span class="w"> </span><span class="nv">other</span><span class="ss">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>
{
<span class="w">    </span><span class="nv">swap</span><span class="ss">(</span><span class="o">*</span><span class="nv">this</span>,<span class="w"> </span><span class="nv">other</span><span class="ss">)</span><span class="c1">; // (2)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="nv">this</span><span class="c1">;</span>
}
</pre></div>

<p>And that's it! With one fell swoop, all three problems are elegantly tackled
at once.</p>
<h4>Why does it work?</h4>
<p>We first notice an important choice: the parameter argument is taken <em>by-
value</em>. While one could just as easily do the following (and indeed, many
naive implementations of the idiom do):</p>
<div class="code"><pre class="code literal-block"><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="w"> </span><span class="n">temp</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>We lose an important optimization opportunity. Not only that, but this choice
is critical in C++11, which is discussed later. (On a general note, a
remarkably useful guideline is as follows: if you're going to make a copy of
something in a function, let the compiler do it in the parameter list.‡)</p>
<p>Either way, this method of obtaining our resource is the key to eliminating
code duplication: we get to use the code from the copy-constructor to make the
copy, and never need to repeat any bit of it. Now that the copy is made, we
are ready to swap.</p>
<p>Observe that upon entering the function that all the new data is already
allocated, copied, and ready to be used. This is what gives us a strong
exception guarantee for free: we won't even enter the function if construction
of the copy fails, and it's therefore not possible to alter the state of
<code>*this</code>. (What we did manually before for a strong exception guarantee, the
compiler is doing for us now; how kind.)</p>
<p>At this point we are home-free, because <code>swap</code> is non-throwing. We swap our
current data with the copied data, safely altering our state, and the old data
gets put into the temporary. The old data is then released when the function
returns. (Where upon the parameter's scope ends and its destructor is called.)</p>
<p>Because the idiom repeats no code, we cannot introduce bugs within the
operator. Note that this means we are rid of the need for a self-assignment
check, allowing a single uniform implementation of <code>operator=</code>. (Additionally,
we no longer have a performance penalty on non-self-assignments.)</p>
<p>And that is the copy-and-swap idiom.</p>
<h3>What about C++11?</h3>
<p>The next version of C++, C++11, makes one very important change to how we
manage resources: the Rule of Three is now <strong>The Rule of Four</strong> (and a half).
Why? Because not only do we need to be able to copy-construct our resource, we
need to move-construct it as well.</p>
<p>Luckily for us, this is easy:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">dumb_array</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="n">dumb_array</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="n">noexcept</span><span class="w"> </span><span class="err">††</span>
<span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="n">dumb_array</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">initialize</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">constructor</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="mi">11</span><span class="w"> </span><span class="n">only</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="p">};</span>
</pre></div>

<p>What's going on here? Recall the goal of move-construction: to take the
resources from another instance of the class, leaving it in a state guaranteed
to be assignable and destructible.</p>
<p>So what we've done is simple: initialize via the default constructor (a C++11
feature), then swap with <code>other</code>; we know a default constructed instance of
our class can safely be assigned and destructed, so we know <code>other</code> will be
able to do the same, after swapping.</p>
<p>(Note that some compilers do not support constructor delegation; in this case,
we have to manually default construct the class. This is an unfortunate but
luckily trivial task.)</p>
<h4>Why does that work?</h4>
<p>That is the only change we need to make to our class, so why does it work?
Remember the ever-important decision we made to make the parameter a value and
not a reference:</p>
<div class="code"><pre class="code literal-block">dumb_array&amp; operator=(dumb_array other); // (1)
</pre></div>

<p>Now, if <code>other</code> is being initialized with an rvalue, <em>it will be move-
constructed</em>. Perfect. In the same way C++03 let us re-use our copy-
constructor functionality by taking the argument by-value, C++11 will
<em>automatically</em> pick the move-constructor when appropriate as well. (And, of
course, as mentioned in previously linked article, the copying/moving of the
value may simply be elided altogether.)</p>
<p>And so concludes the copy-and-swap idiom.</p>
<hr>
<h4>Footnotes</h4>
<p>*Why do we set <code>mArray</code> to null? Because if any further code in the operator throws, the destructor of <code>dumb_array</code> might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</p>
<p>†There are other claims that we should specialize <code>std::swap</code> for our type,
provide an in-class <code>swap</code> along-side a free-function <code>swap</code>, etc. But this is
all unnecessary: any proper use of <code>swap</code> will be through an unqualified call,
and our function will be found through ADL. One function will do.</p>
<p>‡The reason is simple: once you have the resource to yourself, you may swap
and/or move it (C++11) anywhere it needs to be. And by making the copy in the
parameter list, you maximize optimization.</p>
<p>††The move constructor should generally be <code>noexcept</code>, otherwise some code
(e.g. <code>std::vector</code> resizing logic) will use the copy constructor even when a
move would make sense. Of course, only mark it noexcept if the code inside
doesn't throw exceptions.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Assignment, at its heart, is two steps: <strong><em>tearing down the object's old
state</em></strong> and <strong><em>building its new state as a copy</em></strong> of some other object's
state.</p>
<p>Basically, that's what the <strong><em>destructor</em></strong> and the <strong><em>copy constructor</em></strong> do,
so the first idea would be to delegate the work to them. However, since
destruction mustn't fail, while construction might, <em>we actually want to do it
the other way around</em> : <strong><em>first perform the constructive part</em></strong> and, if that
succeeded, <strong><em>then do the destructive part</em></strong>. The copy-and-swap idiom is a
way to do just that: It first calls a class' copy constructor to create a
temporary object, then swaps its data with the temporary's, and then lets the
temporary's destructor destroy the old state.<br>
Since <code>swap()</code> is supposed to never fail, the only part which might fail is
the copy-construction. That is performed first, and if it fails, nothing will
be changed in the targeted object.</p>
<p>In its refined form, copy-and-swap is implemented by having the copy performed
by initializing the (non-reference) parameter of the assignment operator:</p>
<div class="code"><pre class="code literal-block"><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/assignment-operator/" rel="tag">assignment-operator</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B-faq/" rel="tag">c++-faq</a></li>
            <li><a class="tag p-category" href="../../categories/copy-and-swap/" rel="tag">copy-and-swap</a></li>
            <li><a class="tag p-category" href="../../categories/copy-constructor/" rel="tag">copy-constructor</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../postgresql-show-tables-in-postgresql/" rel="prev" title="PostgreSQL: Show tables in PostgreSQL">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-check-if-an-object-has-an-attribute/" rel="next" title="How do I check if an object has an attribute?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
