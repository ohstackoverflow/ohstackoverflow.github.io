<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>PHP“foreach”实际上是如何工作的？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/php-foreach-shi-ji-shang-shi-ru-he-gong-zuo-de/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-cong-wen-ben-wen-jian-zhong-shan-chu-bao-han-te-ding-zi-fu-chuan-de-suo-you-xing/" title="如何从文本文件中删除包含特定字符串的所有行？" type="text/html">
<link rel="next" href="../html-zhong-id-shu-xing-de-you-xiao-zhi-shi-shi-yao/" title="HTML 中 id 属性的有效值是什么？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="PHP“foreach”实际上是如何工作的？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/php-foreach-shi-ji-shang-shi-ru-he-gong-zuo-de/">
<meta property="og:description" content="让我先说我知道它foreach是什么、做什么以及如何使用它。这个问题涉及它在引擎盖下是如何工作的，我不想得到任何类似“这就是你循环数组的方式foreach”的答案。

很长一段时间我都认为它foreach与数组本身一起工作。 然后我发现了很多关于它与数组副本
一起工作的事实的参考资料，从那以后我就认为这就是故事的结局。但是我最近就此事进行了讨论，经过一些实验发现这实际上不是 100% 正确的。
让">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T22:07:21+08:00">
<meta property="article:tag" content="foreach">
<meta property="article:tag" content="iteration">
<meta property="article:tag" content="loops">
<meta property="article:tag" content="php">
<meta property="article:tag" content="php-internals">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">PHP“foreach”实际上是如何工作的？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:07:21+08:00" itemprop="datePublished" title="2023-02-16 22:07">2023-02-16 22:07</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>让我先说我知道它<code>foreach</code>是什么、做什么以及如何使用它。这个问题涉及它在引擎盖下是如何工作的，我不想得到任何类似“这就是你循环数组的方式<code>foreach</code>”的答案。</p>
<hr>
<p>很长一段时间我都认为它<code>foreach</code>与数组本身一起工作。 <em>然后我发现了很多关于它与数组副本</em>
一起工作的事实的参考资料，从那以后我就认为这就是故事的结局。但是我最近就此事进行了讨论，经过一些实验发现这实际上不是 100% 正确的。</p>
<p>让我表明我的意思。对于以下测试用例，我们将使用以下数组：</p>
<div class="code"><pre class="code literal-block">$array = array(1, 2, 3, 4, 5);
</pre></div>

<p>测试用例 1：</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">item</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$item\n"</span><span class="c1">;</span>
<span class="w">  </span><span class="mh">$a</span><span class="nv">rray</span>[]<span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">item</span><span class="c1">;</span>
}
<span class="nv">print_r</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="ss">)</span><span class="c1">;</span>

<span class="cm">/* Output in loop:    1 2 3 4 5</span>
<span class="cm">   $array after loop: 1 2 3 4 5 1 2 3 4 5 */</span>
</pre></div>

<p>这清楚地表明我们没有直接使用源数组 - 否则循环将永远持续下去，因为我们在循环期间不断地将项目推入数组。但只是为了确定是这种情况：</p>
<p>测试用例 2：</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">key</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>$<span class="nv">item</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="mh">$a</span><span class="nv">rray</span>[$<span class="nv">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">item</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$item\n"</span><span class="c1">;</span>
}

<span class="nv">print_r</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="ss">)</span><span class="c1">;</span>

<span class="cm">/* Output in loop:    1 2 3 4 5</span>
<span class="cm">   $array after loop: 1 3 4 5 6 7 */</span>
</pre></div>

<p>这支持了我们最初的结论，我们在循环期间使用源数组的副本，否则我们会在循环期间看到修改后的值。 <em>但...</em></p>
<p>如果我们查看手册，我们会发现以下声明：</p>
<blockquote>
<p>当 foreach 第一次开始执行时，内部数组指针自动重置为数组的第一个元素。</p>
</blockquote>
<p>对...这似乎暗示<code>foreach</code>依赖于源数组的数组指针。但是我们刚刚证明我们 <em>没有使用源数组</em> ，对吧？好吧，不完全是。</p>
<p>测试用例 3：</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Move</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">sure</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">doesn</span><span class="s1">'t affect the loop</span>
<span class="n">var_dump</span><span class="p">(</span><span class="n">each</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>

<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">echo</span><span class="w"> </span><span class="s2">"$item</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">var_dump</span><span class="p">(</span><span class="n">each</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>

<span class="o">/*</span><span class="w"> </span><span class="n">Output</span>
<span class="w">  </span><span class="n">array</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="s2">"value"</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="s2">"key"</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="mi">1</span>
<span class="w">  </span><span class="mi">2</span>
<span class="w">  </span><span class="mi">3</span>
<span class="w">  </span><span class="mi">4</span>
<span class="w">  </span><span class="mi">5</span>
<span class="w">  </span><span class="nb nb-Type">bool</span><span class="p">(</span><span class="bp">false</span><span class="p">)</span>
<span class="o">*/</span>
</pre></div>

<p>因此，尽管事实上我们没有直接使用源数组，但我们直接使用源数组指针——指针在循环结束时位于数组末尾的事实表明了这一点。但这不可能是真的——如果是的话，那么测试用例
1将永远循环下去。</p>
<p>PHP 手册还指出：</p>
<blockquote>
<p>由于 foreach 依赖于内部数组指针，因此在循环内更改它可能会导致意外行为。</p>
</blockquote>
<p>好吧，让我们找出“意外行为”是什么（从技术上讲，任何行为都是意外的，因为我不再知道会发生什么）。</p>
<p>测试用例 4：</p>
<div class="code"><pre class="code literal-block">foreach ($array as $key =&gt; $item) {
  echo "$item\n";
  each($array);
}

/* Output: 1 2 3 4 5 */
</pre></div>

<p>测试用例 5：</p>
<div class="code"><pre class="code literal-block">foreach ($array as $key =&gt; $item) {
  echo "$item\n";
  reset($array);
}

/* Output: 1 2 3 4 5 */
</pre></div>

<p>...没有什么出乎意料的，事实上它似乎支持“源副本”理论。</p>
<hr>
<p><strong>问题</strong></p>
<p>这里发生了什么？我的 C-fu 不足以让我仅通过查看 PHP 源代码就可以得出正确的结论，如果有人能帮我把它翻译成英文，我将不胜感激。</p>
<p>在我看来，它适用<code>foreach</code>于数组的 <em>副本</em> ，但在循环后将源数组的数组指针设置为数组的末尾。</p>
<ul>
<li>这是正确的和整个故事吗？</li>
<li>如果不是，它到底在做什么？</li>
<li>在 a 期间使用调整数组指针（<code>each()</code>，<code>reset()</code>等）的函数<code>foreach</code>是否会影响循环的结果？</li>
</ul>
<p><br><br></p>
<h2>解答</h2>
<p><code>foreach</code>支持对三种不同类型的值进行迭代：</p>
<ul>
<li>数组</li>
<li>普通物体</li>
<li>
<code>Traversable</code>对象</li>
</ul>
<p>在下文中，我将尝试准确解释迭代在不同情况下的工作原理。到目前为止，最简单的情况是<code>Traversable</code>对象，因为这些<code>foreach</code>基本上只是这些代码的语法糖：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">$k</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">$v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>

<span class="cm">/* translates to: */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="w"> </span><span class="n">instanceof</span><span class="w"> </span><span class="n">IteratorAggregate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">$it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">getIterator</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">rewind</span><span class="p">();</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">();</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">$v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">();</span>
<span class="w">    </span><span class="n">$k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>

<p><code>Iterator</code>对于内部类，通过使用本质上仅反映C 级别接口的内部 API 可以避免实际的方法调用。</p>
<p>数组和普通对象的迭代要复杂得多。首先，应该注意的是，在 PHP
中，“数组”实际上是有序的字典，它们将根据这个顺序进行遍历（只要你没有使用类似的东西，它就会匹配插入顺序）<code>sort</code>。这与按键的自然顺序（其他语言中的列表通常如何工作）或根本没有定义的顺序（其他语言中的字典通常如何工作）进行迭代相反。</p>
<p>这同样适用于对象，因为对象属性可以看作是另一个（有序的）字典，将属性名称映射到它们的值，加上一些可见性处理。在大多数情况下，对象属性实际上并没有以这种相当低效的方式存储。但是，如果您开始遍历一个对象，通常使用的打包表示将转换为真正的字典。在这一点上，普通对象的迭代变得非常类似于数组的迭代（这就是为什么我在这里没有过多讨论普通对象的迭代）。</p>
<p>到目前为止，一切都很好。遍历字典不会太难，对吧？当您意识到数组/对象可以在迭代期间更改时，问题就开始了。发生这种情况的方式有多种：</p>
<ul>
<li>如果您通过引用进行迭代，则使用<code>foreach ($arr as &amp;$v)</code>then<code>$arr</code>变成一个引用，您可以在迭代期间更改它。</li>
<li>在 PHP 5 中，即使您按值进行迭代，同样适用，但数组是事先的引用：<code>$ref =&amp; $arr; foreach ($ref as $v)</code>
</li>
<li>对象具有句柄传递语义，对于大多数实际用途而言，这意味着它们的行为类似于引用。所以对象总是可以在迭代过程中改变。</li>
</ul>
<p>在迭代期间允许修改的问题是您当前所在的元素被删除的情况。假设您使用指针来跟踪您当前所在的数组元素。如果这个元素现在被释放，你会留下一个悬空指针（通常会导致段错误）。</p>
<p>有不同的方法来解决这个问题。PHP 5 和 PHP 7 在这方面有很大不同，我将在下面描述这两种行为。总结是 PHP 5
的方法相当愚蠢并导致各种奇怪的边缘案例问题，而 PHP 7 的方法更复杂导致更可预测和一致的行为。</p>
<p>作为最后的准备，应该注意 PHP 使用引用计数和写时复制来管理内存。这意味着如果您“复制”一个值，您实际上只是重复使用旧值并增加其引用计数
(refcount)。只有执行某种修改后，才会完成真正的副本（称为“复制”）。有关此主题的更广泛介绍，请参阅您被骗了。</p>
<h3>PHP 5</h3>
<h4>内部数组指针和 HashPointer</h4>
<p>PHP 5 中的数组有一个专用的“内部数组指针”(IAP)，它适当地支持修改：每当删除一个元素时，都会检查 IAP
是否指向该元素。如果是，则改为前进到下一个元素。</p>
<p>虽然<code>foreach</code>确实使用了 IAP，但还有一个额外的复杂性：只有一个 IAP，但一个数组可以是多个<code>foreach</code>循环的一部分：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Using by-ref iteration here to make sure that it's really</span>
<span class="c1">// the same array in both loops and not a copy</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="no">$</span><span class="n">arr</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="o">&amp;</span><span class="no">$</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="no">$</span><span class="n">arr</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="o">&amp;</span><span class="no">$</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>为了支持只有一个内部数组指针的两个同时循环，<code>foreach</code>执行以下恶作剧：在执行循环体之前，<code>foreach</code>将指向当前元素的指针及其散列备份到
per-foreach 中<code>HashPointer</code>。循环体运行后，如果 IAP 仍然存在，则将 IAP
设置回该元素。但是，如果该元素已被删除，我们将只使用 IAP
当前所在的位置。这个方案大部分都可以工作，但是你可以从中得到很多奇怪的行为，我将在下面演示其中的一些行为。</p>
<h4>数组复制</h4>
<p>IAP 是数组的一个可见特征（通过<code>current</code>函数系列公开），因为在写时复制语义下，对 IAP
的此类更改算作修改。不幸的是，这意味着<code>foreach</code>在许多情况下被迫复制它正在迭代的数组。具体条件是：</p>
<ol>
<li>该数组不是引用 (is_ref=0)。如果它是一个引用，那么对它的更改应该 <em>传播</em> ，所以它不应该被复制。</li>
<li>该数组的 refcount&gt;1。如果<code>refcount</code>是 1，则数组不共享，我们可以直接修改它。</li>
</ol>
<p>如果数组没有重复（is_ref=0，refcount=1），那么只有它<code>refcount</code>会递增（*）。此外，如果<code>foreach</code>使用引用，则（可能重复的）数组将变成引用。</p>
<p>将此代码视为发生重复的示例：</p>
<div class="code"><pre class="code literal-block">function iterate($arr) {
    foreach ($arr as $v) {}
}

$outerArr = [0, 1, 2, 3, 4];
iterate($outerArr);
</pre></div>

<p>在这里，<code>$arr</code>将被复制以防止 IAP 更改<code>$arr</code>泄漏到<code>$outerArr</code>.
从上面的条件来看，数组不是引用（is_ref=0），而是用在两个地方（refcount=2）。这个要求是不幸的，并且是次优实现的产物（这里不关心迭代期间的修改，所以我们一开始真的不需要使用
IAP）。</p>
<p>(*) 增加此处<code>refcount</code>听起来无害，但违反了写时复制 (COW) 语义：这意味着我们将修改 refcount=2 数组的 IAP，而 COW
规定修改只能在 refcount= 上执行1 值。这种违反会导致用户可见的行为变化（而 COW 通常是透明的），因为迭代数组上的 IAP
变化将是可见的——但只能在数组上的第一次非 IAP 修改之前观察到。相反，三个“有效”选项将是 a) 始终重复，b)
不递增<code>refcount</code>并因此允许在循环中任意修改迭代数组或 c) 根本不使用 IAP（PHP 7 溶液）。</p>
<h4>职位晋升顺序</h4>
<p>要正确理解下面的代码示例，您还必须了解最后一个实施细节。遍历某些数据结构的“正常”方式在伪代码中看起来像这样：</p>
<div class="code"><pre class="code literal-block"><span class="nv">reset</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">get_current_data</span><span class="ss">(</span><span class="nv">arr</span>,<span class="w"> </span><span class="o">&amp;</span><span class="nv">data</span><span class="ss">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">SUCCESS</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">code</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">move_forward</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>然而<code>foreach</code>，作为一个相当特殊的雪花，选择做事略有不同：</p>
<div class="code"><pre class="code literal-block"><span class="nv">reset</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">get_current_data</span><span class="ss">(</span><span class="nv">arr</span>,<span class="w"> </span><span class="o">&amp;</span><span class="nv">data</span><span class="ss">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">SUCCESS</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">move_forward</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">code</span><span class="ss">()</span><span class="c1">;</span>
}
</pre></div>

<p>即数组指针在循环体运行 <em>之前就已经向前移动了。</em> 这意味着当循环体在 element 上工作时<code>$i</code>，IAP 已经在 element
上<code>$i+1</code>。这就是为什么在迭代期间显示修改的代码示例将始终是<code>unset</code>下 <em>一个</em> 元素，而不是当前元素的原因。</p>
<h4>示例：您的测试用例</h4>
<p>上面描述的三个方面应该让您对实现的特性有一个基本完整的印象<code>foreach</code>，我们可以继续讨论一些例子。</p>
<p>此时你的测试用例的行为很容易解释：</p>
<ul>
<li>
<p>在测试用例 1 和 2 中，<code>$array</code>以 refcount=1 开始，因此它不会被复制<code>foreach</code>： 只有 the<code>refcount</code>被递增。当循环体随后修改数组（此时 refcount=2）时，复制将在该点发生。Foreach 将继续处理未修改的<code>$array</code>.</p>
</li>
<li>
<p>在测试用例 3 中，数组再次没有重复，因此<code>foreach</code>将修改变量的 IAP <code>$array</code>。在迭代结束时，IAP 为 NULL（表示迭代已完成），这<code>each</code>通过返回 来指示<code>false</code>。</p>
</li>
<li>
<p>在测试用例 4 和 5 中，<code>each</code>和<code>reset</code>都是引用函数。传递给他们时有<code>$array</code>一个<code>refcount=2</code>，因此必须复制。因此<code>foreach</code>将再次在单独的阵列上工作。</p>
</li>
</ul>
<h4>
<code>current</code>示例： in foreach的效果</h4>
<p>显示各种重复行为的一个好方法是观察循环<code>current()</code>内函数的行为<code>foreach</code>。考虑这个例子：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>在这里你应该知道这<code>current()</code>是一个 by-ref 函数（实际上：prefer-
ref），即使它不修改数组。它必须是为了与所有其他函数一起玩得很好，比如<code>next</code>所有的都是引用。通过引用传递意味着数组必须分开，因此<code>$array</code>和<code>foreach-
array</code>将是不同的。<code>2</code>你得到而不是的原因<code>1</code>上面也提到了：在运行用户代码
<em>之前</em><code>foreach</code>而不是之后推进数组指针。因此，即使代码位于第一个元素，也已经将指针推进到第二个元素。 __<code>foreach</code></p>
<p>现在让我们尝试一个小的修改：</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">false</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>这里我们有 is_ref=1 的情况，所以数组没有被复制（就像上面一样）。但现在它是一个引用，在传递给 by-ref
函数时不再需要复制数组<code>current()</code>。因此<code>current()</code>和<code>foreach</code>在同一个数组上工作。<code>foreach</code>但是，由于指针前进的方式，您仍然会看到差一的行为。</p>
<p>在进行 by-ref 迭代时，您会得到相同的行为：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">false</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>这里重要的部分是foreach在通过引用迭代时会产生<code>$array</code>一个is_ref=1，所以基本上你的情况和上面一样。</p>
<p>另一个小变化，这次我们将数组分配给另一个变量：</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Here the refcount of the <code>$array</code> is 2 when the loop is started, so for once
we actually have to do the duplication upfront. Thus <code>$array</code> and the array
used by foreach will be completely separate from the outset. That's why you
get the position of the IAP wherever it was before the loop (in this case it
was at the first position).</p>
<h4>Examples: Modification during iteration</h4>
<p>Trying to account for modifications during iteration is where all our foreach
troubles originated, so it serves to consider some examples for this case.</p>
<p>Consider these nested loops over the same array (where by-ref iteration is
used to make sure it really is the same one):</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v2</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">v1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>$<span class="nv">v2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">unset</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">        </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"($v1, $v2)\n"</span><span class="c1">;</span>
<span class="w">    </span>}
}

<span class="o">//</span><span class="w"> </span><span class="nv">Output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
</pre></div>

<p>The expected part here is that <code>(1, 2)</code> is missing from the output because
element <code>1</code> was removed. What's probably unexpected is that the outer loop
stops after the first element. Why is that?</p>
<p>The reason behind this is the nested-loop hack described above: Before the
loop body runs, the current IAP position and hash is backed up into a
<code>HashPointer</code>. After the loop body it will be restored, but only if the
element still exists, otherwise the current IAP position (whatever it may be)
is used instead. In the example above this is exactly the case: The current
element of the outer loop has been removed, so it will use the IAP, which has
already been marked as finished by the inner loop!</p>
<p>Another consequence of the <code>HashPointer</code> backup+restore mechanism is that
changes to the IAP through <code>reset()</code> etc. usually do not impact <code>foreach</code>. For
example, the following code executes as if the <code>reset()</code> were not present at
all:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<p>The reason is that, while <code>reset()</code> temporarily modifies the IAP, it will be
restored to the current foreach element after the loop body. To force
<code>reset()</code> to make an effect on the loop, you have to additionally remove the
current element, so that the backup/restore mechanism fails:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<p>But, those examples are still sane. The real fun starts if you remember that
the <code>HashPointer</code> restore uses a pointer to the element and its hash to
determine whether it still exists. But: Hashes have collisions, and pointers
can be reused! This means that, with a careful choice of array keys, we can
make <code>foreach</code> believe that an element that has been removed still exists, so
it will jump directly to it. An example:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">'EzEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">'EzFY'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">'FYEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'EzFY'</span><span class="p">]);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'FYFY'</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
</pre></div>

<p>Here we should normally expect the output <code>1, 1, 3, 4</code> according to the
previous rules. How what happens is that <code>'FYFY'</code> has the same hash as the
removed element <code>'EzFY'</code>, and the allocator happens to reuse the same memory
location to store the element. So foreach ends up directly jumping to the
newly inserted element, thus short-cutting the loop.</p>
<h4>Substituting the iterated entity during the loop</h4>
<p>One last odd case that I'd like to mention, it is that PHP allows you to
substitute the iterated entity during the loop. So you can start iterating on
one array and then replace it with another array halfway through. Or start
iterating on an array and then replace it with an object:</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="nv">rr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>]<span class="c1">;</span>
$<span class="nv">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">object</span><span class="ss">)</span><span class="w"> </span>[<span class="mi">6</span>,<span class="w"> </span><span class="mi">7</span>,<span class="w"> </span><span class="mi">8</span>,<span class="w"> </span><span class="mi">9</span>,<span class="w"> </span><span class="mi">10</span>]<span class="c1">;</span>

$<span class="nv">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="mh">$a</span><span class="nv">rr</span><span class="c1">;</span>
<span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">ref</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">val</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$val\n"</span><span class="c1">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span>$<span class="nv">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">obj</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="cm">/* Output: 1 2 3 6 7 8 9 10 */</span>
</pre></div>

<p>As you can see in this case PHP will just start iterating the other entity
from the start once the substitution has happened.</p>
<h3>PHP 7</h3>
<h4>Hashtable iterators</h4>
<p>If you still remember, the main problem with array iteration was how to handle
removal of elements mid-iteration. PHP 5 used a single internal array pointer
(IAP) for this purpose, which was somewhat suboptimal, as one array pointer
had to be stretched to support multiple simultaneous foreach loops <em>and</em>
interaction with <code>reset()</code> etc. on top of that.</p>
<p>PHP 7 uses a different approach, namely, it supports creating an arbitrary
amount of external, safe hashtable iterators. These iterators have to be
registered in the array, from which point on they have the same semantics as
the IAP: If an array element is removed, all hashtable iterators pointing to
that element will be advanced to the next element.</p>
<p>This means that <code>foreach</code> will no longer use the IAP <strong>at all</strong>. The <code>foreach</code>
loop will be absolutely no effect on the results of <code>current()</code> etc. and its
own behavior will never be influenced by functions like <code>reset()</code> etc.</p>
<h4>Array duplication</h4>
<p>Another important change between PHP 5 and PHP 7 relates to array duplication.
Now that the IAP is no longer used, by-value array iteration will only do a
<code>refcount</code> increment (instead of duplication the array) in all cases. If the
array is modified during the <code>foreach</code> loop, at that point a duplication will
occur (according to copy-on-write) and <code>foreach</code> will keep working on the old
array.</p>
<p>In most cases, this change is transparent and has no other effect than better
performance. However, there is one occasion where it results in different
behavior, namely the case where the array was a reference beforehand:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*/</span>
<span class="o">/*</span><span class="w"> </span><span class="n">New</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Previously by-value iteration of reference-arrays was special cases. In this
case, no duplication occurred, so all modifications of the array during
iteration would be reflected by the loop. In PHP 7 this special case is gone:
A by-value iteration of an array will <strong>always</strong> keep working on the original
elements, disregarding any modifications during the loop.</p>
<p>This, of course, does not apply to by-reference iteration. If you iterate by-
reference all modifications will be reflected by the loop. Interestingly, the
same is true for by-value iteration of plain objects:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">stdClass</span><span class="p">;</span>
<span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">obj</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>This reflects the by-handle semantics of objects (i.e. they behave reference-
like even in by-value contexts).</p>
<h4>Examples</h4>
<p>Let's consider a few examples, starting with your test cases:</p>
<ul>
<li>
<p>Test cases 1 and 2 retain the same output: By-value array iteration always keep working on the original elements. (In this case, even <code>refcounting</code> and duplication behavior is exactly the same between PHP 5 and PHP 7).</p>
</li>
<li>
<p>Test case 3 changes: <code>Foreach</code> no longer uses the IAP, so <code>each()</code> is not affected by the loop. It will have the same output before and after.</p>
</li>
<li>
<p>Test cases 4 and 5 stay the same: <code>each()</code> and <code>reset()</code> will duplicate the array before changing the IAP, while <code>foreach</code> still uses the original array. (Not that the IAP change would have mattered, even if the array was shared.)</p>
</li>
</ul>
<p>The second set of examples was related to the behavior of <code>current()</code> under
different <code>reference/refcounting</code> configurations. This no longer makes sense,
as <code>current()</code> is completely unaffected by the loop, so its return value
always stays the same.</p>
<p>However, we get some interesting changes when considering modifications during
iteration. I hope you will find the new behavior saner. The first example:</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>]<span class="c1">;</span>
<span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v2</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">v1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>$<span class="nv">v2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">unset</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">        </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"($v1, $v2)\n"</span><span class="c1">;</span>
<span class="w">    </span>}
}

<span class="o">//</span><span class="w"> </span><span class="nv">Old</span><span class="w"> </span><span class="nv">output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
</pre></div>

<p>As you can see, the outer loop no longer aborts after the first iteration. The
reason is that both loops now have entirely separate hashtable iterators, and
there is no longer any cross-contamination of both loops through a shared IAP.</p>
<p>Another weird edge case that is fixed now, is the odd effect you get when you
remove and add elements that happen to have the same hash:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">'EzEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">'EzFY'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">'FYEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'EzFY'</span><span class="p">]);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'FYFY'</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
<span class="o">//</span><span class="w"> </span><span class="n">New</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
</pre></div>

<p>Previously the HashPointer restore mechanism jumped right to the new element
because it "looked" like it's the same as the removed element (due to
colliding hash and pointer). As we no longer rely on the element hash for
anything, this is no longer an issue.</p>
<p><br></p>
<h3>更多建议</h3>
<p>在示例 3 中，您不修改数组。在所有其他示例中，您修改内容或内部数组指针。由于赋值运算符的语义，这在涉及PHP数组时很重要。</p>
<p>PHP
中数组的赋值运算符更像是一个惰性克隆。与大多数语言不同，将一个变量分配给另一个包含数组的变量将克隆该数组。但是，除非需要，否则不会进行实际的克隆。这意味着只有当其中一个变量被修改时才会发生克隆（写时复制）。</p>
<p>这是一个例子：</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">array</span><span class="ss">(</span><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="ss">)</span><span class="c1">;</span>
<span class="mh">$b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">$a</span><span class="c1">;  // This is lazy cloning of $a. For the time</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">being</span><span class="w"> </span><span class="mh">$a</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mh">$b</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">internal</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="nv">structure</span>.

<span class="mh">$a</span>[]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="c1">; // Here $a changes, which triggers the actual</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">cloning</span>.<span class="w"> </span><span class="nv">From</span><span class="w"> </span><span class="nv">now</span><span class="w"> </span><span class="nv">on</span>,<span class="w"> </span><span class="mh">$a</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mh">$b</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">two</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="nv">structures</span>.<span class="w"> </span><span class="nv">The</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">would</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">happen</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">were</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">change</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="mh">$b</span>.
</pre></div>

<p>回到您的测试用例，您可以很容易地想象<code>foreach</code>创建某种带有对数组的引用的迭代器。此引用与我的示例中的变量完全一样<code>$b</code>。但是，迭代器和引用仅在循环期间存在，然后它们都被丢弃。现在您可以看到，在除
3 之外的所有情况下，数组在循环期间被修改，而这个额外的引用仍然存在。这会触发一个克隆，这就解释了这里发生了什么！</p>
<p>这是一篇关于这种写时复制行为的另一个副作用的优秀文章：The PHP Ternary Operator: Fast or not?</p>
<p><br><br><a href="../how-does-php-foreach-actually-work/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/foreach/" rel="tag">foreach</a></li>
            <li><a class="tag p-category" href="../../categories/iteration/" rel="tag">iteration</a></li>
            <li><a class="tag p-category" href="../../categories/loops/" rel="tag">loops</a></li>
            <li><a class="tag p-category" href="../../categories/php/" rel="tag">php</a></li>
            <li><a class="tag p-category" href="../../categories/php-internals/" rel="tag">php-internals</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-cong-wen-ben-wen-jian-zhong-shan-chu-bao-han-te-ding-zi-fu-chuan-de-suo-you-xing/" rel="prev" title="如何从文本文件中删除包含特定字符串的所有行？">Previous post</a>
            </li>
            <li class="next">
                <a href="../html-zhong-id-shu-xing-de-you-xiao-zhi-shi-shi-yao/" rel="next" title="HTML 中 id 属性的有效值是什么？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
