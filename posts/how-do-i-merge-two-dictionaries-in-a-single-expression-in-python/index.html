<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How do I merge two dictionaries in a single expression in Python? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-find-all-files-containing-specific-text-string-on-linux/" title="How to find all files containing specific text (string) on Linux?" type="text/html">
<link rel="next" href="../how-do-i-return-the-response-from-an-asynchronous-call/" title="How do I return the response from an asynchronous call?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How do I merge two dictionaries in a single expression in Python?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python/">
<meta property="og:description" content="I want to merge two dictionaries into a new dictionary.
x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
z = merge(x, y)

&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'c': 4}


Whenever a key k is present in both dictionaries, on">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T18:29:02+08:00">
<meta property="article:tag" content="dictionary">
<meta property="article:tag" content="merge">
<meta property="article:tag" content="python">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How do I merge two dictionaries in a single expression in Python?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:29:02+08:00" itemprop="datePublished" title="2023-02-16 18:29">2023-02-16 18:29</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I want to merge two dictionaries into a new dictionary.</p>
<div class="code"><pre class="code literal-block">x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
z = merge(x, y)

&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'c': 4}
</pre></div>

<p>Whenever a key <code>k</code> is present in both dictionaries, only the value <code>y[k]</code>
should be kept.</p>
<p><br><br></p>
<h2>Answer</h2>
<h3>How can I merge two Python dictionaries in a single expression?</h3>
<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes
values from <code>y</code>, replacing those from <code>x</code>.</p>
<ul>
<li>
<p>In Python 3.9.0 or greater (released 17 October 2020, <code>PEP-584</code>, discussed here):</p>
<div class="code"><pre class="code literal-block">z = x | y
</pre></div>

</li>
<li>
<p>In Python 3.5 or greater:</p>
<div class="code"><pre class="code literal-block">z = {**x, **y}
</pre></div>

</li>
<li>
<p>In Python 2, (or 3.4 or lower) write a function:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">merge_two_dicts</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">y</span><span class="ss">)</span>:
<span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">x</span>.<span class="nv">copy</span><span class="ss">()</span><span class="w">   </span>#<span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">keys</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">values</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">x</span>
<span class="nv">z</span>.<span class="nv">update</span><span class="ss">(</span><span class="nv">y</span><span class="ss">)</span><span class="w">    </span>#<span class="w"> </span><span class="nv">modifies</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">keys</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">values</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">y</span>
<span class="k">return</span><span class="w"> </span><span class="nv">z</span>
</pre></div>

</li>
</ul>
<p>and now:</p>
<div class="code"><pre class="code literal-block">    z = merge_two_dicts(x, y)
</pre></div>

<h4>Explanation</h4>
<p>Say you have two dictionaries and you want to merge them into a new dictionary
without altering the original dictionaries:</p>
<div class="code"><pre class="code literal-block">x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
</pre></div>

<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged,
and the second dictionary's values overwriting those from the first.</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'c': 4}
</pre></div>

<p>A new syntax for this, proposed in PEP 448 and available as of Python 3.5, is</p>
<div class="code"><pre class="code literal-block">z = {**x, **y}
</pre></div>

<p>And it is indeed a single expression.</p>
<p>Note that we can merge in with literal notation as well:</p>
<div class="code"><pre class="code literal-block">z = {**x, 'foo': 1, 'bar': 2, **y}
</pre></div>

<p>and now:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; z
{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}
</pre></div>

<p>It is now showing as implemented in the release schedule for 3.5, PEP 478, and
it has now made its way into the What's New in Python 3.5 document.</p>
<p>However, since many organizations are still on Python 2, you may wish to do
this in a backward-compatible way. The classically Pythonic way, available in
Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>
<div class="code"><pre class="code literal-block">z = x.copy()
z.update(y) # which returns None since it mutates z
</pre></div>

<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s
values, thus <code>b</code> will point to <code>3</code> in our final result.</p>
<h3>Not yet on Python 3.5, but want a <em>single expression</em>
</h3>
<p>If you are not yet on Python 3.5 or need to write backward-compatible code,
and you want this in a <em>single expression</em> , the most performant while the
correct approach is to put it in a function:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">merge_two_dicts</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">y</span><span class="ss">)</span>:
<span class="w">    </span><span class="s2">"""Given two dictionaries, merge them into a new dict as a shallow copy."""</span>
<span class="w">    </span><span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">x</span>.<span class="nv">copy</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">z</span>.<span class="nv">update</span><span class="ss">(</span><span class="nv">y</span><span class="ss">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">z</span>
</pre></div>

<p>and then you have a single expression:</p>
<div class="code"><pre class="code literal-block">z = merge_two_dicts(x, y)
</pre></div>

<p>You can also make a function to merge an arbitrary number of dictionaries,
from zero to a very large number:</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">merge_dicts</span><span class="ss">(</span><span class="o">*</span><span class="nv">dict_args</span><span class="ss">)</span>:
<span class="w">    </span><span class="s2">""</span><span class="err">"</span>
<span class="err">    Given any number of dictionaries, shallow copy and merge into a new dict,</span>
<span class="err">    precedence goes to key-value pairs in latter dictionaries.</span>
<span class="w">    </span><span class="s2">""</span><span class="err">"</span>
<span class="err">    result = {}</span>
<span class="err">    for dictionary in dict_args:</span>
<span class="err">        result.update(dictionary)</span>
<span class="err">    return result</span>
</pre></div>

<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given
dictionaries <code>a</code> to <code>g</code>:</p>
<div class="code"><pre class="code literal-block">z = merge_dicts(a, b, c, d, e, f, g)
</pre></div>

<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>,
and so on.</p>
<h3>Critiques of Other Answers</h3>
<p>Don't use what you see in the formerly accepted answer:</p>
<div class="code"><pre class="code literal-block">z = dict(x.items() + y.items())
</pre></div>

<p>In Python 2, you create two lists in memory for each dict, create a third list
in memory with length equal to the length of the first two put together, and
then discard all three lists to create the dict. <strong>In Python 3, this will
fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists
-</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">dict</span><span class="ss">(</span><span class="nv">a</span>.<span class="nv">items</span><span class="ss">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">b</span>.<span class="nv">items</span><span class="ss">())</span>
<span class="nv">Traceback</span><span class="w"> </span><span class="ss">(</span><span class="nv">most</span><span class="w"> </span><span class="nv">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="nl">last</span><span class="ss">)</span>:
<span class="w">  </span><span class="nv">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span>,<span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="o">&lt;</span><span class="nv">module</span><span class="o">&gt;</span>
<span class="nv">TypeError</span>:<span class="w"> </span><span class="nv">unsupported</span><span class="w"> </span><span class="nv">operand</span><span class="w"> </span><span class="nv">type</span><span class="ss">(</span><span class="nv">s</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">+</span>:<span class="w"> </span><span class="s1">'dict_items'</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="s1">'dict_items'</span>
</pre></div>

<p>and you would have to explicitly create them as lists, e.g. <code>z =
dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and
computation power.</p>
<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python
2.7) will also fail when values are unhashable objects (like lists, for
example). Even if your values are hashable, <strong>since sets are semantically
unordered, the behavior is undefined in regards to precedence. So don't do
this:</strong></p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c = dict(a.items() | b.items())
</pre></div>

<p>This example demonstrates what happens when values are unhashable:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; x = {'a': []}
&gt;&gt;&gt; y = {'b': []}
&gt;&gt;&gt; dict(x.items() | y.items())
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</pre></div>

<p>Here's an example where <code>y</code> should have precedence, but instead the value from
<code>x</code> is retained due to the arbitrary order of sets:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; x = {'a': 2}
&gt;&gt;&gt; y = {'a': 1}
&gt;&gt;&gt; dict(x.items() | y.items())
{'a': 2}
</pre></div>

<p>Another hack you should not use:</p>
<div class="code"><pre class="code literal-block">z = dict(x, **y)
</pre></div>

<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even
slightly more so than our two-step process) but unless you know precisely what
is happening here (that is, the second dict is being passed as keyword
arguments to the dict constructor), it's difficult to read, it's not the
intended usage, and so it is not Pythonic.</p>
<p>Here's an example of the usage being remediated in django.</p>
<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples),
but <strong>this method fails in Python 3 when keys are not strings.</strong></p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c = dict(a, **b)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: keyword arguments must be strings
</pre></div>

<p>From the mailing list, Guido van Rossum, the creator of the language, wrote:</p>
<blockquote>
<p>I am fine with declaring dict({}, <strong>{1:3}) illegal, since after all it is
abuse of the </strong> mechanism.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Apparently dict(x, **y) is going around as "cool hack" for "call x.update(y)
and return x". Personally, I find it more despicable than cool.</p>
</blockquote>
<p>It is my understanding (as well as the understanding of the creator of the
language) that the intended usage for <code>dict(**y)</code> is for creating dictionaries
for readability purposes, e.g.:</p>
<div class="code"><pre class="code literal-block">dict(a=1, b=10, c=11)
</pre></div>

<p>instead of</p>
<div class="code"><pre class="code literal-block">{'a': 1, 'b': 10, 'c': 11}
</pre></div>

<h3>Response to comments</h3>
<blockquote>
<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict
specification, which btw. works for both Python 2 and 3. The fact that this
only works for string keys is a direct consequence of how keyword parameters
work and not a short-coming of dict. Nor is using the <strong> operator in this
place an abuse of the mechanism, in fact, </strong> was designed precisely to pass
dictionaries as keywords.</p>
</blockquote>
<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling
contract is that namespaces take ordinary dictionaries, while users must only
pass keyword arguments that are strings. All other callables enforced it.
<code>dict</code> broke this consistency in Python 2:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; foo(**{('a', 'b'): None})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: foo() keywords must be strings
&gt;&gt;&gt; dict(**{('a', 'b'): None})
{('a', 'b'): None}
</pre></div>

<p>This inconsistency was bad given other implementations of Python (PyPy,
Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a
breaking change.</p>
<p>I submit to you that it is malicious incompetence to intentionally write code
that only works in one version of a language or that only works given certain
arbitrary constraints.</p>
<p>More comments:</p>
<blockquote>
<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python
2. Readability counts.</p>
</blockquote>
<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if
we're actually concerned about readability. And it is not forward compatible,
as Python 2 is increasingly deprecated.</p>
<blockquote>
<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of
nested keys are simply overwritten, not merged [...] I ended up being burnt
by these answers that do not merge recursively and I was surprised no one
mentioned it. In my interpretation of the word "merging" these answers
describe "updating one dict with another", and not merging.</p>
</blockquote>
<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em>
merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by
the second's - in a single expression.</p>
<p>Assuming two dictionaries of dictionaries, one might recursively merge them in
a single function, but you should be careful not to modify the dictionaries
from either source, and the surest way to avoid that is to make a copy when
assigning values. As keys must be hashable and are usually therefore
immutable, it is pointless to copy them:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">def</span> <span class="nf">dict_of_dicts_merge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">overlapping_keys</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">y</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">overlapping_keys</span><span class="p">:</span>
        <span class="n">z</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_of_dicts_merge</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">overlapping_keys</span><span class="p">:</span>
        <span class="n">z</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">overlapping_keys</span><span class="p">:</span>
        <span class="n">z</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">z</span>
</pre></div>

<p>Usage:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}
&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}
&gt;&gt;&gt; dict_of_dicts_merge(x, y)
{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}
</pre></div>

<p>Coming up with contingencies for other value types is far beyond the scope of
this question, so I will point you at my answer to the canonical question on a
"Dictionaries of dictionaries merge".</p>
<h3>Less Performant But Correct Ad-hocs</h3>
<p>These approaches are less performant, but they will provide correct behavior.
They will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new
unpacking because they iterate through each key-value pair at a higher level
of abstraction, but they <em>do</em> respect the order of precedence (latter
dictionaries have precedence)</p>
<p>You can also chain the dictionaries manually inside a dict comprehension:</p>
<div class="code"><pre class="code literal-block">{<span class="nv">k</span>:<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">dicts</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">k</span>,<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">items</span><span class="ss">()</span>}<span class="w"> </span>#<span class="w"> </span><span class="nv">iteritems</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">Python</span><span class="w"> </span><span class="mi">2</span>.<span class="mi">7</span>
</pre></div>

<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were
introduced):</p>
<div class="code"><pre class="code literal-block"><span class="nv">dict</span><span class="ss">((</span><span class="nv">k</span>,<span class="w"> </span><span class="nv">v</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">dicts</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">k</span>,<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">items</span><span class="ss">())</span><span class="w"> </span>#<span class="w"> </span><span class="nv">iteritems</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">Python</span><span class="w"> </span><span class="mi">2</span>
</pre></div>

<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the
correct order:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="n">z</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="c1"># iteritems in Python 2</span>
</pre></div>

<h3>Performance Analysis</h3>
<p>I'm only going to do the performance analysis of the usages known to behave
correctly. (Self-contained so you can copy and paste yourself.)</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">repeat</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s1">'abcdefg'</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s1">'efghijk'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge_two_dicts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">z</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span>

<span class="nb">min</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">y</span><span class="p">}))</span>
<span class="nb">min</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">merge_two_dicts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
<span class="nb">min</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}))</span>
<span class="nb">min</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">items</span><span class="p">()))))</span>
<span class="nb">min</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
</pre></div>

<p>In Python 3.8.1, NixOS:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">min</span><span class="ss">(</span><span class="nv">repeat</span><span class="ss">(</span><span class="nv">lambda</span>:<span class="w"> </span>{<span class="o">**</span><span class="nv">x</span>,<span class="w"> </span><span class="o">**</span><span class="nv">y</span>}<span class="ss">))</span>
<span class="mi">1</span>.<span class="mi">0804965235292912</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">min</span><span class="ss">(</span><span class="nv">repeat</span><span class="ss">(</span><span class="nv">lambda</span>:<span class="w"> </span><span class="nv">merge_two_dicts</span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">y</span><span class="ss">)))</span>
<span class="mi">1</span>.<span class="mi">636518670246005</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">min</span><span class="ss">(</span><span class="nv">repeat</span><span class="ss">(</span><span class="nv">lambda</span>:<span class="w"> </span>{<span class="nv">k</span>:<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">y</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">k</span>,<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">items</span><span class="ss">()</span>}<span class="ss">))</span>
<span class="mi">3</span>.<span class="mi">1779992282390594</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">min</span><span class="ss">(</span><span class="nv">repeat</span><span class="ss">(</span><span class="nv">lambda</span>:<span class="w"> </span><span class="nv">dict</span><span class="ss">(</span><span class="nv">chain</span><span class="ss">(</span><span class="nv">x</span>.<span class="nv">items</span><span class="ss">()</span>,<span class="w"> </span><span class="nv">y</span>.<span class="nv">items</span><span class="ss">()))))</span>
<span class="mi">2</span>.<span class="mi">740647904574871</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">min</span><span class="ss">(</span><span class="nv">repeat</span><span class="ss">(</span><span class="nv">lambda</span>:<span class="w"> </span><span class="nv">dict</span><span class="ss">(</span><span class="nv">item</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="ss">(</span><span class="nv">x</span>,<span class="w"> </span><span class="nv">y</span><span class="ss">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">item</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">d</span>.<span class="nv">items</span><span class="ss">())))</span>
<span class="mi">4</span>.<span class="mi">266070580109954</span>



$<span class="w"> </span><span class="nv">uname</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span>
<span class="nv">Linux</span><span class="w"> </span><span class="nv">nixos</span><span class="w"> </span><span class="mi">4</span>.<span class="mi">19</span>.<span class="mi">113</span><span class="w"> </span><span class="sc">#1</span><span class="o">-</span><span class="nv">NixOS</span><span class="w"> </span><span class="nv">SMP</span><span class="w"> </span><span class="nv">Wed</span><span class="w"> </span><span class="nv">Mar</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="mi">07</span>:<span class="mi">06</span>:<span class="mi">15</span><span class="w"> </span><span class="nv">UTC</span><span class="w"> </span><span class="mi">2020</span><span class="w"> </span><span class="nv">x86_64</span><span class="w"> </span><span class="nv">GNU</span><span class="o">/</span><span class="nv">Linux</span>
</pre></div>

<h3>Resources on Dictionaries</h3>
<ul>
<li>My explanation of Python's <strong>dictionary implementation</strong> , updated for 3.6.</li>
<li>Answer on how to add new keys to a dictionary</li>
<li>Mapping two lists into a dictionary</li>
<li>The official Python docs on dictionaries</li>
<li>The Dictionary Even Mightier - talk by Brandon Rhodes at Pycon 2017</li>
<li>Modern Python Dictionaries, A Confluence of Great Ideas - talk by Raymond Hettinger at Pycon 2017</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>In your case, you can do:</p>
<div class="code"><pre class="code literal-block">z = dict(list(x.items()) + list(y.items()))
</pre></div>

<p>This will, as you want it, put the final dict in <code>z</code>, and make the value for
key <code>b</code> be properly overridden by the second (<code>y</code>) dict's value:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; x = {'a':1, 'b': 2}
&gt;&gt;&gt; y = {'b':10, 'c': 11}
&gt;&gt;&gt; z = dict(list(x.items()) + list(y.items()))
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</pre></div>

<p>If you use Python 2, you can even remove the <code>list()</code> calls. To create z:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; z = dict(x.items() + y.items())
&gt;&gt;&gt; z
{'a': 1, 'c': 11, 'b': 10}
</pre></div>

<p>If you use Python version 3.9.0a4 or greater, then you can directly use:</p>
<div class="code"><pre class="code literal-block">x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
z = x | y
print(z)



{'a': 1, 'c': 11, 'b': 10}
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dictionary/" rel="tag">dictionary</a></li>
            <li><a class="tag p-category" href="../../categories/merge/" rel="tag">merge</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-find-all-files-containing-specific-text-string-on-linux/" rel="prev" title="How to find all files containing specific text (string) on Linux?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-return-the-response-from-an-asynchronous-call/" rel="next" title="How do I return the response from an asynchronous call?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
