<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>C++11 引入了标准化的内存模型。这是什么意思？它将如何影响 C++ 编程？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/c-11-yin-ru-liao-biao-zhun-hua-de-nei-cun-mo-xing-zhe-shi-shi-yao-yi-si-ta-jiang-ru-he-ying-xiang-c-bian-cheng/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-cha-kan-git-ti-jiao-zhong-de-geng-gai/" title="如何查看 Git 提交中的更改？" type="text/html">
<link rel="next" href="../ru-he-an-suo-yin-cong-lie-biao-zhong-shan-chu-yuan-su/" title="如何按索引从列表中删除元素" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="C++11 引入了标准化的内存模型。这是什么意思？它将如何影响 C++ 编程？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/c-11-yin-ru-liao-biao-zhun-hua-de-nei-cun-mo-xing-zhe-shi-shi-yao-yi-si-ta-jiang-ru-he-ying-xiang-c-bian-cheng/">
<meta property="og:description" content="C++11 引入了标准化的内存模型，但这到底意味着什么？它将如何影响 C++ 编程？
这篇文章（作者是 Gavin Clarke ，他引用了 Herb Sutter 的 话）说，

内存模型意味着 C++
代码现在有一个标准化的库可以调用，而不管编译器是谁制作的以及它在什么平台上运行。有一种标准方法可以控制不同线程如何与处理器内存通信。
“当你谈论在标准中的不同内核之间拆分 [代码] 时，我们谈论">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T22:29:48+08:00">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="cPlusPlus11">
<meta property="article:tag" content="language-lawyer">
<meta property="article:tag" content="memory-model">
<meta property="article:tag" content="multithreading">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">C++11 引入了标准化的内存模型。这是什么意思？它将如何影响 C++ 编程？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:29:48+08:00" itemprop="datePublished" title="2023-02-16 22:29">2023-02-16 22:29</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>C++11 引入了标准化的内存模型，但这到底意味着什么？它将如何影响 C++ 编程？</p>
<p>这篇文章（作者是 <strong>Gavin Clarke</strong> ，他引用了 <strong>Herb Sutter 的</strong> 话）说，</p>
<blockquote>
<p>内存模型意味着 C++
代码现在有一个标准化的库可以调用，而不管编译器是谁制作的以及它在什么平台上运行。有一种标准方法可以控制不同线程如何与处理器内存通信。</p>
<p>“当你谈论在标准中的不同内核之间拆分 [代码] 时，我们谈论的是内存模型。我们将在不破坏人们将在代码中做出的以下假设的情况下对其进行优化，”Sutter
<strong>说</strong> 。</p>
</blockquote>
<p>好吧，我可以 <em>记住</em>
这个和网上提供的类似段落（因为我从出生起就有了自己的记忆模型：P），甚至可以作为对其他人提出的问题的回答发布，但老实说，我不太明白这。</p>
<p>C++ 程序员以前甚至习惯于开发多线程应用程序，那么它是 POSIX 线程、Windows 线程还是 C++11
线程有什么关系呢？有什么好处？我想了解底层细节。</p>
<p>我也觉得 C++11 内存模型在某种程度上与 C++11 多线程支持有关，因为我经常看到这两者在一起。如果是，具体如何？他们为什么要相关？</p>
<p>我不知道多线程的内部是如何工作的，也不知道内存模型一般意味着什么。</p>
<p><br><br></p>
<h2>解答</h2>
<p>首先，你必须学会​​像语言律师一样思考。</p>
<p>C++ 规范不引用任何特定的编译器、操作系统或 CPU。它引用了一个 <em>抽象机器</em>
，它是实际系统的概括。在语言律师的世界里，程序员的工作是为抽象机编写代码；编译器的工作是在具体机器上实现该代码。通过严格按照规范进行编码，您可以确定您的代码无需修改即可在任何具有兼容
C++ 编译器的系统上编译和运行，无论是今天还是 50 年后。</p>
<p>C++98/C++03 规范中的抽​​象机基本上是单线程的。因此，编写关于规范“完全可移植”的多线程 C++
代码是不可能的。该规范甚至没有说明内存加载和存储的 <em>原子性</em> 或加载和存储可能发生的 <em>顺序</em> ，更不用说互斥锁之类的东西了。</p>
<p>当然，您可以在实践中为特定的具体系统（如 pthreads 或 Windows）编写多线程代码。但是C++98/C++03并没有编写多线程代码的
<em>标准方法。</em></p>
<p>C++11 中的抽象机在设计上是多线程的。它还具有定义明确的 <em>内存模型</em> ；也就是说，它说明了在访问内存时编译器可以做什么和不可以做什么。</p>
<p>考虑以下示例，其中两个线程同时访问一对全局变量：</p>
<div class="code"><pre class="code literal-block">           Global
           int x, y;

Thread 1            Thread 2
x = 17;             cout &lt;&lt; y &lt;&lt; " ";
y = 37;             cout &lt;&lt; x &lt;&lt; endl;
</pre></div>

<p>Thread 2 可能输出什么？</p>
<p>在 C++98/C++03 下，这甚至不是未定义行为；这个问题本身是 <em>没有意义的</em> ，因为该标准没有考虑任何称为“线程”的东西。</p>
<p>在 C++11 下，结果是未定义的行为，因为加载和存储通常不需要是原子的。这似乎不是很大的改进......而且就其本身而言，它不是。</p>
<p>但是对于 C++11，你可以这样写：</p>
<div class="code"><pre class="code literal-block"><span class="w">           </span><span class="n">Global</span>
<span class="w">           </span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="w">                 </span><span class="n">Thread</span><span class="w"> </span><span class="mi">2</span>
<span class="n">x</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">17</span><span class="p">);</span><span class="w">             </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">" "</span><span class="p">;</span>
<span class="n">y</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">37</span><span class="p">);</span><span class="w">             </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>现在事情变得有趣多了。首先 <em>定义</em> 这里的行为。线程 2 现在可以打印<code>0 0</code>（如果它在线程 1 之前运行），<code>37 17</code>（如果它在线程 1
之后运行），或者<code>0 17</code>（如果它在线程 1 分配给 x 之后但在分配给 y 之前运行）。</p>
<p>它不能打印的是<code>37 0</code>，因为 C++11 中原子加载/存储的默认模式是强制 <em>顺序一致性</em>
。这只是意味着所有加载和存储必须“好像”它们按照您在每个线程中编写它们的顺序发生，而线程之间的操作可以交错，但系统喜欢。因此，原子的默认行为为加载和存储提供了
<em>原子性</em> 和 <em>顺序</em> 。</p>
<p>现在，在现代 CPU
上，确保顺序一致性可能代价高昂。特别是，编译器可能会在此处的每次访问之间发出完全成熟的内存屏障。但是如果你的算法可以容忍无序的加载和存储；即，如果它需要原子性但不需要排序；即，如果它可以容忍<code>37
0</code>这个程序的输出，那么你可以这样写：</p>
<div class="code"><pre class="code literal-block"><span class="w">           </span><span class="n">Global</span>
<span class="w">           </span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="w">                            </span><span class="n">Thread</span><span class="w"> </span><span class="mi">2</span>
<span class="n">x</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">" "</span><span class="p">;</span>
<span class="n">y</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">37</span><span class="p">,</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>CPU 越现代，它就越有可能比前面的例子更快。</p>
<p>最后，如果您只需要保持特定的加载和存储顺序，您可以这样写：</p>
<div class="code"><pre class="code literal-block"><span class="w">           </span><span class="n">Global</span>
<span class="w">           </span><span class="n">atomic</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>

<span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="w">                            </span><span class="n">Thread</span><span class="w"> </span><span class="mi">2</span>
<span class="n">x</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">" "</span><span class="p">;</span>
<span class="n">y</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">37</span><span class="p">,</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w">   </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>这将我们带回到有序的加载和存储——因此<code>37
0</code>不再是可能的输出——但它以最小的开销实现了这一点。（在这个简单的例子中，结果与完全成熟的顺序一致性相同；在更大的程序中，情况就不同了。）</p>
<p>当然，如果您只想查看<code>0 0</code>或 的输出<code>37
17</code>，您可以只在原始代码周围包装一个互斥量。但是如果你已经读到这里，我敢打赌你已经知道它是如何工作的，而且这个答案已经比我预期的要长:-)。</p>
<p>所以，底线。互斥体很棒，C++11
将它们标准化。但有时出于性能原因，您需要较低级别的原语（例如，经典的双重检查锁定模式）。新标准提供了诸如互斥锁和条件变量之类的高级小工具，还提供了诸如原子类型和各种类型的内存屏障之类的低级小工具。因此，现在您可以完全使用标准指定的语言编写复杂的高性能并发例程，并且可以确定您的代码将在今天和明天的系统上编译和运行而不会发生任何变化。</p>
<p>尽管坦率地说，除非您是专家并且正在编写一些严肃的低级代码，否则您应该坚持使用互斥锁和条件变量。这就是我打算做的。</p>
<p>有关此内容的更多信息，请参阅此博客文章。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我将仅给出我理解内存一致性模型（或简称为内存模型）的类比。它的灵感来自 Leslie Lamport 的开创性论文“Time, Clocks, and
the Ordering of Events in a Distributed
System”。这个类比很贴切，也具有根本意义，但对很多人来说可能有点矫枉过正。但是，我希望它提供一个心理图像（图形表示），以促进对记忆一致性模型的推理。</p>
<p>让我们在时空图中查看所有内存位置的历史，其中横轴表示地址空间（即每个内存位置由该轴上的一个点表示），纵轴表示时间（我们将看到，一般来说，没有一个普遍的时间概念）。因此，每个内存位置所保存的值的历史由该内存地址处的垂直列表示。每个值的更改都是由于其中一个线程向该位置写入了一个新值。通过
_ <strong>内存映像，我们将表示</strong><em> _ <strong>特定线程</strong></em> 在 _ <strong>特定时间</strong><em> 可观察到的所有内存位置的值的聚合/组合。 _ ****</em></p>
<p>引自“内存一致性和缓存一致性入门”</p>
<blockquote>
<p>直观（也是限制性最强）的内存模型是顺序一致性 (SC)，其中多线程执行应该看起来像是每个组成线程的顺序执行的交错，就好像线程在单核处理器上是时分复用的。</p>
</blockquote>
<p>该全局内存顺序可能因程序的一次运行而异，并且事先可能不知道。SC 的特征是地址-空间-时间图中的一组水平切片，表示 _ <strong>同时性的平面</strong><em>
（即内存映像）。在给定平面上，其所有事件（或内存值）都是同时发生的。有一个 _绝对时间</em> 的概念，其中所有线程都同意哪些内存值是同时的。在 SC
中，在每个时刻，所有线程都只共享一个内存映像。也就是说，在任何时刻，所有处理器都对内存映像（即内存的聚合内容）达成一致。这不仅意味着所有线程都查看所有内存位置的相同值序列，而且所有处理器都观察到相同的值序列
__所有变量 <em>值的组合。</em> 这与所有线程以相同的总顺序观察所有内存操作（在所有内存位置上）是一样的。</p>
<p>在宽松的内存模型中，每个线程将以自己的方式划分地址空间时间，唯一的限制是每个线程的切片不得相互交叉，因为所有线程必须就每个单独的内存位置的历史达成一致（当然，不同线程的切片可能并且将会相互交叉）。没有通用的方法来分割它（没有地址-
空间-
时间的特权组合）。切片不必是平面的（或线性的）。它们可以是弯曲的，这可以使一个线程读取另一个线程写入的值，而不是它们写入的顺序。当任何特定线程查看时，不同内存位置的历史可能相对于彼此任意滑动（或拉伸
_ <strong>）</strong>_.
每个线程对于哪些事件（或者，等效地，内存值）是同时发生的会有不同的感觉。与一个线程同步的一组事件（或内存值）与另一个线程不同时。因此，在宽松的内存模型中，所有线程仍然观察每个内存位置的相同历史记录（即值序列）。但是他们可能会观察到不同的记忆图像（即所有记忆位置的值的组合）。即使同一个线程按顺序写入两个不同的内存位置，其他线程也可能以不同的顺序观察到这两个新写入的值。</p>
<p>[图片来自维基百科]<img alt="图片来自维基百科" src="https://upload.wikimedia.org/wikipedia/commons/f/f1/Relsim2.GIF"></p>
<p>熟悉爱因斯坦 <strong>狭义相对论的</strong> 读者会注意到我在暗示什么。将 Minkowski
的话翻译成内存模型领域：地址空间和时间是地址空间时间的影子。在这种情况下，每个观察者（即线程）都会将事件（即内存存储/加载）的阴影投射到他自己的世界线（即他的时间轴）和他自己的同时性平面（他的地址空间轴）上.
C++11 内存模型中的线程对应于狭义相对论中相对于彼此移动的 _ <strong>观察者。</strong>_ 顺序一致性对应于 <strong>伽利略时空</strong>
（即，所有观察者都同意事件的绝对顺序和全球同时性）。</p>
<p>记忆模型和狭义相对论之间的相似性源于这样一个事实，即两者都定义了一组部分有序的事件，通常称为因果集。一些事件（即记忆存储）可以影响（但不受）其他事件。C++11
线程（或物理学中的观察者）只不过是事件链（即完全有序的集合）（例如，内存加载和存储到可能不同的地址）。</p>
<p>在相对论中，一些秩序被恢复到部分有序事件的看似混乱的画面中，因为所有观察者都同意的唯一时间顺序是“类时间”事件之间的顺序（即，那些原则上可以通过任何粒子更慢地连接的事件比真空中的光速还快）。只有与时间相关的事件是不变的。物理学时间，克雷格卡伦德。</p>
<p>在C++11内存模型中，使用了类似的机制（获取-释放一致性模型）来建立这些 _ <strong>局部因果关系</strong>_ 。</p>
<p>为了提供内存一致性的定义和放弃 SC 的动机，我将引用“A Primer on Memory Consistency and Cache
Coherence”</p>
<blockquote>
<p>对于共享内存机器，内存一致性模型定义了其内存系统在体系结构上可见的行为。单个处理器核心的正确性标准将行为分为“ <em>一个正确的结果</em> ”和“
<em>许多不正确的选择</em>
”。这是因为处理器的体系结构要求线程的执行将给定输入状态转换为单个明确定义的输出状态，即使在无序内核上也是如此。然而，共享内存一致性模型涉及多个线程的加载和存储，并且通常允许
<em>许多正确执行</em> 同时不允许许多（更多）不正确的。多个正确执行的可能性是由于 ISA 允许多个线程并发执行，通常来自不同线程的指令有许多可能的合法交错。</p>
<p><em><strong>松散</strong></em> 或 _ <strong>弱</strong><em>
内存一致性模型的动机是强模型中的大多数内存排序都是不必要的。如果一个线程更新十个数据项，然后更新一个同步标志，程序员通常不关心数据项是否按顺序更新，而只关心在更新标志之前更新所有数据项（通常使用
FENCE 指令实现） ). _宽松模型试图捕捉这种增加的排序灵活性，并仅保留程序员“需要</em> 的”顺序 __”以获得更高的性能和 SC 的正确性。
例如，在某些架构中，每个内核使用 FIFO 写入缓冲区在将结果写入缓存之前保存提交（退役）存储的结果。这种优化提高了性能但违反了
SC。写入缓冲区隐藏了服务存储未命中的延迟。因为商店很常见，所以能够避免在大多数商店停滞不前是一个重要的好处。对于单核处理器，通过确保对地址 A
的加载将最近存储的值返回到 A，即使写入缓冲区中有一个或多个 A 的存储，也可以使写入缓冲区在体系结构上不可见。这通常是通过将最近存储到 A 的值绕过从
A 加载来完成的，其中“最近”由程序顺序确定，或者如果 A 的存储在写入缓冲区中，则通过停止 A
的加载。当使用多个内核时，每个内核都有自己的旁路写入缓冲区。没有写缓冲区，硬件是 SC，但有写缓冲区，它不是，使写缓冲区在多核处理器中在体系结构上可见。</p>
<p>如果内核具有非 FIFO
写入缓冲区，允许存储以不同于它们进入的顺序离开，则可能会发生存储存储重新排序。如果第一个存储在高速缓存中未命中而第二个命中，或者如果第二个存储可以与较早的存储合并（即，在第一个存储之前），则可能会发生这种情况。加载-
加载重新排序也可能发生在动态调度的核心上，这些核心执行程序顺序不正确的指令。这与在另一个核心上重新排序存储的行为相同（你能想出一个在两个线程之间交错的例子吗？）。用较晚的存储重新排序较早的加载（加载存储重新排序）可能会导致许多不正确的行为，例如在释放保护它的锁后加载值（如果存储是解锁操作）。</p>
</blockquote>
<p>因为缓存一致性和内存一致性有时会混淆，所以引用这句话很有启发性：</p>
<blockquote>
<p>与一致性不同， _ <strong>缓存一致性</strong><em> 对软件既不可见也不需要。Coherence
试图使共享内存系统的缓存在功能上与单核系统中的缓存一样不可见。正确的一致性确保程序员无法通过分析加载和存储的结果来确定系统是否以及在何处具有缓存。这是因为正确的一致性确保缓存永远不会启用新的或不同的
_ <strong>功能</strong></em> 行为（程序员可能仍然能够使用 _ <strong>时序推断可能的缓存结构</strong><em>
信息）。高速缓存一致性协议的主要目的是维护每个内存位置的单写入多读取器 (SWMR) 不变性。一致性和一致性之间的一个重要区别是一致性是在每个 _
<strong>内存位置的基础</strong></em> 上指定的，而一致性是针对 _ <strong>所有</strong>_ 内存位置指定的。</p>
</blockquote>
<p>继续我们的想象，SWMR 不变量对应于物理要求，即在任何一个位置最多有一个粒子，但任何位置都可以有无限数量的观察者。</p>
<p><br><br><a href="../c-11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-going-to-affect-c-programming/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus11/" rel="tag">cPlusPlus11</a></li>
            <li><a class="tag p-category" href="../../categories/language-lawyer/" rel="tag">language-lawyer</a></li>
            <li><a class="tag p-category" href="../../categories/memory-model/" rel="tag">memory-model</a></li>
            <li><a class="tag p-category" href="../../categories/multithreading/" rel="tag">multithreading</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-cha-kan-git-ti-jiao-zhong-de-geng-gai/" rel="prev" title="如何查看 Git 提交中的更改？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-an-suo-yin-cong-lie-biao-zhong-shan-chu-yuan-su/" rel="next" title="如何按索引从列表中删除元素">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
