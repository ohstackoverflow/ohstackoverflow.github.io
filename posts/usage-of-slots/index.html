<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Usage of __slots__? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/usage-of-slots/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-search-a-git-repository-by-commit-message/" title="How to search a Git repository by commit message?" type="text/html">
<link rel="next" href="../how-can-i-center-text-horizontally-and-vertically-inside-a-div-block/" title="How can I center text (horizontally and vertically) inside a div block?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Usage of __slots__?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/usage-of-slots/">
<meta property="og:description" content="What is the purpose of __slots__ in Python — especially with respect to when
I would want to use it, and when not?

Answer

In Python, what is the purpose of __slots__ and what are the cases one
shoul">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:11:06+08:00">
<meta property="article:tag" content="oop">
<meta property="article:tag" content="python">
<meta property="article:tag" content="python-internals">
<meta property="article:tag" content="slots">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Usage of __slots__?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:11:06+08:00" itemprop="datePublished" title="2023-02-17 05:11">2023-02-17 05:11</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What is the purpose of <code>__slots__</code> in Python — especially with respect to when
I would want to use it, and when not?</p>
<p><br><br></p>
<h2>Answer</h2>
<blockquote>
<h2>In Python, what is the purpose of <code>__slots__</code> and what are the cases one</h2>
<p>should avoid this?</p>
</blockquote>
<h3>TLDR:</h3>
<p>The special attribute <code>__slots__</code> allows you to explicitly state which
instance attributes you expect your object instances to have, with the
expected results:</p>
<ol>
<li>
<strong>faster</strong> attribute access.</li>
<li>
<strong>space savings</strong> in memory.</li>
</ol>
<p>The space savings is from</p>
<ol>
<li>Storing value references in slots instead of <code>__dict__</code>.</li>
<li>Denying <code>__dict__</code> and <code>__weakref__</code> creation if parent classes deny them and you declare <code>__slots__</code>.</li>
</ol>
<h4>Quick Caveats</h4>
<p>Small caveat, you should only declare a particular slot one time in an
inheritance tree. For example:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Base:</span>
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>

<span class="k">class</span> <span class="n">Right</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = <span class="s">'baz'</span>,

<span class="k">class</span> <span class="n">Wrong</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>, <span class="s">'baz'</span>        <span class="c1"># redundant foo and bar</span>
</pre></div>

<p>Python doesn't object when you get this wrong (it probably should), problems
might not otherwise manifest, but your objects will take up more space than
they otherwise should. Python 3.8:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">getsizeof</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">Right</span><span class="p">()),</span> <span class="n">getsizeof</span><span class="p">(</span><span class="n">Wrong</span><span class="p">())</span>
<span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="mi">72</span><span class="p">)</span>
</pre></div>

<p>This is because the Base's slot descriptor has a slot separate from the
Wrong's. This shouldn't usually come up, but it could:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; w = Wrong()
&gt;&gt;&gt; w.foo = 'foo'
&gt;&gt;&gt; Base.foo.__get__(w)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: foo
&gt;&gt;&gt; Wrong.foo.__get__(w)
'foo'
</pre></div>

<p>The biggest caveat is for multiple inheritance - multiple "parent classes with
nonempty slots" cannot be combined.</p>
<p>To accommodate this restriction, follow best practices: Factor out all but one
or all parents' abstraction which their concrete class respectively and your
new concrete class collectively will inherit from - giving the abstraction(s)
empty slots (just like abstract base classes in the standard library).</p>
<p>See section on multiple inheritance below for an example.</p>
<h4>Requirements:</h4>
<ul>
<li>
<p>To have attributes named in <code>__slots__</code> to actually be stored in slots instead of a <code>__dict__</code>, a class must inherit from <code>object</code> (automatic in Python 3, but must be explicit in Python 2).</p>
</li>
<li>
<p>To prevent the creation of a <code>__dict__</code>, you must inherit from <code>object</code> and all classes in the inheritance must declare <code>__slots__</code> and none of them can have a <code>'__dict__'</code> entry.</p>
</li>
</ul>
<p>There are a lot of details if you wish to keep reading.</p>
<h3>Why use <code>__slots__</code>: Faster attribute access.</h3>
<p>The creator of Python, Guido van Rossum, states that he actually created
<code>__slots__</code> for faster attribute access.</p>
<p>It is trivial to demonstrate measurably significant faster access:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">timeit</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">'foo'</span><span class="p">,</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">slotted</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">not_slotted</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">get_set_delete_fn</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_set_delete</span><span class="p">():</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="s1">'foo'</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
        <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
    <span class="k">return</span> <span class="n">get_set_delete</span>
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(slotted)))
0.2846834529991611
&gt;&gt;&gt; min(timeit.repeat(get_set_delete_fn(not_slotted)))
0.3664822799983085
</pre></div>

<p>The slotted access is almost 30% faster in Python 3.5 on Ubuntu.</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; 0.3664822799983085 / 0.2846834529991611
1.2873325658284342
</pre></div>

<p>In Python 2 on Windows I have measured it about 15% faster.</p>
<h3>Why use <code>__slots__</code>: Memory Savings</h3>
<p>Another purpose of <code>__slots__</code> is to reduce the space in memory that each
object instance takes up.</p>
<p>My own contribution to the documentation clearly states the reasons behind
this:</p>
<blockquote>
<p>The space saved over using <code>__dict__</code> can be significant.</p>
</blockquote>
<p>SQLAlchemy attributes a lot of memory savings to <code>__slots__</code>.</p>
<p>To verify this, using the Anaconda distribution of Python 2.7 on Ubuntu Linux,
with <code>guppy.hpy</code> (aka heapy) and <code>sys.getsizeof</code>, the size of a class instance
without <code>__slots__</code> declared, and nothing else, is 64 bytes. That does <em>not</em>
include the <code>__dict__</code>. Thank you Python for lazy evaluation again, the
<code>__dict__</code> is apparently not called into existence until it is referenced, but
classes without data are usually useless. When called into existence, the
<code>__dict__</code> attribute is a minimum of 280 bytes additionally.</p>
<p>In contrast, a class instance with <code>__slots__</code> declared to be <code>()</code> (no data)
is only 16 bytes, and 56 total bytes with one item in slots, 64 with two.</p>
<p>For 64 bit Python, I illustrate the memory consumption in bytes in Python 2.7
and 3.6, for <code>__slots__</code> and <code>__dict__</code> (no slots defined) for each point
where the dict grows in 3.6 (except for 0, 1, and 2 attributes):</p>
<div class="code"><pre class="code literal-block"><span class="w">       </span><span class="nv">Python</span><span class="w"> </span><span class="mi">2</span>.<span class="mi">7</span><span class="w">             </span><span class="nv">Python</span><span class="w"> </span><span class="mi">3</span>.<span class="mi">6</span>
<span class="nv">attrs</span><span class="w">  </span><span class="nv">__slots__</span><span class="w">  </span><span class="nv">__dict__</span><span class="o">*</span><span class="w">   </span><span class="nv">__slots__</span><span class="w">  </span><span class="nv">__dict__</span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="ss">(</span><span class="nv">no</span><span class="w"> </span><span class="nv">slots</span><span class="w"> </span><span class="nv">defined</span><span class="ss">)</span>
<span class="nv">none</span><span class="w">   </span><span class="mi">16</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span>†<span class="w">   </span><span class="mi">16</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>†<span class="w"> </span><span class="o">|</span><span class="w"> </span>†<span class="k">if</span><span class="w"> </span><span class="nv">__dict__</span><span class="w"> </span><span class="nv">referenced</span>
<span class="nv">one</span><span class="w">    </span><span class="mi">48</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span><span class="w">    </span><span class="mi">48</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>
<span class="nv">two</span><span class="w">    </span><span class="mi">56</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">272</span><span class="w">    </span><span class="mi">56</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">112</span>
<span class="nv">six</span><span class="w">    </span><span class="mi">88</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1040</span><span class="w">   </span><span class="mi">88</span><span class="w">         </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">152</span>
<span class="mi">11</span><span class="w">     </span><span class="mi">128</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1040</span><span class="w">   </span><span class="mi">128</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">240</span>
<span class="mi">22</span><span class="w">     </span><span class="mi">216</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3344</span><span class="w">   </span><span class="mi">216</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">408</span><span class="w">     </span>
<span class="mi">43</span><span class="w">     </span><span class="mi">384</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3344</span><span class="w">   </span><span class="mi">384</span><span class="w">        </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">752</span>
</pre></div>

<p>So, in spite of smaller dicts in Python 3, we see how nicely <code>__slots__</code> scale
for instances to save us memory, and that is a major reason you would want to
use <code>__slots__</code>.</p>
<p>Just for completeness of my notes, note that there is a one-time cost per slot
in the class's namespace of 64 bytes in Python 2, and 72 bytes in Python 3,
because slots use data descriptors like properties, called "members".</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; Foo.foo
&lt;member 'foo' of 'Foo' objects&gt;
&gt;&gt;&gt; type(Foo.foo)
&lt;class 'member_descriptor'&gt;
&gt;&gt;&gt; getsizeof(Foo.foo)
72
</pre></div>

<h3>Demonstration of <code>__slots__</code>:</h3>
<p>To deny the creation of a <code>__dict__</code>, you must subclass <code>object</code>. Everything
subclasses <code>object</code> in Python 3, but in Python 2 you had to be explicit:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Base</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = ()
</pre></div>

<p>now:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; b = Base()
&gt;&gt;&gt; b.a = 'a'
Traceback (most recent call last):
  File "&lt;pyshell#38&gt;", line 1, in &lt;module&gt;
    b.a = 'a'
AttributeError: 'Base' object has no attribute 'a'
</pre></div>

<p>Or subclass another class that defines <code>__slots__</code></p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Child</span>(<span class="n">Base</span>):
    <span class="n">__slots__</span> = (<span class="s">'a'</span>,)
</pre></div>

<p>and now:</p>
<div class="code"><pre class="code literal-block">c = Child()
c.a = 'a'
</pre></div>

<p>but:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c.b = 'b'
Traceback (most recent call last):
  File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt;
    c.b = 'b'
AttributeError: 'Child' object has no attribute 'b'
</pre></div>

<p>To allow <code>__dict__</code> creation while subclassing slotted objects, just add
<code>'__dict__'</code> to the <code>__slots__</code> (note that slots are ordered, and you
shouldn't repeat slots that are already in parent classes):</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">SlottedWithDict</span>(<span class="n">Child</span>): 
    <span class="n">__slots__</span> = (<span class="s">'__dict__'</span>, <span class="s">'b'</span>)

<span class="n">swd</span> = <span class="n">SlottedWithDict</span>()
<span class="n">swd</span>.<span class="n">a</span> = <span class="s">'a'</span>
<span class="n">swd</span>.<span class="n">b</span> = <span class="s">'b'</span>
<span class="n">swd</span>.<span class="n">c</span> = <span class="s">'c'</span>
</pre></div>

<p>and</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; swd.__dict__
{'c': 'c'}
</pre></div>

<p>Or you don't even need to declare <code>__slots__</code> in your subclass, and you will
still use slots from the parents, but not restrict the creation of a
<code>__dict__</code>:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">NoSlots</span>(<span class="n">Child</span>): <span class="nb">pass</span>
<span class="n">ns</span> = <span class="n">NoSlots</span>()
<span class="n">ns</span>.<span class="n">a</span> = <span class="s">'a'</span>
<span class="n">ns</span>.<span class="n">b</span> = <span class="s">'b'</span>
</pre></div>

<p>And:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; ns.__dict__
{'b': 'b'}
</pre></div>

<p>However, <code>__slots__</code> may cause problems for multiple inheritance:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">BaseA</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = (<span class="s">'a'</span>,)

<span class="k">class</span> <span class="n">BaseB</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = (<span class="s">'b'</span>,)
</pre></div>

<p>Because creating a child class from parents with both non-empty slots fails:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; class Child(BaseA, BaseB): __slots__ = ()
Traceback (most recent call last):
  File "&lt;pyshell#68&gt;", line 1, in &lt;module&gt;
    class Child(BaseA, BaseB): __slots__ = ()
TypeError: Error when calling the metaclass bases
    multiple bases have instance lay-out conflict
</pre></div>

<p>If you run into this problem, You <em>could</em> just remove <code>__slots__</code> from the
parents, or if you have control of the parents, give them empty slots, or
refactor to abstractions:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>

<span class="k">class</span> <span class="nc">AbstractA</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">BaseA</span><span class="p">(</span><span class="n">AbstractA</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,)</span>

<span class="k">class</span> <span class="nc">AbstractB</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">BaseB</span><span class="p">(</span><span class="n">AbstractB</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">AbstractA</span><span class="p">,</span> <span class="n">AbstractB</span><span class="p">):</span> 
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Child</span><span class="p">()</span> <span class="c1"># no problem!</span>
</pre></div>

<h4>Add <code>'__dict__'</code> to <code>__slots__</code> to get dynamic assignment:</h4>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>):
    <span class="n">__slots__</span> = <span class="s">'bar'</span>, <span class="s">'baz'</span>, <span class="s">'__dict__'</span>
</pre></div>

<p>and now:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.boink = 'boink'
</pre></div>

<p>So with <code>'__dict__'</code> in slots we lose some of the size benefits with the
upside of having dynamic assignment and still having slots for the names we do
expect.</p>
<p>When you inherit from an object that isn't slotted, you get the same sort of
semantics when you use <code>__slots__</code> - names that are in <code>__slots__</code> point to
slotted values, while any other values are put in the instance's <code>__dict__</code>.</p>
<p>Avoiding <code>__slots__</code> because you want to be able to add attributes on the fly
is actually not a good reason - just add <code>"__dict__"</code> to your <code>__slots__</code> if
this is required.</p>
<p>You can similarly add <code>__weakref__</code> to <code>__slots__</code> explicitly if you need that
feature.</p>
<h4>Set to empty tuple when subclassing a namedtuple:</h4>
<p>The namedtuple builtin make immutable instances that are very lightweight
(essentially, the size of tuples) but to get the benefits, you need to do it
yourself if you subclass them:</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="k">class</span> <span class="nc">MyNT</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">'MyNT'</span><span class="p">,</span> <span class="s1">'bar baz'</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">"""MyNT is an immutable and lightweight object"""</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>

<p>usage:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; nt = MyNT('bar', 'baz')
&gt;&gt;&gt; nt.bar
'bar'
&gt;&gt;&gt; nt.baz
'baz'
</pre></div>

<p>And trying to assign an unexpected attribute raises an <code>AttributeError</code>
because we have prevented the creation of <code>__dict__</code>:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; nt.quux = 'quux'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'MyNT' object has no attribute 'quux'
</pre></div>

<p>You <em>can</em> allow <code>__dict__</code> creation by leaving off <code>__slots__ = ()</code>, but you
can't use non-empty <code>__slots__</code> with subtypes of tuple.</p>
<h3>Biggest Caveat: Multiple inheritance</h3>
<p>Even when non-empty slots are the same for multiple parents, they cannot be
used together:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>): 
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>
<span class="k">class</span> <span class="n">Bar</span>(<span class="n">object</span>):
    <span class="n">__slots__</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span> <span class="c1"># alas, would work if empty, i.e. ()</span>

&gt;&gt;&gt; <span class="k">class</span> <span class="n">Baz</span>(<span class="n">Foo</span>, <span class="n">Bar</span>): <span class="nb">pass</span>
<span class="n">Traceback</span> (<span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="nb">last</span>):
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span>, <span class="nb">line</span> <span class="mi">1</span>, <span class="nb">in</span> <span class="s">&lt;module&gt;</span>
<span class="n">TypeError:</span> <span class="n">Error</span> <span class="k">when</span> <span class="n">calling</span> <span class="n">the</span> <span class="n">metaclass</span> <span class="n">bases</span>
    <span class="n">multiple</span> <span class="n">bases</span> <span class="n">have</span> <span class="n">instance</span> <span class="n">lay-out</span> <span class="n">conflict</span>
</pre></div>

<p>Using an empty <code>__slots__</code> in the parent seems to provide the most
flexibility, <strong>allowing the child to choose to prevent or allow</strong> (by adding
<code>'__dict__'</code> to get dynamic assignment, see section above) <strong>the creation of
a<code>__dict__</code></strong>:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">object</span>): <span class="n">__slots__</span> = ()
<span class="k">class</span> <span class="n">Bar</span>(<span class="n">object</span>): <span class="n">__slots__</span> = ()
<span class="k">class</span> <span class="n">Baz</span>(<span class="n">Foo</span>, <span class="n">Bar</span>): <span class="n">__slots__</span> = (<span class="s">'foo'</span>, <span class="s">'bar'</span>)
<span class="n">b</span> = <span class="n">Baz</span>()
<span class="n">b</span>.<span class="n">foo</span>, <span class="n">b</span>.<span class="n">bar</span> = <span class="s">'foo'</span>, <span class="s">'bar'</span>
</pre></div>

<p>You don't <em>have</em> to have slots - so if you add them, and remove them later, it
shouldn't cause any problems.</p>
<p><strong>Going out on a limb here</strong> : If you're composing mixins or using abstract
base classes, which aren't intended to be instantiated, an empty <code>__slots__</code>
in those parents seems to be the best way to go in terms of flexibility for
subclassers.</p>
<p>To demonstrate, first, let's create a class with code we'd like to use under
multiple inheritance</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">AbstractBase:</span>
    <span class="n">__slots__</span> = ()
    <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="n">a</span>, <span class="n">b</span>):
        <span class="nb">self</span>.<span class="n">a</span> = <span class="n">a</span>
        <span class="nb">self</span>.<span class="n">b</span> = <span class="n">b</span>
    <span class="n">def</span> <span class="n">__repr__</span>(<span class="nb">self</span>):
        <span class="k">return</span> <span class="n">f'</span>{<span class="nb">type</span>(<span class="nb">self</span>).<span class="n">__name__</span>}({<span class="k">repr</span>(<span class="nb">self</span>.<span class="n">a</span>)}, {<span class="k">repr</span>(<span class="nb">self</span>.<span class="n">b</span>)})'
</pre></div>

<p>We could use the above directly by inheriting and declaring the expected
slots:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Foo</span>(<span class="n">AbstractBase</span>):
    <span class="n">__slots__</span> = <span class="s">'a'</span>, <span class="s">'b'</span>
</pre></div>

<p>But we don't care about that, that's trivial single inheritance, we need
another class we might also inherit from, maybe with a noisy attribute:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nl">AbstractBaseC</span><span class="p">:</span>
<span class="w">    </span><span class="n">__slots__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="nv">@property</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="s1">'getting c!'</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_c</span>
<span class="w">    </span><span class="nv">@c</span><span class="p">.</span><span class="n">setter</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="s1">'setting c!'</span><span class="p">)</span>
<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span>
</pre></div>

<p>Now if both bases had nonempty slots, we couldn't do the below. (In fact, if
we wanted, we could have given <code>AbstractBase</code> nonempty slots a and b, and left
them out of the below declaration - leaving them in would be wrong):</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Concretion</span>(<span class="n">AbstractBase</span>, <span class="n">AbstractBaseC</span>):
    <span class="n">__slots__</span> = <span class="s">'a b _c'</span>.<span class="nb">split</span>()
</pre></div>

<p>And now we have functionality from both via multiple inheritance, and can
still deny <code>__dict__</code> and <code>__weakref__</code> instantiation:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; c = Concretion('a', 'b')
&gt;&gt;&gt; c.c = c
setting c!
&gt;&gt;&gt; c.c
getting c!
Concretion('a', 'b')
&gt;&gt;&gt; c.d = 'd'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Concretion' object has no attribute 'd'
</pre></div>

<h3>Other cases to avoid slots:</h3>
<ul>
<li>Avoid them when you want to perform <code>__class__</code> assignment with another class that doesn't have them (and you can't add them) unless the slot layouts are identical. (I am very interested in learning who is doing this and why.)</li>
<li>Avoid them if you want to subclass variable length builtins like long, tuple, or str, and you want to add attributes to them.</li>
<li>Avoid them if you insist on providing default values via class attributes for instance variables.</li>
</ul>
<p>You may be able to tease out further caveats from the rest of the <code>__slots__</code>
documentation (the 3.7 dev docs are the most current), which I have made
significant recent contributions to.</p>
<h3>Critiques of other answers</h3>
<p>The current top answers cite outdated information and are quite hand-wavy and
miss the mark in some important ways.</p>
<h4>Do not "only use <code>__slots__</code> when instantiating lots of objects"</h4>
<p>I quote:</p>
<blockquote>
<p>"You would want to use <code>__slots__</code> if you are going to instantiate a lot
(hundreds, thousands) of objects of the same class."</p>
</blockquote>
<p>Abstract Base Classes, for example, from the <code>collections</code> module, are not
instantiated, yet <code>__slots__</code> are declared for them.</p>
<p>Why?</p>
<p>If a user wishes to deny <code>__dict__</code> or <code>__weakref__</code> creation, those things
must not be available in the parent classes.</p>
<p><code>__slots__</code> contributes to reusability when creating interfaces or mixins.</p>
<p>It is true that many Python users aren't writing for reusability, but when you
are, having the option to deny unnecessary space usage is valuable.</p>
<h4>
<code>__slots__</code> doesn't break pickling</h4>
<p>When pickling a slotted object, you may find it complains with a misleading
<code>TypeError</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="n">TypeError</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">defines</span><span class="w"> </span><span class="n">__slots__</span><span class="w"> </span><span class="n">without</span><span class="w"> </span><span class="n">defining</span><span class="w"> </span><span class="n">__getstate__</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">pickled</span>
</pre></div>

<p>This is actually incorrect. This message comes from the oldest protocol, which
is the default. You can select the latest protocol with the <code>-1</code> argument. In
Python 2.7 this would be <code>2</code> (which was introduced in 2.3), and in 3.6 it is
<code>4</code>.</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>in Python 2.7:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>in Python 3.6</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Foo</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mh">0x1129C770</span><span class="o">&gt;</span>
</pre></div>

<p>So I would keep this in mind, as it is a solved problem.</p>
<h3>Critique of the (until Oct 2, 2016) accepted answer</h3>
<p>The first paragraph is half short explanation, half predictive. Here's the
only part that actually answers the question</p>
<blockquote>
<p>The proper use of <code>__slots__</code> is to save space in objects. Instead of having
a dynamic dict that allows adding attributes to objects at anytime, there is
a static structure which does not allow additions after creation. This saves
the overhead of one dict for every object that uses slots</p>
</blockquote>
<p>The second half is wishful thinking, and off the mark:</p>
<blockquote>
<p>While this is sometimes a useful optimization, it would be completely
unnecessary if the Python interpreter was dynamic enough so that it would
only require the dict when there actually were additions to the object.</p>
</blockquote>
<p>Python actually does something similar to this, only creating the <code>__dict__</code>
when it is accessed, but creating lots of objects with no data is fairly
ridiculous.</p>
<p>The second paragraph oversimplifies and misses actual reasons to avoid
<code>__slots__</code>. The below is <em>not</em> a real reason to avoid slots (for <em>actual</em>
reasons, see the rest of my answer above.):</p>
<blockquote>
<p>They change the behavior of the objects that have slots in a way that can be
abused by control freaks and static typing weenies.</p>
</blockquote>
<p>It then goes on to discuss other ways of accomplishing that perverse goal with
Python, not discussing anything to do with <code>__slots__</code>.</p>
<p>The third paragraph is more wishful thinking. Together it is mostly off-the-
mark content that the answerer didn't even author and contributes to
ammunition for critics of the site.</p>
<h2>Memory usage evidence</h2>
<p>Create some normal objects and slotted objects:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; class Foo(object): pass
&gt;&gt;&gt; class Bar(object): __slots__ = ()
</pre></div>

<p>Instantiate a million of them:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">foos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">Foo</span><span class="ss">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">xrange</span><span class="ss">(</span><span class="mi">1000000</span><span class="ss">)</span>]
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">bars</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">Bar</span><span class="ss">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">xrange</span><span class="ss">(</span><span class="mi">1000000</span><span class="ss">)</span>]
</pre></div>

<p>Inspect with <code>guppy.hpy().heap()</code>:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; guppy.hpy().heap()
Partition of a set of 2028259 objects. Total size = 99763360 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0 1000000  49 64000000  64  64000000  64 __main__.Foo
     1     169   0 16281480  16  80281480  80 list
     2 1000000  49 16000000  16  96281480  97 __main__.Bar
     3   12284   1   987472   1  97268952  97 str
...
</pre></div>

<p>Access the regular objects and their <code>__dict__</code> and inspect again:</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">foos</span>:
...<span class="w">     </span><span class="nv">f</span>.<span class="nv">__dict__</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="nv">guppy</span>.<span class="nv">hpy</span><span class="ss">()</span>.<span class="nv">heap</span><span class="ss">()</span>
<span class="nv">Partition</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">set</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="mi">3028258</span><span class="w"> </span><span class="nv">objects</span>.<span class="w"> </span><span class="nv">Total</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">379763480</span><span class="w"> </span><span class="nv">bytes</span>.
<span class="w"> </span><span class="nv">Index</span><span class="w">  </span><span class="nv">Count</span><span class="w">   </span><span class="o">%</span><span class="w">      </span><span class="nv">Size</span><span class="w">    </span><span class="o">%</span><span class="w"> </span><span class="nv">Cumulative</span><span class="w">  </span><span class="o">%</span><span class="w"> </span><span class="nv">Kind</span><span class="w"> </span><span class="ss">(</span><span class="nv">class</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nv">dict</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">class</span><span class="ss">)</span>
<span class="w">     </span><span class="mi">0</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w"> </span><span class="mi">280000000</span><span class="w">  </span><span class="mi">74</span><span class="w"> </span><span class="mi">280000000</span><span class="w">  </span><span class="mi">74</span><span class="w"> </span><span class="nv">dict</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Foo</span>
<span class="w">     </span><span class="mi">1</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w">  </span><span class="mi">64000000</span><span class="w">  </span><span class="mi">17</span><span class="w"> </span><span class="mi">344000000</span><span class="w">  </span><span class="mi">91</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Foo</span>
<span class="w">     </span><span class="mi">2</span><span class="w">     </span><span class="mi">169</span><span class="w">   </span><span class="mi">0</span><span class="w">  </span><span class="mi">16281480</span><span class="w">   </span><span class="mi">4</span><span class="w"> </span><span class="mi">360281480</span><span class="w">  </span><span class="mi">95</span><span class="w"> </span><span class="nv">list</span>
<span class="w">     </span><span class="mi">3</span><span class="w"> </span><span class="mi">1000000</span><span class="w">  </span><span class="mi">33</span><span class="w">  </span><span class="mi">16000000</span><span class="w">   </span><span class="mi">4</span><span class="w"> </span><span class="mi">376281480</span><span class="w">  </span><span class="mi">99</span><span class="w"> </span><span class="nv">__main__</span>.<span class="nv">Bar</span>
<span class="w">     </span><span class="mi">4</span><span class="w">   </span><span class="mi">12284</span><span class="w">   </span><span class="mi">0</span><span class="w">    </span><span class="mi">987472</span><span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="mi">377268952</span><span class="w">  </span><span class="mi">99</span><span class="w"> </span><span class="nv">str</span>
...
</pre></div>

<p>This is consistent with the history of Python, from Unifying types and classes
in Python 2.2</p>
<blockquote>
<p>If you subclass a built-in type, extra space is automatically added to the
instances to accomodate <code>__dict__</code> and <code>__weakrefs__</code>. (The <code>__dict__</code> is
not initialized until you use it though, so you shouldn't worry about the
space occupied by an empty dictionary for each instance you create.) If you
don't need this extra space, you can add the phrase "<code>__slots__ = []</code>" to
your class.</p>
</blockquote>
<p><br></p>
<h3>Suggest</h3>
<p>Quoting Jacob Hallen:</p>
<blockquote>
<p>The proper use of <code>__slots__</code> is to save space in objects. Instead of having
a dynamic dict that allows adding attributes to objects at anytime, there is
a static structure which does not allow additions after creation. [This use
of <code>__slots__</code> eliminates the overhead of one dict for every object.] While
this is sometimes a useful optimization, it would be completely unnecessary
if the Python interpreter was dynamic enough so that it would only require
the dict when there actually were additions to the object.</p>
<p>Unfortunately there is a side effect to slots. They change the behavior of
the objects that have slots in a way that can be abused by control freaks
and static typing weenies. This is bad, because the control freaks should be
abusing the metaclasses and the static typing weenies should be abusing
decorators, since in Python, there should be only one obvious way of doing
something.</p>
<p>Making CPython smart enough to handle saving space without <code>__slots__</code> is a
major undertaking, which is probably why it is not on the list of changes
for P3k (yet).</p>
</blockquote>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/python-internals/" rel="tag">python-internals</a></li>
            <li><a class="tag p-category" href="../../categories/slots/" rel="tag">slots</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-search-a-git-repository-by-commit-message/" rel="prev" title="How to search a Git repository by commit message?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-can-i-center-text-horizontally-and-vertically-inside-a-div-block/" rel="next" title="How can I center text (horizontally and vertically) inside a div block?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
