<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What does T&amp;&amp; (double ampersand) mean in C++11? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-does-t-double-ampersand-mean-in-c-11/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/" title='In CSS Flexbox, why are there no "justify-items" and "justify-self" properties?' type="text/html">
<link rel="next" href="../how-can-one-change-the-timestamp-of-an-old-commit-in-git/" title="How can one change the timestamp of an old commit in Git?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What does T&amp;&amp; (double ampersand) mean in C++11?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-does-t-double-ampersand-mean-in-c-11/">
<meta property="og:description" content="I've been looking into some of the new features of C++11 and one I've noticed
is the double ampersand in declaring variables, like T&amp;&amp; var.
For a start, what is this beast called? I wish Google would ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T07:13:35+08:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="c++11">
<meta property="article:tag" content="c++-faq">
<meta property="article:tag" content="perfect-forwarding">
<meta property="article:tag" content="rvalue-reference">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What does T&amp;&amp; (double ampersand) mean in C++11?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:13:35+08:00" itemprop="datePublished" title="2023-02-17 07:13">2023-02-17 07:13</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I've been looking into some of the new features of C++11 and one I've noticed
is the double ampersand in declaring variables, like <code>T&amp;&amp; var</code>.</p>
<p>For a start, what is this beast called? I wish Google would allow us to search
for punctuation like this.</p>
<p>What exactly does it <em>mean?</em></p>
<p>At first glance, it appears to be a double reference (like the C-style double
pointers <code>T** var</code>), but I'm having a hard time thinking of a use case for
that.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>It declares an rvalue reference (standards proposal doc).</p>
<p>Here's an introduction to rvalue references.</p>
<p>Here's a fantastic in-depth look at rvalue references by one of Microsoft's
standard library developers.</p>
<blockquote>
<p><em><strong>CAUTION:</strong> the linked article on MSDN ("Rvalue References: C++0x Features
in VC10, Part 2") is a very clear introduction to Rvalue references, but
makes statements about Rvalue references that were once true in the draft
C++11 standard, but are not true for the final one! Specifically, it says at
various points that rvalue references can bind to lvalues, which was once
true, but was changed.(e.g. int x; int &amp;&amp;rrx = x; no longer compiles in GCC)
– drewbarbs Jul 13 '14 at 16:12</em></p>
</blockquote>
<p>The biggest difference between a C++03 reference (now called an lvalue
reference in C++11) is that it can bind to an rvalue like a temporary without
having to be const. Thus, this syntax is now legal:</p>
<div class="code"><pre class="code literal-block">T&amp;&amp; r = T();
</pre></div>

<p>rvalue references primarily provide for the following:</p>
<p><strong>Move semantics</strong>. A move constructor and move assignment operator can now be
defined that takes an rvalue reference instead of the usual const-lvalue
reference. A move functions like a copy, except it is not obliged to keep the
source unchanged; in fact, it usually modifies the source such that it no
longer owns the moved resources. This is great for eliminating extraneous
copies, especially in standard library implementations.</p>
<p>For example, a copy constructor might look like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">];</span>
<span class="w">    </span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>If this constructor were passed a temporary, the copy would be unnecessary
because we know the temporary will just be destroyed; why not make use of the
resources the temporary already allocated? In C++03, there's no way to prevent
the copy as we cannot determine whether we were passed a temporary. In C++11,
we can overload a move constructor:</p>
<div class="code"><pre class="code literal-block"><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">this</span><span class="o">-&gt;</span><span class="nf">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="nf">length</span><span class="p">;</span>
<span class="w">   </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">   </span><span class="n">other</span><span class="p">.</span><span class="nf">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>Notice the big difference here: the move constructor actually modifies its
argument. This would effectively "move" the temporary into the object being
constructed, thereby eliminating the unnecessary copy.</p>
<p>The move constructor would be used for temporaries and for non-const lvalue
references that are explicitly converted to rvalue references using the
<code>std::move</code> function (it just performs the conversion). The following code
both invoke the move constructor for <code>f1</code> and <code>f2</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nt">foo</span><span class="w"> </span><span class="nt">f1</span><span class="o">((</span><span class="nt">foo</span><span class="o">()));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Move</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">temporary</span><span class="w"> </span><span class="nt">into</span><span class="w"> </span><span class="nt">f1</span><span class="o">;</span><span class="w"> </span><span class="nt">temporary</span><span class="w"> </span><span class="nt">becomes</span><span class="w"> </span><span class="s2">"empty"</span>
<span class="nt">foo</span><span class="w"> </span><span class="nt">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">f1</span><span class="o">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">Move</span><span class="w"> </span><span class="nt">f1</span><span class="w"> </span><span class="nt">into</span><span class="w"> </span><span class="nt">f2</span><span class="o">;</span><span class="w"> </span><span class="nt">f1</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">now</span><span class="w"> </span><span class="s2">"empty"</span>
</pre></div>

<p><strong>Perfect forwarding</strong>. rvalue references allow us to properly forward
arguments for templated functions. Take for example this factory function:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">A1</span><span class="o">&gt;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">factory</span><span class="o">(</span><span class="nt">A1</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">a1</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">a1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>If we called <code>factory&lt;foo&gt;(5)</code>, the argument will be deduced to be <code>int&amp;</code>,
which will not bind to a literal 5, even if <code>foo</code>'s constructor takes an
<code>int</code>. Well, we could instead use <code>A1 const&amp;</code>, but what if <code>foo</code> takes the
constructor argument by non-const reference? To make a truly generic factory
function, we would have to overload factory on <code>A1&amp;</code> and on <code>A1 const&amp;</code>. That
might be fine if factory takes 1 parameter type, but each additional parameter
type would multiply the necessary overload set by 2. That's very quickly
unmaintainable.</p>
<p>rvalue references fix this problem by allowing the standard library to define
a <code>std::forward</code> function that can properly forward lvalue/rvalue references.
For more information about how <code>std::forward</code> works, see this excellent
answer.</p>
<p>This enables us to define the factory function like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">A1</span><span class="o">&gt;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">unique_ptr</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">factory</span><span class="o">(</span><span class="nt">A1</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">a1</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a1</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>

<p>Now the argument's rvalue/lvalue-ness is preserved when passed to <code>T</code>'s
constructor. That means that if factory is called with an rvalue, <code>T</code>'s
constructor is called with an rvalue. If factory is called with an lvalue,
<code>T</code>'s constructor is called with an lvalue. The improved factory function
works because of one special rule:</p>
<blockquote>
<p>When the function parameter type is of the form <code>T&amp;&amp;</code> where <code>T</code> is a
template parameter, and the function argument is an lvalue of type <code>A</code>, the
type <code>A&amp;</code> is used for template argument deduction.</p>
</blockquote>
<p>Thus, we can use factory like so:</p>
<div class="code"><pre class="code literal-block"><span class="n">auto</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="o">&amp;&amp;</span><span class="p">)</span>
<span class="n">auto</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">);</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>
</pre></div>

<p><strong>Important rvalue reference properties</strong> :</p>
<ul>
<li>For overload resolution, <strong>lvalues prefer binding to lvalue references and rvalues prefer binding to rvalue references</strong>. Hence why temporaries prefer invoking a move constructor / move assignment operator over a copy constructor / assignment operator.</li>
<li>
<strong>rvalue references will implicitly bind to rvalues and to temporaries that are the result of an implicit conversion</strong>. i.e. <code>float f = 0f; int&amp;&amp; i = f;</code> is well formed because float is implicitly convertible to int; the reference would be to a temporary that is the result of the conversion.</li>
<li>
<strong>Named rvalue references are lvalues. Unnamed rvalue references are rvalues.</strong> This is important to understand why the <code>std::move</code> call is necessary in: <code>foo&amp;&amp; r = foo(); foo f = std::move(r);</code>
</li>
</ul>
<p><br></p>
<h3>Suggest</h3>
<p>It denotes an rvalue reference. Rvalue references will only bind to temporary
objects, unless explicitly generated otherwise. They are used to make objects
much more efficient under certain circumstances, and to provide a facility
known as perfect forwarding, which greatly simplifies template code.</p>
<p>In C++03, you can't distinguish between a copy of a non-mutable lvalue and an
rvalue.</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">another</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">more</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>

<p>In C++0x, this is not the case.</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">another</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="w"> </span><span class="n">more</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>

<p>Consider the implementation behind these constructors. In the first case, the
string has to perform a copy to retain value semantics, which involves a new
heap allocation. However, in the second case, we know in advance that the
object which was passed in to our constructor is immediately due for
destruction, and it doesn't have to remain untouched. We can effectively just
swap the internal pointers and not perform any copying at all in this
scenario, which is substantially more efficient. Move semantics benefit any
class which has expensive or prohibited copying of internally referenced
resources. Consider the case of <code>std::unique_ptr</code>- now that our class can
distinguish between temporaries and non-temporaries, we can make the move
semantics work correctly so that the <code>unique_ptr</code> cannot be copied but can be
moved, which means that <code>std::unique_ptr</code> can be legally stored in Standard
containers, sorted, etc, whereas C++03's <code>std::auto_ptr</code> cannot.</p>
<p>Now we consider the other use of rvalue references- perfect forwarding.
Consider the question of binding a reference to a reference.</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="w"> </span><span class="nt">s</span><span class="o">;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">s</span><span class="o">;</span>
<span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;)&amp;</span><span class="w"> </span><span class="nt">anotherref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">ref</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">usually</span><span class="w"> </span><span class="nt">expressed</span><span class="w"> </span><span class="nt">via</span><span class="w"> </span><span class="nt">template</span>
</pre></div>

<p>Can't recall what C++03 says about this, but in C++0x, the resultant type when
dealing with rvalue references is critical. An rvalue reference to a type T,
where T is a reference type, becomes a reference of type T.</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span>
<span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span>
<span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;&amp;</span>
</pre></div>

<p>Consider the simplest template function- min and max. In C++03 you have to
overload for all four combinations of const and non-const manually. In C++0x
it's just one overload. Combined with variadic templates, this enables perfect
forwarding.</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">aref</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">bref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="k">pass</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">argument</span><span class="p">,</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">extension</span><span class="p">,</span><span class="w"> </span><span class="n">aref</span><span class="w"> </span><span class="n">becomes</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">completely</span><span class="w"> </span><span class="n">maintaining</span><span class="w"> </span><span class="n">it</span><span class="s1">'s type information.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aref</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bref</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aref</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bref</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>I left off the return type deduction, because I can't recall how it's done
offhand, but that min can accept any combination of lvalues, rvalues, const
lvalues.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B11/" rel="tag">c++11</a></li>
            <li><a class="tag p-category" href="../../categories/c%2B%2B-faq/" rel="tag">c++-faq</a></li>
            <li><a class="tag p-category" href="../../categories/perfect-forwarding/" rel="tag">perfect-forwarding</a></li>
            <li><a class="tag p-category" href="../../categories/rvalue-reference/" rel="tag">rvalue-reference</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/" rel="prev" title='In CSS Flexbox, why are there no "justify-items" and "justify-self" properties?'>Previous post</a>
            </li>
            <li class="next">
                <a href="../how-can-one-change-the-timestamp-of-an-old-commit-in-git/" rel="next" title="How can one change the timestamp of an old commit in Git?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
