<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>“取消引用”指针是什么意思？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/qu-xiao-yin-yong-zhi-zhen-shi-shi-yao-yi-si/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../javazhong-ru-he-que-ding-dui-xiang-de-da-xiao/" title="Java中如何确定对象的大小" type="text/html">
<link rel="next" href="../async-await-he-shi-fan-hui-task-yu-void/" title="async/await - 何时返回 Task 与 void？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="“取消引用”指针是什么意思？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/qu-xiao-yin-yong-zhi-zhen-shi-shi-yao-yi-si/">
<meta property="og:description" content="请附上一个例子和解释。

解答
复习基本术语
它 通常 足够好 - 除非你正在编写汇编 - 设想一个包含数字内存地址的  指针 ，其中 1 指的是进程内存中的第二个字节，2
是第三个字节，3 是第四个字节等等......

0 和第一个字节发生了什么？好吧，我们稍后再谈——请参阅下面的 空指针 。
有关指针存储的内容以及内存和地址如何关联的更准确定义，请参阅本答案末尾的 “有关内存地址的更多信息，">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T19:23:15+08:00">
<meta property="article:tag" content="c">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="dereference">
<meta property="article:tag" content="pointers">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">“取消引用”指针是什么意思？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T19:23:15+08:00" itemprop="datePublished" title="2023-02-17 19:23">2023-02-17 19:23</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>请附上一个例子和解释。</p>
<p><br><br></p>
<h2>解答</h2>
<h3>复习基本术语</h3>
<p>它 <em>通常</em> 足够好 - 除非你正在编写汇编 - 设想一个包含数字内存地址的 <strong> <em>指针</em></strong> ，其中 1 指的是进程内存中的第二个字节，2
是第三个字节，3 是第四个字节等等......</p>
<ul>
<li>0 和第一个字节发生了什么？好吧，我们稍后再谈——请参阅下面的 <em>空指针</em> 。</li>
<li>有关指针存储的内容以及内存和地址如何关联的更准确定义，请参阅本答案末尾的 <em>“有关内存地址的更多信息，以及您可能不需要知道的原因” 。</em>
</li>
</ul>
<p>当您想要访问指针指向的内存中的数据/值时 - 具有该数字索引的地址的内容 - 然后您 <strong> <em>取消引用</em></strong> 指针。</p>
<p>不同的计算机语言有不同的符号来告诉编译器或解释器你现在对指向对象的（当前）值感兴趣——我在下面重点介绍 C 和 C++。</p>
<h3>指针场景</h3>
<p>考虑在 C 中，给定一个如下所示的指针<code>p</code>......</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="nb">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abc"</span><span class="p">;</span>
</pre></div>

<p>...用于编码字母“a”、“b”、“c”的数值的四个字节和一个表示文本数据结尾的 0 字节，存储在内存中的某处，其数字地址数据存储在<code>p</code>. 这种 C
在内存中编码文本的方式称为 <em>ASCIIZ</em> 。</p>
<p>例如，如果字符串字面量恰好位于地址 0x1000，而<code>p</code>32 位指针位于 0x2000，则内存内容为：</p>
<div class="code"><pre class="code literal-block">Memory Address (hex)    Variable name    Contents
1000                                     'a' == 97 (ASCII)
1001                                     'b' == 98
1002                                     'c' == 99
1003                                     0
...
2000-2003               p                1000 hex
</pre></div>

<p>请注意，地址 0x1000 没有变量名称/标识符，但我们可以使用存储其地址的指针间接引用字符串文字：<code>p</code>。</p>
<h3>取消引用指针</h3>
<p><code>p</code>为了引用指向的字符，我们<code>p</code>使用这些符号之一取消引用（同样，对于 C）：</p>
<div class="code"><pre class="code literal-block"><span class="nt">assert</span><span class="o">(*</span><span class="nt">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">'a'</span><span class="o">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nt">The</span><span class="w"> </span><span class="nt">first</span><span class="w"> </span><span class="nt">character</span><span class="w"> </span><span class="nt">at</span><span class="w"> </span><span class="nt">address</span><span class="w"> </span><span class="nt">p</span><span class="w"> </span><span class="nt">will</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="s1">'a'</span>
<span class="nt">assert</span><span class="o">(</span><span class="nt">p</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">'b'</span><span class="o">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">p</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="nt">actually</span><span class="w"> </span><span class="nt">dereferences</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">created</span><span class="w"> </span><span class="nt">by</span><span class="w"> </span><span class="nt">adding</span>
<span class="w">                     </span><span class="o">//</span><span class="w"> </span><span class="nt">p</span><span class="w"> </span><span class="nt">and</span><span class="w"> </span><span class="nt">1</span><span class="w"> </span><span class="nt">times</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">size</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">things</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">which</span><span class="w"> </span><span class="nt">p</span><span class="w"> </span><span class="nt">points</span><span class="o">:</span>
<span class="w">                     </span><span class="o">//</span><span class="w"> </span><span class="nt">In</span><span class="w"> </span><span class="nt">this</span><span class="w"> </span><span class="nt">case</span><span class="w"> </span><span class="nt">they</span><span class="s1">'re char which are 1 byte in C...</span>
<span class="s1">assert(*(p + 1) == '</span><span class="nt">b</span><span class="err">'</span><span class="o">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nt">Another</span><span class="w"> </span><span class="nt">notation</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="nt">p</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span>
</pre></div>

<p>您还可以通过指向的数据移动指针，并在移动时取消引用它们：</p>
<div class="code"><pre class="code literal-block">++p;  // Increment p so it's now 0x1001
assert(*p == 'b');  // p == 0x1001 which is where the 'b' is...
</pre></div>

<p>如果您有一些可以写入的数据，那么您可以这样做：</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="nb nb-Type">int</span><span class="o">*</span><span class="w"> </span><span class="n">p_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Put</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">p_x</span>
<span class="o">*</span><span class="n">p_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">Change</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">p_x</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="mi">4</span>
<span class="nb">assert</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Check</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="mi">4</span>
</pre></div>

<p>在上面，您必须在编译时知道您需要一个名为 的变量<code>x</code>，并且代码要求编译器安排它应该存储的位置，确保地址可以通过<code>&amp;x</code>.</p>
<h3>取消引用和访问结构数据成员</h3>
<p>在 C 语言中，如果您有一个变量是指向具有数据成员的结构的指针，则可以使用解引用运算<code>-&gt;</code>符访问这些成员：</p>
<div class="code"><pre class="code literal-block"><span class="n">typedef</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">i_</span><span class="p">;</span><span class="w"> </span><span class="n">double</span><span class="w"> </span><span class="n">d_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="n">X</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">d_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159</span><span class="p">;</span><span class="w">  </span><span class="c1">// Dereference and access data member x.d_</span>
<span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">).</span><span class="n">d_</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// Another equivalent notation for accessing x.d_</span>
</pre></div>

<h3>多字节数据类型</h3>
<p>要使用指针，计算机程序还需要深入了解所指向的数据类型——如果该数据类型需要一个以上的字节来表示，那么指针通常指向数据中编号最低的字节。</p>
<p>所以，看一个稍微复杂一点的例子：</p>
<div class="code"><pre class="code literal-block">double sizes[] = { 10.3, 13.4, 11.2, 19.4 };
double* p = sizes;
assert(p[0] == 10.3);  // Knows to look at all the bytes in the first double value
assert(p[1] == 13.4);  // Actually looks at bytes from address p + 1 * sizeof(double)
                       // (sizeof(double) is almost always eight bytes)
++p;                   // Advance p by sizeof(double)
assert(*p == 13.4);    // The double at memory beginning at address p has value 13.4
*(p + 2) = 29.8;       // Change sizes[3] from 19.4 to 29.8
                       // Note earlier ++p and + 2 here =&gt; sizes[3]
</pre></div>

<h3>指向动态分配内存的指针</h3>
<p>有时您不知道需要多少内存，直到您的程序运行并看到向其抛出的数据......然后您可以使用动态分配内存<code>malloc</code>。通常的做法是将地址存储在指针中......</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="o">*</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="o">*</span><span class="ss">)</span><span class="nv">malloc</span><span class="ss">(</span><span class="nv">sizeof</span><span class="ss">(</span><span class="nv">int</span><span class="ss">))</span><span class="c1">; // Get some memory somewhere...</span>
<span class="o">*</span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="c1">;            // Dereference the pointer to the memory, then write a value in</span>
<span class="nv">fn</span><span class="ss">(</span><span class="o">*</span><span class="nv">p</span><span class="ss">)</span><span class="c1">;             // Call a function, passing it the value at address p</span>
<span class="ss">(</span><span class="o">*</span><span class="nv">p</span><span class="ss">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">3</span><span class="c1">;          // Change the value, adding 3 to it</span>
<span class="nv">free</span><span class="ss">(</span><span class="nv">p</span><span class="ss">)</span><span class="c1">;            // Release the memory back to the heap allocation library</span>
</pre></div>

<p>在 C++ 中，内存分配通常通过<code>new</code>运算符完成，并通过以下方式释放<code>delete</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="o">*</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">int</span><span class="ss">(</span><span class="mi">10</span><span class="ss">)</span><span class="c1">; // Memory for one int with initial value 10</span>
<span class="nv">delete</span><span class="w"> </span><span class="nv">p</span><span class="c1">;</span>

<span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">int</span>[<span class="mi">10</span>]<span class="c1">;      // Memory for ten ints with unspecified initial value</span>
<span class="nv">delete</span>[]<span class="w"> </span><span class="nv">p</span><span class="c1">;</span>

<span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">int</span>[<span class="mi">10</span>]<span class="ss">()</span><span class="c1">;    // Memory for ten ints that are value initialised (to 0)</span>
<span class="nv">delete</span>[]<span class="w"> </span><span class="nv">p</span><span class="c1">;</span>
</pre></div>

<p>另请参阅下面的 <em>C++ 智能指针</em> 。</p>
<h3>丢失和泄露地址</h3>
<p>Often a pointer may be the only indication of where some data or buffer exists
in memory. If ongoing use of that data/buffer is needed, or the ability to
call <code>free()</code> or <code>delete</code> to avoid leaking the memory, then the programmer
must operate on a copy of the pointer...</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="nb">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">asprintf</span><span class="p">(</span><span class="s2">"name: </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Common</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">Standard</span><span class="w"> </span><span class="n">printf</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">heap</span>

<span class="o">//</span><span class="w"> </span><span class="n">Replace</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">printable</span><span class="w"> </span><span class="n">characters</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">underscores</span><span class="o">....</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="nb">char</span><span class="o">*</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isprint</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">))</span>
<span class="w">        </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'_'</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Only</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">modified</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>

<p>...or carefully orchestrate reversal of any changes...</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span><span class="p">;</span>
<span class="n">p</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="o">...</span>
<span class="n">p</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Restore</span><span class="w"> </span><span class="n">earlier</span><span class="w"> </span><span class="n">value</span><span class="o">...</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>

<h3>C++ smart pointers</h3>
<p>In C++, it's best practice to use smart pointer objects to store and manage
the pointers, automatically deallocating them when the smart pointers'
destructors run. Since C++11 the Standard Library provides two, <code>unique_ptr</code>
for when there's a single owner for an allocated object...</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="err">{</span><span class="n">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s2">"meaning"</span><span class="p">)}</span><span class="o">;</span>
<span class="w">    </span><span class="nt">call_a_function</span><span class="o">(</span><span class="nt">p</span><span class="o">);</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nt">The</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">above</span><span class="w"> </span><span class="nt">might</span><span class="w"> </span><span class="nt">throw</span><span class="o">,</span><span class="w"> </span><span class="nt">so</span><span class="w"> </span><span class="nt">delete</span><span class="w"> </span><span class="nt">here</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">unreliable</span><span class="o">,</span><span class="w"> </span><span class="nt">but</span><span class="o">...</span>
<span class="err">}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">p</span><span class="s1">'s destructor'</span><span class="nt">s</span><span class="w"> </span><span class="nt">guaranteed</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">run</span><span class="w"> </span><span class="s2">"here"</span><span class="o">,</span><span class="w"> </span><span class="nt">calling</span><span class="w"> </span><span class="nt">delete</span>
</pre></div>

<p>...and <code>shared_ptr</code> for share ownership (using reference counting)...</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span>
<span class="w">    </span><span class="err">auto</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span><span class="w"> </span><span class="s2">"pi"</span><span class="p">);</span>
<span class="w">    </span><span class="err">number_storage1.may_add(p)</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Might</span><span class="w"> </span><span class="err">copy</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">into</span><span class="w"> </span><span class="err">its</span><span class="w"> </span><span class="err">container</span>
<span class="w">    </span><span class="err">number_storage2.may_add(p)</span><span class="p">;</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Might</span><span class="w"> </span><span class="err">copy</span><span class="w"> </span><span class="err">p</span><span class="w"> </span><span class="err">into</span><span class="w"> </span><span class="err">its</span><span class="w"> </span><span class="err">container</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">p</span><span class="err">'</span><span class="nt">s</span><span class="w"> </span><span class="nt">destructor</span><span class="w"> </span><span class="nt">will</span><span class="w"> </span><span class="nt">only</span><span class="w"> </span><span class="nt">delete</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">neither</span><span class="w"> </span><span class="nt">may_add</span><span class="w"> </span><span class="nt">copied</span><span class="w"> </span><span class="nt">it</span>
</pre></div>

<h3>Null pointers</h3>
<p>In C, <code>NULL</code> and <code>0</code> - and additionally in C++ <code>nullptr</code> - can be used to
indicate that a pointer doesn't currently hold the memory address of a
variable, and shouldn't be dereferenced or used in pointer arithmetic. For
example:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="nb">char</span><span class="o">*</span><span class="w"> </span><span class="n">p_filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NULL</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Or</span><span class="w"> </span><span class="s2">"= 0"</span><span class="p">,</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s2">"= nullptr"</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">C</span><span class="o">++</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="s2">"f:"</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">switch</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">case</span><span class="w"> </span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="n">p_filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optarg</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p_filename</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Only</span><span class="w"> </span><span class="n">NULL</span><span class="w"> </span><span class="n">converts</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="bp">false</span>
<span class="w">    </span><span class="o">...</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">Only</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">specified</span>
</pre></div>

<p>In C and C++, just as inbuilt numeric types don't necessarily default to <code>0</code>,
nor <code>bools</code> to <code>false</code>, pointers are not always set to <code>NULL</code>. All these are
set to 0/false/NULL when they're <code>static</code> variables or (C++ only) direct or
indirect member variables of static objects or their bases, or undergo zero
initialisation (e.g. <code>new T();</code> and <code>new T(x, y, z);</code> perform zero-
initialisation on T's members including pointers, whereas <code>new T;</code> does not).</p>
<p>Further, when you assign <code>0</code>, <code>NULL</code> and <code>nullptr</code> to a pointer the bits in
the pointer are not necessarily all reset: the pointer may not contain "0" at
the hardware level, or refer to address 0 in your virtual address space. The
compiler is allowed to store something else there if it has reason to, but
whatever it does - if you come along and compare the pointer to <code>0</code>, <code>NULL</code>,
<code>nullptr</code> or another pointer that was assigned any of those, the comparison
must work as expected. So, below the source code at the compiler level, "NULL"
is potentially a bit "magical" in the C and C++ languages...</p>
<h3>More about memory addresses, and why you probably don't need to know</h3>
<p>More strictly, initialised pointers store a bit-pattern identifying either
<code>NULL</code> or a (often virtual) memory address.</p>
<p>The simple case is where this is a numeric offset into the process's entire
virtual address space; in more complex cases the pointer may be relative to
some specific memory area, which the CPU may select based on CPU "segment"
registers or some manner of segment id encoded in the bit-pattern, and/or
looking in different places depending on the machine code instructions using
the address.</p>
<p>For example, an <code>int*</code> properly initialised to point to an <code>int</code> variable
might - after casting to a <code>float*</code> - access memory in "GPU" memory quite
distinct from the memory where the <code>int</code> variable is, then once cast to and
used as a function pointer it might point into further distinct memory holding
machine opcodes for the program (with the numeric value of the <code>int*</code>
effectively a random, invalid pointer within these other memory regions).</p>
<p>3GL programming languages like C and C++ tend to hide this complexity, such
that:</p>
<ul>
<li>
<p>If the compiler gives you a pointer to a variable or function, you can dereference it freely (as long as the variable's not destructed/deallocated meanwhile) and it's the compiler's problem whether e.g. a particular CPU segment register needs to be restored beforehand, or a distinct machine code instruction used</p>
</li>
<li>
<p>If you get a pointer to an element in an array, you can use pointer arithmetic to move anywhere else in the array, or even to form an address one-past-the-end of the array that's legal to compare with other pointers to elements in the array (or that have similarly been moved by pointer arithmetic to the same one-past-the-end value); again in C and C++, it's up to the compiler to ensure this "just works"</p>
</li>
<li>
<p>Specific OS functions, e.g. shared memory mapping, may give you pointers, and they'll "just work" within the range of addresses that makes sense for them</p>
</li>
<li>
<p>Attempts to move legal pointers beyond these boundaries, or to cast arbitrary numbers to pointers, or use pointers cast to unrelated types, typically have <em>undefined behaviour</em> , so should be avoided in higher level libraries and applications, but code for OSes, device drivers, etc. may need to rely on behaviour left undefined by the C or C++ Standard, that is nevertheless well defined by their specific implementation or hardware.</p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>取消引用指针意味着获取存储在指针指向的内存位置中的值。运算符 * 用于执行此操作，称为取消引用运算符。</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="nb nb-Type">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="s2">"</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">With</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="n">I</span><span class="s1">'m dereferencing the pointer. </span>
<span class="w">                    </span><span class="o">//</span><span class="w"> </span><span class="n">Which</span><span class="w"> </span><span class="n">means</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">am</span><span class="w"> </span><span class="n">asking</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">pointed</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">pointer</span><span class="o">.</span>
<span class="w">                    </span><span class="o">//</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">pointing</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">a</span><span class="o">.</span>
<span class="w">                    </span><span class="o">//</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="n">a</span><span class="s1">'s location, we have 10. So, dereferencing gives this value.</span>

<span class="o">//</span><span class="w"> </span><span class="n">Since</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">indirect</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">a</span><span class="s1">'s location, we can modify its content using the pointer. This is an indirect way to access a.</span>

<span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">Now</span><span class="w"> </span><span class="n">a</span><span class="s1">'s content is no longer 10, and has been modified to 20.</span>
</pre></div>

<p><br><br><a href="../what-does-dereferencing-a-pointer-mean/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c/" rel="tag">c</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/dereference/" rel="tag">dereference</a></li>
            <li><a class="tag p-category" href="../../categories/pointers/" rel="tag">pointers</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../javazhong-ru-he-que-ding-dui-xiang-de-da-xiao/" rel="prev" title="Java中如何确定对象的大小">Previous post</a>
            </li>
            <li class="next">
                <a href="../async-await-he-shi-fan-hui-task-yu-void/" rel="next" title="async/await - 何时返回 Task 与 void？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
