<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>“闭包”和“lambda”之间有什么区别？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/bi-bao-he-lambda-zhi-jian-you-shi-yao-qu-bie/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../javascriptzhong-shu-zu-jiao-ji-de-zui-jian-dan-dai-ma/" title="javascript中数组交集的最简单代码" type="text/html">
<link rel="next" href="../psql-fatal-shu-ju-ku-yong-hu-bu-cun-zai/" title="psql: FATAL: 数据库“&lt;用户&gt;”不存在" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="“闭包”和“lambda”之间有什么区别？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/bi-bao-he-lambda-zhi-jian-you-shi-yao-qu-bie/">
<meta property="og:description" content="有人可以解释吗？我理解它们背后的基本概念，但我经常看到它们可以互换使用，我感到困惑。
既然我们在这里，它们与常规函数有何不同？

解答
lambda只是一个匿名函数——一个没有名字定义的函数 。 在某些语言中，例如 Scheme，它们等同于命名函数。事实上，函数定义被重写为在内部将
lambda 绑定到变量。在其他语言中，如 Python，它们之间存在一些（相当不必要的）区别，但它们在其他方面的行">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T08:37:56+08:00">
<meta property="article:tag" content="closures">
<meta property="article:tag" content="function">
<meta property="article:tag" content="functional-programming">
<meta property="article:tag" content="lambda">
<meta property="article:tag" content="terminology">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">“闭包”和“lambda”之间有什么区别？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:37:56+08:00" itemprop="datePublished" title="2023-02-17 08:37">2023-02-17 08:37</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>有人可以解释吗？我理解它们背后的基本概念，但我经常看到它们可以互换使用，我感到困惑。</p>
<p>既然我们在这里，它们与常规函数有何不同？</p>
<p><br><br></p>
<h2>解答</h2>
<p>lambda只是一个匿名函数——一个没有名字定义的函数 <strong>。</strong> 在某些语言中，例如 Scheme，它们等同于命名函数。事实上，函数定义被重写为在内部将
lambda 绑定到变量。在其他语言中，如 Python，它们之间存在一些（相当不必要的）区别，但它们在其他方面的行为方式相同。</p>
<p><strong>闭包</strong> 是在定义它的环境 <strong>中</strong> <strong>关闭的任何函数。</strong> 这意味着它可以访问不在其参数列表中的变量。例子： ****</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>:<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">h</span>
<span class="nv">def</span><span class="w"> </span><span class="nv">anotherfunc</span><span class="ss">(</span><span class="nv">h</span><span class="ss">)</span>:
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>
</pre></div>

<p>这将导致错误，因为<code>func</code>未 <strong>关闭的</strong> 环境中<code>anotherfunc</code>-<code>h</code>是未定义的。<code>func</code>仅关闭全球环境。这将起作用：</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">anotherfunc</span><span class="ss">(</span><span class="nv">h</span><span class="ss">)</span>:
<span class="w">    </span><span class="nv">def</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>:<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">h</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>
</pre></div>

<p>因为在这里，<code>func</code>定义在<code>anotherfunc</code>, 和 python 2.3 及更高版本（或类似的数字）中，当它们 <em>几乎</em>
得到正确的闭包时（突变仍然不起作用），这意味着它 <strong>关闭了 over</strong> <code>anotherfunc</code>的环境并可以访问其中的变量它。在 Python
3.1+ 中，使用关键字时也可以进行<code>nonlocal</code>变异。</p>
<p>另一个重要的点 -<code>func</code>将继续关闭 over<code>anotherfunc</code>的环境，即使它不再在<code>anotherfunc</code>. 此代码也将起作用：</p>
<div class="code"><pre class="code literal-block"><span class="nv">def</span><span class="w"> </span><span class="nv">anotherfunc</span><span class="ss">(</span><span class="nv">h</span><span class="ss">)</span>:
<span class="w">    </span><span class="nv">def</span><span class="w"> </span><span class="nv">func</span><span class="ss">()</span>:<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">h</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">func</span>

<span class="nv">print</span><span class="w"> </span><span class="nv">anotherfunc</span><span class="ss">(</span><span class="mi">10</span><span class="ss">)()</span>
</pre></div>

<p>这将打印 10。</p>
<p><strong>正如您所注意到的，这与lambda</strong> 无关——它们是两个不同（尽管相关）的概念。</p>
<p><br></p>
<h3>更多建议</h3>
<p>关于 lambda 和闭包存在很多混淆，甚至在此处对这个 StackOverflow
问题的回答中也是如此。与其随机询问从某些编程语言实践中了解闭包的程序员或其他无能为力的程序员，不如踏上源头之旅 <em>（</em> 一切开始的地方）。由于 lambda
和闭包来自 30 年代 Alonzo Church 发明的 <strong>Lambda 微积分</strong> ，当时第一台电子计算机还没有出现，所以这就是我所说的 <em>来源。</em></p>
<p>Lambda 微积分是世界上最简单的编程语言。您可以在其中做的唯一事情：►</p>
<ul>
<li>
<p>应用：将一个表达式应用到另一个表达式，表示为<code>f x</code>。<br>
（把它想象成一个 <em>函数调用</em> ，哪里<code>f</code>是函数，<code>x</code>是它唯一的参数）</p>
</li>
<li>
<p>抽象：绑定一个出现在表达式中的符号来标记这个符号只是一个“槽”，一个等待填充值的空白框，可以说是一个“变量”。它是通过在希腊字母<code>λ</code>(lambda)、符号名称 (eg ) 和表达式前<code>x</code>加一个点来完成的。<code>.</code>然后将表达式转换为需要一个 <em>参数的</em> <em>函数</em> 。例如：获取表达式并告知此表达式中的符号是 <em>绑定变量</em> ——它可以替换为您作为参数提供的值。注意这样定义的函数是 <em>匿名的</em> <strong><br><code>λx.x+2``x+2``x</code> </strong><br>
 __– 它没有名字，所以您还不能引用它，但是您可以 <em>立即调用</em> 它（还记得应用程序吗？），方法是向它提供它正在等待的参数，如下所示：<code>(λx.x+2)
7</code>。然后表达式（在本例中为文字值）<code>7</code>被替换为所应用的 lambda
的<code>x</code>子表达式<code>x+2</code>，因此您得到<code>7+2</code>，然后通过通用算术规则将其归结为<code>9</code>。</p>
</li>
</ul>
<p>所以我们解开了其中一个谜团：<br><strong>lambda</strong> 是上例中的 <em>匿名函数</em><code>λx.x+2</code>， .</p>
<hr>
<p>在不同的编程语言中，函数抽象 (lambda) 的语法可能不同。例如，在 JavaScript 中它看起来像这样：</p>
<div class="code"><pre class="code literal-block"><span class="nv">function</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="o">+</span><span class="mi">2</span><span class="c1">; }</span>
</pre></div>

<p>您可以立即将其应用于某些参数，如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="ss">(</span><span class="nv">function</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="o">+</span><span class="mi">2</span><span class="c1">; })(7)</span>
</pre></div>

<p>或者您可以将此匿名函数 (lambda) 存储到某个变量中：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>

<p>这有效地给它起了一个名字<code>f</code>，允许你引用它并在以后多次调用它，例如：</p>
<div class="code"><pre class="code literal-block">alert(  f(7) + f(10)  );   // should print 21 in the message box
</pre></div>

<p>但你不必为它命名。你可以立即调用它：</p>
<div class="code"><pre class="code literal-block"><span class="nv">alert</span><span class="ss">(</span><span class="w">  </span><span class="nv">function</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="o">+</span><span class="mi">2</span><span class="c1">; } (7)  );  // should print 9 in the message box</span>
</pre></div>

<p>在 LISP 中，lambda 是这样写的：</p>
<div class="code"><pre class="code literal-block">(lambda (x) (+ x 2))
</pre></div>

<p>您可以通过立即将其应用于参数来调用这样的 lambda：</p>
<div class="code"><pre class="code literal-block">(  (lambda (x) (+ x 2))  7  )
</pre></div>

<hr>
<p>好的，现在是解开另一个谜团的时候了：什么是 <em>闭包</em> 。为此，我们来谈谈lambda 表达式中的 <em>符号</em> （ <em>变量</em> ）。</p>
<p>正如我所说，lambda 抽象所做的是在其子表达式中 <em>绑定</em> 一个符号，以便它成为一个可替换的 <em>参数</em> 。这样的符号称为 <em>bound</em>
。但是，如果表达式中还有其他符号怎么办？例如：<code>λx.x/y+2</code>。在此表达式中，符号<code>x</code>受其前面的 lambda 抽象约束<code>λx.</code>。但另一个符号
，<code>y</code>不受约束——它是 <em>免费的</em> 。我们不知道它是什么以及它来自哪里，所以我们不知道它 <em>意味着</em> 什么以及它代表什么 <em>价值</em>
，因此在我们弄清楚它意味着什么之前我们无法评估该表达式<code>y</code>。</p>
<p><code>2</code>事实上，其他两个符号和
也是如此<code>+</code>。只是我们对这两个符号太熟悉了，以至于我们常常忘记计算机并不知道它们，我们需要通过在某个地方定义它们来告诉它它们的含义，例如在图书馆或语言本身。</p>
<p><em>您可以将自由</em> 符号视为在表达式之外的其他地方定义的，在其“周围上下文”中，称为其 <strong>环境</strong>
。环境可能是一个更大的表达式，这个表达式是其中的一部分（正如 Qui-Gon Jinn
所说：“总有一条更大的鱼”；）），或者在某个库中，或者在语言本身中（作为原始语言 <em>）</em> 。</p>
<p>这让我们将 lambda 表达式分为两类：</p>
<ul>
<li>CLOSED 表达式：这些表达式中出现的每个符号都受一些 lambda 抽象的 <em>约束</em> 。换句话说，它们是 <em>独立的</em> ；他们不需要评估任何周围环境。它们也称为 <em>组合器</em> 。</li>
<li>OPEN 表达式：这些表达式中的一些符号没有 <em>绑定</em> ——也就是说，其中出现的一些符号是 <em>自由的</em> ，它们需要一些外部信息，因此在你提供这些符号的定义之前它们无法被评估。</li>
</ul>
<p><strong>您可以通过提供环境</strong> 来关闭一个 <em>开放的</em> lambda 表达式，它通过将所有这些自由符号绑定到某些值（可能是数字、字符串、匿名函数，也就是
lambdas，等等……）来定义所有这些自由符号。 ****</p>
<p>这里是 <em>闭包</em> 部分： <em>lambda 表达式</em> 的<br>
闭 <strong>包是在外部上下文（环境）中定义的一组特殊符号，它们为该表达式中的</strong> <em>自由符号</em> 赋值，使它们不再自由。它将一个仍然包含一些“未定义”自由符号的
<em>开放lambda 表达式变成一个</em> <em>封闭的</em> 表达式，它不再有任何自由符号。 <strong> </strong> <strong> </strong></p>
<p>例如，如果您有以下 lambda
表达式：<code>λx.x/y+2</code>，该符号<code>x</code>是绑定的，而该符号<code>y</code>是自由的，因此<code>open</code>除非您说明其含义，否则该表达式是 and
不能被评估<code>y</code>（并且与 和 相同<code>+</code>，<code>2</code>它们也是自由的）。但是假设你也有这样的 <em>环境：</em></p>
<div class="code"><pre class="code literal-block">{  y: 3,
+: [built-in addition],
2: [built-in number],
q: 42,
w: 5  }
</pre></div>

<p>此 <em>环境</em><code>y</code>为我们的 lambda 表达式 ( , <code>+</code>, )中的所有“未定义”（自由）符号<code>2</code>和几个额外符号 ( <code>q</code>, <code>w</code>)
提供定义。我们需要定义的符号是环境的这个子集：</p>
<div class="code"><pre class="code literal-block">{  y: 3,
+: [built-in addition],
2: [built-in number]  }
</pre></div>

<p>这正是我们的 lambda 表达式的 <em>闭包</em> ：&gt;</p>
<p>换句话说，它 <em>关闭了</em> 一个打开的 lambda 表达式。 <em>这就是闭包</em> 这个名字最初的由来，这就是为什么这个线程中有这么多人的答案不太正确的原因：P</p>
<hr>
<p>那他们为什么错了？为什么这么多人说闭包是内存中的一些数据结构，或者他们使用的语言的一些特性，或者为什么他们把闭包和lambdas混淆了？:P</p>
<p>好吧，Sun/Oracle、Microsoft、Google 等公司的 marketoids 是罪魁祸首，因为这就是他们在自己的语言（Java、C#、Go
等）中对这些结构的称呼。他们通常将本应只是 lambda
的东西称为“闭包”。或者他们将“闭包”称为他们用来实现词法作用域的特定技术，也就是说，函数可以访问定义时在其外部作用域中定义的变量。他们常说函数“封装”了这些变量，也就是将它们捕获到某种数据结构中，以免它们在外层函数执行完毕后被销毁。
<em>但这只是事后</em> 编造的“民间传说词源”和营销，只会让事情变得更加混乱，</p>
<p>更糟糕的是，因为他们所说的总是有一点点真实性，这不允许您轻易地将其视为错误而忽略 :P 让我解释一下：</p>
<p>如果你想实现一种使用 lambda 作为一等公民的语言，你需要允许它们使用在其周围上下文中定义的符号（即，在你的 lambda
中使用自由变量）。即使周围的函数返回，这些符号也必须存在。问题是这些符号被绑定到函数的某些本地存储（通常在调用堆栈上），当函数返回时它们将不再存在。因此，为了让
lambda
以您期望的方式工作，您需要以某种方式从其外部上下文中“捕获”所有这些自由变量并保存它们以备后用，即使外部上下文将消失时也是如此。也就是说，你需要找到
<em>闭包</em> 你的
lambda（它使用的所有这些外部变量）并将其存储在其他地方（通过制作副本，或者通过预先为它们准备空间，而不是在堆栈上的其他地方）。你用来实现这个目标的实际方法是你的语言的“实现细节”。这里重要的是
<em>闭包</em> ，它是来自lambda <em>环境</em> 的一组 <em>自由变量</em> ，需要保存在某个地方。 __</p>
<p>人们很快就开始调用他们在语言实现中使用的实际数据结构来将闭包实现为“闭包”本身。该结构通常看起来像这样：</p>
<div class="code"><pre class="code literal-block">Closure {
   [pointer to the lambda function's machine code],
   [pointer to the lambda function's environment]
}
</pre></div>

<p>这些数据结构作为参数传递给其他函数，从函数返回并存储在变量中，以表示 lambda，并允许它们访问其封闭环境以及在该上下文中运行的机器代码。但这只是实现
<em>闭</em> 包的一种方式（其中一种），而不是 <em>闭</em> 包本身。</p>
<p>正如我在上面解释的那样，lambda 表达式的闭包是其环境中定义的子集，这些定义为该 lambda
表达式中包含的自由变量赋值，有效地关闭了表达式（将一个开放的 lambda 表达式，它还不能 <em>被</em> 评估 <em>，</em> 变成一个 <em>封闭的</em> lambda
表达式，然后可以对其求值，因为其中包含的所有符号现在都已定义）。</p>
<p>其他任何东西都只是程序员和语言供应商的“货物崇拜”和“巫毒魔法”，他们没有意识到这些概念的真正根源。</p>
<p>我希望这能回答你的问题。但如果您有任何后续问题，请随时在评论中提问，我会尽力解释得更好。</p>
<p><br><br><a href="../what-is-the-difference-between-a-closure-and-a-lambda/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/closures/" rel="tag">closures</a></li>
            <li><a class="tag p-category" href="../../categories/function/" rel="tag">function</a></li>
            <li><a class="tag p-category" href="../../categories/functional-programming/" rel="tag">functional-programming</a></li>
            <li><a class="tag p-category" href="../../categories/lambda/" rel="tag">lambda</a></li>
            <li><a class="tag p-category" href="../../categories/terminology/" rel="tag">terminology</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../javascriptzhong-shu-zu-jiao-ji-de-zui-jian-dan-dai-ma/" rel="prev" title="javascript中数组交集的最简单代码">Previous post</a>
            </li>
            <li class="next">
                <a href="../psql-fatal-shu-ju-ku-yong-hu-bu-cun-zai/" rel="next" title="psql: FATAL: 数据库“&lt;用户&gt;”不存在">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
