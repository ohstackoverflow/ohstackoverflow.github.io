<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Callback functions in C++ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/callback-functions-in-c/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-remove-last-n-characters-from-a-string-in-bash/" title="How to remove last n characters from a string in Bash?" type="text/html">
<link rel="next" href="../how-to-export-a-mysql-database-using-command-prompt/" title="How to export a mysql database using Command Prompt?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Callback functions in C++">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/callback-functions-in-c/">
<meta property="og:description" content="In C++, when and how do you use a callback function?
EDIT:
I would like to see a simple example to write a callback function.

Answer
Note: Most of the answers cover function pointers which is one pos">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T17:50:31+08:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="callback">
<meta property="article:tag" content="function-pointers">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Callback functions in C++</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:50:31+08:00" itemprop="datePublished" title="2023-03-03 17:50">2023-03-03 17:50</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>In C++, when and how do you use a callback function?</p>
<p><strong>EDIT:</strong><br>
I would like to see a simple example to write a callback function.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><em>Note: Most of the answers cover function pointers which is one possibility to
achieve "callback" logic in C++, but as of today not the most favourable one I
think.</em></p>
<h2>What are callbacks(?) and why to use them(!)</h2>
<p>A callback is a <em>callable</em> (see further down) accepted by a class or function,
used to customize the current logic depending on that callback.</p>
<p>One reason to use callbacks is to write <strong>generic</strong> code which is independant
from the logic in the called function and can be reused with different
callbacks.</p>
<p>Many functions of the standard algorithms library <code>&lt;algorithm&gt;</code> use callbacks.
For example the <code>for_each</code> algorithm applies an unary callback to every item
in a range of iterators:</p>
<div class="code"><pre class="code literal-block"><span class="nv">template</span><span class="o">&lt;</span><span class="nv">class</span><span class="w"> </span><span class="nv">InputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">UnaryFunction</span><span class="o">&gt;</span>
<span class="nv">UnaryFunction</span><span class="w"> </span><span class="nv">for_each</span><span class="ss">(</span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">first</span>,<span class="w"> </span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">last</span>,<span class="w"> </span><span class="nv">UnaryFunction</span><span class="w"> </span><span class="nv">f</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="c1">; first != last; ++first) {</span>
<span class="w">    </span><span class="nv">f</span><span class="ss">(</span><span class="o">*</span><span class="nv">first</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span>}
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">f</span><span class="c1">;</span>
}
</pre></div>

<p>which can be used to first increment and then print a vector by passing
appropriate callables for example:</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">vector</span><span class="o">&lt;</span><span class="nt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">v</span><span class="p">{</span><span class="w"> </span><span class="err">1.0,</span><span class="w"> </span><span class="err">2.2,</span><span class="w"> </span><span class="err">4.0,</span><span class="w"> </span><span class="err">5.5,</span><span class="w"> </span><span class="err">7.2</span><span class="w"> </span><span class="p">}</span><span class="o">;</span>
<span class="nt">double</span><span class="w"> </span><span class="nt">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">4</span><span class="p">.</span><span class="nc">0</span><span class="o">;</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">for_each</span><span class="o">(</span><span class="nt">v</span><span class="p">.</span><span class="nc">begin</span><span class="o">(),</span><span class="w"> </span><span class="nt">v</span><span class="p">.</span><span class="nc">end</span><span class="o">(),</span><span class="w"> </span><span class="cp">[</span><span class="o">&amp;</span><span class="cp">]</span><span class="o">(</span><span class="nt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nt">v</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">v</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">r</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">std</span><span class="p">::</span><span class="nd">for_each</span><span class="o">(</span><span class="nt">v</span><span class="p">.</span><span class="nc">begin</span><span class="o">(),</span><span class="w"> </span><span class="nt">v</span><span class="p">.</span><span class="nc">end</span><span class="o">(),</span><span class="w"> </span><span class="cp">[]</span><span class="o">(</span><span class="nt">double</span><span class="w"> </span><span class="nt">v</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s2">" "</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
</pre></div>

<p>which prints</p>
<div class="code"><pre class="code literal-block"><span class="mf">5</span><span class="w"> </span><span class="mf">6.2</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="mf">9.5</span><span class="w"> </span><span class="mf">11.2</span>
</pre></div>

<p>Another application of callbacks is the notification of callers of certain
events which enables a certain amount of static / compile time flexibility.</p>
<p>Personally, I use a local optimization library that uses two different
callbacks:</p>
<ul>
<li>The first callback is called if a function value and the gradient based on a vector of input values is required (logic callback: function value determination / gradient derivation).</li>
<li>The second callback is called once for each algorithm step and receives certain information about the convergence of the algorithm (notification callback).</li>
</ul>
<p>Thus, the library designer is not in charge of deciding what happens with the
information that is given to the programmer via the notification callback and
he needn't worry about how to actually determine function values because
they're provided by the logic callback. Getting those things right is a task
due to the library user and keeps the library slim and more generic.</p>
<p>Furthermore, callbacks can enable dynamic runtime behaviour.</p>
<p>Imagine some kind of game engine class which has a function that is fired,
each time the users presses a button on his keyboard and a set of functions
that control your game behaviour. With callbacks you can (re)decide at runtime
which action will be taken.</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">player_jump</span><span class="p">();</span>
<span class="n">void</span><span class="w"> </span><span class="n">player_crouch</span><span class="p">();</span>

<span class="k">class</span><span class="w"> </span><span class="n">game_core</span>
<span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">array</span><span class="o">&lt;</span><span class="n">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(),</span><span class="w"> </span><span class="n">total_num_keys</span><span class="o">&gt;</span><span class="w"> </span><span class="n">actions</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span>
<span class="w">    </span><span class="n">void</span><span class="w"> </span><span class="n">key_pressed</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">key_id</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="p">();</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="n">keybind</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">menu</span>
<span class="w">    </span><span class="n">void</span><span class="w"> </span><span class="n">update_keybind</span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">key_id</span><span class="p">,</span><span class="w"> </span><span class="n">void</span><span class="p">(</span><span class="o">*</span><span class="n">new_action</span><span class="p">)())</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">actions</span><span class="o">[</span><span class="n">key_id</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_action</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span><span class="p">;</span>
</pre></div>

<p>Here the function <code>key_pressed</code> uses the callbacks stored in <code>actions</code> to
obtain the desired behaviour when a certain key is pressed. If the player
chooses to change the button for jumping, the engine can call</p>
<div class="code"><pre class="code literal-block">game_core_instance.update_keybind(newly_selected_key, &amp;player_jump);
</pre></div>

<p>and thus change the behaviour of a call to <code>key_pressed</code> (which the calls
<code>player_jump</code>) once this button is pressed the next time ingame.</p>
<h2>What are <em>callables</em> in C++(11)?</h2>
<p>See C++ concepts: Callable on cppreference for a more formal description.</p>
<p>Callback functionality can be realized in several ways in C++(11) since
several different things turn out to be <strong>callable</strong>* :</p>
<ul>
<li>Function pointers (including pointers to member functions)</li>
<li>
<code>std::function</code> objects</li>
<li>Lambda expressions</li>
<li>Bind expressions</li>
<li>
<p>Function objects (classes with overloaded function call operator <code>operator()</code>)</p>
</li>
<li>
<p><em>Note: Pointer to data members are callable as well but no function is called at all.</em></p>
</li>
</ul>
<h2>Several important ways to write <em>callbacks</em> in detail</h2>
<ul>
<li>X.1 "Writing" a callback in this post means the syntax to declare and name the callback type.</li>
<li>X.2 "Calling" a callback refers to the syntax to call those objects.</li>
<li>X.3 "Using" a callback means the syntax when passing arguments to a function using a callback.</li>
</ul>
<p><em>Note: As of C++17, a call like<code>f(...)</code> can be written as <code>std::invoke(f,
...)</code> which also handles the pointer to member case.</em></p>
<h3>1. Function pointers</h3>
<p>A function pointer is the 'simplest' (in terms of generality; in terms of
readability arguably the worst) type a callback can have.</p>
<p>Let's have a simple function <code>foo</code>:</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="nv">x</span><span class="c1">; }</span>
</pre></div>

<h4>1.1 Writing a function pointer / type notation</h4>
<p>A <strong>function pointer type</strong> has the notation</p>
<div class="code"><pre class="code literal-block">return_type (*)(parameter_type_1, parameter_type_2, parameter_type_3)
// i.e. a pointer to foo has the type:
int (*)(int)
</pre></div>

<p>where a <strong>named function pointer</strong> type will look like</p>
<div class="code"><pre class="code literal-block"><span class="nt">return_type</span><span class="w"> </span><span class="o">(*</span><span class="w"> </span><span class="nt">name</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nt">parameter_type_1</span><span class="o">,</span><span class="w"> </span><span class="nt">parameter_type_2</span><span class="o">,</span><span class="w"> </span><span class="nt">parameter_type_3</span><span class="o">)</span>

<span class="o">//</span><span class="w"> </span><span class="nt">i</span><span class="p">.</span><span class="nc">e</span><span class="o">.</span><span class="w"> </span><span class="nt">f_int_t</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">type</span><span class="o">:</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">one</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">argument</span><span class="o">,</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">typedef</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="o">(*</span><span class="nt">f_int_t</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="o">);</span>

<span class="o">//</span><span class="w"> </span><span class="nt">foo_p</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="o">//</span><span class="w"> </span><span class="nt">initialized</span><span class="w"> </span><span class="nt">by</span><span class="w"> </span><span class="nt">pointer</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">function</span><span class="w"> </span><span class="nt">foo</span><span class="w"> </span><span class="nt">taking</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">returning</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">int</span><span class="w"> </span><span class="o">(*</span><span class="w"> </span><span class="nt">foo_p</span><span class="o">)(</span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">foo</span><span class="o">;</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="nt">can</span><span class="w"> </span><span class="nt">alternatively</span><span class="w"> </span><span class="nt">be</span><span class="w"> </span><span class="nt">written</span><span class="w"> </span><span class="nt">as</span><span class="w"> </span>
<span class="nt">f_int_t</span><span class="w"> </span><span class="nt">foo_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nt">foo</span><span class="o">;</span>
</pre></div>

<p>The <code>using</code> declaration gives us the option to make things a little bit more
readable, since the <code>typedef</code> for <code>f_int_t</code> can also be written as:</p>
<div class="code"><pre class="code literal-block">using f_int_t = int(*)(int);
</pre></div>

<p>Where (at least for me) it is clearer that <code>f_int_t</code> is the new type alias and
recognition of the function pointer type is also easier</p>
<p>And a declaration of a <strong>function using a callback of function pointer type</strong>
will be:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// foobar having a callback argument named moo of type </span>
<span class="c1">// pointer to function returning int taking int as its argument</span>
<span class="nb">int</span><span class="w"> </span><span class="n">foobar</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb">int</span><span class="p">));</span>
<span class="c1">// if f_int is the function pointer typedef from above we can also write foobar as:</span>
<span class="nb">int</span><span class="w"> </span><span class="n">foobar</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">f_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">);</span>
</pre></div>

<h4>1.2 Callback call notation</h4>
<p>The call notation follows the simple function call syntax:</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">foobar</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span>,<span class="w"> </span><span class="nv">int</span><span class="w"> </span><span class="ss">(</span><span class="o">*</span><span class="nv">moo</span><span class="ss">)(</span><span class="nv">int</span><span class="ss">))</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">moo</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="c1">; // function pointer moo called using argument x</span>
}
<span class="o">//</span><span class="w"> </span><span class="nv">analog</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">foobar</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span>,<span class="w"> </span><span class="nv">f_int_t</span><span class="w"> </span><span class="nv">moo</span><span class="ss">)</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">moo</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span><span class="c1">; // function pointer moo called using argument x</span>
}
</pre></div>

<h4>1.3 Callback use notation and compatible types</h4>
<p>A callback function taking a function pointer can be called using function
pointers.</p>
<p>Using a function that takes a function pointer callback is rather simple:</p>
<div class="code"><pre class="code literal-block"> int a = 5;
 int b = foobar(a, foo); // call foobar with pointer to foo as callback
 // can also be
 int b = foobar(a, &amp;foo); // call foobar with pointer to foo as callback
</pre></div>

<h4>1.4 Example</h4>
<p>A function ca be written that doesn't rely on how the callback works:</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">tranform_every_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="nc">int</span><span class="p">))</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>where possible callbacks could be</p>
<div class="code"><pre class="code literal-block"><span class="nv">int</span><span class="w"> </span><span class="nv">double_int</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="nv">x</span><span class="c1">; }</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">square_int</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="o">*</span><span class="nv">x</span><span class="c1">; }</span>
</pre></div>

<p>used like</p>
<div class="code"><pre class="code literal-block">int a[5] = {1, 2, 3, 4, 5};
tranform_every_int(&amp;a[0], 5, double_int);
// now a == {2, 4, 6, 8, 10};
tranform_every_int(&amp;a[0], 5, square_int);
// now a == {4, 16, 36, 64, 100};
</pre></div>

<h3>2. Pointer to member function</h3>
<p>A pointer to member function (of some class <code>C</code>) is a special type of (and
even more complex) function pointer which requires an object of type <code>C</code> to
operate on.</p>
<div class="code"><pre class="code literal-block"><span class="n">struct</span><span class="w"> </span><span class="n">C</span>
<span class="p">{</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>

<h4>2.1 Writing pointer to member function / type notation</h4>
<p>A <strong>pointer to member function type</strong> for some class <code>T</code> has the notation</p>
<div class="code"><pre class="code literal-block"><span class="c1">// can have more or less parameters</span>
<span class="n">return_type</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">::</span><span class="o">*</span><span class="p">)(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span>
<span class="c1">// i.e. a pointer to C::foo has the type</span>
<span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>

<p>where a <strong>named pointer to member function</strong> will -in analogy to the function
pointer- look like this:</p>
<div class="code"><pre class="code literal-block"><span class="n">return_type</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="w"> </span><span class="k">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span>

<span class="o">//</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">e</span><span class="p">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n n-Quoted">`f_C_int`</span><span class="w"> </span><span class="n">representing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n n-Quoted">`C`</span>
<span class="o">//</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">returning</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">is</span><span class="o">:</span>
<span class="n">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C_foo_p</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">returning</span><span class="w"> </span><span class="kt">int</span>
<span class="o">//</span><span class="w"> </span><span class="n">Its</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">C</span>
<span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="w"> </span><span class="n">C_foo_p</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
<span class="o">//</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">typedef</span><span class="o">:</span>
<span class="n">f_C_int_t</span><span class="w"> </span><span class="n">C_foo_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
</pre></div>

<p>Example: Declaring a function taking a <strong>pointer to member function callback</strong>
as one of its arguments:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="n">having</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">named</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">member</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">C</span>
<span class="o">//</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">taking</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">argument</span>
<span class="o">//</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">needs</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">c</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">));</span>
<span class="o">//</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">equivalently</span><span class="w"> </span><span class="n">declared</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">typedef</span><span class="w"> </span><span class="n">above</span><span class="p">:</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">);</span>
</pre></div>

<h4>2.2 Callback call notation</h4>
<p>The pointer to member function of <code>C</code> can be invoked, with respect to an
object of type <code>C</code> by using member access operations on the dereferenced
pointer. <em>Note: Parenthesis required!</em></p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">moo</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">.*</span><span class="n">moo</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">analog</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">f_C_int_t</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">.*</span><span class="n">moo</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
</pre></div>

<p><em>Note: If a pointer to<code>C</code> is available the syntax is equivalent (where the
pointer to <code>C</code> must be dereferenced as well):</em></p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar_2</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">meow</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">meow</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">.*</span><span class="n">meow</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">equivalent</span><span class="p">:</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">C_foobar_2</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">::</span><span class="o">*</span><span class="n">meow</span><span class="p">)(</span><span class="nb nb-Type">int</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">meow</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;*</span><span class="n">meow</span><span class="p">)(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<h4>2.3 Callback use notation and compatible types</h4>
<p>A callback function taking a member function pointer of class <code>T</code> can be
called using a member function pointer of class <code>T</code>.</p>
<p>Using a function that takes a pointer to member function callback is -in
analogy to function pointers- quite simple as well:</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mh">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// aggregate initialization</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">5</span><span class="p">;</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">my_c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// call C_foobar with pointer to foo as its callback</span>
</pre></div>

<h3>3. <code>std::function</code> objects (header <code>&lt;functional&gt;</code>)</h3>
<p>The <code>std::function</code> class is a polymorphic function wrapper to store, copy or
invoke callables.</p>
<h4>3.1 Writing a <code>std::function</code> object / type notation</h4>
<p>The type of a <code>std::function</code> object storing a callable looks like:</p>
<div class="code"><pre class="code literal-block"><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">parameter_type_1</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_2</span><span class="p">,</span><span class="w"> </span><span class="n">parameter_type_3</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">//</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">declaration</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">foo</span><span class="p">:</span>
<span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stdf_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">:</span>
<span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">C</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stdf_C_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">;</span>
</pre></div>

<h4>3.2 Callback call notation</h4>
<p>The class <code>std::function</code> has <code>operator()</code> defined which can be used to invoke
its target.</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">moo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">stdf_C_foobar</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">(</span><span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">moo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">moo</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="w"> </span><span class="n">moo</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">x</span>
<span class="p">}</span>
</pre></div>

<h4>3.3 Callback use notation and compatible types</h4>
<p>The <code>std::function</code> callback is more generic than function pointers or pointer
to member function since different types can be passed and implicitly
converted into a <code>std::function</code> object.</p>
<p><strong>3.3.1 Function pointers and pointers to member functions</strong></p>
<p>A function pointer</p>
<div class="code"><pre class="code literal-block">int a = 2;
int b = stdf_foobar(a, &amp;foo);
// b == 6 ( 2 + (2+2) )
</pre></div>

<p>or a pointer to member function</p>
<div class="code"><pre class="code literal-block"><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="n">C</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mh">7</span><span class="p">};</span><span class="w"> </span><span class="c1">// aggregate initialization</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_C_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span>
<span class="c1">// b == 11 == ( 2 + (7+2) )</span>
</pre></div>

<p>can be used.</p>
<p><strong>3.3.2 Lambda expressions</strong></p>
<p>An unnamed closure from a lambda expression can be stored in a <code>std::function</code>
object:</p>
<div class="code"><pre class="code literal-block"><span class="nc">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="err">}</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="o">==</span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p><strong>3.3.3<code>std::bind</code> expressions</strong></p>
<p>The result of a <code>std::bind</code> expression can be passed. For example by binding
parameters to a function pointer call:</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">foo_2</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">,</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="nt">y</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">9*x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">using</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">placeholders</span><span class="p">::</span><span class="nd">_1</span><span class="o">;</span>

<span class="nt">int</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">2</span><span class="o">;</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">stdf_foobar</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span><span class="o">));</span>
<span class="o">//</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">23</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nt">9</span><span class="o">*</span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">3</span><span class="w"> </span><span class="o">)</span>
<span class="nt">int</span><span class="w"> </span><span class="nt">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">stdf_foobar</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">));</span>
<span class="o">//</span><span class="w"> </span><span class="nt">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">49</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nt">9</span><span class="o">*</span><span class="nt">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">2</span><span class="w"> </span><span class="o">)</span>
</pre></div>

<p>Where also objects can be bound as the object for the invocation of pointer to
member functions:</p>
<div class="code"><pre class="code literal-block"><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">C</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">my_c</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">aggregate</span><span class="w"> </span><span class="n">initialization</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stdf_foobar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">C</span><span class="p">::</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">my_c</span><span class="p">,</span><span class="w"> </span><span class="n">_1</span><span class="p">));</span>
<span class="o">//</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">)</span>
</pre></div>

<p><strong>3.3.4 Function objects</strong></p>
<p>Objects of classes having a proper <code>operator()</code> overload can be stored inside
a <code>std::function</code> object, as well.</p>
<div class="code"><pre class="code literal-block"><span class="nv">struct</span><span class="w"> </span><span class="nv">Meow</span>
{
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">Meow</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">y_</span><span class="ss">)</span><span class="w"> </span>:<span class="w"> </span><span class="nv">y</span><span class="ss">(</span><span class="nv">y_</span><span class="ss">)</span><span class="w"> </span>{}
<span class="w">  </span><span class="nv">int</span><span class="w"> </span><span class="nv">operator</span><span class="ss">()(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span>{<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">x</span><span class="c1">; }</span>
}<span class="c1">;</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="c1">;</span>
<span class="nv">int</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">stdf_foobar</span><span class="ss">(</span><span class="nv">a</span>,<span class="w"> </span><span class="nv">Meow</span>{<span class="mi">8</span>}<span class="ss">)</span><span class="c1">;</span>
<span class="o">//</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">(</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="ss">)</span>
</pre></div>

<h4>3.4 Example</h4>
<p>Changing the function pointer example to use <code>std::function</code></p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">function</span><span class="o">&lt;</span><span class="nc">int</span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>gives a whole lot more utility to that function because (see 3.3) we have more
possibilities to use it:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// using function pointer still possible</span>
<span class="nb">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">double_int</span><span class="p">);</span>
<span class="c1">// now a == {2, 4, 6, 8, 10};</span>

<span class="c1">// use it without having to write another function by using a lambda</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="c1">// now a == {1, 2, 3, 4, 5}; again</span>

<span class="c1">// use std::bind :</span>
<span class="nb">int</span><span class="w"> </span><span class="n">nine_x_and_y</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="n">using</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">placeholders</span><span class="p">::</span><span class="n">_1</span><span class="p">;</span>
<span class="c1">// calls nine_x_and_y for every int in a with y being 4 every time</span>
<span class="n">stdf_tranform_every_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="n">nine_x_and_y</span><span class="p">,</span><span class="w"> </span><span class="n">_1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">));</span>
<span class="c1">// now a == {13, 22, 31, 40, 49};</span>
</pre></div>

<h3>4. Templated callback type</h3>
<p>Using templates, the code calling the callback can be even more general than
using <code>std::function</code> objects.</p>
<p><em>Note that templates are a compile-time feature and are a design tool for
compile-time polymorphism. If runtime dynamic behaviour is to be achieved
through callbacks, templates will help but they won't induce runtime
dynamics.</em></p>
<h4>4.1 Writing (type notations) and calling templated callbacks</h4>
<p>Generalizing i.e. the <code>std_ftransform_every_int</code> code from above even further
can be achieved by using templates:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">void</span><span class="w"> </span><span class="n">stdf_transform_every_int_templ</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">  </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="k">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fp</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>with an even more general (as well as easiest) syntax for a callback type
being a plain, to-be-deduced templated argument:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span>
<span class="n">void</span><span class="w"> </span><span class="n">transform_every_int_templ</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"transform_every_int_templ&lt;"</span><span class="w"> </span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nf">type_name</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"&gt;\n"</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p><em>Note: The included output prints the type name deduced for templated type<code>F</code>.
The implementation of <code>type_name</code> is given at the end of this post.</em></p>
<p>The most general implementation for the unary transformation of a range is
part of the standard library, namely <code>std::transform</code>, which is also templated
with respect to the iterated types.</p>
<div class="code"><pre class="code literal-block"><span class="nv">template</span><span class="o">&lt;</span><span class="nv">class</span><span class="w"> </span><span class="nv">InputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">OutputIt</span>,<span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">UnaryOperation</span><span class="o">&gt;</span>
<span class="nv">OutputIt</span><span class="w"> </span><span class="nv">transform</span><span class="ss">(</span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">first1</span>,<span class="w"> </span><span class="nv">InputIt</span><span class="w"> </span><span class="nv">last1</span>,<span class="w"> </span><span class="nv">OutputIt</span><span class="w"> </span><span class="nv">d_first</span>,
<span class="w">  </span><span class="nv">UnaryOperation</span><span class="w"> </span><span class="nv">unary_op</span><span class="ss">)</span>
{
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">last1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="o">*</span><span class="nv">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unary_op</span><span class="ss">(</span><span class="o">*</span><span class="nv">first1</span><span class="o">++</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">  </span>}
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">d_first</span><span class="c1">;</span>
}
</pre></div>

<h4>4.2 Examples using templated callbacks and compatible types</h4>
<p>The compatible types for the templated <code>std::function</code> callback method
<code>stdf_transform_every_int_templ</code> are identical to the above mentioned types
(see 3.4).</p>
<p>Using the templated version however, the signature of the used callback may
change a little:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Let</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">muh</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">woof</span><span class="w"> </span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="nb nb-Type">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">}</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">muh</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">}</span>
<span class="n">stdf_transform_every_int_templ</span><span class="o">&lt;</span><span class="nb nb-Type">int</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">woof</span><span class="p">);</span>
</pre></div>

<p><em>Note:<code>std_ftransform_every_int</code> (non templated version; see above) does work
with <code>foo</code> but not using <code>muh</code>.</em></p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Let</span>
<span class="n">void</span><span class="w"> </span><span class="n">print_int</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="n">bool</span><span class="w"> </span><span class="n">f</span><span class="err">{</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="err">{</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="ss">""</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="ss">" "</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="ss">"\n"</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>The plain templated parameter of <code>transform_every_int_templ</code> can be every
possible callable type.</p>
<div class="code"><pre class="code literal-block"><span class="nt">int</span><span class="w"> </span><span class="nt">a</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">1,</span><span class="w"> </span><span class="err">2,</span><span class="w"> </span><span class="err">3,</span><span class="w"> </span><span class="err">4,</span><span class="w"> </span><span class="err">5</span><span class="w"> </span><span class="p">}</span><span class="o">;</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">foo</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">muh</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">woof</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="cp">[]</span><span class="o">(</span><span class="nt">int</span><span class="w"> </span><span class="nt">x</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">Meow</span><span class="p">{</span><span class="w"> </span><span class="err">4</span><span class="w"> </span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">using</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">placeholders</span><span class="p">::</span><span class="nd">_1</span><span class="o">;</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">bind</span><span class="o">(</span><span class="nt">foo_2</span><span class="o">,</span><span class="w"> </span><span class="nt">_1</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span><span class="o">));</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
<span class="nt">transform_every_int_templ</span><span class="o">(&amp;</span><span class="nt">a</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">,</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">function</span><span class="o">&lt;</span><span class="nt">int</span><span class="o">(</span><span class="nt">int</span><span class="o">)&gt;</span><span class="p">{</span><span class="err">&amp;foo</span><span class="p">}</span><span class="o">);</span>
<span class="nt">print_int</span><span class="o">(</span><span class="nt">a</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span>
</pre></div>

<p>The above code prints:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="mf">5</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">3</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="mf">6</span><span class="w"> </span><span class="mf">7</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="err">&amp;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">6</span><span class="w"> </span><span class="mf">8</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="mf">12</span><span class="w"> </span><span class="mf">14</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="nb">int</span><span class="err">&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="nb">int</span><span class="err">&amp;</span><span class="p">)</span><span class="o">&gt;</span>
<span class="mf">9</span><span class="w"> </span><span class="mf">11</span><span class="w"> </span><span class="mf">13</span><span class="w"> </span><span class="mf">15</span><span class="w"> </span><span class="mf">17</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">main</span><span class="p">::</span><span class="err">{</span><span class="n">lambda</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="err">#</span><span class="mf">1</span><span class="err">}</span><span class="w"> </span><span class="o">&gt;</span>
<span class="mf">27</span><span class="w"> </span><span class="mf">33</span><span class="w"> </span><span class="mf">39</span><span class="w"> </span><span class="mf">45</span><span class="w"> </span><span class="mf">51</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Meow</span><span class="o">&gt;</span>
<span class="mf">108</span><span class="w"> </span><span class="mf">132</span><span class="w"> </span><span class="mf">156</span><span class="w"> </span><span class="mf">180</span><span class="w"> </span><span class="mf">204</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">_Bind</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Placeholder</span><span class="o">&lt;</span><span class="mf">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="p">))(</span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;&gt;</span>
<span class="mf">975</span><span class="w"> </span><span class="mf">1191</span><span class="w"> </span><span class="mf">1407</span><span class="w"> </span><span class="mf">1623</span><span class="w"> </span><span class="mf">1839</span>
<span class="n">transform_every_int_templ</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">&gt;&gt;</span>
<span class="mf">977</span><span class="w"> </span><span class="mf">1193</span><span class="w"> </span><span class="mf">1409</span><span class="w"> </span><span class="mf">1625</span><span class="w"> </span><span class="mf">1841</span>
</pre></div>

<h2>
<code>type_name</code> implementation used above</h2>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;typeinfo&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cxxabi.h&gt;</span>

<span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kr">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="w"> </span><span class="n">type_name</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kr">typedef</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">TR</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kr">char</span><span class="p">,</span><span class="w"> </span><span class="kr">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kr">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">own</span>
<span class="w">    </span><span class="p">(</span><span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="n">typeid</span><span class="p">(</span><span class="n">TR</span><span class="p">).</span><span class="n">name</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">    </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">own</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="o">?</span><span class="n">own</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span><span class="o">:</span><span class="n">typeid</span><span class="p">(</span><span class="n">TR</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_const</span><span class="o">&lt;</span><span class="n">TR</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" const"</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_volatile</span><span class="o">&lt;</span><span class="n">TR</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" volatile"</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" &amp;"</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">" &amp;&amp;"</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>There is also the C way of doing callbacks: function pointers</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">signature</span><span class="p">,</span>
<span class="o">//</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">makes</span><span class="w"> </span><span class="n">life</span><span class="w"> </span><span class="n">easier</span>

<span class="o">//</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">CallbackType</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb nb-Type">float</span>
<span class="o">//</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="nb nb-Type">int</span>
<span class="n">typedef</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">CallbackType</span><span class="p">)(</span><span class="nb nb-Type">float</span><span class="p">);</span>

<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">DoWork</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">calculations</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Call</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variable</span><span class="p">,</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">retrieve</span><span class="w"> </span><span class="n">the</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">result</span>
<span class="w">  </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">result</span>
<span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">SomeCallback</span><span class="p">(</span><span class="nb nb-Type">float</span><span class="w"> </span><span class="n">variable</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Interpret</span><span class="w"> </span><span class="n">variable</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb nb-Type">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">SomeCallback</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">DoWork</span>
<span class="w">  </span><span class="n">DoWork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SomeCallback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>Now, if you want to pass in class methods as callbacks, the declarations to
those function pointers have more complex declarations, for example:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Declaration:</span>
<span class="n">typedef</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="p">(</span><span class="n">ClassName</span><span class="p">::</span><span class="o">*</span><span class="n">CallbackType</span><span class="p">)(</span><span class="n">float</span><span class="p">);</span>

<span class="c1">// This method performs work using an object instance</span>
<span class="n">void</span><span class="w"> </span><span class="n">DoWorkObject</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Class instance to invoke it through</span>
<span class="w">  </span><span class="n">ClassName</span><span class="w"> </span><span class="n">objectInstance</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Invocation</span>
<span class="w">  </span><span class="nb">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">objectInstance</span><span class="o">.*</span><span class="n">callback</span><span class="p">)(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//This method performs work using an object pointer</span>
<span class="n">void</span><span class="w"> </span><span class="n">DoWorkPointer</span><span class="p">(</span><span class="n">CallbackType</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Class pointer to invoke it through</span>
<span class="w">  </span><span class="n">ClassName</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pointerInstance</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Invocation</span>
<span class="w">  </span><span class="nb">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">pointerInstance</span><span class="o">-&gt;*</span><span class="n">callback</span><span class="p">)(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Pass in SomeCallback to the DoWork</span>
<span class="w">  </span><span class="n">DoWorkObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ClassName</span><span class="p">::</span><span class="n">Method</span><span class="p">);</span>
<span class="w">  </span><span class="n">DoWorkPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ClassName</span><span class="p">::</span><span class="n">Method</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/callback/" rel="tag">callback</a></li>
            <li><a class="tag p-category" href="../../categories/function-pointers/" rel="tag">function-pointers</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-remove-last-n-characters-from-a-string-in-bash/" rel="prev" title="How to remove last n characters from a string in Bash?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-to-export-a-mysql-database-using-command-prompt/" rel="next" title="How to export a mysql database using Command Prompt?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
