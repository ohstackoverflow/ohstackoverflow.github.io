<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What is an application binary interface (ABI)? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-is-an-application-binary-interface-abi/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-is-a-slug-in-django/" title='What is a "slug" in Django?' type="text/html">
<link rel="next" href="../how-to-replace-a-string-in-multiple-files-in-linux-command-line/" title="How to replace a string in multiple files in linux command line" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What is an application binary interface (ABI)?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-is-an-application-binary-interface-abi/">
<meta property="og:description" content="I never clearly understood what an ABI is. Please don't point me to a
Wikipedia article. If I could understand it, I wouldn't be here posting such a
lengthy post.
This is my mindset about different in">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T15:30:56+08:00">
<meta property="article:tag" content="abi">
<meta property="article:tag" content="compiler-construction">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What is an application binary interface (ABI)?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T15:30:56+08:00" itemprop="datePublished" title="2023-02-17 15:30">2023-02-17 15:30</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I never clearly understood what an ABI is. Please don't point me to a
Wikipedia article. If I could understand it, I wouldn't be here posting such a
lengthy post.</p>
<p>This is my mindset about different interfaces:</p>
<p>A TV remote is an interface between the user and the TV. It is an existing
entity, but useless (doesn't provide any functionality) by itself. All the
functionality for each of those buttons on the remote is implemented in the
television set.</p>
<blockquote>
<p><strong>Interface:</strong> It is an "existing entity" layer between the <code>functionality</code>
and <code>consumer</code> of that functionality. An interface by itself doesn't do
anything. It just invokes the functionality lying behind.</p>
<p>Now depending on who the user is there are different type of interfaces.</p>
<p><strong>Command Line Interface (CLI)</strong> commands are the existing entities, the
consumer is the user and functionality lies behind.</p>
<p><code>functionality:</code> my software functionality which solves some purpose to
which we are describing this interface.</p>
<p><code>existing entities:</code> commands</p>
<p><code>consumer:</code> user</p>
<p><strong>Graphical User Interface(GUI)</strong> window, buttons, etc. are the existing
entities, and again the consumer is the user and functionality lies behind.</p>
<p><code>functionality:</code> my software functionality which solves some problem to
which we are describing this interface.</p>
<p><code>existing entities:</code> window, buttons etc..</p>
<p><code>consumer:</code> user</p>
<p><strong>Application Programming Interface(API)</strong> functions (or to be more correct)
interfaces (in interfaced based programming) are the existing entities,
consumer here is another program not a user, and again functionality lies
behind this layer.</p>
<p><code>functionality:</code> my software functionality which solves some problem to
which we are describing this interface.</p>
<p><code>existing entities:</code> functions, Interfaces (array of functions).</p>
<p><code>consumer:</code> another program/application.</p>
<p><strong>Application Binary Interface (ABI)</strong> Here is where my problem starts.</p>
<p><code>functionality:</code> ???</p>
<p><code>existing entities:</code> ???</p>
<p><code>consumer:</code> ???</p>
</blockquote>
<ul>
<li>I've written software in different languages and provided different kinds of interfaces (CLI, GUI, and API), but I'm not sure if I have ever provided any ABI.</li>
</ul>
<p>Wikipedia says:</p>
<blockquote>
<p>ABIs cover details such as</p>
<ul>
<li>data type, size, and alignment;</li>
<li>the calling convention, which controls how functions' arguments are
passed and return values retrieved;</li>
<li>the system call numbers and how an application should make system calls
to the operating system;
</li>
</ul>
<p>Other ABIs standardize details such as</p>
<ul>
<li>the C++ name mangling,</li>
<li>exception propagation, and</li>
<li>calling convention between compilers on the same platform, but do not
require cross-platform compatibility.
</li>
</ul>
</blockquote>
<ul>
<li>
<p>Who needs these details? Please don't say the OS. I know assembly programming. I know how linking &amp; loading works. I know exactly what happens inside.</p>
</li>
<li>
<p>Why did C++ name mangling come in? I thought we are talking at the binary level. Why do languages come in?</p>
</li>
</ul>
<p>Anyway, I've downloaded the [PDF] System V Application Binary Interface
<em>Edition 4.1 (1997-03-18)</em> to see what exactly it contains. Well, most of it
didn't make any sense.</p>
<ul>
<li>
<p>Why does it contain two chapters (4th &amp; 5th) to describe the ELF file format? In fact, these are the only two significant chapters of that specification. The rest of the chapters are "processor specific". Anyway, I though that it is a completely different topic. Please don't say that ELF file format specifications <em>are</em> the ABI. It doesn't qualify to be an <em>interface</em> according to the definition.</p>
</li>
<li>
<p>I know, since we are talking at such a low level it must be very specific. But I'm not sure how is it "instruction set architecture (ISA)" specific?</p>
</li>
<li>
<p>Where can I find Microsoft Windows' ABI?</p>
</li>
</ul>
<p>So, these are the major queries that are bugging me.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>One easy way to understand "ABI" is to compare it to "API".</p>
<p>You are already familiar with the concept of an API. If you want to use the
features of, say, some library or your OS, you will program against an API.
The API consists of data types/structures, constants, functions, etc that you
can use in your code to access the functionality of that external component.</p>
<p>An ABI is very similar. Think of it as the compiled version of an API (or as
an API on the machine-language level). When you write source code, you access
the library through an API. Once the code is compiled, your application
accesses the binary data in the library through the ABI. The ABI defines the
structures and methods that your compiled application will use to access the
external library (just like the API did), only on a lower level. Your API
defines the order in which you pass arguments to a function. Your ABI defines
the mechanics of <em>how</em> these arguments are passed (registers, stack, etc.).
Your API defines which functions are part of your library. Your ABI defines
how your code is stored inside the library file, so that any program using
your library can locate the desired function and execute it.</p>
<p>ABIs are important when it comes to applications that use external libraries.
Libraries are full of code and other resources, but your program has to know
how to locate what it needs inside the library file. Your ABI defines how the
contents of a library are stored inside the file, and your program uses the
ABI to search through the file and find what it needs. If everything in your
system conforms to the same ABI, then any program is able to work with any
library file, no matter who created them. Linux and Windows use different
ABIs, so a Windows program won't know how to access a library compiled for
Linux.</p>
<p>Sometimes, ABI changes are unavoidable. When this happens, any programs that
use that library will not work unless they are re-compiled to use the new
version of the library. If the ABI changes but the API does not, then the old
and new library versions are sometimes called "source compatible". This
implies that while a program compiled for one library version will not work
with the other, source code written for one will work for the other if re-
compiled.</p>
<p>For this reason, developers tend to try to keep their ABI stable (to minimize
disruption). Keeping an ABI stable means not changing function interfaces
(return type and number, types, and order of arguments), definitions of data
types or data structures, defined constants, etc. New functions and data types
can be added, but existing ones must stay the same. If, for instance, your
library uses 32-bit integers to indicate the offset of a function and you
switch to 64-bit integers, then already-compiled code that uses that library
will not be accessing that field (or any following it) correctly. Accessing
data structure members gets converted into memory addresses and offsets during
compilation and if the data structure changes, then these offsets will not
point to what the code is expecting them to point to and the results are
unpredictable at best.</p>
<p>An ABI isn't necessarily something you will explicitly provide unless you are
doing very low-level systems design work. It isn't language-specific either,
since (for example) a C application and a Pascal application can use the same
ABI after they are compiled.</p>
<p><strong>Edit:</strong> Regarding your question about the chapters regarding the ELF file
format in the SysV ABI docs: The reason this information is included is
because the ELF format defines the interface between operating system and
application. When you tell the OS to run a program, it expects the program to
be formatted in a certain way and (for example) expects the first section of
the binary to be an ELF header containing certain information at specific
memory offsets. This is how the application communicates important information
about itself to the operating system. If you build a program in a non-ELF
binary format (such as a.out or PE), then an OS that expects ELF-formatted
applications will not be able to interpret the binary file or run the
application. This is one big reason why Windows apps cannot be run directly on
a Linux machine (or vice versa) without being either re-compiled or run inside
some type of emulation layer that can translate from one binary format to
another.</p>
<p>IIRC, Windows currently uses the Portable Executable (or, PE) format. There
are links in the "external links" section of that Wikipedia page with more
information about the PE format.</p>
<p>Also, regarding your note about C++ name mangling: When locating a function in
a library file, the function is typically looked up by name. C++ allows you to
overload function names, so name alone is not sufficient to identify a
function. C++ compilers have their own ways of dealing with this internally,
called <em>name mangling</em>. An ABI can define a standard way of encoding the name
of a function so that programs built with a different language or compiler can
locate what they need. When you use <code>extern "c"</code> in a C++ program, you're
instructing the compiler to use a standardized way of recording names that's
understandable by other software.</p>
<p><br></p>
<h3>Suggest</h3>
<p>If you know assembly and how things work at the OS-level, you are conforming
to a certain ABI. The ABI govern things like how parameters are passed, where
return values are placed. For many platforms there is only one ABI to choose
from, and in those cases the ABI is just "how things work".</p>
<p>However, the ABI also govern things like how classes/objects are laid out in
C++. This is necessary if you want to be able to pass object references across
module boundaries or if you want to mix code compiled with different
compilers.</p>
<p>Also, if you have an 64-bit OS which can execute 32-bit binaries, you will
have different ABIs for 32- and 64-bit code.</p>
<p>In general, any code you link into the same executable must conform to the
same ABI. If you want to communicate between code using different ABIs, you
must use some form of RPC or serialization protocols.</p>
<p>I think you are trying too hard to squeeze in different types of interfaces
into a fixed set of characteristics. For example, an interface doesn't
necessarily have to be split into consumers and producers. An interface is
just a convention by which two entities interact.</p>
<p>ABIs can be (partially) ISA-agnostic. Some aspects (such as calling
conventions) depend on the ISA, while other aspects (such as C++ class layout)
do not.</p>
<p>A well defined ABI is very important for people writing compilers. Without a
well defined ABI, it would be impossible to generate interoperable code.</p>
<p>EDIT: Some notes to clarify:</p>
<ul>
<li>"Binary" in ABI does not exclude the use of strings or text. If you want to link a DLL exporting a C++ class, somewhere in it the methods and type signatures must be encoded. That's where C++ name-mangling comes in.</li>
<li>The reason why you never provided an ABI is that the vast majority of programmers will never do it. ABIs are provided by the same people designing the platform (i.e. operating system), and very few programmers will ever have the privilege to design a widely-used ABI.</li>
</ul>
</div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/abi/" rel="tag">abi</a></li>
            <li><a class="tag p-category" href="../../categories/compiler-construction/" rel="tag">compiler-construction</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-is-a-slug-in-django/" rel="prev" title='What is a "slug" in Django?'>Previous post</a>
            </li>
            <li class="next">
                <a href="../how-to-replace-a-string-in-multiple-files-in-linux-command-line/" rel="next" title="How to replace a string in multiple files in linux command line">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
