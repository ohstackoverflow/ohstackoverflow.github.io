<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How does PHP 'foreach' actually work? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-does-php-foreach-actually-work/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-delete-from-a-text-file-all-lines-that-contain-a-specific-string/" title="How to delete from a text file, all lines that contain a specific string?" type="text/html">
<link rel="next" href="../what-are-valid-values-for-the-id-attribute-in-html/" title="What are valid values for the id attribute in HTML?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How does PHP 'foreach' actually work?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-does-php-foreach-actually-work/">
<meta property="og:description" content="Let me prefix this by saying that I know what foreach is, does and how to
use it. This question concerns how it works under the bonnet, and I don't want
any answers along the lines of &quot;this is how you">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T22:06:53+08:00">
<meta property="article:tag" content="foreach">
<meta property="article:tag" content="iteration">
<meta property="article:tag" content="loops">
<meta property="article:tag" content="php">
<meta property="article:tag" content="php-internals">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How does PHP 'foreach' actually work?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:06:53+08:00" itemprop="datePublished" title="2023-02-16 22:06">2023-02-16 22:06</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Let me prefix this by saying that I know what <code>foreach</code> is, does and how to
use it. This question concerns how it works under the bonnet, and I don't want
any answers along the lines of "this is how you loop an array with <code>foreach</code>".</p>
<hr>
<p>For a long time I assumed that <code>foreach</code> worked with the array itself. Then I
found many references to the fact that it works with a <em>copy</em> of the array,
and I have since assumed this to be the end of the story. But I recently got
into a discussion on the matter, and after a little experimentation found that
this was not in fact 100% true.</p>
<p>Let me show what I mean. For the following test cases, we will be working with
the following array:</p>
<div class="code"><pre class="code literal-block">$array = array(1, 2, 3, 4, 5);
</pre></div>

<p>Test case 1:</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">item</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$item\n"</span><span class="c1">;</span>
<span class="w">  </span><span class="mh">$a</span><span class="nv">rray</span>[]<span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">item</span><span class="c1">;</span>
}
<span class="nv">print_r</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="ss">)</span><span class="c1">;</span>

<span class="cm">/* Output in loop:    1 2 3 4 5</span>
<span class="cm">   $array after loop: 1 2 3 4 5 1 2 3 4 5 */</span>
</pre></div>

<p>This clearly shows that we are not working directly with the source array -
otherwise the loop would continue forever, since we are constantly pushing
items onto the array during the loop. But just to be sure this is the case:</p>
<p>Test case 2:</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">key</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>$<span class="nv">item</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="mh">$a</span><span class="nv">rray</span>[$<span class="nv">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">item</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$item\n"</span><span class="c1">;</span>
}

<span class="nv">print_r</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="ss">)</span><span class="c1">;</span>

<span class="cm">/* Output in loop:    1 2 3 4 5</span>
<span class="cm">   $array after loop: 1 3 4 5 6 7 */</span>
</pre></div>

<p>This backs up our initial conclusion, we are working with a copy of the source
array during the loop, otherwise we would see the modified values during the
loop. <em>But...</em></p>
<p>If we look in the manual, we find this statement:</p>
<blockquote>
<p>When foreach first starts executing, the internal array pointer is
automatically reset to the first element of the array.</p>
</blockquote>
<p>Right... this seems to suggest that <code>foreach</code> relies on the array pointer of
the source array. But we've just proved that we're <em>not working with the
source array</em> , right? Well, not entirely.</p>
<p>Test case 3:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Move</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">sure</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">doesn</span><span class="s1">'t affect the loop</span>
<span class="n">var_dump</span><span class="p">(</span><span class="n">each</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>

<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">echo</span><span class="w"> </span><span class="s2">"$item</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">var_dump</span><span class="p">(</span><span class="n">each</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>

<span class="o">/*</span><span class="w"> </span><span class="n">Output</span>
<span class="w">  </span><span class="n">array</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="s2">"value"</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">[</span><span class="s2">"key"</span><span class="p">]</span><span class="o">=&gt;</span>
<span class="w">    </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="mi">1</span>
<span class="w">  </span><span class="mi">2</span>
<span class="w">  </span><span class="mi">3</span>
<span class="w">  </span><span class="mi">4</span>
<span class="w">  </span><span class="mi">5</span>
<span class="w">  </span><span class="nb nb-Type">bool</span><span class="p">(</span><span class="bp">false</span><span class="p">)</span>
<span class="o">*/</span>
</pre></div>

<p>So, despite the fact that we are not working directly with the source array,
we are working directly with the source array pointer - the fact that the
pointer is at the end of the array at the end of the loop shows this. Except
this can't be true - if it was, then test case 1 would loop forever.</p>
<p>The PHP manual also states:</p>
<blockquote>
<p>As foreach relies on the internal array pointer changing it within the loop
may lead to unexpected behavior.</p>
</blockquote>
<p>Well, let's find out what that "unexpected behavior" is (technically, any
behavior is unexpected since I no longer know what to expect).</p>
<p>Test case 4:</p>
<div class="code"><pre class="code literal-block">foreach ($array as $key =&gt; $item) {
  echo "$item\n";
  each($array);
}

/* Output: 1 2 3 4 5 */
</pre></div>

<p>Test case 5:</p>
<div class="code"><pre class="code literal-block">foreach ($array as $key =&gt; $item) {
  echo "$item\n";
  reset($array);
}

/* Output: 1 2 3 4 5 */
</pre></div>

<p>...nothing that unexpected there, in fact it seems to support the "copy of
source" theory.</p>
<hr>
<p><strong>The Question</strong></p>
<p>What is going on here? My C-fu is not good enough for me to able to extract a
proper conclusion simply by looking at the PHP source code, I would appreciate
it if someone could translate it into English for me.</p>
<p>It seems to me that <code>foreach</code> works with a <em>copy</em> of the array, but sets the
array pointer of the source array to the end of the array after the loop.</p>
<ul>
<li>Is this correct and the whole story?</li>
<li>If not, what is it really doing?</li>
<li>Is there any situation where using functions that adjust the array pointer (<code>each()</code>, <code>reset()</code> et al.) during a <code>foreach</code> could affect the outcome of the loop?</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<p><code>foreach</code> supports iteration over three different kinds of values:</p>
<ul>
<li>Arrays</li>
<li>Normal objects</li>
<li>
<code>Traversable</code> objects</li>
</ul>
<p>In the following, I will try to explain precisely how iteration works in
different cases. By far the simplest case is <code>Traversable</code> objects, as for
these <code>foreach</code> is essentially only syntax sugar for code along these lines:</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">$k</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">$v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>

<span class="cm">/* translates to: */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="w"> </span><span class="n">instanceof</span><span class="w"> </span><span class="n">IteratorAggregate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">$it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">getIterator</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">rewind</span><span class="p">();</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">();</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">$v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">();</span>
<span class="w">    </span><span class="n">$k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">$it</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>

<p>For internal classes, actual method calls are avoided by using an internal API
that essentially just mirrors the <code>Iterator</code> interface on the C level.</p>
<p>Iteration of arrays and plain objects is significantly more complicated. First
of all, it should be noted that in PHP "arrays" are really ordered
dictionaries and they will be traversed according to this order (which matches
the insertion order as long as you didn't use something like <code>sort</code>). This is
opposed to iterating by the natural order of the keys (how lists in other
languages often work) or having no defined order at all (how dictionaries in
other languages often work).</p>
<p>The same also applies to objects, as the object properties can be seen as
another (ordered) dictionary mapping property names to their values, plus some
visibility handling. In the majority of cases, the object properties are not
actually stored in this rather inefficient way. However, if you start
iterating over an object, the packed representation that is normally used will
be converted to a real dictionary. At that point, iteration of plain objects
becomes very similar to iteration of arrays (which is why I'm not discussing
plain-object iteration much in here).</p>
<p>So far, so good. Iterating over a dictionary can't be too hard, right? The
problems begin when you realize that an array/object can change during
iteration. There are multiple ways this can happen:</p>
<ul>
<li>If you iterate by reference using <code>foreach ($arr as &amp;$v)</code> then <code>$arr</code> is turned into a reference and you can change it during iteration.</li>
<li>In PHP 5 the same applies even if you iterate by value, but the array was a reference beforehand: <code>$ref =&amp; $arr; foreach ($ref as $v)</code>
</li>
<li>Objects have by-handle passing semantics, which for most practical purposes means that they behave like references. So objects can always be changed during iteration.</li>
</ul>
<p>The problem with allowing modifications during iteration is the case where the
element you are currently on is removed. Say you use a pointer to keep track
of which array element you are currently at. If this element is now freed, you
are left with a dangling pointer (usually resulting in a segfault).</p>
<p>There are different ways of solving this issue. PHP 5 and PHP 7 differ
significantly in this regard and I'll describe both behaviors in the
following. The summary is that PHP 5's approach was rather dumb and lead to
all kinds of weird edge-case issues, while PHP 7's more involved approach
results in more predictable and consistent behavior.</p>
<p>As a last preliminary, it should be noted that PHP uses reference counting and
copy-on-write to manage memory. This means that if you "copy" a value, you
actually just reuse the old value and increment its reference count
(refcount). Only once you perform some kind of modification a real copy
(called a "duplication") will be done. See You're being lied to for a more
extensive introduction on this topic.</p>
<h3>PHP 5</h3>
<h4>Internal array pointer and HashPointer</h4>
<p>Arrays in PHP 5 have one dedicated "internal array pointer" (IAP), which
properly supports modifications: Whenever an element is removed, there will be
a check whether the IAP points to this element. If it does, it is advanced to
the next element instead.</p>
<p>While <code>foreach</code> does make use of the IAP, there is an additional complication:
There is only one IAP, but one array can be part of multiple <code>foreach</code> loops:</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Using by-ref iteration here to make sure that it's really</span>
<span class="c1">// the same array in both loops and not a copy</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="no">$</span><span class="n">arr</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="o">&amp;</span><span class="no">$</span><span class="n">v1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="no">$</span><span class="n">arr</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="o">&amp;</span><span class="no">$</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>To support two simultaneous loops with only one internal array pointer,
<code>foreach</code> performs the following shenanigans: Before the loop body is
executed, <code>foreach</code> will back up a pointer to the current element and its hash
into a per-foreach <code>HashPointer</code>. After the loop body runs, the IAP will be
set back to this element if it still exists. If however the element has been
removed, we'll just use wherever the IAP is currently at. This scheme mostly-
kinda-sort of works, but there's a lot of weird behavior you can get out of
it, some of which I'll demonstrate below.</p>
<h4>Array duplication</h4>
<p>The IAP is a visible feature of an array (exposed through the <code>current</code> family
of functions), as such changes to the IAP count as modifications under copy-
on-write semantics. This, unfortunately, means that <code>foreach</code> is in many cases
forced to duplicate the array it is iterating over. The precise conditions
are:</p>
<ol>
<li>The array is not a reference (is_ref=0). If it's a reference, then changes to it are <em>supposed</em> to propagate, so it should not be duplicated.</li>
<li>The array has refcount&gt;1. If <code>refcount</code> is 1, then the array is not shared and we're free to modify it directly.</li>
</ol>
<p>If the array is not duplicated (is_ref=0, refcount=1), then only its
<code>refcount</code> will be incremented (*). Additionally, if <code>foreach</code> by reference is
used, then the (potentially duplicated) array will be turned into a reference.</p>
<p>Consider this code as an example where duplication occurs:</p>
<div class="code"><pre class="code literal-block">function iterate($arr) {
    foreach ($arr as $v) {}
}

$outerArr = [0, 1, 2, 3, 4];
iterate($outerArr);
</pre></div>

<p>Here, <code>$arr</code> will be duplicated to prevent IAP changes on <code>$arr</code> from leaking
to <code>$outerArr</code>. In terms of the conditions above, the array is not a reference
(is_ref=0) and is used in two places (refcount=2). This requirement is
unfortunate and an artifact of the suboptimal implementation (there is no
concern of modification during iteration here, so we don't really need to use
the IAP in the first place).</p>
<p>(*) Incrementing the <code>refcount</code> here sounds innocuous, but violates copy-on-
write (COW) semantics: This means that we are going to modify the IAP of a
refcount=2 array, while COW dictates that modifications can only be performed
on refcount=1 values. This violation results in user-visible behavior change
(while a COW is normally transparent) because the IAP change on the iterated
array will be observable -- but only until the first non-IAP modification on
the array. Instead, the three "valid" options would have been a) to always
duplicate, b) do not increment the <code>refcount</code> and thus allowing the iterated
array to be arbitrarily modified in the loop or c) don't use the IAP at all
(the PHP 7 solution).</p>
<h4>Position advancement order</h4>
<p>There is one last implementation detail that you have to be aware of to
properly understand the code samples below. The "normal" way of looping
through some data structure would look something like this in pseudocode:</p>
<div class="code"><pre class="code literal-block"><span class="nv">reset</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">get_current_data</span><span class="ss">(</span><span class="nv">arr</span>,<span class="w"> </span><span class="o">&amp;</span><span class="nv">data</span><span class="ss">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">SUCCESS</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">code</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">move_forward</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>However <code>foreach</code>, being a rather special snowflake, chooses to do things
slightly differently:</p>
<div class="code"><pre class="code literal-block"><span class="nv">reset</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">while</span><span class="w"> </span><span class="ss">(</span><span class="nv">get_current_data</span><span class="ss">(</span><span class="nv">arr</span>,<span class="w"> </span><span class="o">&amp;</span><span class="nv">data</span><span class="ss">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">SUCCESS</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">move_forward</span><span class="ss">(</span><span class="nv">arr</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">code</span><span class="ss">()</span><span class="c1">;</span>
}
</pre></div>

<p>Namely, the array pointer is already moved forward <em>before</em> the loop body
runs. This means that while the loop body is working on element <code>$i</code>, the IAP
is already at element <code>$i+1</code>. This is the reason why code samples showing
modification during iteration will always <code>unset</code> the <em>next</em> element, rather
than the current one.</p>
<h4>Examples: Your test cases</h4>
<p>The three aspects described above should provide you with a mostly complete
impression of the idiosyncrasies of the <code>foreach</code> implementation and we can
move on to discuss some examples.</p>
<p>The behavior of your test cases is simple to explain at this point:</p>
<ul>
<li>
<p>In test cases 1 and 2 <code>$array</code> starts off with refcount=1, so it will not be duplicated by <code>foreach</code>: Only the <code>refcount</code> is incremented. When the loop body subsequently modifies the array (which has refcount=2 at that point), the duplication will occur at that point. Foreach will continue working on an unmodified copy of <code>$array</code>.</p>
</li>
<li>
<p>In test case 3, once again the array is not duplicated, thus <code>foreach</code> will be modifying the IAP of the <code>$array</code> variable. At the end of the iteration, the IAP is NULL (meaning iteration has done), which <code>each</code> indicates by returning <code>false</code>.</p>
</li>
<li>
<p>In test cases 4 and 5 both <code>each</code> and <code>reset</code> are by-reference functions. The <code>$array</code> has a <code>refcount=2</code> when it is passed to them, so it has to be duplicated. As such <code>foreach</code> will be working on a separate array again.</p>
</li>
</ul>
<h4>Examples: Effects of <code>current</code> in foreach</h4>
<p>A good way to show the various duplication behaviors is to observe the
behavior of the <code>current()</code> function inside a <code>foreach</code> loop. Consider this
example:</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Here you should know that <code>current()</code> is a by-ref function (actually: prefer-
ref), even though it does not modify the array. It has to be in order to play
nice with all the other functions like <code>next</code> which are all by-ref. By-
reference passing implies that the array has to be separated and thus <code>$array</code>
and the <code>foreach-array</code> will be different. The reason you get <code>2</code> instead of
<code>1</code> is also mentioned above: <code>foreach</code> advances the array pointer <em>before</em>
running the user code, not after. So even though the code is at the first
element, <code>foreach</code> already advanced the pointer to the second.</p>
<p>Now lets try a small modification:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">false</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Here we have the is_ref=1 case, so the array is not copied (just like above).
But now that it is a reference, the array no longer has to be duplicated when
passing to the by-ref <code>current()</code> function. Thus <code>current()</code> and <code>foreach</code>
work on the same array. You still see the off-by-one behavior though, due to
the way <code>foreach</code> advances the pointer.</p>
<p>You get the same behavior when doing by-ref iteration:</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="bp">false</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Here the important part is that foreach will make <code>$array</code> an is_ref=1 when it
is iterated by reference, so basically you have the same situation as above.</p>
<p>Another small variation, this time we'll assign the array to another variable:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Here the refcount of the <code>$array</code> is 2 when the loop is started, so for once
we actually have to do the duplication upfront. Thus <code>$array</code> and the array
used by foreach will be completely separate from the outset. That's why you
get the position of the IAP wherever it was before the loop (in this case it
was at the first position).</p>
<h4>Examples: Modification during iteration</h4>
<p>Trying to account for modifications during iteration is where all our foreach
troubles originated, so it serves to consider some examples for this case.</p>
<p>Consider these nested loops over the same array (where by-ref iteration is
used to make sure it really is the same one):</p>
<div class="code"><pre class="code literal-block"><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v2</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">v1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>$<span class="nv">v2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">unset</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">        </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"($v1, $v2)\n"</span><span class="c1">;</span>
<span class="w">    </span>}
}

<span class="o">//</span><span class="w"> </span><span class="nv">Output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
</pre></div>

<p>The expected part here is that <code>(1, 2)</code> is missing from the output because
element <code>1</code> was removed. What's probably unexpected is that the outer loop
stops after the first element. Why is that?</p>
<p>The reason behind this is the nested-loop hack described above: Before the
loop body runs, the current IAP position and hash is backed up into a
<code>HashPointer</code>. After the loop body it will be restored, but only if the
element still exists, otherwise the current IAP position (whatever it may be)
is used instead. In the example above this is exactly the case: The current
element of the outer loop has been removed, so it will use the IAP, which has
already been marked as finished by the inner loop!</p>
<p>Another consequence of the <code>HashPointer</code> backup+restore mechanism is that
changes to the IAP through <code>reset()</code> etc. usually do not impact <code>foreach</code>. For
example, the following code executes as if the <code>reset()</code> were not present at
all:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<p>The reason is that, while <code>reset()</code> temporarily modifies the IAP, it will be
restored to the current foreach element after the loop body. To force
<code>reset()</code> to make an effect on the loop, you have to additionally remove the
current element, so that the backup/restore mechanism fails:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
</pre></div>

<p>But, those examples are still sane. The real fun starts if you remember that
the <code>HashPointer</code> restore uses a pointer to the element and its hash to
determine whether it still exists. But: Hashes have collisions, and pointers
can be reused! This means that, with a careful choice of array keys, we can
make <code>foreach</code> believe that an element that has been removed still exists, so
it will jump directly to it. An example:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">'EzEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">'EzFY'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">'FYEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'EzFY'</span><span class="p">]);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'FYFY'</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">reset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
</pre></div>

<p>Here we should normally expect the output <code>1, 1, 3, 4</code> according to the
previous rules. How what happens is that <code>'FYFY'</code> has the same hash as the
removed element <code>'EzFY'</code>, and the allocator happens to reuse the same memory
location to store the element. So foreach ends up directly jumping to the
newly inserted element, thus short-cutting the loop.</p>
<h4>Substituting the iterated entity during the loop</h4>
<p>One last odd case that I'd like to mention, it is that PHP allows you to
substitute the iterated entity during the loop. So you can start iterating on
one array and then replace it with another array halfway through. Or start
iterating on an array and then replace it with an object:</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="nv">rr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>]<span class="c1">;</span>
$<span class="nv">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">object</span><span class="ss">)</span><span class="w"> </span>[<span class="mi">6</span>,<span class="w"> </span><span class="mi">7</span>,<span class="w"> </span><span class="mi">8</span>,<span class="w"> </span><span class="mi">9</span>,<span class="w"> </span><span class="mi">10</span>]<span class="c1">;</span>

$<span class="nv">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="mh">$a</span><span class="nv">rr</span><span class="c1">;</span>
<span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">ref</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span>$<span class="nv">val</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"$val\n"</span><span class="c1">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span>$<span class="nv">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>$<span class="nv">obj</span><span class="c1">;</span>
<span class="w">    </span>}
}
<span class="cm">/* Output: 1 2 3 6 7 8 9 10 */</span>
</pre></div>

<p>As you can see in this case PHP will just start iterating the other entity
from the start once the substitution has happened.</p>
<h3>PHP 7</h3>
<h4>Hashtable iterators</h4>
<p>If you still remember, the main problem with array iteration was how to handle
removal of elements mid-iteration. PHP 5 used a single internal array pointer
(IAP) for this purpose, which was somewhat suboptimal, as one array pointer
had to be stretched to support multiple simultaneous foreach loops <em>and</em>
interaction with <code>reset()</code> etc. on top of that.</p>
<p>PHP 7 uses a different approach, namely, it supports creating an arbitrary
amount of external, safe hashtable iterators. These iterators have to be
registered in the array, from which point on they have the same semantics as
the IAP: If an array element is removed, all hashtable iterators pointing to
that element will be advanced to the next element.</p>
<p>This means that <code>foreach</code> will no longer use the IAP <strong>at all</strong>. The <code>foreach</code>
loop will be absolutely no effect on the results of <code>current()</code> etc. and its
own behavior will never be influenced by functions like <code>reset()</code> etc.</p>
<h4>Array duplication</h4>
<p>Another important change between PHP 5 and PHP 7 relates to array duplication.
Now that the IAP is no longer used, by-value array iteration will only do a
<code>refcount</code> increment (instead of duplication the array) in all cases. If the
array is modified during the <code>foreach</code> loop, at that point a duplication will
occur (according to copy-on-write) and <code>foreach</code> will keep working on the old
array.</p>
<p>In most cases, this change is transparent and has no other effect than better
performance. However, there is one occasion where it results in different
behavior, namely the case where the array was a reference beforehand:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">array</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*/</span>
<span class="o">/*</span><span class="w"> </span><span class="n">New</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>Previously by-value iteration of reference-arrays was special cases. In this
case, no duplication occurred, so all modifications of the array during
iteration would be reflected by the loop. In PHP 7 this special case is gone:
A by-value iteration of an array will <strong>always</strong> keep working on the original
elements, disregarding any modifications during the loop.</p>
<p>This, of course, does not apply to by-reference iteration. If you iterate by-
reference all modifications will be reflected by the loop. Interestingly, the
same is true for by-value iteration of plain objects:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">stdClass</span><span class="p">;</span>
<span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">obj</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="o">$</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">*/</span>
</pre></div>

<p>This reflects the by-handle semantics of objects (i.e. they behave reference-
like even in by-value contexts).</p>
<h4>Examples</h4>
<p>Let's consider a few examples, starting with your test cases:</p>
<ul>
<li>
<p>Test cases 1 and 2 retain the same output: By-value array iteration always keep working on the original elements. (In this case, even <code>refcounting</code> and duplication behavior is exactly the same between PHP 5 and PHP 7).</p>
</li>
<li>
<p>Test case 3 changes: <code>Foreach</code> no longer uses the IAP, so <code>each()</code> is not affected by the loop. It will have the same output before and after.</p>
</li>
<li>
<p>Test cases 4 and 5 stay the same: <code>each()</code> and <code>reset()</code> will duplicate the array before changing the IAP, while <code>foreach</code> still uses the original array. (Not that the IAP change would have mattered, even if the array was shared.)</p>
</li>
</ul>
<p>The second set of examples was related to the behavior of <code>current()</code> under
different <code>reference/refcounting</code> configurations. This no longer makes sense,
as <code>current()</code> is completely unaffected by the loop, so its return value
always stays the same.</p>
<p>However, we get some interesting changes when considering modifications during
iteration. I hope you will find the new behavior saner. The first example:</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>]<span class="c1">;</span>
<span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">foreach</span><span class="w"> </span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="o">&amp;</span>$<span class="nv">v2</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span>$<span class="nv">v1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>$<span class="nv">v2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">            </span><span class="nv">unset</span><span class="ss">(</span><span class="mh">$a</span><span class="nv">rray</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">        </span>}
<span class="w">        </span><span class="nv">echo</span><span class="w"> </span><span class="s2">"($v1, $v2)\n"</span><span class="c1">;</span>
<span class="w">    </span>}
}

<span class="o">//</span><span class="w"> </span><span class="nv">Old</span><span class="w"> </span><span class="nv">output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">output</span>:<span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
<span class="o">//</span><span class="w">             </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">3</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="mi">5</span>,<span class="w"> </span><span class="mi">5</span><span class="ss">)</span>
</pre></div>

<p>As you can see, the outer loop no longer aborts after the first iteration. The
reason is that both loops now have entirely separate hashtable iterators, and
there is no longer any cross-contamination of both loops through a shared IAP.</p>
<p>Another weird edge case that is fixed now, is the odd effect you get when you
remove and add elements that happen to have the same hash:</p>
<div class="code"><pre class="code literal-block"><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">'EzEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">'EzFY'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">'FYEz'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'EzFY'</span><span class="p">]);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s1">'FYFY'</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">//</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
<span class="o">//</span><span class="w"> </span><span class="n">New</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
</pre></div>

<p>Previously the HashPointer restore mechanism jumped right to the new element
because it "looked" like it's the same as the removed element (due to
colliding hash and pointer). As we no longer rely on the element hash for
anything, this is no longer an issue.</p>
<p><br></p>
<h3>Suggest</h3>
<p>In example 3 you don't modify the array. In all other examples you modify
either the contents or the internal array pointer. This is important when it
comes to PHP arrays because of the semantics of the assignment operator.</p>
<p>The assignment operator for the arrays in PHP works more like a lazy clone.
Assigning one variable to another that contains an array will clone the array,
unlike most languages. However, the actual cloning will not be done unless it
is needed. This means that the clone will take place only when either of the
variables is modified (copy-on-write).</p>
<p>Here is an example:</p>
<div class="code"><pre class="code literal-block"><span class="mh">$a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">array</span><span class="ss">(</span><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="ss">)</span><span class="c1">;</span>
<span class="mh">$b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">$a</span><span class="c1">;  // This is lazy cloning of $a. For the time</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">being</span><span class="w"> </span><span class="mh">$a</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mh">$b</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">internal</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="nv">structure</span>.

<span class="mh">$a</span>[]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="c1">; // Here $a changes, which triggers the actual</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">cloning</span>.<span class="w"> </span><span class="nv">From</span><span class="w"> </span><span class="nv">now</span><span class="w"> </span><span class="nv">on</span>,<span class="w"> </span><span class="mh">$a</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="mh">$b</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">two</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">different</span><span class="w"> </span><span class="nv">data</span><span class="w"> </span><span class="nv">structures</span>.<span class="w"> </span><span class="nv">The</span><span class="w"> </span><span class="nv">same</span><span class="w"> </span><span class="nv">would</span>
<span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nv">happen</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">there</span><span class="w"> </span><span class="nv">were</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">change</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="mh">$b</span>.
</pre></div>

<p>Coming back to your test cases, you can easily imagine that <code>foreach</code> creates
some kind of iterator with a reference to the array. This reference works
exactly like the variable <code>$b</code> in my example. However, the iterator along with
the reference live only during the loop and then, they are both discarded. Now
you can see that, in all cases but 3, the array is modified during the loop,
while this extra reference is alive. This triggers a clone, and that explains
what's going on here!</p>
<p>Here is an excellent article for another side effect of this copy-on-write
behaviour: The PHP Ternary Operator: Fast or not?</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/foreach/" rel="tag">foreach</a></li>
            <li><a class="tag p-category" href="../../categories/iteration/" rel="tag">iteration</a></li>
            <li><a class="tag p-category" href="../../categories/loops/" rel="tag">loops</a></li>
            <li><a class="tag p-category" href="../../categories/php/" rel="tag">php</a></li>
            <li><a class="tag p-category" href="../../categories/php-internals/" rel="tag">php-internals</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-delete-from-a-text-file-all-lines-that-contain-a-specific-string/" rel="prev" title="How to delete from a text file, all lines that contain a specific string?">Previous post</a>
            </li>
            <li class="next">
                <a href="../what-are-valid-values-for-the-id-attribute-in-html/" rel="next" title="What are valid values for the id attribute in HTML?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
