<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Is the greedy best-first search algorithm different from the best-first search algorithm? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/is-the-greedy-best-first-search-algorithm-different-from-the-best-first-search-algorithm/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../is-there-any-difference-between-an-activation-function-and-a-transfer-function/" title="Is there any difference between an activation function and a transfer function?" type="text/html">
<link rel="next" href="../how-does-a-system-like-wolfram-alpha-or-mathematica-solve-equations/" title="How does a system like Wolfram Alpha or Mathematica solve equations?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Is the greedy best-first search algorithm different from the best-firs">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/is-the-greedy-best-first-search-algorithm-different-from-the-best-first-search-algorithm/">
<meta property="og:description" content="Is the greedy best-first search algorithm different from the best-first
search algorithm?
The wiki page has a separate paragraph about Greedy BFS but it's a little
unclear.
My understanding is that Gr">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-28T02:47:16+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="artificial-intelligence">
<meta property="article:tag" content="best-first-search">
<meta property="article:tag" content="search">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Is the greedy best-first search algorithm different from the best-first search algorithm?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:47:16+08:00" itemprop="datePublished" title="2023-02-28 02:47">2023-02-28 02:47</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Is the <em>greedy</em> best-first search algorithm different from the best-first
search algorithm?</p>
<p>The wiki page has a separate paragraph about Greedy BFS but it's a little
unclear.</p>
<p>My understanding is that Greedy BFS is just BFS where the "best node from
OPEN" in wikipedia's algorithm is a heuristic function one calculates for a
node. So implementing this:</p>
<div class="code"><pre class="code literal-block"><span class="n">OPEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">initial</span><span class="w"> </span><span class="n">state</span><span class="p">]</span>
<span class="n">CLOSED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="k">while</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">do</span>
<span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">.</span>
<span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">goal</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">through</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parents</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">path</span><span class="p">.</span>
<span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">Create</span><span class="w"> </span><span class="n">n</span><span class="err">'</span><span class="n">s</span><span class="w"> </span><span class="n">successors</span><span class="p">.</span>
<span class="w"> </span><span class="mf">4.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="k">do</span><span class="o">:</span>
<span class="w">   </span><span class="n">a</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">CLOSED</span><span class="o">:</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">parent</span><span class="p">.</span>
<span class="w">   </span><span class="n">b</span><span class="p">.</span><span class="w"> </span><span class="n">Otherwise</span><span class="o">:</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">done</span>
</pre></div>

<p>with "best node from OPEN" being a heuristic function estimating how close the
node is to the goal, is actually Greedy BFS. Am I right?</p>
<p><em>EDIT:</em> Comment on Anonymouse's answer:</p>
<p>So essentially a greedy BFS doesn't need an "OPEN list" and should base its
decisions only on the current node? Is this algorithm GBFS:</p>
<div class="code"><pre class="code literal-block"><span class="mf">1.</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">START</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="n">node</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="n">Path</span><span class="w"> </span><span class="err">[</span><span class="ow">and</span><span class="w"> </span><span class="n">optinally</span><span class="p">,</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="kr">CLOSE</span><span class="n">D</span><span class="err">?]</span>
<span class="mf">3.</span><span class="w"> </span><span class="kr">If</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">GO</span><span class="n">AL</span><span class="p">,</span><span class="w"> </span><span class="n">exit</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">Evaluate</span><span class="w"> </span><span class="n">CURRENT</span><span class="err">'</span><span class="n">s</span><span class="w"> </span><span class="n">successors</span>
<span class="mf">5.</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">BEST</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">CURRENT</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="kr">go</span><span class="w"> </span><span class="kr">to</span><span class="w"> </span><span class="mf">2.</span>
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>Ten years after I asked this question, I got back to it and <em>finally</em>
understood what that article in Wikipedia was saying.</p>
<p>Greedy BFS is greedy in expanding a potentially better successor of the
<strong>current</strong> node. The difference between the two algorithms is in the loop
that handles the evaluation of successors. Best-first search always exhausts
the current node's successors by evaluating them and continues with the best
one from them:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="mi">4</span>.<span class="w"> </span><span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">successor</span><span class="w"> </span><span class="k">do</span>:
<span class="w">        </span><span class="nv">a</span>.<span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">CLOSED</span>:<span class="w"> </span><span class="nv">evaluate</span><span class="w"> </span><span class="nv">it</span>,<span class="w"> </span><span class="nv">add</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">OPEN</span>,<span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">record</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">parent</span>.
<span class="w">        </span><span class="nv">b</span>.<span class="w"> </span><span class="nv">Otherwise</span>:<span class="w"> </span><span class="nv">change</span><span class="w"> </span><span class="nv">recorded</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">better</span><span class="w"> </span><span class="nv">than</span><span class="w"> </span><span class="nv">previous</span><span class="w"> </span><span class="nv">one</span>.
</pre></div>

<p>Greedy BFS doesn't expand <strong>all</strong> successors of a node if it finds one that
has a better <em>heuristic</em> than the current node. Instead it <em>greedily</em> expands
this potentially better node, leaving some of the current node's successors
unexpanded. This means the current node shouldn't be removed from the OPEN
list unless all its successors have been evaluated. This is the pseudo-code:</p>
<div class="code"><pre class="code literal-block"><span class="n">OPEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">initial</span><span class="w"> </span><span class="n">state</span><span class="p">]</span>
<span class="n">CLOSED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="k">while</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span>
<span class="k">do</span>
<span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">.</span>
<span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">goal</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">backtrace</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">through</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parents</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">path</span><span class="p">.</span>
<span class="w"> </span><span class="mf">3.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">successor</span><span class="w"> </span><span class="k">do</span><span class="o">:</span>
<span class="w">   </span><span class="n">a</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">CLOSED</span><span class="o">:</span><span class="w"> </span>
<span class="w">       </span><span class="n">i</span><span class="p">.</span><span class="w"> </span><span class="n">Evaluate</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">parent</span>
<span class="w">       </span><span class="n">ii</span><span class="p">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">heuristic</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="n">remove</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">CLOSED</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">OPEN</span><span class="w"> </span>
<span class="w">           </span><span class="p">(</span><span class="n">after</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">successor</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="mf">3.</span>
<span class="w">   </span><span class="n">b</span><span class="p">.</span><span class="w"> </span><span class="n">Otherwise</span><span class="o">:</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">recorded</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">better</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">one</span><span class="p">.</span>
<span class="n">done</span>
</pre></div>

<p>I have removed the step <code>3. Create n's successors.</code> from the BFS code above
because some of n's successors may not be evaluated, so there is no use
creating them. Instead each successor should be created and immediately
evaluated in <code>3. For each successor do:</code>.</p>
<p><br></p>
<h3>Suggest</h3>
<p>BFS is an instance of <em>tree search</em> and <em>graph search</em> algorithms in which a
node is selected for expansion based on the evaluation function <code>f(n) = g(n) +
h(n)</code>, where <code>g(n)</code> is length of the path from the root to <code>n</code> and <code>h(n)</code> is
an estimate of the length of the path from <code>n</code> to the goal node. In a BFS
algorithm, the node with the lowest evaluation (i.e. lowest <code>f(n)</code>) is
selected for expansion.</p>
<p>Greedy BFS uses the following evaluation function <code>f(n) = h(n)</code>, which is just
the heuristic function <code>h(n)</code>, which estimates the closeness of <code>n</code> to the
goal. Hence, greedy BFS tries to expand the node that is thought to be closest
to the goal, without taking into account previously gathered knowledge (i.e.
<code>g(n)</code>).</p>
<p>To summarize, the main difference between these (similar) search methods is
the evaluation function.</p>
<p>As a side note, the A<em> algorithm is a best-first search algorithm in which the
heuristic function <code>h</code> is an admissible heuristic (i.e. <code>h</code> is always an
underestimation of the perfect heuristic function <code>h*</code>, for all <code>n</code>). A</em> is
not a gredy BFS algorithm because its evaluation function is <code>f(n) = g(n) +
h(n)</code>.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/artificial-intelligence/" rel="tag">artificial-intelligence</a></li>
            <li><a class="tag p-category" href="../../categories/best-first-search/" rel="tag">best-first-search</a></li>
            <li><a class="tag p-category" href="../../categories/search/" rel="tag">search</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../is-there-any-difference-between-an-activation-function-and-a-transfer-function/" rel="prev" title="Is there any difference between an activation function and a transfer function?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-does-a-system-like-wolfram-alpha-or-mathematica-solve-equations/" rel="next" title="How does a system like Wolfram Alpha or Mathematica solve equations?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
