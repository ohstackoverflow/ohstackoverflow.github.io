<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>如何分析在 Linux 上运行的 C++ 代码？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ru-he-fen-xi-zai-linux-shang-yun-xing-de-c-dai-ma/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-he-bing-liang-ge-git-cun-chu-ku/" title="如何合并两个 Git 存储库？" type="text/html">
<link rel="next" href="../duan-lu-array-foreach-jiu-xiang-diao-yong-break/" title="短路 Array.forEach 就像调用 break" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="如何分析在 Linux 上运行的 C++ 代码？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ru-he-fen-xi-zai-linux-shang-yun-xing-de-c-dai-ma/">
<meta property="og:description" content="如何找到在 Linux 上运行的 C++ 应用程序中运行缓慢的代码区域？

解答
如果您的目标是使用分析器，请使用建议的分析器之一。
但是，如果您赶时间并且可以在调试器下手动中断您的程序，而它主观上很慢，那么有一种简单的方法可以找到性能问题。
只需暂停几次，每次都查看调用堆栈。如果有一些代码浪费了一定百分比的时间，20% 或 50%
或其他任何时间，这就是您在每个样本的行为中捕获它的概率。因此，这">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T22:41:29+08:00">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="profiling">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">如何分析在 Linux 上运行的 C++ 代码？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:41:29+08:00" itemprop="datePublished" title="2023-02-16 22:41">2023-02-16 22:41</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>如何找到在 Linux 上运行的 C++ 应用程序中运行缓慢的代码区域？</p>
<p><br><br></p>
<h2>解答</h2>
<p>如果您的目标是使用分析器，请使用建议的分析器之一。</p>
<p>但是，如果您赶时间并且可以在调试器下手动中断您的程序，而它主观上很慢，那么有一种简单的方法可以找到性能问题。</p>
<p>只需暂停几次，每次都查看调用堆栈。如果有一些代码浪费了一定百分比的时间，20% 或 50%
或其他任何时间，这就是您在每个样本的行为中捕获它的概率。因此，这大致就是您将看到它的样本百分比。不需要有根据的猜测。如果您确实猜测问题是什么，这将证明或反驳它。</p>
<p>您可能有多个不同大小的性能问题。如果你清除了其中任何一个，其余的将在随后的传递中占据更大的百分比，并且更容易被发现。这种 <em>放大效应</em>
，当在多个问题上复合时，会导致真正巨大的加速因子。</p>
<p><strong>警告</strong>
：程序员往往对这种技术持怀疑态度，除非他们自己使用过。他们会说探查器会为您提供此信息，但只有当他们对整个调用堆栈进行抽样然后让您检查一组随机样本时才会如此。（摘要是失去洞察力的地方。）调用图不会给你相同的信息，因为</p>
<ol>
<li>他们不在指令级别进行总结，并且</li>
<li>他们在存在递归的情况下给出了令人困惑的总结。</li>
</ol>
<p>他们还会说它只适用于玩具程序，而实际上它适用于任何程序，而且似乎在更大的程序上效果更好，因为它们往往有更多的问题需要发现。他们会说它有时会发现不是问题的东西，但只有当你看到某样东西时才会
<em>如此</em> 。如果您在不止一个样品上发现问题，那是真的。</p>
<p><strong>PS</strong> 这也可以在多线程程序上完成，如果有一种方法可以在某个时间点收集线程池的调用堆栈样本，就像在 Java 中那样。</p>
<p><strong>PPS</strong> 作为一个粗略的概括，您的软件中的抽象层越多，您就越有可能发现这是性能问题的原因（以及获得加速的机会）。</p>
<p><strong>补充</strong>
：这可能不是很明显，但堆栈采样技术在递归的情况下同样有效。原因是删除一条指令所节省的时间近似于包含它的样本的分数，而不管它在一个样本中可能出现的次数。</p>
<p>我经常听到的另一个反对意见是：“ <em>它会随机停在某个地方，它会错过真正的问题</em>
”。这是因为对真正的问题是什么有一个先验的概念。性能问题的一个关键属性是它们违背预期。抽样告诉您有问题，您的第一反应是难以置信。这很自然，但您可以确定它是否发现问题是真实存在的，反之亦然。</p>
<p><strong>补充</strong>
：让我对它的工作原理做一个贝叶斯解释。假设有一些指令<code>I</code>（调用或其他）在调用堆栈上有一段<code>f</code>时间（因此花费那么多）。为简单起见，假设我们不知道<code>f</code>是什么，但假设它是
0.1、0.2、0.3、... 0.9、1.0，并且每种可能性的先验概率都是 0.1，因此所有这些成本的可能性均等先验的。</p>
<p>然后假设我们只取 2 个堆栈样本，并且我们在两个样本上都看到了指令<code>I</code>，指定为 observation
<code>o=2/2</code>。这给了我们新的频率估计<code>f</code>，<code>I</code>根据这个：</p>
<div class="code"><pre class="code literal-block">Prior                                    
P(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp;f=x)  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x | o=2/2)

0.1    1     1             0.1          0.1            0.25974026
0.1    0.9   0.81          0.081        0.181          0.47012987
0.1    0.8   0.64          0.064        0.245          0.636363636
0.1    0.7   0.49          0.049        0.294          0.763636364
0.1    0.6   0.36          0.036        0.33           0.857142857
0.1    0.5   0.25          0.025        0.355          0.922077922
0.1    0.4   0.16          0.016        0.371          0.963636364
0.1    0.3   0.09          0.009        0.38           0.987012987
0.1    0.2   0.04          0.004        0.384          0.997402597
0.1    0.1   0.01          0.001        0.385          1

                  P(o=2/2) 0.385
</pre></div>

<p>最后一列表示，例如，&gt;= 0.5 的概率<code>f</code>为 92%，高于先前假设的 60%。</p>
<p>假设先验假设不同。假设我们假设<code>P(f=0.1)</code>是 .991（几乎可以肯定），所有其他可能性几乎都是不可能的
(0.001)。换句话说，我们事先确定的是<code>I</code>便宜。然后我们得到：</p>
<div class="code"><pre class="code literal-block">Prior                                    
P(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp; f=x)  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x | o=2/2)

0.001  1    1              0.001        0.001          0.072727273
0.001  0.9  0.81           0.00081      0.00181        0.131636364
0.001  0.8  0.64           0.00064      0.00245        0.178181818
0.001  0.7  0.49           0.00049      0.00294        0.213818182
0.001  0.6  0.36           0.00036      0.0033         0.24
0.001  0.5  0.25           0.00025      0.00355        0.258181818
0.001  0.4  0.16           0.00016      0.00371        0.269818182
0.001  0.3  0.09           0.00009      0.0038         0.276363636
0.001  0.2  0.04           0.00004      0.00384        0.279272727
0.991  0.1  0.01           0.00991      0.01375        1

                  P(o=2/2) 0.01375
</pre></div>

<p>现在它说<code>P(f &gt;= 0.5)</code>是 26%，高于之前假设的 0.6%。所以贝叶斯允许我们更新我们对
的可能成本的估计<code>I</code>。如果数据量很小，它并不能准确地告诉我们成本是多少，只是它大到值得修复。</p>
<p>另一种看待它的方式称为继承规则。如果你掷一枚硬币 2 次，两次都是正面朝上，这告诉你硬币的可能权重是多少？受人尊敬的回答方式是说它是 Beta
分布，平均值为<code>(number of hits + 1) / (number of tries + 2) = (2+1)/(2+2) = 75%</code>。</p>
<p>（关键是我们看到了<code>I</code>不止一次。如果我们只看到一次，那除了<code>f</code>&gt; 0 之外并没有告诉我们太多信息。）</p>
<p>因此，即使是非常少量的样本也可以告诉我们很多关于它所看到的指令的成本。（平均而言，它会看到它们的频率与它们的成本成正比。如果<code>n</code>样本被抽取，并且<code>f</code>是成本，那么<code>I</code>将出现在<code>nf+/-sqrt(nf(1-f))</code>样本上。示例，，，<code>n=10</code>即<code>f=0.3</code>样本<code>3+/-1.4</code>。）</p>
<hr>
<p><strong>添加</strong> ：为了直观地感受测量堆栈采样和随机堆栈采样之间的区别：<br>
现在有分析器对堆栈进行采样，即使是在挂钟时间，但 <em>得出的</em>
是测量值（或热点路径，或热点，从中“瓶颈”很容易隐藏）。他们没有向您展示（而且他们很容易可以）的是实际样本本身。如果您的目标是 <em>找到</em>
瓶颈，那么您需要查看的瓶颈数量 <em>平均</em> 为 2 除以所需时间。因此，如果花费 30% 的时间，则平均有 2/.3 = 6.7 个样本会显示它，而 20
个样本会显示它的机会为 99.2%。</p>
<p>这是检查测量值和检查堆栈样本之间差异的即兴说明。瓶颈可能是像这样的一个大斑点，也可能是许多小斑点，这没有区别。</p>
<p><img alt="在此处输入图像描述" src="../../images/FpWuS.png"></p>
<p>测量是水平的；它会告诉您特定例程需要多少时间。采样是垂直的。如果有任何方法可以避免整个程序在那一刻正在做的事情， <em>并且如果您在第二个示例中看到它</em>
，那么您就找到了瓶颈。这就是与众不同的原因 - 看到花费时间的全部原因，而不仅仅是多少。</p>
<p><br></p>
<h3>更多建议</h3>
<p>使用具有以下选项的Valgrind ：</p>
<div class="code"><pre class="code literal-block"><span class="n">valgrind</span><span class="w"> </span><span class="o">--</span><span class="k">tool</span><span class="o">=</span><span class="n">callgrind</span><span class="w"> </span><span class="o">./</span><span class="p">(</span><span class="n">Your</span><span class="w"> </span><span class="n">binary</span><span class="p">)</span>
</pre></div>

<p>这会生成一个名为<code>callgrind.out.x</code>. 使用该<code>kcachegrind</code>工具读取此文件。它将为您提供图形分析结果，例如哪些线路成本多少。</p>
<p><br><br><a href="../how-do-i-profile-c-code-running-on-linux/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/linux/" rel="tag">linux</a></li>
            <li><a class="tag p-category" href="../../categories/profiling/" rel="tag">profiling</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-he-bing-liang-ge-git-cun-chu-ku/" rel="prev" title="如何合并两个 Git 存储库？">Previous post</a>
            </li>
            <li class="next">
                <a href="../duan-lu-array-foreach-jiu-xiang-diao-yong-break/" rel="next" title="短路 Array.forEach 就像调用 break">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
