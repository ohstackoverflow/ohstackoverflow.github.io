<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>monad只是endofunctors类别中的一个幺半群，有什么问题？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/monadzhi-shi-endofunctorslei-bie-zhong-de-yi-ge-yao-ban-qun-you-shi-yao-wen-ti/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-zai-python-zhong-shi-yong-with-open-da-kai-duo-ge-wen-jian/" title="如何在 Python 中使用“with open”打开多个文件？" type="text/html">
<link rel="next" href="../qing-li-jiu-de-yuan-cheng-git-fen-zhi/" title="清理旧的远程 git 分支" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="monad只是endofunctors类别中的一个幺半群，有什么问题？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/monadzhi-shi-endofunctorslei-bie-zhong-de-yi-ge-yao-ban-qun-you-shi-yao-wen-ti/">
<meta property="og:description" content="下面是谁先说的？

monad只是endofunctors类别中的一个幺半群，有什么问题？

还有一个不太重要的注意事项，这是真的吗？如果是的话，您能否给出解释（希望那些没有太多 Haskell 经验的人能够理解）？

解答
这个特别的措辞出自 James Iry，来自他极具娱乐性的 编程语言的简要、不完整和大部分错误的历史 ，他在其中虚构地将其归因于 Philip
Wadler。
原始引用来自 ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T10:34:18+08:00">
<meta property="article:tag" content="category-theory">
<meta property="article:tag" content="haskell">
<meta property="article:tag" content="monads">
<meta property="article:tag" content="monoids">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">monad只是endofunctors类别中的一个幺半群，有什么问题？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:34:18+08:00" itemprop="datePublished" title="2023-02-17 10:34">2023-02-17 10:34</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>下面是谁先说的？</p>
<blockquote>
<p>monad只是endofunctors类别中的一个幺半群，有什么问题？</p>
</blockquote>
<p>还有一个不太重要的注意事项，这是真的吗？如果是的话，您能否给出解释（希望那些没有太多 Haskell 经验的人能够理解）？</p>
<p><br><br></p>
<h2>解答</h2>
<p>这个特别的措辞出自 James Iry，来自他极具娱乐性的 <em>编程语言的简要、不完整和大部分错误的历史</em> ，他在其中虚构地将其归因于 Philip
Wadler。</p>
<p>原始引用来自 Saunders Mac Lane 的 <em>Categories for the Working Mathematician</em>
，这是范畴论的基础文本之一。Here it is in context，这可能是准确了解其含义的最佳位置。</p>
<p>但是，我会试一试。原句是这样的：</p>
<blockquote>
<p>总而言之，X 中的单子只是 X 的内函子范畴中的幺半群，乘积 × 由内函子的组合替换，单位由恒等内函子设置。</p>
</blockquote>
<p><em>这里的X</em> 是一个类别。内函子是从类别到自身的函子（就函数式程序员而言，通常 <em>都是s ，因为他们主要只处理一个类别；类型的类别——但我离题了）。</em>
<em>但是您可以想象另一个类别，即“ X</em><code>Functor</code>上的内函子”类别。这是一个对象是内函子而态射是自然变换的范畴。 __</p>
<p>在这些内函子中，其中一些可能是单子。哪些是单子？正是那些在特定意义上是 <em>幺半群的。</em> 我没有详细说明从单子到幺半群的确切映射（因为 Mac Lane
做得比我希望的要好得多），我只是将它们各自的定义并排放置，让你比较：</p>
<h3>一个幺半群是...</h3>
<ul>
<li>一组， _ <strong>S</strong>_</li>
<li>一个操作， _ <strong>• : S × S → S</strong>_</li>
<li>
<em>S</em> 的一个元素， _ <strong>e : 1 → S</strong>_</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li>
<em>(a • b) • c = a • (b • c)</em> ，对于 <em>S</em> 中的所有 <em>a</em> 、 <em>b</em> 和 <em>c</em> __</li>
<li>
<em>e • a = a • e = a</em> ，对于 <em>S</em> 中的所有 <em>a</em> __</li>
</ul>
<h3>一个单子是...</h3>
<ul>
<li>一个内函子， _ <strong>T : X → X</strong>_<code>* -&gt; *</code> （在 Haskell 中，是一种带有实例的类型构造函数<code>Functor</code>）</li>
<li>自然变换， _ <strong>μ : T × T → T</strong><em> ，其中 </em>×<em> 表示函子组合（ _μ</em> 在 Haskell 中称为 <em><code>join</code></em> ）</li>
<li>一个自然变换， _ <strong>η : I → T</strong><em> ，其中 _I是</em> <em>X</em> 上的身份内函子（ <em>η</em> 在 Haskell 中被称为 <em><code>return</code></em> ）</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li><em>μ ∘ Tμ = μ ∘ μT</em></li>
<li>
<em>μ ∘ Tη = μ ∘ ηT = 1</em> （恒等式自然变换）</li>
</ul>
<p>稍微眯着眼睛，您可能会发现这两个定义都是同一个抽象概念的实例。</p>
<p><br></p>
<h3>更多建议</h3>
<p>首先，我们将要使用的扩展和库：</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span><span class="o">-</span><span class="c1"># LANGUAGE RankNTypes, TypeOperators #-}</span>

<span class="kn">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="n">join</span><span class="p">)</span>
</pre></div>

<p>其中，<code>RankNTypes</code>是唯一对以下内容绝对必要的。我曾经写过一篇解释，<code>RankNTypes</code>有些人似乎觉得有用，所以我会参考它。</p>
<p>引用Tom Crockett 的出色回答，我们有：</p>
<blockquote>
<h3>一个单子是...</h3>
<ul>
<li>一个内函子， _ <strong>T : X - &gt; X</strong>_</li>
<li>自然变换， _ <strong>μ : T × T - &gt; T</strong><em>，其中 </em>×_ 表示函子组合</li>
<li>自然变换 _ <strong>η : I - &gt; T</strong><em>，其中 _I是</em> <em>X</em> 上的身份内函子 __
</li>
</ul>
<h4>...满足这些法律：</h4>
<ul>
<li><em>μ(μ(T × T) × T)) = μ(T × μ(T × T))</em></li>
<li>
<em>μ(η(T)) = T = μ(T(η))</em>
</li>
</ul>
</blockquote>
<p>我们如何将其翻译成 Haskell 代码？ <strong>好吧，让我们从自然变换</strong> 的概念开始：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">--</span> <span class="p">|</span> <span class="nv">A</span> <span class="s s-Atom">natural</span> <span class="s s-Atom">transformations</span> <span class="s s-Atom">between</span> <span class="s s-Atom">two</span> <span class="s s-Atom">'Functor'</span> <span class="s s-Atom">instances</span><span class="p">.</span>  <span class="nv">Law</span><span class="o">:</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">--</span> <span class="o">&gt;</span> <span class="s s-Atom">fmap</span> <span class="s s-Atom">f</span> <span class="p">.</span> <span class="s s-Atom">eta</span> <span class="s s-Atom">g</span> <span class="o">==</span> <span class="s s-Atom">eta</span> <span class="s s-Atom">g</span> <span class="p">.</span> <span class="s s-Atom">fmap</span> <span class="s s-Atom">f</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">--</span> <span class="nv">Neat</span> <span class="s s-Atom">fact</span><span class="p">:</span> <span class="s s-Atom">the</span> <span class="s s-Atom">type</span> <span class="s s-Atom">system</span> <span class="s s-Atom">actually</span> <span class="s s-Atom">guarantees</span> <span class="s s-Atom">this</span> <span class="s s-Atom">law</span><span class="p">.</span>
<span class="s s-Atom">--</span>
<span class="s s-Atom">newtype</span> <span class="nf">f</span> <span class="o">:-&gt;</span> <span class="s s-Atom">g</span> <span class="o">=</span>
    <span class="nv">Natural</span> <span class="p">{</span> <span class="s s-Atom">eta</span> <span class="o">::</span> <span class="s s-Atom">forall</span> <span class="s s-Atom">x</span><span class="p">.</span> <span class="s s-Atom">f</span> <span class="s s-Atom">x</span> <span class="s s-Atom">-&gt;</span> <span class="s s-Atom">g</span> <span class="s s-Atom">x</span> <span class="p">}</span>
</pre></div>

<p>形式的类型<code>f :-&gt; g</code>类似于函数类型，但与其将其视为两种 <em>类型</em> （属于 kind ）之间的 <em>函数</em> ，不如将其视为两个 <strong>函子</strong> （属于
kind ）之间的 <strong>态射。</strong> 例子： __<code>*</code> <strong><em>* </em></strong>*<code>* -&gt; *</code></p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">listToMaybe</span> <span class="o">::</span> <span class="p">[]</span> <span class="o">:-&gt;</span> <span class="nv">Maybe</span>
<span class="s s-Atom">listToMaybe</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">go</span>
    <span class="s s-Atom">where</span> <span class="s s-Atom">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="nv">Nothing</span>
          <span class="nf">go</span> <span class="p">(</span><span class="s s-Atom">x</span><span class="p">:</span><span class="k">_</span><span class="p">)</span> <span class="o">=</span> <span class="nv">Just</span> <span class="s s-Atom">x</span>

<span class="s s-Atom">maybeToList</span> <span class="o">::</span> <span class="nv">Maybe</span> <span class="o">:-&gt;</span> <span class="p">[]</span>
<span class="s s-Atom">maybeToList</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">go</span>
    <span class="s s-Atom">where</span> <span class="s s-Atom">go</span> <span class="nv">Nothing</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="nf">go</span> <span class="p">(</span><span class="nv">Just</span> <span class="s s-Atom">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">x</span><span class="p">]</span>

<span class="s s-Atom">reverse' :: [] :-&gt; []</span>
<span class="s s-Atom">reverse'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="s s-Atom">reverse</span>
</pre></div>

<p>基本上，在 Haskell 中，自然转换是从某种类型<code>f x</code>到另一种类型的函数<code>g
x</code>，这样<code>x</code>类型变量对于调用者是“不可访问的”。因此，例如，<code>sort :: Ord a =&gt; [a] -&gt;
[a]</code>不能进行自然转换，因为它对我们可以实例化的类型很“挑剔” <code>a</code>。我经常用来思考的一种直观方法如下：</p>
<ul>
<li>仿函数是一种在不触及 <em>结构的情况下对</em> <em>内容</em> 进行操作的方法。 __</li>
<li>自然转换是一种在不接触或查看 <em>内容的情况下对某事物的</em> <em>结构</em> 进行操作的方式。 __</li>
</ul>
<p>现在，撇开这些不谈，让我们来处理定义的子句。</p>
<p>第一个子句是“一个内函子， _ <strong>T : X - &gt; X</strong>_ ”。好吧，Haskell 中的 every<code>Functor</code>是人们称之为“Hask
类别”的内函子，其对象是 Haskell 类型（属于 kind <code>*</code>），其态射是 Haskell
函数。这听起来像是一个复杂的陈述，但它实际上是一个非常微不足道的陈述。这意味着 a 为您提供了为 any构造类型和从 any构造函数<code>Functor f
:: * -&gt; *</code>的方法，并且这些都遵守函子法则。<code>f a :: * ``a :: *``fmap f :: f a -&gt; f b``f :: a -&gt;
b</code></p>
<p>第二个子句：<code>Identity</code>Haskell 中的仿函数（它是平台自带的，所以你可以直接导入它）是这样定义的：</p>
<div class="code"><pre class="code literal-block">newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
    fmap f (Identity a) = Identity (f a)
</pre></div>

<p>因此，汤姆·克罗克特 (Tom Crockett) 定义的自然变换 _ <strong>η : I - &gt; T</strong>_<code>Monad</code>对于任何实例都可以这样写<code>t</code>：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">return' :: Monad t =&gt; Identity :-&gt; t</span>
<span class="s s-Atom">return'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="p">(</span><span class="s s-Atom">return</span> <span class="p">.</span> <span class="s s-Atom">runIdentity</span><span class="p">)</span>
</pre></div>

<p>第三条：Haskell 中两个函子的组合可以这样定义（平台也有）：</p>
<div class="code"><pre class="code literal-block">newtype Compose f g a = Compose { getCompose :: f (g a) }

-- | The composition of two 'Functor's is also a 'Functor'.
instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
    fmap f (Compose fga) = Compose (fmap (fmap f) fga)
</pre></div>

<p>因此，Tom Crockett 定义的自然变换 _ <strong>μ : T × T - &gt; T</strong>_可以这样写：</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">join' :: Monad t =&gt; Compose t t :-&gt; t</span>
<span class="s s-Atom">join'</span> <span class="o">=</span> <span class="nv">Natural</span> <span class="p">(</span><span class="s s-Atom">join</span> <span class="p">.</span> <span class="s s-Atom">getCompose</span><span class="p">)</span>
</pre></div>

<p>声明这是内函子类别中的幺半群，则意味着<code>Compose</code>（仅部分应用于其前两个参数）是关联的，这<code>Identity</code>就是它的恒等元。即，以下同构成立：</p>
<ul>
<li><code>Compose f (Compose g h) ~= Compose (Compose f g) h</code></li>
<li><code>Compose f Identity ~= f</code></li>
<li><code>Compose Identity g ~= g</code></li>
</ul>
<p>这些很容易证明，因为<code>Compose</code>和<code>Identity</code>都被定义为<code>newtype</code>，Haskell 报告将
的语义定义为被定义的类型与的数据构造<code>newtype</code>函数的参数类型之间的同构。<code>newtype</code>例如，让我们证明<code>Compose f Identity
~= f</code>：</p>
<div class="code"><pre class="code literal-block">Compose f Identity a
    ~= f (Identity a)                 -- newtype Compose f g a = Compose (f (g a))
    ~= f a                            -- newtype Identity a = Identity a
Q.E.D.
</pre></div>

<p><br><br><a href="../a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/category-theory/" rel="tag">category-theory</a></li>
            <li><a class="tag p-category" href="../../categories/haskell/" rel="tag">haskell</a></li>
            <li><a class="tag p-category" href="../../categories/monads/" rel="tag">monads</a></li>
            <li><a class="tag p-category" href="../../categories/monoids/" rel="tag">monoids</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-zai-python-zhong-shi-yong-with-open-da-kai-duo-ge-wen-jian/" rel="prev" title="如何在 Python 中使用“with open”打开多个文件？">Previous post</a>
            </li>
            <li class="next">
                <a href="../qing-li-jiu-de-yuan-cheng-git-fen-zhi/" rel="next" title="清理旧的远程 git 分支">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
