<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What is a plain English explanation of "Big O" notation? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-is-a-plain-english-explanation-of-big-o-notation/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../reset-local-repository-branch-to-be-just-like-remote-repository-head/" title="Reset local repository branch to be just like remote repository HEAD" type="text/html">
<link rel="next" href="../how-do-i-resolve-merge-conflicts-in-a-git-repository/" title="How do I resolve merge conflicts in a Git repository?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content='What is a plain English explanation of "Big O" notation?'>
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-is-a-plain-english-explanation-of-big-o-notation/">
<meta property="og:description" content="I'd prefer as little formal definition as possible and simple mathematics.

Answer
Quick note, my answer is almost certainly confusing Big Oh notation (which is
an upper bound) with Big Theta notation">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T18:42:20+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="big-o">
<meta property="article:tag" content="complexity-theory">
<meta property="article:tag" content="computer-science">
<meta property="article:tag" content="time-complexity">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What is a plain English explanation of "Big O" notation?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:42:20+08:00" itemprop="datePublished" title="2023-02-16 18:42">2023-02-16 18:42</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I'd prefer as little formal definition as possible and simple mathematics.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Quick note, my answer is almost certainly confusing Big Oh notation (which is
an upper bound) with Big Theta notation "Θ" (which is a two-side bound). But
in my experience, this is actually typical of discussions in non-academic
settings. Apologies for any confusion caused.</p>
<hr>
<p>BigOh complexity can be visualized with this graph:</p>
<p><img alt="Big Oh Analysis" src="../../images/WcBRI.png"></p>
<p>The simplest definition I can give for Big Oh notation is this:</p>
<p><strong>Big Oh notation is a relative representation of the complexity of an
algorithm.</strong></p>
<p>There are some important and deliberately chosen words in that sentence:</p>
<blockquote>
<ul>
<li>
<strong>relative:</strong> you can only compare apples to apples. You can't compare
an algorithm that does arithmetic multiplication to an algorithm that sorts
a list of integers. But a comparison of two algorithms to do arithmetic
operations (one multiplication, one addition) will tell you something
meaningful;</li>
<li>
<strong>representation:</strong> BigOh (in its simplest form) reduces the comparison
between algorithms to a single variable. That variable is chosen based on
observations or assumptions. For example, sorting algorithms are typically
compared based on comparison operations (comparing two nodes to determine
their relative ordering). This assumes that comparison is expensive. But
what if the comparison is cheap but swapping is expensive? It changes the
comparison; and</li>
<li>
<strong>complexity:</strong> if it takes me one second to sort 10,000 elements, how
long will it take me to sort one million? Complexity in this instance is a
relative measure to something else.
</li>
</ul>
</blockquote>
<p>Come back and reread the above when you've read the rest.</p>
<p>The best example of BigOh I can think of is doing arithmetic. Take two numbers
(123456 and 789012). The basic arithmetic operations we learned in school
were:</p>
<blockquote>
<ul>
<li>addition;</li>
<li>subtraction;</li>
<li>multiplication; and</li>
<li>division.
</li>
</ul>
</blockquote>
<p>Each of these is an operation or a problem. A method of solving these is
called an <strong>algorithm</strong>.</p>
<p>The addition is the simplest. You line the numbers up (to the right) and add
the digits in a column writing the last number of that addition in the result.
The 'tens' part of that number is carried over to the next column.</p>
<p>Let's assume that the addition of these numbers is the most expensive
operation in this algorithm. It stands to reason that to add these two numbers
together we have to add together 6 digits (and possibly carry a 7th). If we
add two 100 digit numbers together we have to do 100 additions. If we add
<strong>two</strong> 10,000 digit numbers we have to do 10,000 additions.</p>
<p>See the pattern? The <strong>complexity</strong> (being the number of operations) is
directly proportional to the number of digits <em>n</em> in the larger number. We
call this <strong>O(n)</strong> or <strong>linear complexity</strong>.</p>
<p>Subtraction is similar (except you may need to borrow instead of carry).</p>
<p>Multiplication is different. You line the numbers up, take the first digit in
the bottom number and multiply it in turn against each digit in the top number
and so on through each digit. So to multiply our two 6 digit numbers we must
do 36 multiplications. We may need to do as many as 10 or 11 column adds to
get the end result too.</p>
<p>If we have two 100-digit numbers we need to do 10,000 multiplications and 200
adds. For two one million digit numbers we need to do one trillion (1012)
multiplications and two million adds.</p>
<p>As the algorithm scales with n- <em>squared</em> , this is <strong>O(n 2)</strong> or <strong>quadratic
complexity</strong>. This is a good time to introduce another important concept:</p>
<p><strong>We only care about the most significant portion of complexity.</strong></p>
<p>The astute may have realized that we could express the number of operations
as: n2 + 2n. But as you saw from our example with two numbers of a million
digits apiece, the second term (2n) becomes insignificant (accounting for
0.0002% of the total operations by that stage).</p>
<p>One can notice that we've assumed the worst case scenario here. While
multiplying 6 digit numbers, if one of them has 4 digits and the other one has
6 digits, then we only have 24 multiplications. Still, we calculate the worst
case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big Oh
notation is about the Worst-case scenario of an algorithm.</p>
<h2>The Telephone Book</h2>
<p>The next best example I can think of is the telephone book, normally called
the White Pages or similar but it varies from country to country. But I'm
talking about the one that lists people by surname and then initials or first
name, possibly address and then telephone numbers.</p>
<p>Now if you were instructing a computer to look up the phone number for "John
Smith" in a telephone book that contains 1,000,000 names, what would you do?
Ignoring the fact that you could guess how far in the S's started (let's
assume you can't), what would you do?</p>
<p>A typical implementation might be to open up to the middle, take the 500,000th
and compare it to "Smith". If it happens to be "Smith, John", we just got
really lucky. Far more likely is that "John Smith" will be before or after
that name. If it's after we then divide the last half of the phone book in
half and repeat. If it's before then we divide the first half of the phone
book in half and repeat. And so on.</p>
<p>This is called a <strong>binary search</strong> and is used every day in programming
whether you realize it or not.</p>
<p>So if you want to find a name in a phone book of a million names you can
actually find any name by doing this at most 20 times. In comparing search
algorithms we decide that this comparison is our 'n'.</p>
<blockquote>
<ul>
<li>For a phone book of 3 names it takes 2 comparisons (at most).</li>
<li>For 7 it takes at most 3.</li>
<li>For 15 it takes 4.</li>
<li>…</li>
<li>For 1,000,000 it takes 20.
</li>
</ul>
</blockquote>
<p>That is staggeringly good, isn't it?</p>
<p>In BigOh terms this is <strong>O(log n)</strong> or <strong>logarithmic complexity</strong>. Now the
logarithm in question could be ln (base e), log10, log2 or some other base. It
doesn't matter it's still O(log n) just like O(2n2) and O(100n2) are still
both O(n2).</p>
<p>It's worthwhile at this point to explain that BigOh can be used to determine
three cases with an algorithm:</p>
<blockquote>
<ul>
<li>
<strong>Best Case:</strong> In the telephone book search, the best case is that we
find the name in one comparison. This is <strong>O(1)</strong> or <strong>constant complexity</strong>
;</li>
<li>
<strong>Expected Case:</strong> As discussed above this is O(log n); and</li>
<li>
<strong>Worst Case:</strong> This is also O(log n).
</li>
</ul>
</blockquote>
<p>Normally we don't care about the best case. We're interested in the expected
and worst case. Sometimes one or the other of these will be more important.</p>
<p>Back to the telephone book.</p>
<p>What if you have a phone number and want to find a name? The police have a
reverse phone book but such look-ups are denied to the general public. Or are
they? Technically you can reverse look-up a number in an ordinary phone book.
How?</p>
<p>You start at the first name and compare the number. If it's a match, great, if
not, you move on to the next. You have to do it this way because the phone
book is <strong>unordered</strong> (by phone number anyway).</p>
<p>So to find a name given the phone number (reverse lookup):</p>
<blockquote>
<ul>
<li>
<strong>Best Case:</strong> O(1);</li>
<li>
<strong>Expected Case:</strong> O(n) (for 500,000); and</li>
<li>
<strong>Worst Case:</strong> O(n) (for 1,000,000).
</li>
</ul>
</blockquote>
<h2>The Traveling Salesman</h2>
<p>This is quite a famous problem in computer science and deserves a mention. In
this problem, you have N towns. Each of those towns is linked to 1 or more
other towns by a road of a certain distance. The Traveling Salesman problem is
to find the shortest tour that visits every town.</p>
<p>Sounds simple? Think again.</p>
<p>If you have 3 towns A, B, and C with roads between all pairs then you could
go:</p>
<blockquote>
<ul>
<li>A → B → C</li>
<li>A → C → B</li>
<li>B → C → A</li>
<li>B → A → C</li>
<li>C → A → B</li>
<li>C → B → A
</li>
</ul>
</blockquote>
<p>Well, actually there's less than that because some of these are equivalent (A
→ B → C and C → B → A are equivalent, for example, because they use the same
roads, just in reverse).</p>
<p>In actuality, there are 3 possibilities.</p>
<blockquote>
<ul>
<li>Take this to 4 towns and you have (iirc) 12 possibilities.</li>
<li>With 5 it's 60.</li>
<li>6 becomes 360.
</li>
</ul>
</blockquote>
<p>This is a function of a mathematical operation called a <strong>factorial</strong>.
Basically:</p>
<blockquote>
<ul>
<li>5! = 5 × 4 × 3 × 2 × 1 = 120</li>
<li>6! = 6 × 5 × 4 × 3 × 2 × 1 = 720</li>
<li>7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040</li>
<li>…</li>
<li>25! = 25 × 24 × … × 2 × 1 = 15,511,210,043,330,985,984,000,000</li>
<li>…</li>
<li>50! = 50 × 49 × … × 2 × 1 = 3.04140932 × 1064
</li>
</ul>
</blockquote>
<p>So the BigOh of the Traveling Salesman problem is <strong>O(n!)</strong> or <strong>factorial or
combinatorial complexity</strong>.</p>
<p><strong>By the time you get to 200 towns there isn't enough time left in the
universe to solve the problem with traditional computers.</strong></p>
<p>Something to think about.</p>
<h2>Polynomial Time</h2>
<p>Another point I wanted to make a quick mention of is that any algorithm that
has a complexity of <strong>O(n a)</strong> is said to have <strong>polynomial complexity</strong> or is
solvable in <strong>polynomial time</strong>.</p>
<p>O(n), O(n2) etc. are all polynomial time. Some problems cannot be solved in
polynomial time. Certain things are used in the world because of this. Public
Key Cryptography is a prime example. It is computationally hard to find two
prime factors of a very large number. If it wasn't, we couldn't use the public
key systems we use.</p>
<p>Anyway, that's it for my (hopefully plain English) explanation of BigOh
(revised).</p>
<p><br></p>
<h3>Suggest</h3>
<p>It shows how an algorithm scales based on input size.</p>
<p><strong>O(n 2)</strong>: known as <strong>Quadratic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 100 operations</li>
<li>100 items: 10,000 operations</li>
</ul>
<p>Notice that the number of items increases by a factor of 10, but the time
increases by a factor of 102. Basically, n=10 and so O(n2) gives us the
scaling factor n2 which is 102.</p>
<p><strong>O(n)</strong> : known as <strong>Linear complexity</strong></p>
<ul>
<li>1 item: 1 operation</li>
<li>10 items: 10 operations</li>
<li>100 items: 100 operations</li>
</ul>
<p>This time the number of items increases by a factor of 10, and so does the
time. n=10 and so O(n)'s scaling factor is 10.</p>
<p><strong>O(1)</strong> : known as <strong>Constant complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 1 operations</li>
<li>100 items: 1 operations</li>
</ul>
<p>The number of items is still increasing by a factor of 10, but the scaling
factor of O(1) is always 1.</p>
<p><strong>O(log n)</strong> : known as <strong>Logarithmic complexity</strong></p>
<ul>
<li>1 item: 1 operations</li>
<li>10 items: 2 operations</li>
<li>100 items: 3 operations</li>
<li>1000 items: 4 operations</li>
<li>10,000 items: 5 operations</li>
</ul>
<p>The number of computations is only increased by a log of the input value. So
in this case, assuming each computation takes 1 second, the log of the input
<code>n</code> is the time required, hence <code>log n</code>.</p>
<p>That's the gist of it. They reduce the maths down so it might not be exactly
n2 or whatever they say it is, but that'll be the dominating factor in the
scaling.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/big-o/" rel="tag">big-o</a></li>
            <li><a class="tag p-category" href="../../categories/complexity-theory/" rel="tag">complexity-theory</a></li>
            <li><a class="tag p-category" href="../../categories/computer-science/" rel="tag">computer-science</a></li>
            <li><a class="tag p-category" href="../../categories/time-complexity/" rel="tag">time-complexity</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../reset-local-repository-branch-to-be-just-like-remote-repository-head/" rel="prev" title="Reset local repository branch to be just like remote repository HEAD">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-resolve-merge-conflicts-in-a-git-repository/" rel="next" title="How do I resolve merge conflicts in a Git repository?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
