<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java 8 Iterable.forEach() 与 foreach 循环 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/java-8-iterable-foreach-yu-foreach-xun-huan/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ef-qian-yi-hui-gun-shang-ci-ying-yong-de-qian-yi/" title="EF 迁移：回滚上次应用的迁移？" type="text/html">
<link rel="next" href="../zai-javascript-zhong-bo-chong-sui-ji-shu-sheng-cheng-qi/" title="在 Javascript 中播种随机数生成器" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Java 8 Iterable.forEach() 与 foreach 循环">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/java-8-iterable-foreach-yu-foreach-xun-huan/">
<meta property="og:description" content="以下哪项是 Java 8 中更好的做法？
Java 8：
joins.forEach(join -&gt; mIrc.join(mSession, join));


Java 7：
for (String join : joins) {
    mIrc.join(mSession, join);
}


我有很多可以用 lambda 表达式“简化”的 for 循环，但是使用它们真的有什么好处吗？它会">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T05:22:05+08:00">
<meta property="article:tag" content="for-loop">
<meta property="article:tag" content="java">
<meta property="article:tag" content="java-8">
<meta property="article:tag" content="java-stream">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java 8 Iterable.forEach() 与 foreach 循环</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T05:22:05+08:00" itemprop="datePublished" title="2023-02-18 05:22">2023-02-18 05:22</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>以下哪项是 Java 8 中更好的做法？</p>
<p>Java 8：</p>
<div class="code"><pre class="code literal-block"><span class="n">joins</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="nf">join</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">mIrc</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">mSession</span><span class="p">,</span><span class="w"> </span><span class="nf">join</span><span class="p">));</span>
</pre></div>

<p>Java 7：</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">String</span><span class="w"> </span><span class="nv">join</span><span class="w"> </span>:<span class="w"> </span><span class="nv">joins</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">mIrc</span>.<span class="nv">join</span><span class="ss">(</span><span class="nv">mSession</span>,<span class="w"> </span><span class="nv">join</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>我有很多可以用 lambda 表达式“简化”的 for 循环，但是使用它们真的有什么好处吗？它会提高它们的性能和可读性吗？</p>
<p><strong>编辑</strong></p>
<p>我还将把这个问题扩展到更长的方法。我知道您不能从 lambda 返回或中断父函数，在比较它们时也应该考虑到这一点，但是还有什么要考虑的吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>更好的做法是使用<code>for-each</code>. 除了违背 <em>Keep It Simple, Stupid</em>
原则外，这种新奇产品<code>forEach()</code>至少还有以下不足：</p>
<ul>
<li>
<strong>不能使用非最终变量</strong> 。所以，像下面这样的代码不能变成 forEach lambda：</li>
</ul>
<blockquote>
<div class="code"><pre class="code literal-block"><span class="nv">Object</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">null</span><span class="c1">;</span>
<span class="k">for</span><span class="ss">(</span><span class="nv">Object</span><span class="w"> </span><span class="nv">curr</span><span class="w"> </span>:<span class="w"> </span><span class="nv">list</span><span class="ss">)</span>
{
<span class="w">    </span><span class="k">if</span><span class="ss">(</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">null</span><span class="w"> </span><span class="ss">)</span>
<span class="w">        </span><span class="nv">foo</span><span class="ss">(</span><span class="nv">prev</span>,<span class="w"> </span><span class="nv">curr</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">curr</span><span class="c1">;</span>
}
</pre></div>

</blockquote>
<ul>
<li>
<p><strong>无法处理已检查的异常</strong> 。Lambdas 实际上并没有被禁止抛出检查过的异常，但是常见的功能接口如<code>Consumer</code>不声明任何。因此，任何抛出已检查异常的代码都必须将它们包装在<code>try-catch</code>or中<code>Throwables.propagate()</code>。但即使您这样做了，也并不总是清楚抛出的异常会发生什么。它可能会被吞入内脏的某个地方<code>forEach()</code></p>
</li>
<li>
<p><strong>有限的流量控制</strong> 。<code>return</code>lambda 中的A等于<code>continue</code>for-each 中的 a，但没有等同于 a 的<code>break</code>。执行诸如返回值、短路或 <em>设置标志之类</em> 的事情也很困难（如果不违反 <em>无非最终变量</em> 规则，这会稍微缓解一些事情）。“这不仅仅是一种优化，而且当你考虑到某些序列（比如读取文件中的行）可能有副作用，或者你可能有一个无限序列时，这就很重要了。”</p>
</li>
<li>
<p><strong>可能并行执行</strong> ，这对除了需要优化的 0.1% 代码之外的所有人来说都是一件可怕的事情。任何并行代码都必须经过深思熟虑（即使它不使用锁、易失性和传统多线程执行的其他特别讨厌的方面）。任何错误都很难找到。</p>
</li>
<li>
<p><strong>可能会影响性能</strong> ，因为 JIT 无法将 forEach()+lambda 优化到与普通循环相同的程度，尤其是现在 lambda 是新的。我所说的“优化”并不是指调用 lambda 的开销（很小），而是指现代 JIT 编译器对运行代码执行的复杂分析和转换。</p>
</li>
<li>
<p><strong>如果您确实需要并行性，那么使用 ExecutorService 可能会更快并且不会更难</strong> 。流都是自动的（阅读：对你的问题了解不多） <em>并</em> 使用专门的（阅读：一般情况下效率低下）并行化策略（fork-join 递归分解）。</p>
</li>
<li>
<p><strong>使调试更加混乱</strong> ，因为嵌套的调用层次结构，上帝保佑，并行执行。调试器在显示周围代码中的变量时可能会出现问题，并且诸如逐步执行之类的操作可能无法按预期工作。</p>
</li>
<li>
<p><strong>流通常更难编码、读取和调试</strong> 。实际上，一般来说，复杂的“流畅”API都是如此。复杂的单一语句、大量使用泛型和缺少中间变量的组合共同产生了令人困惑的错误消息并阻碍了调试。而不是“此方法没有类型 X 的重载”，您会收到一条错误消息，更接近于“您在某个地方弄乱了类型，但我们不知道在哪里或如何”。同样，您不能像将代码分解为多个语句并将中间值保存到变量中那样轻松地逐步检查调试器中的内容。最后，阅读代码并理解每个执行阶段的类型和行为可能很重要。</p>
</li>
<li>
<p><strong>像拇指一样突出</strong> 。Java 语言已经有了 for-each 语句。为什么用函数调用替换它？为什么鼓励在表达式中的某处隐藏副作用？为什么要鼓励笨重的单行代码？随意混合常规的 for-each 和新的 forEach 是糟糕的风格。代码应该用成语说话（由于重复而很快理解的模式），使用的成语越少，代码越清晰，花在决定使用哪个成语上的时间就越少（对于像我这样的完美主义者来说，这是一个很大的时间消耗！ ).</p>
</li>
</ul>
<p>如您所见，我不是 forEach() 的忠实粉丝，除非它有意义。</p>
<p>对我来说特别令人反感的是它<code>Stream</code>没有实现<code>Iterable</code>（尽管实际上有方法<code>iterator</code>）并且不能在 for-each 中使用，只能与
forEach() 一起使用。我建议使用<code>(Iterable&lt;T&gt;)stream::iterator</code>. 更好的选择是使用StreamEx，它修复了许多
Stream API 问题，包括实现<code>Iterable</code>.</p>
<p>也就是说，<code>forEach()</code>对于以下内容很有用：</p>
<ul>
<li>
<p><strong>原子地迭代同步列表</strong> 。在此之前，生成的列表<code>Collections.synchronizedList()</code>对于 get 或 set 之类的事情是原子的，但在迭代时不是线程安全的。</p>
</li>
<li>
<p><strong>并行执行（使用适当的并行流）</strong> 。如果您的问题符合 Streams 和 Spliterator 中内置的性能假设，那么与使用 ExecutorService 相比，这可以为您节省几行代码。</p>
</li>
<li>
<p><strong>特定的容器</strong> ，如同步列表，受益于控制迭代（尽管这在很大程度上是理论上的，除非人们可以举出更多的例子）</p>
</li>
<li>
<p><strong><em>*通过使用<code>forEach()</code>和方法引用参数（即） </em>*更干净地调用单个函数</strong><code>list.forEach (obj::someMethod)</code>。但是，请记住有关已检查异常、更难调试以及减少编写代码时使用的习语数量的要点。</p>
</li>
</ul>
<p>我参考的文章：</p>
<ul>
<li>关于 Java 8 的一切</li>
<li>Iteration Inside and Out（正如另一位海报所指出的）</li>
</ul>
<p><strong>编辑：</strong> 看起来 lambda 的一些原始建议（例如http://www.javac.info/closures-v06a.html  Google
Cache）解决了我提到的一些问题（当然，同时增加了它们自己的复杂性）。</p>
<p><br></p>
<h3>更多建议</h3>
<p>当操作可以并行执行时，优势就体现出来了。（参见http://java.dzone.com/articles/devoxx-2012-java-8-lambda-
and - 关于内部和外部迭代的部分）</p>
<ul>
<li>
<p>从我的角度来看，主要优点是可以定义在循环内执行的操作，而不必决定是并行执行还是顺序执行</p>
</li>
<li>
<p>如果你想让你的循环并行执行，你可以简单地写</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">joins</span><span class="p">.</span><span class="n">parallelStream</span><span class="p">().</span><span class="n">forEach</span><span class="p">(</span><span class="nf">join</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">mIrc</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">mSession</span><span class="p">,</span><span class="w"> </span><span class="nf">join</span><span class="p">));</span>
</pre></div>

</li>
</ul>
<p>您将不得不为线程处理等编写一些额外的代码。</p>
<p><strong>注意：</strong> 对于我的回答，我假设 join 实现了<code>java.util.Stream</code>接口。如果 joins
仅实现<code>java.util.Iterable</code>接口，则不再如此。</p>
<p><br><br><a href="../java-8-iterable-foreach-vs-foreach-loop/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/for-loop/" rel="tag">for-loop</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/java-8/" rel="tag">java-8</a></li>
            <li><a class="tag p-category" href="../../categories/java-stream/" rel="tag">java-stream</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ef-qian-yi-hui-gun-shang-ci-ying-yong-de-qian-yi/" rel="prev" title="EF 迁移：回滚上次应用的迁移？">Previous post</a>
            </li>
            <li class="next">
                <a href="../zai-javascript-zhong-bo-chong-sui-ji-shu-sheng-cheng-qi/" rel="next" title="在 Javascript 中播种随机数生成器">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
