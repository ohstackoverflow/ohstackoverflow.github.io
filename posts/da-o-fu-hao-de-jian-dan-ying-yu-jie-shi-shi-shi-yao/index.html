<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>“大 O”符号的简单英语解释是什么？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/da-o-fu-hao-de-jian-dan-ying-yu-jie-shi-shi-shi-yao/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../jiang-ben-di-cun-chu-ku-fen-zhi-zhong-zhi-wei-jiu-xiang-yuan-cheng-cun-chu-ku-head/" title="将本地存储库分支重置为就像远程存储库 HEAD" type="text/html">
<link rel="next" href="../ru-he-jie-jue-git-cun-chu-ku-zhong-de-he-bing-chong-tu/" title="如何解决 Git 存储库中的合并冲突？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="“大 O”符号的简单英语解释是什么？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/da-o-fu-hao-de-jian-dan-ying-yu-jie-shi-shi-shi-yao/">
<meta property="og:description" content="我更喜欢尽可能少的正式定义和简单的数学。

解答
快速说明，我的回答几乎肯定会混淆Big Oh 符号（上限）和 Big Theta
符号“Θ”（两侧边界）。但根据我的经验，这实际上是非学术环境中的典型讨论。对造成的任何混乱表示歉意。

BigOh 的复杂性可以用这张图来形象化：

我可以为 Big Oh 符号给出的最简单定义是：
Big Oh 符号是算法复杂性的相对表示。
该句子中有一些重要且故意">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T18:42:44+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="big-o">
<meta property="article:tag" content="complexity-theory">
<meta property="article:tag" content="computer-science">
<meta property="article:tag" content="time-complexity">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">“大 O”符号的简单英语解释是什么？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T18:42:44+08:00" itemprop="datePublished" title="2023-02-16 18:42">2023-02-16 18:42</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我更喜欢尽可能少的正式定义和简单的数学。</p>
<p><br><br></p>
<h2>解答</h2>
<p>快速说明，我的回答几乎肯定会混淆Big Oh 符号（上限）和 Big Theta
符号“Θ”（两侧边界）。但根据我的经验，这实际上是非学术环境中的典型讨论。对造成的任何混乱表示歉意。</p>
<hr>
<p>BigOh 的复杂性可以用这张图来形象化：</p>
<p><img alt="大哦分析" src="../../images/WcBRI.png"></p>
<p>我可以为 Big Oh 符号给出的最简单定义是：</p>
<p><strong>Big Oh 符号是算法复杂性的相对表示。</strong></p>
<p>该句子中有一些重要且故意选择的词：</p>
<blockquote>
<ul>
<li>
<strong>相对：</strong>
你只能比较苹果与苹果。您不能将执行算术乘法的算法与对整数列表进行排序的算法进行比较。但是比较两种算法来进行算术运算（一种乘法，一种加法）会告诉你一些有意义的事情；</li>
<li>
<strong>表示：</strong>
BigOh（最简单的形式）将算法之间的比较减少到单个变量。该变量是根据观察或假设选择的。例如，排序算法通常基于比较操作（比较两个节点以确定它们的相对顺序）进行比较。这假设比较是昂贵的。但是，如果比较便宜但交换很昂贵怎么办？它改变了比较；和</li>
<li>
<strong>复杂性：</strong> 如果我需要一秒钟来排序 10,000 个元素，那么我需要多长时间来排序 100
万个元素？在这种情况下，复杂性是对其他事物的相对衡量。
</li>
</ul>
</blockquote>
<p>阅读完其余内容后，再回来重读上面的内容。</p>
<p>我能想到的 BigOh 最好的例子就是做算术。取两个数字（123456 和 789012）。我们在学校学到的基本算术运算是：</p>
<blockquote>
<ul>
<li>添加;</li>
<li>减法；</li>
<li>乘法; 和</li>
<li>分配。
</li>
</ul>
</blockquote>
<p>其中每一个都是一个操作或一个问题。解决这些问题的方法称为 <strong>算法</strong> 。</p>
<p>添加是最简单的。您将数字排成一行（向右）并将数字添加到一列中，在结果中写入该加法的最后一个数字。该数字的“十”部分被转移到下一列。</p>
<p>让我们假设这些数字的相加是该算法中最昂贵的操作。按理说，要将这两个数字加在一起，我们必须将 6 位数字加在一起（并且可能带有第 7 位）。如果我们将两个
100 位数字加在一起，我们必须进行 100 次加法。如果我们将 <strong>两个</strong> 10,000 位数字相加，我们必须进行 10,000 次加法。</p>
<p>看到图案了吗？ <strong>复杂度</strong> （即操作数）与较大数字中的位数 <em>n成正比。</em> 我们称之为 <strong>O(n)</strong> 或 <strong>线性复杂度</strong> 。</p>
<p>减法是类似的（除了你可能需要借位而不是进位）。</p>
<p>乘法不同。您将数字排成一行，取底部数字中的第一个数字，然后依次将其与顶部数字中的每个数字相乘，依此类推。所以要将我们的两个 6 位数字相乘，我们必须进行
36 次乘法。我们可能需要添加多达 10 或 11 列才能获得最终结果。</p>
<p>如果我们有两个 100 位数字，我们需要进行 10,000 次乘法和 200 次加法。对于两个百万位数字，我们需要进行一万亿 (10 12 )
次乘法和两百万次加法。</p>
<p>由于算法按 n <em>平方</em> 缩放，因此这是 <strong>O(n 2 )</strong>或 <strong>二次复杂度</strong> 。现在是介绍另一个重要概念的好时机：</p>
<p><strong>我们只关心最重要的复杂性部分。</strong></p>
<p>精明的人可能已经意识到我们可以将操作数表示为：n 2 + 2n。但是正如您从我们的示例中看到的那样，每个数字都有两个百万位数字，第二项 (2n)
变得微不足道（占该阶段总运算的 0.0002%）。</p>
<p>可以注意到我们在这里假设了最坏的情况。6位数字相乘时，如果一个是4位，另一个是6位，那么我们只有24次乘法。尽管如此，我们还是计算了该“n”的最坏情况，即当两者都是
6 位数字时。因此，Big Oh 表示法是关于算法的最坏情况。</p>
<h2>电话簿</h2>
<p>我能想到的下一个最好的例子是电话簿，通常称为白页或类似的，但它因国家/地区而异。但我说的是按姓氏，然后是首字母或名字，可能是地址，然后是电话号码列出人员的那个。</p>
<p>现在，如果您要指示计算机在包含 1,000,000 个姓名的电话簿中查找“John Smith”的电话号码，您会怎么做？忽略你可以猜出 S
开始了多远的事实（假设你不能），你会怎么做？</p>
<p>一个典型的实现可能是向中间开放，取第 500,000个并将其与“Smith”进行比较。如果碰巧是“史密斯，约翰”，我们真的很幸运。更有可能的是，“John
Smith”将出现在该名称之前或之后。如果是在我们之后，则将电话簿的后半部分分成两半并重复。如果是之前，那么我们将电话簿的前半部分分成两半并重复。等等。</p>
<p>这称为 <strong>二进制搜索</strong> ，无论您是否意识到，它每天都在编程中使用。</p>
<p>所以如果你想在一百万个名字的电话簿中找到一个名字，你实际上可以通过最多执行 20 次来找到任何名字。在比较搜索算法时，我们决定这种比较就是我们的“n”。</p>
<blockquote>
<ul>
<li>对于 3 个名字的电话簿，需要进行 2 次比较（最多）。</li>
<li>对于 7，最多需要 3 个。</li>
<li>15 需要 4。</li>
<li>……</li>
<li>1,000,000 需要 20 个。
</li>
</ul>
</blockquote>
<p>这真是太好了，不是吗？</p>
<p>在 BigOh 术语中，这是 <strong>O(log n)</strong> 或 <strong>对数复杂度</strong> 。现在所讨论的对数可以是 ln（以 e 为底）、log 10、log
2或其他一些底数。它仍然是 O(log n) 并不重要，就像 O(2n 2 ) 和 O(100n 2 ) 仍然都是 O(n 2 ) 一样。</p>
<p>在这一点上值得解释一下，BigOh 可用于通过算法确定三种情况：</p>
<blockquote>
<ul>
<li>
<strong>Best Case：</strong> 在电话簿搜索中，最好的情况是我们在一次比较中找到名字。这是 <strong>O(1)</strong> 或 <strong>常数复杂度</strong> ；</li>
<li>
<strong>预期情况：</strong> 如上所述，这是 O(log n)；和</li>
<li>
<strong>最坏情况：</strong> 这也是 O(log n)。
</li>
</ul>
</blockquote>
<p>通常我们不关心最好的情况。我们对预期的和最坏的情况感兴趣。有时其中一个或另一个会更重要。</p>
<p>回到电话簿。</p>
<p>如果您有电话号码并想查找姓名怎么办？警方有一本反向电话簿，但公众拒绝进行此类查询。或者他们是？从技术上讲，您可以在普通电话簿中反向查找号码。如何？</p>
<p>你从名字开始比较数字。如果匹配，很好，如果不匹配，则继续下一个。您必须这样做，因为电话簿是 <strong>无序的</strong> （无论如何按电话号码）。</p>
<p>所以要找到一个给定电话号码的名字（反向查找）：</p>
<blockquote>
<ul>
<li>
<strong>最佳情况：</strong> O(1)；</li>
<li>
<strong>预期情况：</strong> O(n)（500,000）；和</li>
<li>
<strong>最坏情况：</strong> O(n)（1,000,000）。
</li>
</ul>
</blockquote>
<h2>旅行推销员</h2>
<p>这是计算机科学中一个相当著名的问题，值得一提。在这个问题中，你有 N 个城镇。这些城镇中的每一个都通过一定距离的道路与 1
个或多个其他城镇相连。旅行商问题是找到访问每个城镇的最短旅行。</p>
<p>听起来很简单？再想一想。</p>
<p>如果你有 3 个城镇 A、B 和 C，所有对之间都有道路，那么你可以去：</p>
<blockquote>
<ul>
<li>A → B → C</li>
<li>A → C → B</li>
<li>B → C → A</li>
<li>B → A → C</li>
<li>C → A → B</li>
<li>C → B → A
</li>
</ul>
</blockquote>
<p>好吧，实际上比这少，因为其中一些是等价的（A → B → C 和 C → B → A 是等价的，例如，因为它们使用相同的道路，只是相反）。</p>
<p>实际上，有3种可能性。</p>
<blockquote>
<ul>
<li>把它带到 4 个城镇，你有 (iirc) 12 种可能性。</li>
<li>5是60。</li>
<li>6 变成 360。
</li>
</ul>
</blockquote>
<p><strong>这是称为阶乘的</strong> 数学运算的函数。基本上：</p>
<blockquote>
<ul>
<li>5！= 5 × 4 × 3 × 2 × 1 = 120</li>
<li>6！= 6 × 5 × 4 × 3 × 2 × 1 = 720</li>
<li>7！= 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040</li>
<li>……</li>
<li>25！= 25 × 24 × … × 2 × 1 = 15,511,210,043,330,985,984,000,000</li>
<li>……</li>
<li>50！= 50 × 49 × … × 2 × 1 = 3.04140932 × 10 64
</li>
</ul>
</blockquote>
<p>因此，旅行商问题的 BigOh 是 <strong>O(n!)</strong> 或 <strong>阶乘或组合复杂度</strong> 。</p>
<p><strong>当你到达 200 个城镇时，宇宙中没有足够的时间来解决传统计算机的问题。</strong></p>
<p>需要考虑的事情。</p>
<h2>多项式时间</h2>
<p>我想快速提及的另一点是，任何复杂度为 <strong>O(n a )</strong>的算法都被称为具有 <strong>多项式复杂度</strong> 或可在 <strong>多项式时间</strong> 内求解。</p>
<p>O(n)、O(n 2
)等都是多项式时间。有些问题不能在多项式时间内解决。因此，某些东西在世界上被使用。公钥密码术就是一个典型的例子。在计算上很难找到一个非常大的数的两个质因数。如果不是，我们就无法使用我们使用的公钥系统。</p>
<p>Anyway, that's it for my (hopefully plain English) explanation of BigOh
(revised).</p>
<p><br></p>
<h3>更多建议</h3>
<p>它显示了算法如何根据输入大小进行缩放。</p>
<p><strong>O(n 2 )</strong>：称为 <strong>二次复杂度</strong></p>
<ul>
<li>1 项：1 次操作</li>
<li>10 项：100 次操作</li>
<li>100 项：10,000 次操作</li>
</ul>
<p>请注意，项目数量增加了 10 倍，但时间增加了 10 2倍。基本上，n=10 并且 O(n 2 ) 给了我们比例因子 n 2，它是 10 2。</p>
<p><strong>O(n)</strong> ：称为 <strong>线性复杂度</strong></p>
<ul>
<li>1 项：1 次操作</li>
<li>10 项：10 次操作</li>
<li>100 项：100 次操作</li>
</ul>
<p>这次项目的数量增加了 10 倍，时间也是如此。n=10 所以 O(n) 的比例因子是 10。</p>
<p><strong>O(1)</strong> ：称为 <strong>常量复杂度</strong></p>
<ul>
<li>1 项：1 次操作</li>
<li>10 项：1 次操作</li>
<li>100 项：1 次操作</li>
</ul>
<p>项目的数量仍在以 10 倍增加，但 O(1) 的比例因子始终为 1。</p>
<p><strong>O(log n)</strong> ：称为对 <strong>数复杂度</strong></p>
<ul>
<li>1 项：1 次操作</li>
<li>10 项：2 次操作</li>
<li>100 个项目：3 个操作</li>
<li>1000 项：4 次操作</li>
<li>10,000 项：5 次操作</li>
</ul>
<p>计算次数仅按输入值的对数增加。所以在这种情况下，假设每次计算需要 1 秒，输入的对数<code>n</code>就是所需的时间，因此<code>log n</code>。</p>
<p>这就是它的要点。他们减少了数学运算，所以它可能不完全是 n 2或者他们所说的任何东西，但这将是缩放中的主导因素。</p>
<p><br><br><a href="../what-is-a-plain-english-explanation-of-big-o-notation/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/big-o/" rel="tag">big-o</a></li>
            <li><a class="tag p-category" href="../../categories/complexity-theory/" rel="tag">complexity-theory</a></li>
            <li><a class="tag p-category" href="../../categories/computer-science/" rel="tag">computer-science</a></li>
            <li><a class="tag p-category" href="../../categories/time-complexity/" rel="tag">time-complexity</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../jiang-ben-di-cun-chu-ku-fen-zhi-zhong-zhi-wei-jiu-xiang-yuan-cheng-cun-chu-ku-head/" rel="prev" title="将本地存储库分支重置为就像远程存储库 HEAD">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-jie-jue-git-cun-chu-ku-zhong-de-he-bing-chong-tu/" rel="next" title="如何解决 Git 存储库中的合并冲突？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
