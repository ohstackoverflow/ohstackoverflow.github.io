<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>如何将抽取的文本粘贴到 Vim 命令行 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ru-he-jiang-chou-qu-de-wen-ben-nian-tie-dao-vim-ming-ling-xing/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../cong-gai-han-shu-zhong-que-ding-han-shu-ming-cheng-bu-shi-yong-hui-su/" title="从该函数中确定函数名称（不使用回溯）" type="text/html">
<link rel="next" href="../wo-ru-he-xiu-fu-vi-zhong-zheng-ge-wen-jian-de-suo-jin/" title="我如何修复 Vi 中整个文件的缩进？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="如何将抽取的文本粘贴到 Vim 命令行">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ru-he-jiang-chou-qu-de-wen-ben-nian-tie-dao-vim-ming-ling-xing/">
<meta property="og:description" content='我想将提取的文本粘贴到 Vim 的命令行中。是否可以？

解答
是的。打Ctrl-R然后"。如果您在抽出的内容中有文字控制字符，请使用Ctrl- R、Ctrl- O、"。
这里解释了你可以用寄存器做什么。你可以用寄存器做很多事，一旦你知道如何使用它们，你就离不开它们。
寄存器基本上是字符串的存储位置。Vim 有许多以不同方式工作的寄存器：

0（抽出寄存器：当您y在正常模式下使用时，如果没有指定寄'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T17:40:40+08:00">
<meta property="article:tag" content="copy-paste">
<meta property="article:tag" content="vim">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">如何将抽取的文本粘贴到 Vim 命令行</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T17:40:40+08:00" itemprop="datePublished" title="2023-02-17 17:40">2023-02-17 17:40</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我想将提取的文本粘贴到 Vim 的命令行中。是否可以？</p>
<p><br><br></p>
<h2>解答</h2>
<p>是的。打<code>Ctrl</code>-<code>R</code>然后<code>"</code>。如果您在抽出的内容中有文字控制字符，请使用<code>Ctrl</code>- <code>R</code>、<code>Ctrl</code>- <code>O</code>、<code>"</code>。</p>
<p>这里解释了你可以用寄存器做什么。你可以用寄存器做很多事，一旦你知道如何使用它们，你就离不开它们。</p>
<p>寄存器基本上是字符串的存储位置。Vim 有许多以不同方式工作的寄存器：</p>
<ul>
<li>
<code>0</code>（抽出寄存器：当您<code>y</code>在正常模式下使用时，如果没有指定寄存器，抽出的文本会出现在默认寄存器中），</li>
<li>
<code>1</code>到<code>9</code>（移动删除寄存器，当你使用诸如<code>c</code>或 之类的命令时<code>d</code>，已删除的内容转到寄存器 1，寄存器 1 中的内容转到寄存器 2， <em>等等</em> ），</li>
<li>
<code>"</code>（默认寄存器，也称为未命名寄存器。这是- ,<code>"</code>的来源），<code>Ctrl``R``"</code>
</li>
<li>
<code>a</code>to<code>z</code>供您自己使用（大写<code>A</code>to<code>Z</code>是为了附加到相应的寄存器）。</li>
<li>
<code>_</code>（就像<code>/dev/null</code>（Unix）或<code>NUL</code>（Windows）一样，你可以写入它但它被丢弃并且当你从它读取时，它总是空的），</li>
<li>
<code>-</code>（小删除寄存器），</li>
<li>
<code>/``/</code>（搜索模式寄存器，当您使用, <code>?</code>,<code>*</code>或<code>#</code>例如查找文本时更新；您也可以写入它以动态更改搜索模式），</li>
<li>
<code>:``Q</code>（通过or存储最后一个 VimL 输入的命令<code>:</code>，只读），</li>
<li>
<code>+</code>和<code>*</code>（系统剪贴板寄存器，您可以写入它们以设置剪贴板并从中读取剪贴板内容）</li>
</ul>
<p>请参阅<code>:help registers</code>完整参考。</p>
<p>您可以随时使用<code>:registers</code>来显示所有寄存器的内容。此命令的同义词和简写是<code>:display</code>,<code>:reg</code>和<code>:di</code>。</p>
<p>在插入或命令行模式下，<code>Ctrl</code>-<code>R</code>加上一个寄存器名称，插入该寄存器的内容。如果你想按字面意义插入它们（没有自动缩进，没有控制字符转换为<code>0x08</code>退格等），你可以使用<code>Ctrl</code>-
<code>R</code>，<code>Ctrl</code>- <code>O</code>，注册名称。请参阅<code>:help i_CTRL-R</code>以下段落以获取更多参考。</p>
<p>但您也可以执行以下操作（我可能忘记了寄存器的许多用途）。</p>
<ul>
<li>在正常模式下，点击<code>"``:``p</code>。你在 vim 中使用的最后一个命令被粘贴到你的缓冲区中。<br>
Let's
decompose:<code>"</code>是一个普通模式命令，可以让您选择在下一个抽取、删除或粘贴操作期间要使用的寄存器。所以<code>"``:</code>选择冒号寄存器（存储最后一条命令）。然后<code>p</code>是一个你已经知道的命令，它粘贴寄存器的内容。</li>
</ul>
<p>比照。<code>:help "</code>,<code>:help quote_:</code></p>
<ul>
<li>您正在编辑一个 VimL 文件（例如您的<code>.vimrc</code>），现在想执行几行连续的代码：<code>y``j``:``@``"``Enter</code>. <br>
在这里，<code>y``j</code>将当前行和下一行（这是因为 j 是一个线性运动，但这超出了这个答案的范围）到默认寄存器（也称为未命名寄存器）。然后<code>:@</code>Ex
命令播放存储在作为参数给定的寄存器中的 Ex 命令，这<code>"</code>就是您引用未命名寄存器的方式。另请参阅此答案的顶部，这是相关的。</li>
</ul>
<p>不要将<code>"</code>此处使用的（这是一个寄存器名称）与<code>"</code>前面示例中的普通模式命令混淆。</p>
<p>比照。<code>:help :@</code>和<code>:help quote_quote</code></p>
<ul>
<li>
<code>Ctrl</code>在插入模式下将最后一个搜索模式插入到您的文件中，或者使用- <code>R</code>,插入到命令行中<code>/</code>。</li>
</ul>
<p>比照。<code>:help quote_/</code>,<code>help i_CTRL-R</code></p>
<p>推论：保留您的搜索模式，但添加替代方案：<code>/</code> <code>Ctrl</code>- <code>R</code>, <code>/</code> <code>\|alternative</code>.</p>
<ul>
<li>您在可视模式下选择了一行中间的两个单词，用 将它们拉出<code>y</code>，它们在未命名的寄存器中。现在你想在你所在的位置下面打开一个新行，用这两个词：<code>:pu</code>。这是 的简写<code>:put "</code>。该<code>:put</code>命令与许多 Ex 命令一样，只能按行运行。</li>
</ul>
<p>比照。<code>:help :put</code></p>
<p>你也可以这样做：<code>:call setreg('"', @", 'V')</code>then
<code>p</code>。该<code>setreg</code>函数设置名称作为第一个参数（作为字符串）的寄存器，用第二个参数的内容初始化它（并且您可以使用寄存器作为变量，其中名称是 VimL
中的寄存器名称）<code>@x</code>，<code>x</code>并且将其转换为第三个参数中指定的模式，<code>V</code>对于 linewise，对于 characterwise
没有任何内容，<code>^V</code>对于 blockwise 则为文字。</p>
<p>比照。<code>:help setreg()</code>. 反向函数是<code>getreg()</code>和<code>getregtype()</code>。</p>
<ul>
<li>如果你用<code>qa</code>...录制了一个宏<code>q</code>，那么<code>:echo @a</code>它会告诉你你输入了什么，并<code>@a</code>会重播这个宏（可能你知道那个，对于避免重复性任务非常有用）</li>
</ul>
<p>比照。<code>:help q</code>,<code>help @</code></p>
<p>前面示例的推论：如果您在<code>8go</code>剪贴板中，则将<code>@+</code>剪贴板内容作为宏播放，从而转到文件的第 8
个字节。实际上，这几乎适用于每个寄存器。如果您最后插入的字符串处于<code>dd</code>插入模式，则将<code>@.</code>（因为<code>.</code>寄存器包含最后插入的字符串）删除一行。（Vim文档在这方面是错误的，因为它指出寄存器
、 和只能与<code>#</code>、<code>%</code>和-一起使用）。<code>:``.``p``P``:put``Ctrl``R</code></p>
<p>比照。<code>:help @</code></p>
<p>不要混淆<code>:@</code>(从寄存器播放 Vim 命令的命令) 和<code>@</code>(从寄存器播放普通模式命令的普通模式命令)。</p>
<p>值得注意的例外是<code>@:</code>。命令寄存器不包含初始冒号，也不包含最终回车符。但是在普通模式下，<code>@:</code>将按照您的预期进行操作，将寄存器解释为 Ex
命令，而不是尝试在普通模式下播放它。因此，如果您的最后一个命令是<code>:e</code>，则寄存器包含<code>e</code>但<code>@:</code>会重新加载文件，而不是进入单词结尾。</p>
<p>比照。<code>:help @:</code></p>
<ul>
<li>在运行它之前显示您将在普通模式下做什么：<code>@='dd'</code> <code>Enter</code>。一旦你按下这个<code>=</code>键，Vim 就会切换到表达式求值：当你输入一个表达式并按下 时<code>Enter</code>，Vim 会计算它，结果作为一个寄存器内容。当然寄存器<code>=</code>是只读的，而且是一次性的。每次开始使用它时，您都必须输入一个新表达式。</li>
</ul>
<p>比照。<code>:help quote_=</code></p>
<p>推论：如果你正在编辑一个命令，并且你意识到你应该需要从你当前的缓冲区中插入一些行到你的命令行中：不要按<code>Esc</code>！使用<code>Ctrl</code>- <code>R</code>
<code>=getline(58)</code> <code>Enter</code>。之后您将返回到命令行编辑，但它已插入第 58 行的内容。</p>
<ul>
<li>手动定义搜索模式：<code>:let @/ = 'foo'</code>
</li>
</ul>
<p>比照。<code>:help :let</code></p>
<p>请注意，这样做时，您无需<code>/</code>在模式中转义。但是，您当然需要将所有单引号加倍。</p>
<ul>
<li>复制以 开头的所有行<code>foo</code>，然后复制所有包含的行<code>bar</code>到剪贴板，链接这些命令：（<code>qaq</code>重置其中存储空宏的寄存器 <em>）</em><code>:g/^foo/y A</code>，, <code>:g/bar/y A</code>, <code>:let @+ = @a</code>.</li>
</ul>
<p>使用大写寄存器名称使寄存器以追加模式工作</p>
<p>更好的是，如果<code>Q</code>没有被重新映射<code>mswin.vim</code>，用 启动 Ex 模式<code>Q</code>，链接那些实际上更好称为“Ex
命令”的“冒号命令”，然后通过键入返回正常模式<code>visual</code>。</p>
<p>比照。<code>:help :g</code>, <code>:help :y</code>,<code>:help Q</code></p>
<ul>
<li>
<p>双倍空间你的文件：<code>:g/^/put _</code>. 这会将黑洞寄存器的内容（读取时为空，但可写，行为类似于<code>/dev/null</code>）逐行放置在每一行之后（因为每一行都有一个开头！）。</p>
</li>
<li>
<p><code>foo</code>在每行之前添加一行： <code>:g/^/-put ='foo'</code>。这是表达式寄存器的巧妙使用。这里，是(cf. )<code>-</code>的同义词。由于将文本放在行之后，您必须明确告诉它对前一行进行操作。<code>.-1``:help :range``:put</code></p>
</li>
<li>
<p>将整个缓冲区复制到系统剪贴板：<code>:%y+</code>。</p>
</li>
</ul>
<p>比照。<code>:help :range</code>（对于<code>%</code>部分）和<code>:help :y</code>。</p>
<ul>
<li>
<p>如果您错误地录制了宏，您可以键入<code>:let @a='</code> <code>Ctrl</code>-<code>R</code> <code>=replace(@a,"'","''",'g')</code> <code>Enter</code> <code>'</code>并对其进行编辑。这将修改存储在 register 中的宏的内容<code>a</code>，此处显示了如何使用表达式 register 来执行此操作。另一种更简单的修改宏的方法是将其粘贴到缓冲区 ( <code>"ap</code>) 中，对其进行编辑，然后通过选择它和 将其再次放入寄存器中<code>"ay</code>。</p>
</li>
<li>
<p>如果你这样做了<code>dddd</code>，你可能会<code>uu</code>为了撤消而做。<code>p</code>你可以得到最后删除的行。<code>@1</code>但实际上你也可以通过寄存器恢复最多 9 个删除<code>@9</code>。</p>
</li>
</ul>
<p>更好的是，如果你这样做<code>"1P</code>，那么<code>.</code>在普通模式下会播放<code>"2P</code>，等等。</p>
<p>比照。<code>:help .</code>和<code>:help quote_number</code></p>
<ul>
<li>如果你想在插入模式下插入当前日期：<code>Ctrl</code>- <code>R``=strftime('%y%m%d')``Enter</code>。</li>
</ul>
<p>比照。<code>:help strftime()</code></p>
<p>再一次，什么可能令人困惑：</p>
<ul>
<li>
<p><code>:@</code>是一个命令行命令，它将寄存器的内容解释为 vimscript 并将其作为源代码</p>
</li>
<li>
<p><code>@</code>在将寄存器的内容解释为正常模式击键的正常模式命令中（除非您使用<code>:</code>寄存器，它包含最后播放的命令但没有初始冒号：在这种情况下，它会重播命令，就好像您还重新键入了冒号和最后的返回键）。</p>
</li>
<li>
<p><code>"</code>在正常模式下，帮助您选择寄存器以进行抽取、粘贴、删除、更正等操作的命令。</p>
</li>
<li>
<p><code>"</code>也是一个有效的寄存器名称（默认或未命名的寄存器），因此可以作为期望寄存器名称的命令的参数传递</p>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>要粘贴系统剪贴板中的内容，您可以使用<code>SHIFT</code>- <code>INS</code>。</p>
<p>它适用于 Windows，但我猜它也适用于 Linux。</p>
<p><br><br><a href="../how-to-paste-yanked-text-into-the-vim-command-line/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/copy-paste/" rel="tag">copy-paste</a></li>
            <li><a class="tag p-category" href="../../categories/vim/" rel="tag">vim</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../cong-gai-han-shu-zhong-que-ding-han-shu-ming-cheng-bu-shi-yong-hui-su/" rel="prev" title="从该函数中确定函数名称（不使用回溯）">Previous post</a>
            </li>
            <li class="next">
                <a href="../wo-ru-he-xiu-fu-vi-zhong-zheng-ge-wen-jian-de-suo-jin/" rel="next" title="我如何修复 Vi 中整个文件的缩进？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
