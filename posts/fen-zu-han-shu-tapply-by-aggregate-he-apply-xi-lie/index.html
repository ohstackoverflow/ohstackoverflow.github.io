<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>分组函数（tapply、by、aggregate）和 *apply 系列 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../zai-python-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-bu-er-zhi/" title="在 Python 中将字符串转换为布尔值" type="text/html">
<link rel="next" href="../han-shu-shi-bian-cheng-hui-qu-dai-gof-she-ji-mo-shi-ma/" title="函数式编程会取代 GoF 设计模式吗？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="分组函数（tapply、by、aggregate）和 *apply 系列">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/fen-zu-han-shu-tapply-by-aggregate-he-apply-xi-lie/">
<meta property="og:description" content="每当我想在 R 中做一些“映射”py 时，我通常会尝试使用家族中的函数apply。
然而，我从来没有完全理解它们之间的区别——如何将函数应用到输入/分组输入，输出看起来像什么，甚至输入可以是什么——所以我sapply经常lapply只是通过他们，直到我得到我想要的。
有人可以解释一下何时使用哪个吗？
我目前（可能不正确/不完整）的理解是......


sapply(vec, f)：输入是一个向量">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:24:17+08:00">
<meta property="article:tag" content="apply">
<meta property="article:tag" content="r">
<meta property="article:tag" content="r-faq">
<meta property="article:tag" content="vectorization">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">分组函数（tapply、by、aggregate）和 *apply 系列</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:24:17+08:00" itemprop="datePublished" title="2023-02-17 05:24">2023-02-17 05:24</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>每当我想在 R 中做一些“映射”py 时，我通常会尝试使用家族中的函数<code>apply</code>。</p>
<p>然而，我从来没有完全理解它们之间的区别——如何将函数应用到输入/分组输入，输出看起来像什么，甚至输入可以是什么——所以我<code>sapply</code>经常<code>lapply</code>只是通过他们，直到我得到我想要的。</p>
<p>有人可以解释一下何时使用哪个吗？</p>
<p>我目前（可能不正确/不完整）的理解是......</p>
<ol>
<li>
<p><code>sapply(vec, f)</code>：输入是一个向量。output 是一个向量/矩阵，其中 element<code>i</code>是，如果有一个多元素输出，<code>f(vec[i])</code>则给你一个矩阵<code>f</code></p>
</li>
<li>
<p><code>lapply(vec, f)</code>: 与 相同<code>sapply</code>，但输出是一个列表？</p>
</li>
<li>
<p><code>apply(matrix, 1/2, f)</code>：输入是一个矩阵。输出是一个向量，其中元素<code>i</code>是 f（矩阵的行/列 i）</p>
</li>
<li>
<code>tapply(vector, grouping, f)</code>：输出是一个矩阵/数组，其中矩阵/数组中的元素是向量<code>f</code>分组中的值，并被推送到行/列名称<code>g``g</code>
</li>
<li>
<code>by(dataframe, grouping, f)</code>: 让我们<code>g</code>成为一个分组。适用<code>f</code>于组/数据框的每一列。<code>f</code>漂亮地打印每列的分组和值。</li>
<li>
<code>aggregate(matrix, grouping, f)</code>：类似于<code>by</code>，但聚合不是漂亮地打印输出，而是将所有内容粘贴到数据框中。</li>
</ol>
<p>附带问题：我还没有学会 plyr 或 reshape —— 会<code>plyr</code>或<code>reshape</code>完全取代所有这些吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>R 有许多 <em>apply
函数，这些函数在帮助文件（例如<code>?apply</code>）中有巧妙的描述。但是，它们已经足够多了，初学者可能难以决定哪一个适合他们的情况，甚至难以记住它们。他们可能有一种普遍的感觉，即“我应该在这里使用
</em>apply 函数”，但一开始很难让他们保持直截了当。</p>
<p>尽管事实（在其他答案中指出） *apply 系列的大部分功能都包含在非常流行的<code>plyr</code>包中，但基本功能仍然有用且值得了解。</p>
<p>该答案旨在充当新用户的一种 <strong>路标</strong> ，以帮助将他们引导至针对其特定问题的正确 <em>apply 功能。请注意，这并不是 </em><em>简单</em><em> 地重复或替换 R
文档！希望这个答案可以帮助您决定哪个 </em>apply 函数适合您的情况，然后由您进一步研究。除了一个例外，性能差异将不会被解决。</p>
<ul>
<li>
<p><strong>apply</strong> - <em>当你想将一个函数应用于矩阵的行或列（和更高维的类似物）时； 通常不建议用于数据帧，因为它会首先强制转换为矩阵。</em></p>
<div class="code"><pre class="code literal-block"> # Two dimensional matrix
</pre></div>

<p>M &lt;- matrix(seq(1,16), 4, 4)</p>
<p># apply min to rows
 apply(M, 1, min)
 [1] 1 2 3 4</p>
<p># apply max to columns
 apply(M, 2, max)
 [1]  4  8 12 16</p>
<p># 3 dimensional array
 M &lt;- array( seq(32), dim = c(4,4,2))</p>
<p># Apply sum across each M[*, , ] - i.e Sum across 2nd and 3rd dimension
 apply(M, 1, sum)
 # Result is one-dimensional
 [1] 120 128 136 144</p>
<p># Apply sum across each M[<em>, </em>, ] - i.e Sum across 3rd dimension
 apply(M, c(1,2), sum)
 # Result is two-dimensional
      [,1] [,2] [,3] [,4]
 [1,]   18   26   34   42
 [2,]   20   28   36   44
 [3,]   22   30   38   46
 [4,]   24   32   40   48</p>
</li>
</ul>
<p>如果您想要二维矩阵的行/列均值或求和，请务必研究高度优化的、闪电般快速的<code>colMeans</code>, <code>rowMeans</code>, <code>colSums</code>,
<code>rowSums</code>。</p>
<ul>
<li>
<strong>lapply</strong> - <em>当您想依次将函数应用于列表的每个元素并获取列表时。</em>
</li>
</ul>
<p>这是许多其他 *apply 函数的主力。翻开他们的代码，您通常会<code>lapply</code>在下面找到它们。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="nf">lapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="o">$</span><span class="n">a</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">1</span>
<span class="w"> </span><span class="o">$</span><span class="n">b</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">3</span>
<span class="w"> </span><span class="o">$</span><span class="n">c</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">91</span>
<span class="w"> </span><span class="nf">lapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="o">$</span><span class="n">a</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">1</span>
<span class="w"> </span><span class="o">$</span><span class="n">b</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">6</span>
<span class="w"> </span><span class="o">$</span><span class="n">c</span><span class="w"> </span>
<span class="w"> </span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="m">5005</span>
</pre></div>

<ul>
<li>
<strong>sapply</strong> - <em>当您想依次将函数应用于列表的每个元素时，但您想要返回一个 <strong>向量</strong> 而不是列表。</em>
</li>
</ul>
<p>如果您发现自己在打字<code>unlist(lapply(...))</code>，请停下来考虑一下<code>sapply</code>。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span>
<span class="w"> </span><span class="c1"># Compare with above; a named vector, not a list </span>
<span class="w"> </span><span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w">  </span>
<span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="n">b</span><span class="w">  </span><span class="n">c</span><span class="w">   </span>
<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">91</span>

<span class="w"> </span><span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">   </span>
<span class="w"> </span><span class="n">a</span><span class="w">    </span><span class="n">b</span><span class="w">    </span><span class="n">c</span><span class="w">    </span>
<span class="w"> </span><span class="m">1</span><span class="w">    </span><span class="m">6</span><span class="w"> </span><span class="m">5005</span>
</pre></div>

<p>在更高级的使用中，<code>sapply</code>如果合适，它将尝试将结果强制转换为多维数组。例如，如果我们的函数返回相同长度的向量，<code>sapply</code>将把它们用作矩阵的列：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) rnorm(3,x))
</pre></div>

<p>如果我们的函数返回一个二维矩阵，<code>sapply</code>将做基本相同的事情，将每个返回的矩阵视为一个长向量：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) matrix(x,2,2))
</pre></div>

<p>除非我们指定<code>simplify = "array"</code>，在这种情况下它将使用单个矩阵来构建多维数组：</p>
<div class="code"><pre class="code literal-block">     sapply(1:5,function(x) matrix(x,2,2), simplify = "array")
</pre></div>

<p>当然，这些行为中的每一个都取决于我们的函数返回相同长度或维度的向量或矩阵。</p>
<ul>
<li>
<strong>vapply</strong> - <em>当您想要使用<code>sapply</code>但可能需要从您的代码中挤出更多速度或想要更多类型安全时。</em>
</li>
</ul>
<p>对于<code>vapply</code>，您基本上为 R 提供了一个示例，说明您的函数将返回什么样的东西，这可以节省一些时间来强制返回值以适应单个原子向量。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">:</span><span class="m">100</span><span class="p">)</span>
<span class="w"> </span><span class="c1">#Note that since the advantage here is mainly speed, this</span>
<span class="w"> </span><span class="c1"># example is only for illustration. We're telling R that</span>
<span class="w"> </span><span class="c1"># everything returned by length() should be an integer of </span>
<span class="w"> </span><span class="c1"># length 1. </span>
<span class="w"> </span><span class="nf">vapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">FUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">FUN.VALUE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0L</span><span class="p">)</span><span class="w"> </span>
<span class="w"> </span><span class="n">a</span><span class="w">  </span><span class="n">b</span><span class="w">  </span><span class="n">c</span><span class="w">  </span>
<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="m">3</span><span class="w"> </span><span class="m">91</span>
</pre></div>

<ul>
<li>
<strong>mapply</strong> - <em>当你有多个数据结构（例如向量，列表）并且你想将一个函数应用于每个的第一个元素，然后是每个的第二个元素，等等，将结果强制转换为向量/数组，如<code>sapply</code>.</em>
</li>
</ul>
<p>这是多元的，因为你的函数必须接受多个参数。</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span>#<span class="nv">Sums</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="mi">1</span><span class="nv">st</span><span class="w"> </span><span class="nv">elements</span>,<span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="mi">2</span><span class="nv">nd</span><span class="w"> </span><span class="nv">elements</span>,<span class="w"> </span><span class="nv">etc</span>.<span class="w"> </span>
<span class="w"> </span><span class="nv">mapply</span><span class="ss">(</span><span class="nv">sum</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">5</span><span class="ss">)</span><span class="w"> </span>
<span class="w"> </span>[<span class="mi">1</span>]<span class="w">  </span><span class="mi">3</span><span class="w">  </span><span class="mi">6</span><span class="w">  </span><span class="mi">9</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">15</span>
<span class="w"> </span>#<span class="nv">To</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">rep</span><span class="ss">(</span><span class="mi">1</span>,<span class="mi">4</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">rep</span><span class="ss">(</span><span class="mi">2</span>,<span class="mi">3</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">etc</span>.
<span class="w"> </span><span class="nv">mapply</span><span class="ss">(</span><span class="nv">rep</span>,<span class="w"> </span><span class="mi">1</span>:<span class="mi">4</span>,<span class="w"> </span><span class="mi">4</span>:<span class="mi">1</span><span class="ss">)</span><span class="w">   </span>
<span class="w"> </span>[[<span class="mi">1</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span>

<span class="w"> </span>[[<span class="mi">2</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span>

<span class="w"> </span>[[<span class="mi">3</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span>

<span class="w"> </span>[[<span class="mi">4</span>]]
<span class="w"> </span>[<span class="mi">1</span>]<span class="w"> </span><span class="mi">4</span>
</pre></div>

<ul>
<li>
<p><strong>Map</strong> - <em>with</em> <em>的包装器 ，因此它保证返回一个列表。<code>mapply``SIMPLIFY = FALSE</code></em></p>
<div class="code"><pre class="code literal-block"> Map(sum, 1:5, 1:5, 1:5)
</pre></div>

<p>[[1]]
 [1] 3</p>
<p>[[2]]
 [1] 6</p>
<p>[[3]]
 [1] 9</p>
<p>[[4]]
 [1] 12</p>
<p>[[5]]
 [1] 15</p>
</li>
<li>
<p><strong>rapply</strong> - <em>当你想递归地将函数应用于 <strong>嵌套列表</strong> 结构的每个元素时。</em></p>
</li>
</ul>
<p>为了让您了解这有多不常见<code>rapply</code>，我在第一次发布此答案时忘记了它！显然，我敢肯定很多人都在使用它，但是
YMMV。<code>rapply</code>最好用一个用户定义的函数来说明：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1"># Append ! to string, otherwise increment</span>
<span class="w"> </span><span class="n">myFun</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
<span class="w">     </span><span class="nf">if</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">x</span><span class="p">)){</span>
<span class="w">       </span><span class="nf">return</span><span class="p">(</span><span class="nf">paste</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">"!"</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">""</span><span class="p">))</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="n">else</span><span class="p">{</span>
<span class="w">       </span><span class="nf">return</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="w">     </span><span class="p">}</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="c1">#A nested list structure</span>
<span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Boo"</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Eeek"</span><span class="p">),</span><span class="w"> </span>
<span class="w">           </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Yikes"</span><span class="p">,</span><span class="w"> </span>
<span class="w">           </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hey"</span><span class="p">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)))</span>


<span class="w"> </span><span class="c1"># Result is named vector, coerced to character          </span>
<span class="w"> </span><span class="nf">rapply</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">myFun</span><span class="p">)</span>

<span class="w"> </span><span class="c1"># Result is a nested list like l, with values altered</span>
<span class="w"> </span><span class="nf">rapply</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">myFun</span><span class="p">,</span><span class="w"> </span><span class="n">how</span><span class="o">=</span><span class="s">"replace"</span><span class="p">)</span>
</pre></div>

<ul>
<li>
<strong>tapply</strong> - <em>当您想要将函数应用于向量的 <strong>子集</strong> 并且子集由某个其他向量定义时，通常是一个因子。</em>
</li>
</ul>
<p>*apply 家族的害群之马。帮助文件中使用的短语“参差不齐的数组”可能有点令人困惑，但实际上非常简单。</p>
<p>向量：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">20</span>
</pre></div>

<p>定义组的因子（长度相同！）：</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="kc">letters</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">],</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">))</span>
</pre></div>

<p><code>x</code>将以下定义的每个子组中的值相加<code>y</code>：</p>
<div class="code"><pre class="code literal-block">     tapply(x, y, sum)  
  a  b  c  d  e  
 10 26 42 58 74
</pre></div>

<p>可以处理更复杂的示例，其中子组由多个因素列表的唯一组合定义。<code>tapply</code>在精神上类似于 R 中常见的拆分-应用-
组合函数（<code>aggregate</code>、<code>by</code>、<code>ave</code>、<code>ddply</code>等），因此它是害群之马。</p>
<p><br></p>
<h3>更多建议</h3>
<p>在旁注中，这里是各种<code>plyr</code>功能如何对应于基本<code>*apply</code>功能（来自 plyr 网页http://had.co.nz/plyr/的介绍到 plyr
文档）</p>
<div class="code"><pre class="code literal-block"><span class="n">Base</span><span class="w"> </span><span class="k">function</span><span class="w">   </span><span class="n">Input</span><span class="w">   </span><span class="n">Output</span><span class="w">   </span><span class="n">plyr</span><span class="w"> </span><span class="k">function</span><span class="w"> </span>
<span class="o">---------------------------------------</span>
<span class="n">aggregate</span><span class="w">        </span><span class="n">d</span><span class="w">       </span><span class="n">d</span><span class="w">       </span><span class="n">ddply</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">colwise</span><span class="w"> </span>
<span class="n">apply</span><span class="w">            </span><span class="n">a</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">aaply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">alply</span><span class="w"> </span>
<span class="n">by</span><span class="w">               </span><span class="n">d</span><span class="w">       </span><span class="n">l</span><span class="w">       </span><span class="n">dlply</span><span class="w"> </span>
<span class="n">lapply</span><span class="w">           </span><span class="n">l</span><span class="w">       </span><span class="n">l</span><span class="w">       </span><span class="n">llply</span><span class="w">  </span>
<span class="n">mapply</span><span class="w">           </span><span class="n">a</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">maply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">mlply</span><span class="w"> </span>
<span class="n">replicate</span><span class="w">        </span><span class="n">r</span><span class="w">       </span><span class="n">a</span><span class="o">/</span><span class="n">l</span><span class="w">     </span><span class="n">raply</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">rlply</span><span class="w"> </span>
<span class="n">sapply</span><span class="w">           </span><span class="n">l</span><span class="w">       </span><span class="n">a</span><span class="w">       </span><span class="n">laply</span>
</pre></div>

<p>的目标之一<code>plyr</code>是为每个函数提供一致的命名约定，在函数名称中对输入和输出数据类型进行编码。它还提供了输出的一致性，因为输出<code>dlply()</code>可以很容易地传递到<code>ldply()</code>以产生有用的输出等。</p>
<p>从概念上讲，学习<code>plyr</code>并不比理解基本函数更难<code>*apply</code>。</p>
<p><code>plyr``reshape</code>在我的日常使用中，功能几乎取代了所有这些功能。但是，同样来自 Intro to Plyr 文档：</p>
<blockquote>
<p>相关函数在 中<code>tapply</code>没有<code>sweep</code>相应的函数<code>plyr</code>，仍然有用。<code>merge</code>对于将摘要与原始数据相结合很有用。</p>
</blockquote>
<p><br><br><a href="../grouping-functions-tapply-by-aggregate-and-the-apply-family/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/apply/" rel="tag">apply</a></li>
            <li><a class="tag p-category" href="../../categories/r/" rel="tag">r</a></li>
            <li><a class="tag p-category" href="../../categories/r-faq/" rel="tag">r-faq</a></li>
            <li><a class="tag p-category" href="../../categories/vectorization/" rel="tag">vectorization</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../zai-python-zhong-jiang-zi-fu-chuan-zhuan-huan-wei-bu-er-zhi/" rel="prev" title="在 Python 中将字符串转换为布尔值">Previous post</a>
            </li>
            <li class="next">
                <a href="../han-shu-shi-bian-cheng-hui-qu-dai-gof-she-ji-mo-shi-ma/" rel="next" title="函数式编程会取代 GoF 设计模式吗？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
