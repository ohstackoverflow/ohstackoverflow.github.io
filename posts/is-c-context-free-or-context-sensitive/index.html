<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Is C++ context-free or context-sensitive? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/is-c-context-free-or-context-sensitive/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../why-aren-t-variable-length-arrays-part-of-the-c-standard/" title="Why aren't variable-length arrays part of the C++ standard?" type="text/html">
<link rel="next" href="../why-doesn-t-this-code-simply-print-letters-a-to-z/" title="Why doesn't this code simply print letters A to Z?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Is C++ context-free or context-sensitive?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/is-c-context-free-or-context-sensitive/">
<meta property="og:description" content="I often hear claims that C++ is a context-sensitive language. Take the
following example:
a b(c);


Is this a variable definition or a function declaration? That depends on the
meaning of the symbol c">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T13:22:51+08:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="context-free-grammar">
<meta property="article:tag" content="context-sensitive-grammar">
<meta property="article:tag" content="grammar">
<meta property="article:tag" content="syntax">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Is C++ context-free or context-sensitive?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:22:51+08:00" itemprop="datePublished" title="2023-03-03 13:22">2023-03-03 13:22</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I often hear claims that C++ is a context-sensitive language. Take the
following example:</p>
<div class="code"><pre class="code literal-block">a b(c);
</pre></div>

<p>Is this a variable definition or a function declaration? That depends on the
meaning of the symbol <code>c</code>. If <code>c</code> is a <em>variable</em> , then <code>a b(c);</code> defines a
variable named <code>b</code> of type <code>a</code>. It is directly initialized with <code>c</code>. But if
<code>c</code> is a <em>type</em> , then <code>a b(c);</code> declares a function named <code>b</code> that takes a
<code>c</code> and returns an <code>a</code>.</p>
<p>If you look up the definition of context-free languages, it will basically
tell you that all grammar rules must have left-hand sides that consist of
exactly one non-terminal symbol. Context-sensitive grammars, on the other
hand, allow arbitrary strings of terminal and non-terminal symbols on the
left-hand side.</p>
<p>Browsing through Appendix A of "The C++ Programming Language", I couldn't find
a single grammar rule that had anything else besides a single non-terminal
symbol on its left-hand side. That would imply that C++ is context-free. (Of
course, every context-free language is also context-sensitive in the sense
that the context-free languages form a subset of the context-sensitive
languages, but that is not the point.)</p>
<p>So, is C++ context-free or context-sensitive?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Below is my (current) favorite demonstration of why parsing C++ is (probably)
Turing-complete, since it shows a program which is syntactically correct if
and only if a given integer is prime.</p>
<p>So I assert that <strong>C++ is neither context-free nor context-sensitive</strong>.</p>
<p>If you allow arbitrary symbol sequences on both sides of any production, you
produce an Type-0 grammar ("unrestricted") in the Chomsky hierarchy, which is
more powerful than a context-sensitive grammar; unrestricted grammars are
Turing-complete. A context-sensitive (Type-1) grammar allows multiple symbols
of context on the left hand side of a production, but the same context must
appear on the right hand side of the production (hence the name "context-
sensitive"). [1] Context-sensitive grammars are equivalent to linear-bounded
Turing machines.</p>
<p>In the example program, the prime computation could be performed by a linear-
bounded Turing machine, so it does not quite prove Turing equivalence, but the
important part is that the parser needs to perform the computation in order to
perform syntactic analysis. It could have been any computation expressible as
a template instantiation and there is every reason to believe that C++
template instantiation is Turing-complete. See, for example, Todd L.
Veldhuizen's 2003 paper.</p>
<p>Regardless, C++ can be parsed by a computer, so it could certainly be parsed
by a Turing machine. Consequently, an unrestricted grammar could recognize it.
Actually writing such a grammar would be impractical, which is why the
standard doesn't try to do so. (See below.)</p>
<p>The issue with "ambiguity" of certain expressions is mostly a red herring. To
start with, ambiguity is a feature of a particular grammar, not a language.
Even if a language can be proven to have no unambiguous grammars, if it can be
recognized by a context-free grammar, it's context-free. Similarly, if it
cannot be recognized by a context-free grammar but it can be recognized by a
context-sensitive grammar, it's context-sensitive. Ambiguity is not relevant.</p>
<p>But in any event, like line 21 (i.e. <code>auto b =
foo&lt;IsPrime&lt;234799&gt;&gt;::typen&lt;1&gt;();</code>) in the program below, the expressions are
not ambiguous at all; they are simply parsed differently depending on context.
In the simplest expression of the issue, the syntactic category of certain
identifiers is dependent on how they have been declared (types and functions,
for example), which means that the formal language would have to recognize the
fact that two arbitrary-length strings in the same program are identical
(declaration and use). This can be modelled by the "copy" grammar, which is
the grammar which recognizes two consecutive exact copies of the same word.
It's easy to prove with the pumping lemma that this language is not context-
free. A context-sensitive grammar for this language is possible, and a Type-0
grammar is provided in the answer to this question:
https://math.stackexchange.com/questions/163830/context-sensitive-grammar-for-
the-copy-language .</p>
<p>If one were to attempt to write a context-sensitive (or unrestricted) grammar
to parse C++, it would quite possibly fill the universe with scribblings.
Writing a Turing machine to parse C++ would be an equally impossible
undertaking. Even writing a C++ program is difficult, and as far as I know
none have been proven correct. This is why the standard does not attempt to
provide a complete formal grammar, and why it chooses to write some of the
parsing rules in technical English.</p>
<p>What looks like a formal grammar in the C++ standard is not the complete
formal definition of the syntax of the C++ language. It's not even the
complete formal definition of the language after preprocessing, which might be
easier to formalize. (That wouldn't be the language, though: the C++ language
as defined by the standard includes the preprocessor, and the operation of the
preprocessor is described algorithmically since it would be extremely hard to
describe in any grammatical formalism. It is in that section of the standard
where lexical decomposition is described, including the rules where it must be
applied more than once.)</p>
<p>The various grammars (two overlapping grammars for lexical analysis, one which
takes place before preprocessing and the other, if necessary, afterwards, plus
the "syntactic" grammar) are collected in Appendix A, with this important note
(emphasis added):</p>
<blockquote>
<p>This summary of C++ syntax is intended to be an aid to comprehension. <strong>It
is not an exact statement of the language</strong>. In particular, the grammar
described here accepts a <em>superset of valid C++ constructs</em>. Disambiguation
rules (6.8, 7.1, 10.2) must be applied to distinguish expressions from
declarations. Further, access control, ambiguity, and type rules must be
used to weed out syntactically valid but meaningless constructs.</p>
</blockquote>
<p>Finally, here's the promised program. Line 21 is syntactically correct if and
only if the N in <code>IsPrime&lt;N&gt;</code> is prime. Otherwise, <code>typen</code> is an integer, not
a template, so <code>typen&lt;1&gt;()</code> is parsed as <code>(typen&lt;1)&gt;()</code> which is syntactically
incorrect because <code>()</code> is not a syntactically valid expression.</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">bool</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">answer</span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="err">{}</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="n">operator</span><span class="p">()()</span><span class="err">{</span><span class="k">return</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="err">}}</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">bool</span><span class="w"> </span><span class="k">no</span><span class="p">,</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">IsPrimeHelper</span>
<span class="w">  </span><span class="err">:</span><span class="w"> </span><span class="n">IsPrimeHelper</span><span class="o">&lt;</span><span class="n">p</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="err">{}</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">bool</span><span class="w"> </span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">IsPrimeHelper</span><span class="o">&lt;</span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">answer</span><span class="o">&lt;</span><span class="k">false</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="nc">int</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">IsPrimeHelper</span><span class="o">&lt;</span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">answer</span><span class="o">&lt;</span><span class="k">true</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="nc">int</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">IsPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typename</span><span class="w"> </span><span class="n">IsPrimeHelper</span><span class="o">&lt;</span><span class="err">!</span><span class="p">(</span><span class="n">I</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="nc">int</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span>
<span class="n">struct</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p">;</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="err">}</span><span class="p">;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;&gt;</span><span class="n">struct</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="n">answer</span><span class="o">&lt;</span><span class="k">true</span><span class="o">&gt;&gt;</span><span class="err">{</span>
<span class="w">  </span><span class="n">template</span><span class="o">&lt;</span><span class="nc">int</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">typen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="n">answer</span><span class="o">&lt;</span><span class="k">false</span><span class="o">&gt;&gt;</span><span class="err">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">typen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span>

<span class="nc">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">  </span><span class="n">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="n">IsPrime</span><span class="o">&lt;</span><span class="mi">234799</span><span class="o">&gt;&gt;::</span><span class="n">typen</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Syntax</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">prime</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<hr>
<p>[1] To put it more technically, every production in a context-sensitive
grammar must be of the form:</p>
<p><code>αAβ → αγβ</code></p>
<p>where <code>A</code> is a non-terminal and <code>α</code>, <code>β</code> are possibly empty sequences of
grammar symbols, and <code>γ</code> is a non-empty sequence. (Grammar symbols may be
either terminals or non-terminals).</p>
<p>This can be read as <code>A → γ</code> only in the context <code>[α, β]</code>. In a context-free
(Type 2) grammar, <code>α</code> and <code>β</code> must be empty.</p>
<p>It turns out that you can also restrict grammars with the "monotonic"
restriction, where every production must be of the form:</p>
<p><code>α → β</code> where <code>|α| ≥ |β| &gt; 0</code> (<code>|α|</code> means "the length of <code>α</code>")</p>
<p>It's possible to prove that the set of languages recognized by monotonic
grammars is exactly the same as the set of languages recognized by context-
sensitive grammars, and it's often the case that it's easier to base proofs on
monotonic grammars. Consequently, it's pretty common to see "context-
sensitive" used as though it meant "monotonic".</p>
<p><br></p>
<h3>Suggest</h3>
<p>First, you rightly observed there are no context sensitive rules in the
grammar at the end of the C++ standard, so that grammar <em>is</em> context-free.</p>
<p>However, that grammar doesn't precisely describe the C++ language, because it
produces non-C++ programs such as</p>
<div class="code"><pre class="code literal-block">int m() { m++; }
</pre></div>

<p>or</p>
<div class="code"><pre class="code literal-block">typedef static int int;
</pre></div>

<p>The C++ language defined as "the set of well-formed C++ programs" is not
context-free (it's possible to show that merely demanding variables to be
declared makes it so). Given you can theoretically write Turing-complete
programs in templates and make a program ill-formed based on their result,
it's not even context-sensitive.</p>
<p>Now, (ignorant) people (usually not language theorists, but parser designers)
typically use "not context-free" in some of the following meanings</p>
<ul>
<li>ambiguous</li>
<li>can't be parsed with Bison</li>
<li>not LL(k), LR(k), LALR(k) or whatever parser-defined language class they chose</li>
</ul>
<p>The grammar at the back of the standard doesn't satisfy these categories (i.e.
it is ambiguous, not LL(k)...) so C++ grammar is "not context-free" for them.
And in a sense, they're right it's damn well hard to produce a working C++
parser.</p>
<p>Note that the properties here used are only weakly connected to context-free
languages - ambiguity doesn't have anything to do with context-sensitivity (in
fact, context-sensitive rules typically help disambiguate productions), the
other two are merely subsets of context-free languages. And parsing context-
free languages is not a linear process (although parsing deterministic ones
is).</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/context-free-grammar/" rel="tag">context-free-grammar</a></li>
            <li><a class="tag p-category" href="../../categories/context-sensitive-grammar/" rel="tag">context-sensitive-grammar</a></li>
            <li><a class="tag p-category" href="../../categories/grammar/" rel="tag">grammar</a></li>
            <li><a class="tag p-category" href="../../categories/syntax/" rel="tag">syntax</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../why-aren-t-variable-length-arrays-part-of-the-c-standard/" rel="prev" title="Why aren't variable-length arrays part of the C++ standard?">Previous post</a>
            </li>
            <li class="next">
                <a href="../why-doesn-t-this-code-simply-print-letters-a-to-z/" rel="next" title="Why doesn't this code simply print letters A to Z?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
