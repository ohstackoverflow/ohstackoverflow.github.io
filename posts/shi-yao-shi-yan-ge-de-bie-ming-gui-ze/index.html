<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么是严格的别名规则？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-yan-ge-de-bie-ming-gui-ze/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../qing-can-yue-chrome-kai-fa-zhe-gong-ju-zhong-de-xuan-ting-zhuang-tai/" title="请参阅 Chrome 开发者工具中的悬停状态" type="text/html">
<link rel="next" href="../visual-studio-code-zhong-de-duo-xing-bian-ji/" title="Visual Studio Code 中的多行编辑" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么是严格的别名规则？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-yan-ge-de-bie-ming-gui-ze/">
<meta property="og:description" content="当询问C 中常见的未定义行为时，人们有时会提到严格的别名规则。
他们在说什么？

解答
遇到严格别名问题的典型情况是将结构（如设备/网络消息）覆盖到系统字长的缓冲区（如指向 s 或 s
的指针）uint32_t上uint16_t。当您将结构覆盖到这样的缓冲区上，或者通过指针转换将缓冲区覆盖到这样的结构上时，您很容易违反严格的别名规则。
所以在这种设置中，如果我想向某物发送消息，我必须有两个不兼容的">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T08:48:03+08:00">
<meta property="article:tag" content="c">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="strict-aliasing">
<meta property="article:tag" content="type-punning">
<meta property="article:tag" content="undefined-behavior">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么是严格的别名规则？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:48:03+08:00" itemprop="datePublished" title="2023-02-17 08:48">2023-02-17 08:48</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>当询问C 中常见的未定义行为时，人们有时会提到严格的别名规则。<br>
他们在说什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>遇到严格别名问题的典型情况是将结构（如设备/网络消息）覆盖到系统字长的缓冲区（如指向 s 或 s
的指针）<code>uint32_t</code>上<code>uint16_t</code>。当您将结构覆盖到这样的缓冲区上，或者通过指针转换将缓冲区覆盖到这样的结构上时，您很容易违反严格的别名规则。</p>
<p>所以在这种设置中，如果我想向某物发送消息，我必须有两个不兼容的指针指向同一块内存。然后我可能会天真地编写这样的代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">typedef</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">Msg</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Msg</span><span class="p">;</span>

<span class="n">void</span><span class="w"> </span><span class="n">SendWord</span><span class="p">(</span><span class="n">uint32_t</span><span class="p">);</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Get a 32-bit buffer from the system</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">buff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">Msg</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Alias that buffer through message</span>
<span class="w">    </span><span class="n">Msg</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Msg</span><span class="o">*</span><span class="p">)(</span><span class="n">buff</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Send a bunch of messages    </span>
<span class="w">    </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">   </span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>严格的别名规则使此设置非法：取消引用别名对象的指针，该对象不是兼容类型或C 2011 6.5 第 7
1段允许的其他类型之一是未定义的行为。不幸的是，您仍然可以用这种方式编写代码， <em>可能</em> 会收到一些警告，编译正常，但在运行代码时只会出现奇怪的意外行为。</p>
<p>（GCC 在发出别名警告的能力上似乎有些不一致，有时会给我们一个友好的警告，有时则不会。）</p>
<p>要了解为什么此行为未定义，我们必须考虑严格的别名规则为编译器带来了什么。基本上，有了这个规则，它就不必考虑插入指令来刷新<code>buff</code>每次循环运行的内容。取而代之的是，在优化时，使用一些令人讨厌的关于别名的非强制性假设，它可以省略这些指令，在循环运行之前加载<code>buff[0]</code>并<code>buff[1]</code>进入
CPU
寄存器一次，并加速循环体。在引入严格别名之前，编译器不得不处于一种偏执状态，即其内容<code>buff</code>可能会被任何先前的内存存储更改。因此，为了获得额外的性能优势，并假设大多数人不使用双关语指针，引入了严格的别名规则。</p>
<p>请记住，如果您认为该示例是人为设计的，那么如果您将缓冲区传递给另一个为您发送的函数（如果您有的话），甚至可能会发生这种情况。</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">SendMessage</span><span class="p">(</span><span class="n">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">size32</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size32</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>并重写了我们之前的循环以利用这个方便的功能</p>
<div class="code"><pre class="code literal-block"><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">SendMessage</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>编译器可能会或可能不会或足够聪明地尝试内联 SendMessage 并且它可能会或可能不会决定再次加载或不加载
buff。如果<code>SendMessage</code>是另一个单独编译的 API 的一部分，它可能有加载 buff 内容的指令。再一次，也许你在 C++
中，这是编译器认为它可以内联的一些模板化头文件实现。或者它可能只是您为了方便而在 .c
文件中编写的内容。无论如何，未定义的行为可能仍会随之而来。即使我们知道引擎盖下发生的一些事情，它仍然违反规则，因此不能保证明确定义的行为。因此，仅通过包装一个采用我们的单词分隔缓冲区的函数并不一定有帮助。</p>
<p><strong>那么我该如何解决这个问题呢？</strong></p>
<ul>
<li>
<p>使用工会。大多数编译器都支持这一点，而不会抱怨严格的别名。这在 C99 中是允许的，并且在 C11 中是明确允许的。</p>
<div class="code"><pre class="code literal-block">  union {
  Msg msg;
  unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];
</pre></div>

<p>};</p>
</li>
<li>
<p>您可以在编译器中禁用严格别名（ gcc 中的f[no-]strict-aliasing））</p>
</li>
<li>
<p>您可以使用<code>char*</code>别名代替系统的字词。规则允许例外<code>char*</code>（包括<code>signed char</code>和<code>unsigned char</code>）。总是假定<code>char*</code>别名其他类型。然而，这不会以另一种方式起作用：没有假设您的结构别名是字符缓冲区。</p>
</li>
</ul>
<p><strong>初学者当心</strong></p>
<p>当两种类型相互叠加时，这只是一个潜在的雷区。您还应该了解字节顺序、单词对齐以及如何通过正确打包结构来处理对齐问题。</p>
<h3>脚注</h3>
<p>1 C 2011 6.5 7 允许左值访问的类型是：</p>
<ul>
<li>与对象的有效类型兼容的类型，</li>
<li>与对象的有效类型兼容的类型的限定版本，</li>
<li>一个类型，它是与对象的有效类型相对应的有符号或无符号类型，</li>
<li>一个类型，它是与对象的有效类型的限定版本相对应的有符号或无符号类型，</li>
<li>在其成员中包含上述类型之一的聚合或联合类型（递归地包括子聚合或包含的联合的成员），或</li>
<li>一种字符类型。</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>我找到的最好的解释是 Mike Acton 的Understanding Strict Aliasing。它稍微专注于 PS3 开发，但基本上只是 GCC。</p>
<p>从文章：</p>
<blockquote>
<p>“严格别名是 C（或 C++）编译器做出的假设，即取消引用指向不同类型对象的指针永远不会引用相同的内存位置（即彼此别名。）”</p>
</blockquote>
<p>所以基本上，如果你有一个<code>int*</code>指向某个包含 an 的内存<code>int</code>，然后你将 a 指向<code>float*</code>那个内存并将它用作
a，<code>float</code>你就违反了规则。如果您的代码不遵守这一点，那么编译器的优化器很可能会破坏您的代码。</p>
<p>该规则的例外是 a <code>char*</code>，它可以指向任何类型。</p>
<p><br><br><a href="../what-is-the-strict-aliasing-rule/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c/" rel="tag">c</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/strict-aliasing/" rel="tag">strict-aliasing</a></li>
            <li><a class="tag p-category" href="../../categories/type-punning/" rel="tag">type-punning</a></li>
            <li><a class="tag p-category" href="../../categories/undefined-behavior/" rel="tag">undefined-behavior</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../qing-can-yue-chrome-kai-fa-zhe-gong-ju-zhong-de-xuan-ting-zhuang-tai/" rel="prev" title="请参阅 Chrome 开发者工具中的悬停状态">Previous post</a>
            </li>
            <li class="next">
                <a href="../visual-studio-code-zhong-de-duo-xing-bian-ji/" rel="next" title="Visual Studio Code 中的多行编辑">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
