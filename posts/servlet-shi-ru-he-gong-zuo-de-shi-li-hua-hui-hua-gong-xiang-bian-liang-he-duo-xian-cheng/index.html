<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>servlet 是如何工作的？实例化、会话、共享变量和多线程 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/servlet-shi-ru-he-gong-zuo-de-shi-li-hua-hui-hua-gong-xiang-bian-liang-he-duo-xian-cheng/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../zi-yuan-yi-cun-zai-shi-post-de-http-xiang-ying-dai-ma/" title="资源已存在时 POST 的 HTTP 响应代码" type="text/html">
<link rel="next" href="../ru-he-zai-xuan-ting-shi-zhi-zuo-twitter-bootstrap-cai-dan-xia-la-cai-dan-er-bu-shi-dan-ji/" title="如何在悬停时制作 Twitter Bootstrap 菜单下拉菜单而不是单击" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="servlet 是如何工作的？实例化、会话、共享变量和多线程">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/servlet-shi-ru-he-gong-zuo-de-shi-li-hua-hui-hua-gong-xiang-bian-liang-he-duo-xian-cheng/">
<meta property="og:description" content="假设，我有一个包含大量 servlet 的网络服务器。对于在这些 servlet 之间传递的信息，我正在设置会话和实例变量。
现在，如果 2 个或更多用户向该服务器发送请求，那么会话变量会发生什么变化？
它们对所有用户都是通用的还是对每个用户都不同？
如果它们不同，那么服务器如何区分不同的用户？
还有一个类似的问题，如果有n用户访问一个特定的 servlet，那么这个 servlet
只会在第一个">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T04:12:19+08:00">
<meta property="article:tag" content="instance-variables">
<meta property="article:tag" content="java">
<meta property="article:tag" content="multithreading">
<meta property="article:tag" content="servlets">
<meta property="article:tag" content="session-variables">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">servlet 是如何工作的？实例化、会话、共享变量和多线程</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:12:19+08:00" itemprop="datePublished" title="2023-02-17 04:12">2023-02-17 04:12</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>假设，我有一个包含大量 servlet 的网络服务器。对于在这些 servlet 之间传递的信息，我正在设置会话和实例变量。</p>
<p>现在，如果 2 个或更多用户向该服务器发送请求，那么会话变量会发生什么变化？<br>
它们对所有用户都是通用的还是对每个用户都不同？<br>
如果它们不同，那么服务器如何区分不同的用户？</p>
<p>还有一个类似的问题，如果有<code>n</code>用户访问一个特定的 servlet，那么这个 servlet
只会在第一个用户第一次访问它时被实例化，还是会为所有用户单独实例化？<br>
换句话说，实例变量会发生什么？</p>
<p><br><br></p>
<h2>解答</h2>
<h3><code>ServletContext</code></h3>
<p>当 servlet 容器（如Apache Tomcat）启动时，它将部署并加载其所有 Web 应用程序。加载 Web 应用程序时，servlet 容器会创建
once<code>ServletContext</code>并将其保存在服务器的内存中。Web 应用程序<code>web.xml</code>和所有包含的<code>web-
fragment.xml</code>文件都被解析，每个<code>&lt;servlet&gt;</code>,<code>&lt;filter&gt;</code>和找到的（或分别用,和注释<code>&lt;listener&gt;</code>的每个类）将被实例化一次并保存在服务器的内存中，通过.
对于每个实例化的过滤器，它的方法是用一个新的参数调用的，该参数又包含所涉及的.<code>@WebServlet``@WebFilter``@WebListener``ServletContext``init()``FilterConfig``ServletContext</code></p>
<p>当 a<code>Servlet</code>的<code>&lt;servlet&gt;&lt;load-on-startup&gt;</code>or<code>@WebServlet(loadOnStartup)</code>值大于
时<code>0</code>，它的<code>init()</code>方法也会在启动期间使用一个新参数调用<code>ServletConfig</code>，该参数又包含所涉及的<code>ServletContext</code>.
这些 servlet 以该值指定的相同顺序进行初始化（<code>1</code>是第一个，<code>2</code>是第二个，等等）。如果为多个 servlet 指定了相同的值，则这些
servlet 中的每一个都按照它们在 、<code>web.xml</code>或<code>web-
fragment.xml</code>classloading<code>@WebServlet</code>中出现的相同顺序加载。如果“load-on-
startup”值不存在，只要HTTP 请求第一次命中该 servlet，<code>init()</code>就会调用该方法。</p>
<p>当 servlet
容器完成上述所有初始化步骤时，<code>ServletContextListener#contextInitialized()</code>将使用一个参数调用<code>ServletContextEvent</code>，该参数又包含所涉及的<code>ServletContext</code>.
这将使开发人员有机会以编程方式注册另一个<code>Servlet</code>，<code>Filter</code>或<code>Listener</code>。</p>
<p>当 servlet 容器关闭时，它会卸载所有 Web 应用程序，调用所有已初始化的 servlet
和过滤器的方法，<code>destroy()</code>并且所有通过和注册的实例都将被丢弃。最后将调用 will
并将其本身丢弃。<code>Servlet``Filter``Listener``ServletContext``ServletContextListener#contextDestroyed()``ServletContext</code></p>
<h3>
<code>HttpServletRequest</code>和<code>HttpServletResponse</code>
</h3>
<p>servlet 容器附加到 Web 服务器，该服务器在特定端口号（开发期间通常使用端口 8080，生产中通常使用端口 80）上侦听 HTTP
请求。当客户端（例如，具有 Web 浏览器的用户，或以编程方式使用<code>URLConnection</code>）发送 HTTP 请求时，servlet
容器创建新的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象并将它们传递给<code>Filter</code>链中定义的任何对象，并最终传递给实例<code>Servlet</code>。</p>
<p>在filters的情况下，<code>doFilter()</code>调用该方法。当 servlet 容器的代码调用 时<code>chain.doFilter(request,
response)</code>，请求和响应继续到下一个过滤器，或者如果没有剩余过滤器则命中 servlet。</p>
<p>在servlet的情况下，<code>service()</code>调用该方法。默认情况下，此方法<code>doXxx()</code>根据<code>request.getMethod()</code>. 如果
servlet 中不存在确定的方法，则在响应中返回 HTTP 405 错误。</p>
<p>请求对象提供对有关 HTTP 请求的所有信息的访问，例如其URL、标头、查询字符串和正文。响应对象提供了以您想要的方式控制和发送 HTTP
响应的能力，例如，允许您设置标头和正文（通常使用从 JSP 文件生成的 HTML 内容）。当提交并完成 HTTP
响应时，请求和响应对象都将被回收并可供重用。</p>
<h3><code>HttpSession</code></h3>
<p>当客户端第一次访问 webapp 和/或<code>HttpSession</code>第一次通过 获取 时<code>request.getSession()</code>，servlet
容器创建一个新<code>HttpSession</code>对象，生成一个长且唯一的 ID（可以通过
获取<code>session.getId()</code>），并将其存储在服务器的记忆。servlet 容器还在HTTP
响应的标头<code>Cookie</code>中设置一个作为其名称和唯一会话 ID 的值。<code>Set-Cookie``JSESSIONID</code></p>
<p>根据HTTP cookie 规范（任何体面的 Web 浏览器和 Web 服务器都必须遵守的合同），只要 cookie 有效，客户端（Web
浏览器）就需要在标头中的后续请求中发回此cookie<code>Cookie</code> （即唯一 ID 必须引用未过期的会话并且域和路径是正确的）。使用浏览器内置的 HTTP
流量监视器，您可以验证 cookie 是否有效（在 Chrome / Firefox 23+ / IE9+ 中按 F12，并检查网络 <em>/网络</em>
选项卡）。servlet 容器将检查<code>Cookie</code>每个传入 HTTP 请求的标头中是否存在具有名称的 cookie ，并使用其值（会话
ID）从服务器内存中<code>JSESSIONID</code>获取关联。<code>HttpSession</code></p>
<p>保持<code>HttpSession</code>活动状态，直到它空闲（即未在请求中使用）的时间超过 中指定的超时值<code>&lt;session-timeout&gt;</code>，这是
中的一个设置<code>web.xml</code>。超时值默认为 30 分钟。因此，当客户端在超过指定时间的情况下未访问 Web 应用程序时，servlet
容器会丢弃会话。每个后续请求，即使指定了 cookie，也将无法再访问同一会话；servlet 容器将创建一个新会话。</p>
<p>在客户端，只要浏览器实例在运行，会话 cookie
就会保持活动状态。因此，如果客户端关闭浏览器实例（所有选项卡/窗口），那么会话将在客户端被丢弃。在新的浏览器实例中，与会话关联的 cookie
将不存在，因此将不再发送它。<code>HttpSession</code>这会导致创建一个全新的会话 cookie ，并使用一个全新的会话 cookie。</p>
<h3>简而言之</h3>
<ul>
<li>
<code>ServletContext</code>只要网络应用程序存在，生命就会存在。 <em>它在所有会话中的</em> <em>所有</em> 请求之间共享。 __</li>
<li>只要<code>HttpSession</code>客户端使用相同的浏览器实例与 Web 应用程序交互，并且会话在服务器端没有超时，就会一直存在。 <em>它在同一会话中的</em> <em>所有</em> 请求之间共享。 __</li>
<li>
<code>HttpServletRequest</code>从servlet 收到来自客户端的 HTTP 请求开始<code>HttpServletResponse</code>，直到完整的响应（网页）到达。它 <em>不会</em> 在其他地方共享。</li>
<li>只要 Web 应用程序存在，所有 和实例<code>Servlet</code>就会存在。 <em>它们在所有会话中的</em> <em>所有</em> 请求之间共享。<code>Filter``Listener</code> <strong> </strong>
</li>
<li>
<code>attribute</code>中定义的任何对象<code>ServletContext</code>，只要所讨论的对象存在，它们就会存在<code>HttpServletRequest</code>。<code>HttpSession</code>对象本身代表 Bean 管理框架（例如 JSF、CDI、Spring 等）中的“作用域”。这些框架将它们的作用域 Bean 存储为其<code>attribute</code>最接近的匹配作用域。</li>
</ul>
<h3>线程安全</h3>
<p>也就是说，您主要关心的可能是 <em>thread safety</em> 。您现在应该知道 servlet 和过滤器在所有请求之间共享。这是 Java
的优点，它是多线程的，不同的线程（阅读：HTTP
请求）可以使用同一个实例。否则重新创建它们的成本太高，<code>init()</code>而且<code>destroy()</code>每个请求都需要重新创建。</p>
<p>您还应该意识到，您 <strong>永远</strong> 不应将任何请求或会话范围内的数据分配为servlet 或过滤器的 <em>实例变量。</em>
它将在其他会话中的所有其他请求之间共享。那 <strong>不是</strong> 线程安全的！下面的例子说明了这一点：</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">ExampleServlet</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">HttpServlet</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">private</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="w"> </span><span class="n">thisIsNOTThreadSafe</span><span class="p">;</span>

<span class="w">    </span><span class="n">protected</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">doGet</span><span class="p">(</span><span class="n">HttpServletRequest</span><span class="w"> </span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">HttpServletResponse</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="n">throws</span><span class="w"> </span><span class="n">ServletException</span><span class="p">,</span><span class="w"> </span><span class="n">IOException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb nb-Type">Object</span><span class="w"> </span><span class="n">thisIsThreadSafe</span><span class="p">;</span>

<span class="w">        </span><span class="n">thisIsNOTThreadSafe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="o">.</span><span class="n">getParameter</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">BAD</span><span class="o">!!</span><span class="w"> </span><span class="n">Shared</span><span class="w"> </span><span class="n">among</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">requests</span><span class="o">!</span>
<span class="w">        </span><span class="n">thisIsThreadSafe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="o">.</span><span class="n">getParameter</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">OK</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="n">safe</span><span class="o">.</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<h4>也可以看看：</h4>
<ul>
<li>JSF、Servlet 和 JSP 有什么区别？</li>
<li>Java 会话管理的最佳选择</li>
<li>servlet 映射 url 模式中 / 和 /* 的区别</li>
<li>Servlet 中的 doGet 和 doPost</li>
<li>Servlet 似乎同步处理多个并发浏览器请求</li>
<li>为什么 Servlet 不是线程安全的？</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<h3>会话</h3>
<p><img alt="在此处输入图像描述" src="../../images/ABDSX.png"><img alt="在此处输入图像描述" src="../../images/IWAF3.png"></p>
<p>简而言之：网络服务器会在 <em>每位访问者</em> <em>首次</em> 访问时为其分配一个唯一标识符。访客必须带回该
ID，以便下次被识别。该标识符还允许服务器正确地将一个会话拥有的对象与另一个会话拥有的对象分开。</p>
<h3>Servlet实例化</h3>
<p>如果 <strong>启动时加载</strong> 为 <strong>false</strong> ：</p>
<p><img alt="在此处输入图像描述" src="../../images/Jjvcb.png"><img alt="在此处输入图像描述" src="../../images/7Bw3x.png"></p>
<p>如果 <strong>启动时加载</strong> 为 <strong>真</strong> ：</p>
<p><img alt="在此处输入图像描述" src="../../images/t33bd.png"><img alt="在此处输入图像描述" src="../../images/e7BB7.png"></p>
<p>一旦他进入服务模式并处于最佳状态，同 <em>一个</em> servlet 将处理来自所有其他客户端的请求。</p>
<p><img alt="在此处输入图像描述" src="../../images/gqoR4.png"></p>
<p>为什么每个客户端一个实例不是一个好主意？想一想：您会为每一份订单雇用一个比萨店员吗？那样做，你很快就会倒闭。</p>
<p>虽然它有一个小风险。请记住：这个人的口袋里装着所有的订单信息：因此，如果您对servlet 上的线程安全性不谨慎，他可能最终会向某个客户发出错误的订单。</p>
<p><br><br><a href="../how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreading/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/instance-variables/" rel="tag">instance-variables</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/multithreading/" rel="tag">multithreading</a></li>
            <li><a class="tag p-category" href="../../categories/servlets/" rel="tag">servlets</a></li>
            <li><a class="tag p-category" href="../../categories/session-variables/" rel="tag">session-variables</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../zi-yuan-yi-cun-zai-shi-post-de-http-xiang-ying-dai-ma/" rel="prev" title="资源已存在时 POST 的 HTTP 响应代码">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-zai-xuan-ting-shi-zhi-zuo-twitter-bootstrap-cai-dan-xia-la-cai-dan-er-bu-shi-dan-ji/" rel="next" title="如何在悬停时制作 Twitter Bootstrap 菜单下拉菜单而不是单击">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
