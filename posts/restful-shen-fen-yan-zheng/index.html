<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>RESTful 身份验证 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/restful-shen-fen-yan-zheng/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-cong-wo-de-android-she-bei-fang-wen-wo-de-ben-di-zhu-ji/" title="如何从我的 Android 设备访问我的本地主机？" type="text/html">
<link rel="next" href="../gu-ding-wei-zhi-dan-xiang-dui-yu-rong-qi/" title="固定位置但相对于容器" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="RESTful 身份验证">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/restful-shen-fen-yan-zheng/">
<meta property="og:description" content="RESTful 身份验证是什么意思，它是如何工作的？我在 Google 上找不到很好的概述。我唯一的理解是您在 URL
中传递了会话密钥（remeberal），但这可能是非常错误的。

解答
如何在 RESTful 客户端-服务器架构中处理身份验证是一个有争议的问题。
通常，在 SOA over HTTP 世界中，它可以通过以下方式实现：

基于 HTTPS 的 HTTP 基本身份验证；
Cook">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T13:30:52+08:00">
<meta property="article:tag" content="authentication">
<meta property="article:tag" content="rest">
<meta property="article:tag" content="rest-security">
<meta property="article:tag" content="restful-authentication">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">RESTful 身份验证</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T13:30:52+08:00" itemprop="datePublished" title="2023-02-17 13:30">2023-02-17 13:30</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>RESTful 身份验证是什么意思，它是如何工作的？我在 Google 上找不到很好的概述。我唯一的理解是您在 URL
中传递了会话密钥（remeberal），但这可能是非常错误的。</p>
<p><br><br></p>
<h2>解答</h2>
<p>如何在 RESTful 客户端-服务器架构中处理身份验证是一个有争议的问题。</p>
<p>通常，在 SOA over HTTP 世界中，它可以通过以下方式实现：</p>
<ul>
<li>基于 HTTPS 的 HTTP 基本身份验证；</li>
<li>Cookie 和会话管理；</li>
<li>HTTP 标头中的令牌（例如 <em>OAuth</em> 2.0 + JWT）；</li>
<li>使用附加签名参数查询身份验证。</li>
</ul>
<p>您必须适应，甚至更好地混合这些技术，以最好地匹配您的软件架构。</p>
<p>每种身份验证方案都有自己的优点和缺点，具体取决于您的安全策略和软件架构的目的。</p>
<p><strong>基于 HTTPS 的 HTTP 基本身份验证</strong></p>
<p>第一个解决方案基于标准的 HTTPS 协议，被大多数 Web 服务使用。</p>
<div class="code"><pre class="code literal-block"><span class="nf">GET</span> <span class="nn">/spec.html</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.example.org</span>
<span class="na">Authorization</span><span class="o">:</span> <span class="l">Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</span>
</pre></div>

<p>它很容易实现，默认情况下在所有浏览器上可用，但有一些已知的缺点，比如浏览器上显示的糟糕的身份验证窗口，它将持续存在（这里没有类似注销的功能），一些服务器端额外的
CPU 消耗，以及用户名和密码（通过 HTTPS）传输到服务器的事实（在键盘输入期间让密码仅保留在客户端并作为安全散列存储在服务器上应该更安全） .</p>
<p>我们可以使用Digest Authentication，但它也需要 HTTPS，因为它容易受到MiM或Replay攻击，并且特定于 HTTP。</p>
<p><strong>通过 Cookie 进行会话</strong></p>
<p>老实说，在服务器上管理的会话并不是真正的无状态。</p>
<p>一种可能性是在 cookie 内容中维护所有数据。而且，根据设计，cookie 在服务器端处理（实际上，客户端甚至不会尝试解释此 cookie
数据：它只是在每个连续请求时将其返回给服务器）。但是这个 cookie 数据是应用程序状态数据，所以在纯无状态的世界中，客户端应该管理它，而不是服务器。</p>
<div class="code"><pre class="code literal-block"><span class="nf">GET</span> <span class="nn">/spec.html</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="o">:</span> <span class="l">www.example.org</span>
<span class="na">Cookie</span><span class="o">:</span> <span class="l">theme=light; sessionToken=abc123</span>
</pre></div>

<p>cookie 技术本身是 HTTP 链接的，因此它不是真正的 RESTful，它应该是独立于协议的，恕我直言。它容易受到MiM或Replay攻击。</p>
<p><strong>通过令牌 (OAuth2) 授予</strong></p>
<p>另一种方法是在 HTTP 标头中放置一个令牌，以便对请求进行身份验证。例如，这就是 <em>OAuth 2.0 所做的。</em> 请参阅RFC 6749：</p>
<div class="code"><pre class="code literal-block"> GET /resource/1 HTTP/1.1
 Host: example.com
 Authorization: Bearer mF_9.B5f-4.1JqM
</pre></div>

<p>简而言之，这与 cookie 非常相似，并且存在相同的问题：不是无状态的，依赖于 HTTP 传输细节，并且存在许多安全漏洞- 包括 MiM 和
Replay - 因此只能通过 HTTPS 使用。通常，JWT用作令牌。</p>
<p><strong>查询认证</strong></p>
<p>查询身份验证包括通过 URI 上的一些附加参数对每个 RESTful 请求进行签名。请参阅这篇参考文章。</p>
<p>在这篇文章中是这样定义的：</p>
<blockquote>
<p>所有 REST 查询都必须通过使用私有凭证作为签名令牌对按小写字母顺序排序的查询参数进行签名来进行身份验证。签名应该发生在 URL 编码查询字符串之前。</p>
</blockquote>
<p>这种技术可能与无状态架构更兼容，也可以通过轻型会话管理（使用内存中会话而不是数据库持久性）来实现。</p>
<p>例如，这是来自上面链接的通用 URI 示例：</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /object?apiKey=Qwerty2010</span>
</pre></div>

<p>应该这样传送：</p>
<div class="code"><pre class="code literal-block"><span class="err">GET /object?timestamp=1261496500&amp;apiKey=Qwerty2010&amp;signature=abcdef0123456789</span>
</pre></div>

<p>被签名的字符串是<code>/object?apikey=Qwerty2010&amp;timestamp=1261496500</code>并且签名是使用 API
密钥的私有组件的该字符串的 SHA256 哈希值。</p>
<p>服务器端数据缓存可以始终可用。例如，在我们的框架中，我们在 SQL 级别缓存响应，而不是在 URI 级别。所以添加这个额外的参数不会破坏缓存机制。</p>
<p>有关基于 JSON 和 REST 的客户端-服务器 ORM/SOA/MVC 框架中的 RESTful
身份验证的一些详细信息，请参阅本文。由于我们不仅允许通过 HTTP/1.1 进行通信，还允许通过命名管道或 GDI
消息（本地）进行通信，因此我们尝试实现真正的 RESTful 身份验证模式，而不依赖于 HTTP 特性（如标头或 cookie）。</p>
<p><em>稍后注意</em> ：在 URI 中添加签名可以被视为不好的做法（因为例如它会出现在 http 服务器日志中）因此必须减轻它，例如通过适当的 TTL
来避免重播。但是如果你的 http 日志被泄露，你肯定会有更大的安全问题。</p>
<p>实际上，即将推出的OAuth 2.0 MAC 令牌身份验证可能是相对于“通过令牌授予”当前方案的巨大改进。但这仍在进行中，并且与 HTTP 传输相关联。</p>
<p><strong>结论</strong></p>
<p>值得得出的结论是，REST 不仅是基于 HTTP 的，即使在实践中，它也主要通过 HTTP 实现。REST 可以使用其他通信层。因此，RESTful
身份验证不仅仅是 HTTP 身份验证的同义词，无论 Google 给出什么答案。它甚至应该完全不使用 HTTP 机制，而应该从通信层中抽象出来。如果您使用
HTTP 通信，由于Let's Encrypt 倡议，没有理由不使用适当的 HTTPS，这是除了任何身份验证方案之外所必需的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我怀疑那些热情地喊着“HTTP 身份验证”的人是否曾经尝试过使用 REST 制作基于浏览器的应用程序（而不是机器对机器的 Web 服务）（无意冒犯 -
我只是认为他们从未遇到过复杂情况） .</p>
<p>我在生成要在浏览器中查看的 HTML 页面的 RESTful 服务上使用 HTTP 身份验证时发现的问题是：</p>
<ul>
<li>用户通常会得到一个丑陋的浏览器制作的登录框，这对用户非常不友好。您不能添加密码检索、帮助框等。</li>
<li>注销或以不同的名称登录是一个问题 - 浏览器将继续向站点发送身份验证信息，直到您关闭窗口</li>
<li>超时很难</li>
</ul>
<p>此处有一篇非常有见地的文章逐点解决这些问题，但这会导致大量 <em>特定</em> 于浏览器的 javascript
hackery、变通方法的变通方法等等。因此，它也不向前兼容，因此在发布新浏览器时需要不断维护。我不考虑那种简洁明了的设计，而且我觉得这是很多额外的工作和头痛，只是为了让我可以热情地向我的朋友们展示我的
REST-badge。</p>
<p>我相信 cookie 是解决方案。但是等等，饼干是邪恶的，不是吗？不，它们不是，通常使用 cookie 的方式是邪恶的。cookie
本身只是一条客户端信息，就像浏览器在您浏览时会跟踪的 HTTP 身份验证信息一样。这条客户端信息会在每次请求时发送到服务器，就像 HTTP
身份验证信息一样。从概念上讲，唯一的区别是这段客户端状态的 <em>内容可以由</em> <em>服务器</em> 确定，作为其响应的一部分。</p>
<p>通过仅使用以下规则使会话成为 RESTful 资源：</p>
<ul>
<li>会话将密钥映射到用户 ID（可能 <em>还有</em> 超时的最后操作时间戳）</li>
<li>如果 <em>会话</em> 存在，则意味着密钥有效。</li>
<li>登录意味着 POST 到 /sessions，一个新的密钥被设置为一个 cookie</li>
<li>注销意味着删除 /sessions/{key} （使用过载的 POST，请记住，我们是浏览器，HTML 5 还有很长的路要走）</li>
<li>身份验证是通过在每次请求时将密钥作为 cookie 发送并检查会话是否存在且有效来完成的</li>
</ul>
<p>现在，与 HTTP 身份验证的唯一区别是，身份验证密钥由服务器生成并发送给不断发回它的客户端，而不是客户端根据输入的凭据计算它。</p>
<p>converter42 补充说，当使用 https（我们应该这样做）时，重要的是 cookie
将设置其安全标志，以便永远不会通过非安全连接发送身份验证信息。好点，我自己没见过。</p>
<p>我觉得这是一个足够好的解决方案，但我必须承认我还不够安全专家来识别这个方案中的潜在漏洞——我所知道的是数百个非 RESTful Web
应用程序使用基本相同的登录协议（PHP 中的 $_SESSION，Java EE 中的 HttpSession 等）。cookie
标头内容仅用于寻址服务器端资源，就像接受语言可能用于访问翻译资源等。我感觉是一样的，但也许别人不这么认为？你们觉得怎么样？</p>
<p><br><br><a href="../restful-authentication/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/authentication/" rel="tag">authentication</a></li>
            <li><a class="tag p-category" href="../../categories/rest/" rel="tag">rest</a></li>
            <li><a class="tag p-category" href="../../categories/rest-security/" rel="tag">rest-security</a></li>
            <li><a class="tag p-category" href="../../categories/restful-authentication/" rel="tag">restful-authentication</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-cong-wo-de-android-she-bei-fang-wen-wo-de-ben-di-zhu-ji/" rel="prev" title="如何从我的 Android 设备访问我的本地主机？">Previous post</a>
            </li>
            <li class="next">
                <a href="../gu-ding-wei-zhi-dan-xiang-dui-yu-rong-qi/" rel="next" title="固定位置但相对于容器">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
