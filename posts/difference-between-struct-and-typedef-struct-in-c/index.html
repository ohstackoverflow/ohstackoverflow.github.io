<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Difference between 'struct' and 'typedef struct' in C++? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/difference-between-struct-and-typedef-struct-in-c/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-run-a-powershell-script/" title="How to run a PowerShell script" type="text/html">
<link rel="next" href="../git-ignore-file-for-xcode-projects/" title="Git ignore file for Xcode projects" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Difference between 'struct' and 'typedef struct' in C++?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/difference-between-struct-and-typedef-struct-in-c/">
<meta property="og:description" content="In C++ , is there any difference between:
struct Foo { ... };


and:
typedef struct { ... } Foo;



Answer
In C++, there is only a subtle difference. It's a holdover from C, in which it
makes a differ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T08:57:57+08:00">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="struct">
<meta property="article:tag" content="typedef">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Difference between 'struct' and 'typedef struct' in C++?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:57:57+08:00" itemprop="datePublished" title="2023-02-17 08:57">2023-02-17 08:57</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>In <strong>C++</strong> , is there any difference between:</p>
<div class="code"><pre class="code literal-block">struct Foo { ... };
</pre></div>

<p>and:</p>
<div class="code"><pre class="code literal-block">typedef struct { ... } Foo;
</pre></div>

<p><br><br></p>
<h2>Answer</h2>
<p>In C++, there is only a subtle difference. It's a holdover from C, in which it
makes a difference.</p>
<p>The C language standard (C89 §3.1.2.3, C99 §6.2.3, and C11 §6.2.3) mandates
separate namespaces for different categories of identifiers, including <em>tag
identifiers</em> (for <code>struct</code>/<code>union</code>/<code>enum</code>) and <em>ordinary identifiers</em> (for
<code>typedef</code> and other identifiers).</p>
<p>If you just said:</p>
<div class="code"><pre class="code literal-block">struct Foo { ... };
Foo x;
</pre></div>

<p>you would get a compiler error, because <code>Foo</code> is only defined in the tag
namespace.</p>
<p>You'd have to declare it as:</p>
<div class="code"><pre class="code literal-block">struct Foo x;
</pre></div>

<p>Any time you want to refer to a <code>Foo</code>, you'd always have to call it a <code>struct
Foo</code>. This gets annoying fast, so you can add a <code>typedef</code>:</p>
<div class="code"><pre class="code literal-block">struct Foo { ... };
typedef struct Foo Foo;
</pre></div>

<p>Now <code>struct Foo</code> (in the tag namespace) and just plain <code>Foo</code> (in the ordinary
identifier namespace) both refer to the same thing, and you can freely declare
objects of type <code>Foo</code> without the <code>struct</code> keyword.</p>
<hr>
<p>The construct:</p>
<div class="code"><pre class="code literal-block">typedef struct Foo { ... } Foo;
</pre></div>

<p>is just an abbreviation for the declaration and <code>typedef</code>.</p>
<hr>
<p>Finally,</p>
<div class="code"><pre class="code literal-block">typedef struct { ... } Foo;
</pre></div>

<p>declares an anonymous structure and creates a <code>typedef</code> for it. Thus, with
this construct, it doesn't have a name in the tag namespace, only a name in
the typedef namespace. This means it also cannot be forward-declared. <em>If you
want to make a forward declaration, you have to give it a name in the tag
namespace</em>.</p>
<hr>
<p>In C++, all <code>struct</code>/<code>union</code>/<code>enum</code>/<code>class</code> declarations act like they are
implicitly <code>typedef</code>'ed, as long as the name is not hidden by another
declaration with the same name. See Michael Burr's answer for the full
details.</p>
<p><br></p>
<h3>Suggest</h3>
<p>In this DDJ article, Dan Saks explains one small area where bugs can creep
through if you do not typedef your structs (and classes!):</p>
<blockquote>
<p>If you want, you can imagine that C++ generates a typedef for every tag
name, such as</p>
<div class="code"><pre class="code literal-block">typedef class string string;
</pre></div>

<p>Unfortunately, this is not entirely accurate. I wish it were that simple,
but it's not. C++ can't generate such typedefs for structs, unions, or enums
without introducing incompatibilities with C.</p>
<p>For example, suppose a C program declares both a function and a struct named
status:</p>
<div class="code"><pre class="code literal-block">int status(); struct status;
</pre></div>

<p>Again, this may be bad practice, but it is C. In this program, status (by
itself) refers to the function; struct status refers to the type.</p>
<p>If C++ did automatically generate typedefs for tags, then when you compiled
this program as C++, the compiler would generate:</p>
<div class="code"><pre class="code literal-block">typedef struct status status;
</pre></div>

<p>Unfortunately, this type name would conflict with the function name, and the
program would not compile. That's why C++ can't simply generate a typedef
for each tag.</p>
<p>In C++, tags act just like typedef names, except that a program can declare
an object, function, or enumerator with the same name and the same scope as
a tag. In that case, the object, function, or enumerator name hides the tag
name. The program can refer to the tag name only by using the keyword class,
struct, union, or enum (as appropriate) in front of the tag name. A type
name consisting of one of these keywords followed by a tag is an elaborated-
type-specifier. For instance, struct status and enum month are elaborated-
type-specifiers.</p>
<p>Thus, a C program that contains both:</p>
<div class="code"><pre class="code literal-block">int status(); struct status;
</pre></div>

<p>behaves the same when compiled as C++. The name status alone refers to the
function. The program can refer to the type only by using the elaborated-
type-specifier struct status.</p>
<p>So how does this allow bugs to creep into programs? Consider the program in
Listing 1. This program defines a class foo with a default constructor, and
a conversion operator that converts a foo object to char const *. The
expression</p>
<div class="code"><pre class="code literal-block">p = foo();
</pre></div>

<p>in main should construct a foo object and apply the conversion operator. The
subsequent output statement</p>
<div class="code"><pre class="code literal-block">cout &lt;&lt; p &lt;&lt; '\n';
</pre></div>

<p>should display class foo, but it doesn't. It displays function foo.</p>
<p>This surprising result occurs because the program includes header lib.h
shown in Listing 2. This header defines a function also named foo. The
function name foo hides the class name foo, so the reference to foo in main
refers to the function, not the class. main can refer to the class only by
using an elaborated-type-specifier, as in</p>
<div class="code"><pre class="code literal-block">p = class foo();
</pre></div>

<p>The way to avoid such confusion throughout the program is to add the
following typedef for the class name foo:</p>
<div class="code"><pre class="code literal-block">typedef class foo foo;
</pre></div>

<p>immediately before or after the class definition. This typedef causes a
conflict between the type name foo and the function name foo (from the
library) that will trigger a compile-time error.</p>
<p>I know of no one who actually writes these typedefs as a matter of course.
It requires a lot of discipline. Since the incidence of errors such as the
one in Listing 1 is probably pretty small, you many never run afoul of this
problem. But if an error in your software might cause bodily injury, then
you should write the typedefs no matter how unlikely the error.</p>
<p>I can't imagine why anyone would ever want to hide a class name with a
function or object name in the same scope as the class. The hiding rules in
C were a mistake, and they should not have been extended to classes in C++.
Indeed, you can correct the mistake, but it requires extra programming
discipline and effort that should not be necessary.</p>
</blockquote>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/c%2B%2B/" rel="tag">c++</a></li>
            <li><a class="tag p-category" href="../../categories/struct/" rel="tag">struct</a></li>
            <li><a class="tag p-category" href="../../categories/typedef/" rel="tag">typedef</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-run-a-powershell-script/" rel="prev" title="How to run a PowerShell script">Previous post</a>
            </li>
            <li class="next">
                <a href="../git-ignore-file-for-xcode-projects/" rel="next" title="Git ignore file for Xcode projects">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
