<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Fastest sort of fixed length 6 int array | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/fastest-sort-of-fixed-length-6-int-array/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-is-the-motivation-for-bringing-symbols-to-es6/" title="What is the motivation for bringing Symbols to ES6?" type="text/html">
<link rel="next" href="../why-is-jsonrequestbehavior-needed/" title="Why is JsonRequestBehavior needed?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Fastest sort of fixed length 6 int array">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/fastest-sort-of-fixed-length-6-int-array/">
<meta property="og:description" content="Answering to another Stack Overflow question (this one) I stumbled upon an
interesting sub-problem. What is the fastest way to sort an array of 6
integers?
As the question is very low level:

we can't">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T17:20:01+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="gpgpu">
<meta property="article:tag" content="optimization">
<meta property="article:tag" content="sorting">
<meta property="article:tag" content="sorting-network">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Fastest sort of fixed length 6 int array</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T17:20:01+08:00" itemprop="datePublished" title="2023-03-03 17:20">2023-03-03 17:20</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Answering to another Stack Overflow question (this one) I stumbled upon an
interesting sub-problem. What is the fastest way to sort an array of 6
integers?</p>
<p>As the question is very low level:</p>
<ul>
<li>we can't assume libraries are available (and the call itself has its cost), only plain C</li>
<li>to avoid emptying instruction pipeline (that has a <em>very</em> high cost) we should probably minimize branches, jumps, and every other kind of control flow breaking (like those hidden behind sequence points in <code>&amp;&amp;</code> or <code>||</code>).</li>
<li>room is constrained and minimizing registers and memory use is an issue, ideally in place sort is probably best.</li>
</ul>
<p>Really this question is a kind of Golf where the goal is not to minimize
source length but execution time. I call it 'Zening' code as used in the title
of the book Zen of Code optimization by Michael Abrash and its sequels.</p>
<p>As for why it is interesting, there is several layers:</p>
<ul>
<li>the example is simple and easy to understand and measure, not much C skill involved</li>
<li>it shows effects of choice of a good algorithm for the problem, but also effects of the compiler and underlying hardware.</li>
</ul>
<p>Here is my reference (naive, not optimized) implementation and my test set.</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">sort6</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="err">{</span>

<span class="w">    </span><span class="nc">char</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">imin</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">        </span><span class="n">imin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">imin</span><span class="o">]</span><span class="p">)</span><span class="err">{</span>
<span class="w">                </span><span class="n">imin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="err">}</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">d</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">imin</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">d</span><span class="o">[</span><span class="n">imin</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">rdtsc</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">  </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">     </span><span class="n">__asm__</span><span class="w"> </span><span class="n">volatile</span><span class="w"> </span><span class="p">(</span><span class="ss">".byte 0x0f, 0x31"</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="ss">"=A"</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="err">}</span>

<span class="nc">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="nc">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="err">{</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">5</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="err">}</span><span class="p">,</span>
<span class="w">        </span><span class="err">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="err">}</span><span class="p">,</span>
<span class="w">        </span><span class="err">{</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="err">}</span><span class="p">,</span>
<span class="w">        </span><span class="err">{</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="err">}</span><span class="p">,</span>
<span class="w">        </span><span class="err">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">600</span><span class="err">}</span><span class="p">,</span>
<span class="w">        </span><span class="err">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="err">}</span>
<span class="w">    </span><span class="err">}</span><span class="p">;</span>

<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">cycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rdtsc</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="err">{</span>
<span class="w">        </span><span class="n">sort6</span><span class="p">(</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * printf("d%d : %d %d %d %d %d %d\n", i,</span>
<span class="cm">         *  d[i][0], d[i][6], d[i][7],</span>
<span class="cm">         *  d[i][8], d[i][9], d[i][10]);</span>
<span class="cm">        */</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="n">cycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rdtsc</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cycles</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="ss">"Time is %d\n"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">unsigned</span><span class="p">)</span><span class="n">cycles</span><span class="p">);</span>
<span class="err">}</span>
</pre></div>

<h3><strong>Raw results</strong></h3>
<p>As number of variants is becoming large, I gathered them all in a test suite
that can be found here. The actual tests used are a bit less naive than those
showed above, thanks to Kevin Stock. You can compile and execute it in your
own environment. I'm quite interested by behavior on different target
architecture/compilers. (OK guys, put it in answers, I will +1 every
contributor of a new resultset).</p>
<p>I gave the answer to Daniel Stutzbach (for golfing) one year ago as he was at
the source of the fastest solution at that time (sorting networks).</p>
<p><strong>Linux 64 bits, gcc 4.6.1 64 bits, Intel Core 2 Duo E8400, -O2</strong></p>
<ul>
<li>Direct call to qsort library function : 689.38</li>
<li>Naive implementation (insertion sort) : 285.70</li>
<li>Insertion Sort (Daniel Stutzbach) : 142.12</li>
<li>Insertion Sort Unrolled : 125.47</li>
<li>Rank Order : 102.26</li>
<li>Rank Order with registers : 58.03</li>
<li>Sorting Networks (Daniel Stutzbach) : 111.68</li>
<li>Sorting Networks (Paul R) : 66.36</li>
<li>Sorting Networks 12 with Fast Swap : 58.86</li>
<li>Sorting Networks 12 reordered Swap : 53.74</li>
<li>Sorting Networks 12 reordered Simple Swap : 31.54</li>
<li>Reordered Sorting Network w/ fast swap : 31.54</li>
<li>Reordered Sorting Network w/ fast swap V2 : 33.63</li>
<li>Inlined Bubble Sort (Paolo Bonzini) : 48.85</li>
<li>Unrolled Insertion Sort (Paolo Bonzini) : 75.30</li>
</ul>
<p><strong>Linux 64 bits, gcc 4.6.1 64 bits, Intel Core 2 Duo E8400, -O1</strong></p>
<ul>
<li>Direct call to qsort library function : 705.93</li>
<li>Naive implementation (insertion sort) : 135.60</li>
<li>Insertion Sort (Daniel Stutzbach) : 142.11</li>
<li>Insertion Sort Unrolled : 126.75</li>
<li>Rank Order : 46.42</li>
<li>Rank Order with registers : 43.58</li>
<li>Sorting Networks (Daniel Stutzbach) : 115.57</li>
<li>Sorting Networks (Paul R) : 64.44</li>
<li>Sorting Networks 12 with Fast Swap : 61.98</li>
<li>Sorting Networks 12 reordered Swap : 54.67</li>
<li>Sorting Networks 12 reordered Simple Swap : 31.54</li>
<li>Reordered Sorting Network w/ fast swap : 31.24</li>
<li>Reordered Sorting Network w/ fast swap V2 : 33.07</li>
<li>Inlined Bubble Sort (Paolo Bonzini) : 45.79</li>
<li>Unrolled Insertion Sort (Paolo Bonzini) : 80.15</li>
</ul>
<p>I included both -O1 and -O2 results because surprisingly for several programs
O2 is <strong>less</strong> efficient than O1. I wonder what specific optimization has this
effect ?</p>
<h3><strong>Comments on proposed solutions</strong></h3>
<p><strong>Insertion Sort (Daniel Stutzbach)</strong></p>
<p>As expected minimizing branches is indeed a good idea.</p>
<p><strong>Sorting Networks (Daniel Stutzbach)</strong></p>
<p>Better than insertion sort. I wondered if the main effect was not get from
avoiding the external loop. I gave it a try by unrolled insertion sort to
check and indeed we get roughly the same figures (code is here).</p>
<p><strong>Sorting Networks (Paul R)</strong></p>
<p>The best so far. The actual code I used to test is here. Don't know yet why it
is nearly two times as fast as the other sorting network implementation.
Parameter passing ? Fast max ?</p>
<p><strong>Sorting Networks 12 SWAP with Fast Swap</strong></p>
<p>As suggested by Daniel Stutzbach, I combined his 12 swap sorting network with
branchless fast swap (code is here). It is indeed faster, the best so far with
a small margin (roughly 5%) as could be expected using 1 less swap.</p>
<p>It is also interesting to notice that the branchless swap seems to be much (4
times) less efficient than the simple one using if on PPC architecture.</p>
<p><strong>Calling Library qsort</strong></p>
<p>To give another reference point I also tried as suggested to just call library
qsort (code is here). As expected it is much slower : 10 to 30 times slower...
as it became obvious with the new test suite, the main problem seems to be the
initial load of the library after the first call, and it compares not so
poorly with other version. It is just between 3 and 20 times slower on my
Linux. On some architecture used for tests by others it seems even to be
faster (I'm really surprised by that one, as library qsort use a more complex
API).</p>
<p><strong>Rank order</strong></p>
<p>Rex Kerr proposed another completely different method : for each item of the
array compute directly its final position. This is efficient because computing
rank order do not need branch. The drawback of this method is that it takes
three times the amount of memory of the array (one copy of array and variables
to store rank orders). The performance results are very surprising (and
interesting). On my reference architecture with 32 bits OS and Intel Core2
Quad E8300, cycle count was slightly below 1000 (like sorting networks with
branching swap). But when compiled and executed on my 64 bits box (Intel Core2
Duo) it performed much better : it became the fastest so far. I finally found
out the true reason. My 32bits box use gcc 4.4.1 and my 64bits box gcc 4.4.3
and the last one seems much better at optimizing this particular code (there
was very little difference for other proposals).</p>
<p><em>update</em> :</p>
<p>As published figures above shows this effect was still enhanced by later
versions of gcc and Rank Order became consistently twice as fast as any other
alternative.</p>
<p><strong>Sorting Networks 12 with reordered Swap</strong></p>
<dl>
<dt>The amazing efficiency of the Rex Kerr proposal with gcc 4.4.3 made me wonder</dt>
<dd>how could a program with 3 times as much memory usage be faster than
branchless sorting networks? My hypothesis was that it had less dependencies
of the kind read after write, allowing for better use of the superscalar
instruction scheduler of the x86. That gave me an idea: reorder swaps to
minimize read after write dependencies. More simply put: when you do <code>SWAP(1,
2); SWAP(0, 2);</code> you have to wait for the first swap to be finished before
performing the second one because both access to a common memory cell. When
you do <code>SWAP(1, 2); SWAP(4, 5);</code>the processor can execute both in parallel. I
tried it and it works as expected, the sorting networks is running about 10%
faster.</dd>
</dl>
<p><strong>Sorting Networks 12 with Simple Swap</strong></p>
<p>One year after the original post Steinar H. Gunderson suggested, that we
should not try to outsmart the compiler and keep the swap code simple. It's
indeed a good idea as the resulting code is about 40% faster! He also proposed
a swap optimized by hand using x86 inline assembly code that can still spare
some more cycles. The most surprising (it says volumes on programmer's
psychology) is that one year ago none of used tried that version of swap. Code
I used to test is here. Others suggested other ways to write a C fast swap,
but it yields the same performances as the simple one with a decent compiler.</p>
<p>The "best" code is now as follow:</p>
<div class="code"><pre class="code literal-block"><span class="k">static</span><span class="w"> </span><span class="n">inline</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">sort6_sorting_network_simple_swap</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="err">{</span>
<span class="n">#define</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="vm">?</span><span class="nl">x</span><span class="p">:</span><span class="n">y</span><span class="p">)</span>
<span class="n">#define</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="vm">?</span><span class="nl">y</span><span class="p">:</span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="n">#define</span><span class="w"> </span><span class="n">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="p">);</span><span class="w"> </span><span class="err">\</span>
<span class="w">                    </span><span class="n">const</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="p">);</span><span class="w"> </span><span class="err">\</span>
<span class="w">                    </span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="err">}</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">#undef</span><span class="w"> </span><span class="n">SWAP</span>
<span class="n">#undef</span><span class="w"> </span><span class="nf">min</span>
<span class="n">#undef</span><span class="w"> </span><span class="nf">max</span>
<span class="err">}</span>
</pre></div>

<p>If we believe our test set (and, yes it is quite poor, it's mere benefit is
being short, simple and easy to understand what we are measuring), the average
number of cycles of the resulting code for one sort is below 40 cycles (6
tests are executed). That put each swap at an average of 4 cycles. I call that
amazingly fast. Any other improvements possible ?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>For any optimization, it's always best to test, test, test. I would try at
least sorting networks and insertion sort. If I were betting, I'd put my money
on insertion sort based on past experience.</p>
<p>Do you know anything about the input data? Some algorithms will perform better
with certain kinds of data. For example, insertion sort performs better on
sorted or almost-sorted dat, so it will be the better choice if there's an
above-average chance of almost-sorted data.</p>
<p>The algorithm you posted is similar to an insertion sort, but it looks like
you've minimized the number of swaps at the cost of more comparisons.
Comparisons are far more expensive than swaps, though, because branches can
cause the instruction pipeline to stall.</p>
<p>Here's an insertion sort implementation:</p>
<div class="code"><pre class="code literal-block"><span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">sort6</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="err">{</span>
<span class="w">        </span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">                </span><span class="nc">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">j-1</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
<span class="w">                        </span><span class="n">d</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">j-1</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="n">d</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">        </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>Here's how I'd build a sorting network. First, use this site to generate a
minimal set of SWAP macros for a network of the appropriate length. Wrapping
that up in a function gives me:</p>
<div class="code"><pre class="code literal-block"><span class="k">static</span><span class="w"> </span><span class="n">__inline__</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">sort6</span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="err">{</span>
<span class="n">#define</span><span class="w"> </span><span class="n">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="err">}</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">SWAP</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">#undef</span><span class="w"> </span><span class="n">SWAP</span>
<span class="err">}</span>
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>Here's an implementation using sorting networks:</p>
<div class="code"><pre class="code literal-block"><span class="n">inline</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Sort2</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">inline</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Sort3</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">inline</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Sort4</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p3</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w">  </span>
<span class="p">}</span>

<span class="n">inline</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Sort6</span><span class="p">(</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p3</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p4</span><span class="p">,</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">*</span><span class="n">p5</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sort3</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort3</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="w"> </span><span class="n">p4</span><span class="p">,</span><span class="w"> </span><span class="n">p5</span><span class="p">);</span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">Sort2</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p5</span><span class="p">);</span><span class="w">  </span>
<span class="w">    </span><span class="n">Sort4</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">,</span><span class="w"> </span><span class="n">p4</span><span class="p">);</span><span class="w">  </span>
<span class="p">}</span>
</pre></div>

<p>You really need very efficient branchless <code>min</code> and <code>max</code> implementations for
this, since that is effectively what this code boils down to - a sequence of
<code>min</code> and <code>max</code> operations (13 of each, in total). I leave this as an exercise
for the reader.</p>
<p>Note that this implementation lends itself easily to vectorization (e.g. SIMD
- most SIMD ISAs have vector min/max instructions) and also to GPU
implementations (e.g. CUDA - being branchless there are no problems with warp
divergence etc).</p>
<p>See also: Fast algorithm implementation to sort very small list</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/algorithm/" rel="tag">algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/gpgpu/" rel="tag">gpgpu</a></li>
            <li><a class="tag p-category" href="../../categories/optimization/" rel="tag">optimization</a></li>
            <li><a class="tag p-category" href="../../categories/sorting/" rel="tag">sorting</a></li>
            <li><a class="tag p-category" href="../../categories/sorting-network/" rel="tag">sorting-network</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-is-the-motivation-for-bringing-symbols-to-es6/" rel="prev" title="What is the motivation for bringing Symbols to ES6?">Previous post</a>
            </li>
            <li class="next">
                <a href="../why-is-jsonrequestbehavior-needed/" rel="next" title="Why is JsonRequestBehavior needed?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
