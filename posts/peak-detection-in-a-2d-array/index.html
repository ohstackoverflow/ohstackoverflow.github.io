<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Peak detection in a 2D array | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/peak-detection-in-a-2d-array/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-to-use-glob-to-find-files-recursively/" title="How to use glob() to find files recursively?" type="text/html">
<link rel="next" href="../how-can-i-get-last-characters-of-a-string/" title="How can I get last characters of a string" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Peak detection in a 2D array">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/peak-detection-in-a-2d-array/">
<meta property="og:description" content="I'm helping a veterinary clinic measuring pressure under a dogs paw. I use
Python for my data analysis and now I'm stuck trying to divide the paws into
(anatomical) subregions.
I made a 2D array of ea">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T08:05:59+08:00">
<meta property="article:tag" content="image-processing">
<meta property="article:tag" content="python">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Peak detection in a 2D array</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:05:59+08:00" itemprop="datePublished" title="2023-02-17 08:05">2023-02-17 08:05</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>I'm helping a veterinary clinic measuring pressure under a dogs paw. I use
Python for my data analysis and now I'm stuck trying to divide the paws into
(anatomical) subregions.</p>
<p>I made a 2D array of each paw, that consists of the maximal values for each
sensor that has been loaded by the paw over time. Here's an example of one
paw, where I used Excel to draw the areas I want to 'detect'. These are 2 by 2
boxes around the sensor with local maxima's, that together have the largest
sum.</p>
<p><img alt="alt text" src="../../images/BuUbq.png"></p>
<p>So I tried some experimenting and decide to simply look for the maximums of
each column and row (can't look in one direction due to the shape of the paw).
This seems to 'detect' the location of the separate toes fairly well, but it
also marks neighboring sensors.</p>
<p><img alt="alt text" src="../../images/UyNRU.png"></p>
<p>So what would be the best way to tell Python which of these maximums are the
ones I want?</p>
<p><strong>Note: The 2x2 squares can't overlap, since they have to be separate toes!</strong></p>
<p>Also I took 2x2 as a convenience, any more advanced solution is welcome, but
I'm simply a human movement scientist, so I'm neither a real programmer or a
mathematician, so please keep it 'simple'.</p>
<p>Here's a version that can be loaded with <code>np.loadtxt</code></p>
<hr>
<h3>Results</h3>
<p>So I tried @jextee's solution (see the results below). As you can see, it
works very on the front paws, but it works less well for the hind legs.</p>
<p>More specifically, it can't recognize the small peak that's the fourth toe.
This is obviously inherent to the fact that the loop looks top down towards
the lowest value, without taking into account where this is.</p>
<p>Would anyone know how to tweak @jextee's algorithm, so that it might be able
to find the 4th toe too?</p>
<p><img alt="alt text" src="../../images/FFX0x.png"></p>
<p>Since I haven't processed any other trials yet, I can't supply any other
samples. But the data I gave before were the averages of each paw. This file
is an array with the maximal data of 9 paws in the order they made contact
with the plate.</p>
<p>This image shows how they were spatially spread out over the plate.</p>
<p><img alt="alt text" src="../../images/iPXEv.png"></p>
<h3>Update:</h3>
<p><strong>I have set up a blog for anyone interested</strong> and I have setup a OneDrive
with all the raw measurements. So to anyone requesting more data: more power
to you!</p>
<hr>
<h3>New update:</h3>
<p>So after the help I got with my questions regarding paw detection and paw
sorting, I was finally able to check the toe detection for every paw! Turns
out, it doesn't work so well in anything but paws sized like the one in my own
example. Off course in hindsight, it's my own fault for choosing the 2x2 so
arbitrarily.</p>
<p>Here's a nice example of where it goes wrong: a nail is being recognized as a
toe and the 'heel' is so wide, it gets recognized twice!</p>
<p><img alt="alt text" src="../../images/JEpIa.png"></p>
<p>The paw is too large, so taking a 2x2 size with no overlap, causes some toes
to be detected twice. The other way around, in small dogs it often fails to
find a 5th toe, which I suspect is being caused by the 2x2 area being too
large.</p>
<p>After trying the current solution on all my measurements I came to the
staggering conclusion that for nearly all my small dogs it didn't find a 5th
toe and that in over 50% of the impacts for the large dogs it would find more!</p>
<p>So clearly I need to change it. My own guess was changing the size of the
<code>neighborhood</code> to something smaller for small dogs and larger for large dogs.
But <code>generate_binary_structure</code> wouldn't let me change the size of the array.</p>
<p>Therefore, I'm hoping that anyone else has a better suggestion for locating
the toes, perhaps having the toe area scale with the paw size?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>I detected the peaks using a <strong>local maximum filter</strong>. Here is the result on
your first dataset of 4 paws: <img alt="Peaks detection result" src="../../images/Kgt4H.png"></p>
<p>I also ran it on the second dataset of 9 paws and it worked as well.</p>
<p>Here is how you do it:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">maximum_filter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">generate_binary_structure</span><span class="p">,</span> <span class="n">binary_erosion</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="c1">#for some reason I had to reshape. Numpy ignored the shape header.</span>
<span class="n">paws_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">loadtxt</span><span class="p">(</span><span class="s2">"paws.txt"</span><span class="p">)</span><span class="o">.</span><span class="kp">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span>

<span class="c1">#getting a list of images</span>
<span class="n">paws</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="kp">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="kp">vsplit</span><span class="p">(</span><span class="n">paws_data</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">detect_peaks</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Takes an image and detect the peaks usingthe local maximum filter.</span>
<span class="sd">    Returns a boolean mask of the peaks (i.e. 1 when</span>
<span class="sd">    the pixel's value is the neighborhood maximum, 0 otherwise)</span>
<span class="sd">    """</span>

    <span class="c1"># define an 8-connected neighborhood</span>
    <span class="n">neighborhood</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1">#apply the local maximum filter; all pixel of maximal value </span>
    <span class="c1">#in their neighborhood are set to 1</span>
    <span class="n">local_max</span> <span class="o">=</span> <span class="n">maximum_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">neighborhood</span><span class="p">)</span><span class="o">==</span><span class="n">image</span>
    <span class="c1">#local_max is a mask that contains the peaks we are </span>
    <span class="c1">#looking for, but also the background.</span>
    <span class="c1">#In order to isolate the peaks we must remove the background from the mask.</span>

    <span class="c1">#we create the mask of the background</span>
    <span class="n">background</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#a little technicality: we must erode the background in order to </span>
    <span class="c1">#successfully subtract it form local_max, otherwise a line will </span>
    <span class="c1">#appear along the background border (artifact of the local maximum filter)</span>
    <span class="n">eroded_background</span> <span class="o">=</span> <span class="n">binary_erosion</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">neighborhood</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#we obtain the final mask, containing only peaks, </span>
    <span class="c1">#by removing the background from the local_max mask (xor operation)</span>
    <span class="n">detected_peaks</span> <span class="o">=</span> <span class="n">local_max</span> <span class="o">^</span> <span class="n">eroded_background</span>

    <span class="k">return</span> <span class="n">detected_peaks</span>


<span class="c1">#applying the detection and plotting results</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">paw</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paws</span><span class="p">):</span>
    <span class="n">detected_peaks</span> <span class="o">=</span> <span class="n">detect_peaks</span><span class="p">(</span><span class="n">paw</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">paw</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">detected_peaks</span><span class="p">)</span>

<span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p>All you need to do after is use <code>scipy.ndimage.measurements.label</code> on the mask
to label all distinct objects. Then you'll be able to play with them
individually.</p>
<p><strong>Note</strong> that the method works well because the background is not noisy. If it
were, you would detect a bunch of other unwanted peaks in the background.
Another important factor is the size of the <em>neighborhood</em>. You will need to
adjust it if the peak size changes (the should remain roughly proportional).</p>
<p><br></p>
<h3>Suggest</h3>
<h4>Solution</h4>
<p>Data file: paw.txt. Source code:</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">from</span> <span class="s s-Atom">scipy</span> <span class="s s-Atom">import</span> <span class="o">*</span>
<span class="s s-Atom">from</span> <span class="s s-Atom">operator</span> <span class="s s-Atom">import</span> <span class="s s-Atom">itemgetter</span>

<span class="s s-Atom">n</span> <span class="o">=</span> <span class="mi">5</span>  <span class="s s-Atom">#</span> <span class="s s-Atom">how</span> <span class="s s-Atom">many</span> <span class="s s-Atom">fingers</span> <span class="s s-Atom">are</span> <span class="s s-Atom">we</span> <span class="s s-Atom">looking</span> <span class="s s-Atom">for</span>

<span class="s s-Atom">d</span> <span class="o">=</span> <span class="nf">loadtxt</span><span class="p">(</span><span class="s2">"paw.txt"</span><span class="p">)</span>
<span class="s s-Atom">width</span><span class="p">,</span> <span class="s s-Atom">height</span> <span class="o">=</span> <span class="s s-Atom">d</span><span class="p">.</span><span class="s s-Atom">shape</span>

<span class="s s-Atom">#</span> <span class="nv">Create</span> <span class="s s-Atom">an</span> <span class="s s-Atom">array</span> <span class="s s-Atom">where</span> <span class="s s-Atom">every</span> <span class="s s-Atom">element</span> <span class="o">is</span> <span class="s s-Atom">a</span> <span class="s s-Atom">sum</span> <span class="s s-Atom">of</span> <span class="mi">2</span><span class="s s-Atom">x2</span> <span class="s s-Atom">squares</span><span class="p">.</span>

<span class="s s-Atom">fourSums</span> <span class="o">=</span> <span class="s s-Atom">d</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">d</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">d</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">d</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span>

<span class="s s-Atom">#</span> <span class="nv">Find</span> <span class="s s-Atom">positions</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="s s-Atom">fingers</span><span class="p">.</span>

<span class="s s-Atom">#</span> <span class="nv">Pair</span> <span class="s s-Atom">each</span> <span class="s s-Atom">sum</span> <span class="s s-Atom">with</span> <span class="s s-Atom">its</span> <span class="s s-Atom">position</span> <span class="nf">number</span> <span class="p">(</span><span class="s s-Atom">from</span> <span class="mi">0</span> <span class="s s-Atom">to</span> <span class="s s-Atom">width</span><span class="o">*</span><span class="s s-Atom">height</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>

<span class="s s-Atom">pairs</span> <span class="o">=</span> <span class="nf">zip</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="s s-Atom">width</span><span class="o">*</span><span class="s s-Atom">height</span><span class="p">),</span> <span class="s s-Atom">fourSums</span><span class="p">.</span><span class="nf">flatten</span><span class="p">())</span>

<span class="s s-Atom">#</span> <span class="nv">Sort</span> <span class="s s-Atom">by</span> <span class="s s-Atom">descending</span> <span class="s s-Atom">sum</span> <span class="nb">val</span><span class="s s-Atom">ue</span><span class="p">,</span> <span class="s s-Atom">filter</span> <span class="s s-Atom">overlapping</span> <span class="s s-Atom">squares</span>

<span class="s s-Atom">def</span> <span class="nf">drop_overlapping</span><span class="p">(</span><span class="s s-Atom">pairs</span><span class="p">)</span><span class="o">:</span>
    <span class="s s-Atom">no_overlaps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="s s-Atom">def</span> <span class="nf">does_not_overlap</span><span class="p">(</span><span class="s s-Atom">p1</span><span class="p">,</span> <span class="s s-Atom">p2</span><span class="p">)</span><span class="o">:</span>
        <span class="s s-Atom">i1</span><span class="p">,</span> <span class="s s-Atom">i2</span> <span class="o">=</span> <span class="s s-Atom">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s s-Atom">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="s s-Atom">r1</span><span class="p">,</span> <span class="s s-Atom">col1</span> <span class="o">=</span> <span class="s s-Atom">i1</span> <span class="o">/</span> <span class="p">(</span><span class="s s-Atom">width</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s s-Atom">i1</span> <span class="c1">% (width-1)</span>
        <span class="s s-Atom">r2</span><span class="p">,</span> <span class="s s-Atom">col2</span> <span class="o">=</span> <span class="s s-Atom">i2</span> <span class="o">/</span> <span class="p">(</span><span class="s s-Atom">width</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s s-Atom">i2</span> <span class="c1">% (width-1)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="s s-Atom">r1</span><span class="o">-</span><span class="s s-Atom">r2</span><span class="p">),</span><span class="nf">abs</span><span class="p">(</span><span class="s s-Atom">col1</span><span class="o">-</span><span class="s s-Atom">col2</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="s s-Atom">for</span> <span class="s s-Atom">p</span> <span class="s s-Atom">in</span> <span class="s s-Atom">pairs</span><span class="p">:</span>
        <span class="s s-Atom">if</span> <span class="nf">all</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="s s-Atom">lambda</span> <span class="s s-Atom">prev</span><span class="p">:</span> <span class="nf">does_not_overlap</span><span class="p">(</span><span class="s s-Atom">p</span><span class="p">,</span><span class="s s-Atom">prev</span><span class="p">),</span> <span class="s s-Atom">no_overlaps</span><span class="p">))</span><span class="o">:</span>
            <span class="s s-Atom">no_overlaps</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s s-Atom">p</span><span class="p">)</span>
    <span class="s s-Atom">return</span> <span class="s s-Atom">no_overlaps</span>

<span class="s s-Atom">pairs2</span> <span class="o">=</span> <span class="nf">drop_overlapping</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="s s-Atom">pairs</span><span class="p">,</span> <span class="s s-Atom">key</span><span class="o">=</span><span class="nf">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s s-Atom">reverse</span><span class="o">=</span><span class="nv">True</span><span class="p">))</span>

<span class="s s-Atom">#</span> <span class="nv">Take</span> <span class="s s-Atom">the</span> <span class="s s-Atom">first</span> <span class="s s-Atom">n</span> <span class="s s-Atom">with</span> <span class="s s-Atom">the</span> <span class="s s-Atom">heighest</span> <span class="nb">val</span><span class="s s-Atom">ues</span>

<span class="s s-Atom">positions</span> <span class="o">=</span> <span class="s s-Atom">pairs2</span><span class="p">[</span><span class="o">:</span><span class="s s-Atom">n</span><span class="p">]</span>

<span class="s s-Atom">#</span> <span class="nv">Print</span> <span class="s s-Atom">results</span>

<span class="s s-Atom">print</span> <span class="s s-Atom">d</span><span class="p">,</span> <span class="s2">"\n"</span>

<span class="s s-Atom">for</span> <span class="s s-Atom">i</span><span class="p">,</span> <span class="nb">val</span> <span class="s s-Atom">in</span> <span class="s s-Atom">positions</span><span class="p">:</span>
    <span class="s s-Atom">row</span> <span class="o">=</span> <span class="s s-Atom">i</span> <span class="o">/</span> <span class="p">(</span><span class="s s-Atom">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="s s-Atom">column</span> <span class="o">=</span> <span class="s s-Atom">i</span> <span class="c1">% (width-1)</span>
    <span class="s s-Atom">print</span> <span class="s2">"sum = %f @ %d,%d (%d)"</span> <span class="c1">% (val, row, column, i)</span>
    <span class="s s-Atom">print</span> <span class="s s-Atom">d</span><span class="p">[</span><span class="s s-Atom">row</span><span class="p">:</span><span class="s s-Atom">row</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">column</span><span class="p">:</span><span class="s s-Atom">column</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="s2">"\n"</span>
</pre></div>

<p>Output without overlapping squares. It seems that the same areas are selected
as in your example.</p>
<h4>Some comments</h4>
<p>The tricky part is to calculate sums of all 2x2 squares. I assumed you need
all of them, so there might be some overlapping. I used slices to cut the
first/last columns and rows from the original 2D array, and then overlapping
them all together and calculating sums.</p>
<p>To understand it better, imaging a 3x3 array:</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; a = arange(9).reshape(3,3) ; a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</pre></div>

<p>Then you can take its slices:</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span>
<span class="nf">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
</pre></div>

<p>Now imagine you stack them one above the other and sum elements at the same
positions. These sums will be exactly the same sums over the 2x2 squares with
the top-left corner in the same position:</p>
<div class="code"><pre class="code literal-block"><span class="s s-Atom">&gt;&gt;&gt;</span> <span class="s s-Atom">sums</span> <span class="o">=</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="o">:-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="o">:-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span> <span class="o">+</span> <span class="s s-Atom">a</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">,</span><span class="mi">1</span><span class="o">:</span><span class="p">];</span> <span class="s s-Atom">sums</span>
<span class="nf">array</span><span class="p">([[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span>
</pre></div>

<p>When you have the sums over 2x2 squares, you can use <code>max</code> to find the
maximum, or <code>sort</code>, or <code>sorted</code> to find the peaks.</p>
<p>To remember positions of the peaks I couple every value (the sum) with its
ordinal position in a flattened array (see <code>zip</code>). Then I calculate row/column
position again when I print the results.</p>
<h4>Notes</h4>
<p>I allowed for the 2x2 squares to overlap. Edited version filters out some of
them such that only non-overlapping squares appear in the results.</p>
<h4>Choosing fingers (an idea)</h4>
<p>Another problem is how to choose what is likely to be fingers out of all the
peaks. I have an idea which may or may not work. I don't have time to
implement it right now, so just pseudo-code.</p>
<p>I noticed that if the front fingers stay on almost a perfect circle, the rear
finger should be inside of that circle. Also, the front fingers are more or
less equally spaced. We may try to use these heuristic properties to detect
the fingers.</p>
<p>Pseudo code:</p>
<div class="code"><pre class="code literal-block"><span class="n">select</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="n">finger</span><span class="w"> </span><span class="n">candidates</span><span class="w"> </span><span class="p">(</span><span class="ow">not</span><span class="w"> </span><span class="n">too</span><span class="w"> </span><span class="n">many</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span>
<span class="n">consider</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="n">combinations</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="p">(</span><span class="n">use</span><span class="w"> </span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">combination</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">fingers</span><span class="p">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">finger</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span>
<span class="w">        </span><span class="n">fit</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="n">circle</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="mi">4</span>
<span class="w">        </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span>
<span class="w">        </span><span class="n">check</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">selected</span><span class="w"> </span><span class="n">finger</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">circle</span>
<span class="w">        </span><span class="n">check</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="n">four</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">evenly</span><span class="w"> </span><span class="n">spread</span>
<span class="w">        </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">angles</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">center</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">circle</span><span class="p">)</span>
<span class="w">        </span><span class="n">assign</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">cost</span><span class="w"> </span><span class="p">(</span><span class="n">penalty</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">selection</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">peaks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">rear</span><span class="w"> </span><span class="n">finger</span>
<span class="w">        </span><span class="p">(</span><span class="n">consider</span><span class="p">,</span><span class="w"> </span><span class="n">probably</span><span class="w"> </span><span class="n">weighted</span><span class="p">:</span>
<span class="w">             </span><span class="n">circle</span><span class="w"> </span><span class="n">fitting</span><span class="w"> </span><span class="n">error</span><span class="p">,</span>
<span class="w">             </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">rear</span><span class="w"> </span><span class="n">finger</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">inside</span><span class="p">,</span>
<span class="w">             </span><span class="n">variance</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">spreading</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="n">fingers</span><span class="p">,</span>
<span class="w">             </span><span class="n">total</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">peaks</span><span class="p">)</span>
<span class="n">choose</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">combination</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">peaks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">rear</span><span class="w"> </span><span class="n">peak</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lowest</span><span class="w"> </span><span class="n">penalty</span>
</pre></div>

<p>This is a brute-force approach. If N is relatively small, then I think it is
doable. For N=12, there are C_12^5 = 792 combinations, times 5 ways to select
a rear finger, so 3960 cases to evaluate for every paw.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/image-processing/" rel="tag">image-processing</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-to-use-glob-to-find-files-recursively/" rel="prev" title="How to use glob() to find files recursively?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-can-i-get-last-characters-of-a-string/" rel="next" title="How can I get last characters of a string">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
