<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>具有类的第一个元素的 CSS 选择器 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ju-you-lei-de-di-yi-ge-yuan-su-de-css-xuan-ze-qi/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../shi-yong-grepjin-xing-fu-pi-pei-pi-pei-bu-bao-han-foode-xing/" title="使用grep进行负匹配（匹配不包含foo的行）" type="text/html">
<link rel="next" href="../ru-he-shi-yong-nvm-she-zhi-mo-ren-jie-dian-ban-ben/" title="如何使用 NVM 设置默认节点版本？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="具有类的第一个元素的 CSS 选择器">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ju-you-lei-de-di-yi-ge-yuan-su-de-css-xuan-ze-qi/">
<meta property="og:description" content='我有一堆带有类名的元素red，但我似乎无法使用class="red"以下 CSS 规则选择第一个元素：
.home .red:first-child {
    border: 1px solid red;
}


&lt;div class="home"&gt;
    &lt;span&gt;blah&lt;/span&gt;
    &lt;p class="red"&gt;first&lt;/p&gt;
    &lt;p class="red"&gt;sec'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T03:58:22+08:00">
<meta property="article:tag" content="css">
<meta property="article:tag" content="css-selectors">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">具有类的第一个元素的 CSS 选择器</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T03:58:22+08:00" itemprop="datePublished" title="2023-02-17 03:58">2023-02-17 03:58</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我有一堆带有类名的元素<code>red</code>，但我似乎无法使用<code>class="red"</code>以下 CSS 规则选择第一个元素：</p>
<div class="code"><pre class="code literal-block">.home<span class="w"> </span>.red:first-child<span class="w"> </span>{
<span class="w">    </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>red;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"home"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;span&gt;</span>blah<span class="nt">&lt;/span&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>这个选择器有什么问题，我该如何更正它以定位第一个有 class 的孩子<code>red</code>？</p>
<p><br><br></p>
<h2>解答</h2>
<p>这是作者误解工作原理的最著名例子之一<code>:first-child</code>。在 CSS2 中引入的伪<code>:first-child</code>类代表 <strong>其父类的第一个子类</strong>
。就是这样。有一个非常普遍的误解，认为它会选择第一个匹配复合选择器其余部分指定条件的子元素。由于选择器的工作方式（参见此处的解释），这根本不是真的。</p>
<p>选择器级别 3 引入了一个<code>:first-of-type</code>伪类，它代表其元素类型的兄弟姐妹中的第一个元素。这个答案<code>:first-
child</code>用插图解释了和之间的区别<code>:first-of-type</code>。但是，与 一样<code>:first-child</code>，它不考虑任何其他条件或属性。在 HTML
中，元素类型由标签名称表示。在问题中，该类型是<code>p</code>.</p>
<p>不幸的是，没有类似的<code>:first-of-class</code>伪类来匹配给定类的第一个子元素。在这个答案首次发布时，新发布的 FPWD of Selectors
level 4 引入了一个<code>:nth-
match()</code>伪类，正如我在第一段中提到的那样，通过添加一个选择器列表参数，围绕现有的选择器机制设计，通过它你可以提供其余的复合选择器以获得所需的过滤行为。近年来，此功能被包含在<code>:nth-
child()</code>自身中，选择器列表作为可选的第二个参数出现，以简化事情并避免<code>:nth-match()</code>在整个文档中匹配的错误印象（请参阅下面的最后注释）。</p>
<p>在我们等待跨浏览器支持的同时（说真的，已经将近 10 年了，其中最后 5 年只有一个实现），Lea
Verou和我独立开发的一个解决方法（她首先做到了！）是首先将您想要的样式应用于该类的 <em>所有元素：</em></p>
<div class="code"><pre class="code literal-block"><span class="cm">/* </span>
<span class="cm"> * Select all .red children of .home, including the first one,</span>
<span class="cm"> * and give them a border.</span>
<span class="cm"> */</span>
<span class="na">.home</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="no">.red</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">border:</span><span class="w"> </span><span class="err">1</span><span class="nf">px</span><span class="w"> </span><span class="no">solid</span><span class="w"> </span><span class="no">red</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>...然后在覆盖规则中使用通用兄弟组合器“撤消” <em>第一个</em> 元素之后的类元素的样式：<code>~</code></p>
<div class="code"><pre class="code literal-block"><span class="cm">/* </span>
<span class="cm"> * Select all but the first .red child of .home,</span>
<span class="cm"> * and remove the border from the previous rule.</span>
<span class="cm"> */</span>
<span class="na">.home</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="no">.red</span><span class="w"> </span><span class="err">~</span><span class="w"> </span><span class="no">.red</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">border:</span><span class="w"> </span><span class="nf">none</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>现在只有第一个元素<code>class="red"</code>有边框。</p>
<p>下面是如何应用规则的说明：</p>
<div class="code"><pre class="code literal-block">.home<span class="w"> </span>&gt;<span class="w"> </span>.red<span class="w"> </span>{
<span class="w">    </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>red;
}

.home<span class="w"> </span>&gt;<span class="w"> </span>.red<span class="w"> </span>~<span class="w"> </span>.red<span class="w"> </span>{
<span class="w">    </span>border:<span class="w"> </span>none;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"home"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>blah<span class="nt">&lt;/span&gt;</span><span class="w">         </span><span class="cm">&lt;!-- [1] --&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span><span class="w">  </span><span class="cm">&lt;!-- [2] --&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/p&gt;</span><span class="w"> </span><span class="cm">&lt;!-- [3] --&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span><span class="w">  </span><span class="cm">&lt;!-- [3] --&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/p&gt;</span><span class="w"> </span><span class="cm">&lt;!-- [3] --&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<ol>
<li>
<p><strong>不适用任何规则； 没有边框被渲染。</strong><br>
该元素没有 class <code>red</code>，因此被跳过。</p>
</li>
<li>
<p><strong>仅适用第一条规则； 呈现红色边框。</strong><br>
该元素具有 class ，但其父元素中<code>red</code>没有任何具有该 class 的元素。<code>red</code>因此不应用第二条规则，仅应用第一条，并且元素保持其边界。</p>
</li>
<li>
<p><strong>两条规则都适用； 没有边框被渲染。</strong><br>
这个元素有类<code>red</code>。它的前面还有至少一个具有 class
的其他元素<code>red</code>。因此，这两个规则都适用，第二个<code>border</code>声明覆盖第一个，可以这么说，从而“撤销”它。</p>
</li>
</ol>
<p>作为奖励，虽然它是在 Selectors 3 中引入的，但通用兄弟组合器实际上得到了 IE7 和更新版本的很好支持，这与 IE9
以后的版本不同<code>:first-of-type</code>并且<code>:nth-of-type()</code>仅支持。如果您需要良好的浏览器支持，那么您很幸运。</p>
<p>事实上，同级组合器是该技术中唯一重要的组件， <em>而且</em>
它具有如此惊人的浏览器支持，这使得该技术非常通用——您可以将其调整为通过类选择器之外的其他东西过滤元素：</p>
<ul>
<li>
<p>您可以<code>:first-of-type</code>通过简单地提供类型选择器而不是类选择器来使用它来解决 IE7 和 IE8 中的问题（同样，在后面的部分中，更多关于它在问题中的不正确用法）：</p>
<div class="code"><pre class="code literal-block"> article &gt; p {
 /* Apply styles to article &gt; p:first-of-type, which may or may not be :first-child */
</pre></div>

<p>}</p>
<p>article &gt; p ~ p {
     /<em> Undo the above styles for every subsequent article &gt; p </em>/
 }</p>
</li>
<li>
<p>您可以按属性选择器或任何其他简单选择器而不是类进行过滤。</p>
</li>
<li>
<p>您还可以将这种覆盖技术与伪元素结合使用，即使从技术上讲伪元素并不是简单的选择器。</p>
</li>
</ul>
<p>请注意，为了使其起作用，您需要提前知道其他同级元素的默认样式是什么，以便您可以覆盖第一条规则。此外，由于这涉及覆盖 CSS 中的规则，因此您无法使用与
Selectors API或Selenium的 CSS 定位器一起使用的单个选择器来实现相同的目的。</p>
<p>最后一点，请记住，这个答案假设问题是寻找具有给定类的 <em>任意数量的第一个子元素。</em> <em>对于整个文档中</em> 复杂选择器的第 n 次匹配，既没有伪类也没有通用的
CSS 解决方案——是否存在解决方案在很大程度上取决于文档结构。jQuery为此提供了<code>:eq()</code>、<code>:first</code>和更多，但请再次注意它们的功能与et
al非常不同。使用选择器 API，您可以使用获取第一个匹配项：<code>:last``:nth-child()``document.querySelector()</code></p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="o">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s1">'.home &gt; .red'</span><span class="p">);</span>
</pre></div>

<p>或者<code>document.querySelectorAll()</code>与索引器一起使用来选择任何特定的匹配项：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">redElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">document</span><span class="o">.</span><span class="n">querySelectorAll</span><span class="p">(</span><span class="s1">'.home &gt; .red'</span><span class="p">);</span>
<span class="k">var</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">redElements</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">var</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">redElements</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="o">//</span><span class="w"> </span><span class="n">etc</span>
</pre></div>

<hr>
<p>尽管Philip Daubmeier<code>.red:nth-of-
type(1)</code>最初接受的答案中的解决方案有效（最初由Martyn编写但后来被删除），但它的行为并不像您期望的那样。</p>
<p>例如，如果您只想选择<code>p</code>此处：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;&lt;/p&gt;</span>
<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;&lt;/div&gt;</span>
</pre></div>

<p>... 那么你不能使用<code>.red:first-of-type</code>(equivalent to <code>.red:nth-of-
type(1)</code>)，因为每个元素都是其类型中的第一个（也是唯一的）一个（<code>p</code>分别<code>div</code>），所以 <em>两者都</em> 将被选择器匹配。</p>
<p>当某个类的第一个元素 <em>也是其类型的第一个时</em> ，伪类就会起作用，但这 <strong>只是巧合</strong>
。菲利普的回答证明了这种行为。当您在此元素之前插入相同类型的元素时，选择器将失败。从问题中获取标记：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"home"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>blah<span class="nt">&lt;/span&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>应用规则 with<code>.red:first-of-type</code>将起作用，但是一旦您添加另一个<code>p</code>没有类的规则：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"home"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>blah<span class="nt">&lt;/span&gt;</span>
<span class="w">  </span><span class="nt">&lt;p&gt;</span>dummy<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>...选择器将立即失败，因为第一个<code>.red</code>元素现在是 <em>第二个</em> <code>p</code>元素。</p>
<p><br></p>
<h3>更多建议</h3>
<p><code>:first-child</code>顾名思义，选择器旨在选择父标签的第一个子标签。所以这个例子会起作用（只是在这里试过）：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;body&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></div>

<p>但是，如果您将标签嵌套在不同的父标签下，或者如果您的类标签<code>red</code>不是父标签下的第一个标签，这将不起作用。</p>
<p>还要注意，这不仅适用于整个文档中的第一个这样的标签，而且每次都有一个新的父级包裹在它周围，例如：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;div&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;div&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p><code>first</code>然后<code>third</code>会变红。</p>
<p>对于您的情况，您可以使用<code>:nth-of-type</code>选择器：</p>
<div class="code"><pre class="code literal-block">.red:nth-of-type(1)
{
<span class="w">    </span>border:5px<span class="w"> </span>solid<span class="w"> </span>red;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"home"</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;span&gt;</span>blah<span class="nt">&lt;/span&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>first<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>second<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>third<span class="nt">&lt;/p&gt;</span>
<span class="w">    </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">class=</span><span class="s">"red"</span><span class="nt">&gt;</span>fourth<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>感谢Martyn，他删除了包含这种方法的答案。</p>
<p><code>:nth-child()</code>有关和的更多信息<code>:nth-of-
type()</code>，请访问http://www.quirksmode.org/css/nthchild.html。</p>
<p>请注意，这是一个 CSS3 选择器，因此一些现在过时的浏览器版本可能无法按预期运行（例如 IE8
或更早版本）。访问https://caniuse.com/?search=nth-of-type了解更多详情。</p>
<p><br><br><a href="../css-selector-for-first-element-with-class/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/css/" rel="tag">css</a></li>
            <li><a class="tag p-category" href="../../categories/css-selectors/" rel="tag">css-selectors</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../shi-yong-grepjin-xing-fu-pi-pei-pi-pei-bu-bao-han-foode-xing/" rel="prev" title="使用grep进行负匹配（匹配不包含foo的行）">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-shi-yong-nvm-she-zhi-mo-ren-jie-dian-ban-ben/" rel="next" title="如何使用 NVM 设置默认节点版本？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
