<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么是复制和交换成语？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-fu-zhi-he-jiao-huan-cheng-yu/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../postgresql-zai-postgresql-zhong-xian-shi-biao/" title="PostgreSQL：在 PostgreSQL 中显示表" type="text/html">
<link rel="next" href="../ru-he-jian-cha-dui-xiang-shi-fou-ju-you-shu-xing/" title="如何检查对象是否具有属性？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么是复制和交换成语？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-fu-zhi-he-jiao-huan-cheng-yu/">
<meta property="og:description" content="什么是复制和交换习语，什么时候应该使用它？它解决了什么问题？C++11 会改变吗？
有关的：

您最喜欢的 C++ 编码风格习语是什么：复制交换
C++ 中的复制构造函数和 = 运算符重载：是否可以使用通用函数？
什么是复制省略以及它如何优化复制和交换习语
C++：动态分配对象数组？


解答
概述
为什么我们需要复制和交换习语？
任何管理资源（ 包装器
，如智能指针）的类都需要实现三巨头。虽然复">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T21:49:33+08:00">
<meta property="article:tag" content="assignment-operator">
<meta property="article:tag" content="copy-and-swap">
<meta property="article:tag" content="copy-constructor">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="cPlusPlus-faq">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么是复制和交换成语？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T21:49:33+08:00" itemprop="datePublished" title="2023-02-16 21:49">2023-02-16 21:49</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>什么是复制和交换习语，什么时候应该使用它？它解决了什么问题？C++11 会改变吗？</p>
<p>有关的：</p>
<ul>
<li>您最喜欢的 C++ 编码风格习语是什么：复制交换</li>
<li>C++ 中的复制构造函数和 = 运算符重载：是否可以使用通用函数？</li>
<li>什么是复制省略以及它如何优化复制和交换习语</li>
<li>C++：动态分配对象数组？</li>
</ul>
<p><br><br></p>
<h2>解答</h2>
<h2>概述</h2>
<h4>为什么我们需要复制和交换习语？</h4>
<p>任何管理资源（ <em>包装器</em>
，如智能指针）的类都需要实现三巨头。虽然复制构造函数和析构函数的目标和实现很简单，但复制赋值运算符可以说是最微妙和最困难的。应该怎么做？需要避免哪些陷阱？</p>
<p>复制 <em>和交换习惯用法</em> 是解决方案，它优雅地帮助赋值运算符实现两件事：避免代码重复，并提供强大的异常保证。</p>
<h4>它是如何工作的？</h4>
<p>从概念上讲，它通过使用复制构造函数的功能来创建数据的本地副本，然后使用函数获取复制的数据<code>swap</code>，将旧数据与新数据交换。临时副本然后破坏，带走旧数据。我们留下了新数据的副本。</p>
<p>为了使用复制和交换习惯用法，我们需要三样东西：一个有效的复制构造函数，一个有效的析构函数（两者都是任何包装器的基础，所以无论如何都应该是完整的）和一个函数<code>swap</code>。</p>
<p>交换函数是一个 <em>非抛出</em>
函数，它交换一个类的两个对象，一个成员一个成员。我们可能会想使用<code>std::swap</code>而不是提供我们自己的，但这是不可能的；<code>std::swap</code>在其实现中使用复制构造函数和复制赋值运算符，我们最终将尝试根据自身来定义赋值运算符！</p>
<p>（不仅如此，对 的非限定调用<code>swap</code>将使用我们的自定义交换运算符，跳过我们类的不必要的构造和破坏<code>std::swap</code>。）</p>
<hr>
<h2>深入的解释</h2>
<h4>目标</h4>
<p>让我们考虑一个具体案例。我们想在一个无用的类中管理一个动态数组。我们从一个工作构造函数、复制构造函数和析构函数开始：</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">algorithm</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">cstddef</span><span class="o">&gt;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span>

<span class="k">class</span><span class="w"> </span><span class="n">dumb_array</span>
<span class="err">{</span>
<span class="k">public</span><span class="err">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="p">)</span><span class="w"> </span><span class="k">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="err">:</span><span class="w"> </span><span class="n">mSize</span><span class="p">(</span><span class="k">size</span><span class="p">),</span>
<span class="w">          </span><span class="n">mArray</span><span class="p">(</span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="p">()</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="o">-</span><span class="k">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="err">:</span><span class="w"> </span><span class="n">mSize</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mSize</span><span class="p">),</span>
<span class="w">          </span><span class="n">mArray</span><span class="p">(</span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">throwing</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">data</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">used</span><span class="p">;</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">attention</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">regards</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">exceptions</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="k">general</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">however</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mSize</span><span class="p">,</span><span class="w"> </span><span class="n">mArray</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">dumb_array</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="nl">private</span><span class="p">:</span>
<span class="w">    </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">size_t</span><span class="w"> </span><span class="n">mSize</span><span class="p">;</span>
<span class="w">    </span><span class="nc">int</span><span class="o">*</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span>
</pre></div>

<p>这个类几乎成功地管理了数组，但它需要<code>operator=</code>正常工作。</p>
<h4>一个失败的解决方案</h4>
<p>这是一个天真的实现可能看起来的样子：</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">hard</span><span class="w"> </span><span class="n">part</span>
<span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="k">get</span><span class="w"> </span><span class="n">rid</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">old</span><span class="w"> </span><span class="k">data</span><span class="p">...</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="n">mArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">see</span><span class="w"> </span><span class="n">footnote</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">rationale</span><span class="p">)</span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="p">...</span><span class="ow">and</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">new</span>
<span class="w">        </span><span class="n">mSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mSize</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="n">mArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mSize</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">int</span><span class="o">[</span><span class="n">mSize</span><span class="o">]</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">mArray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mSize</span><span class="p">,</span><span class="w"> </span><span class="n">mArray</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="err">}</span>
</pre></div>

<p>我们说我们完成了；这现在管理一个数组，没有泄漏。但是，它存在三个问题，在代码中依次标记为<code>(n)</code>.</p>
<ol>
<li>
<p>首先是自我分配测试。<br>
此检查有两个目的：它是防止我们在自赋值时运行不必要的代码的简单方法，它保护我们免受细微错误的影响（例如删除数组只是为了尝试复制它）。但在所有其他情况下，它只是用来减慢程序速度，并在代码中充当噪音；自赋值很少发生，所以大多数时候这种检查都是浪费。<br>
如果没有它，操作员也能正常工作，那就更好了。</p>
</li>
<li>
<p>二是它只提供基本的异常保证。如果<code>new int[mSize]</code>失败，<code>*this</code>将被修改。（也就是说，大小不对，数据消失了！）<br>
为了获得强大的异常保证，它需要类似于：</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
</pre></div>

<p>{
     if (this != &amp;other) // (1)
     {
         // get the new data ready before we replace the old
         std::size_t newSize = other.mSize;
         int* newArray = newSize ? new int<a href=".">newSize</a> : nullptr; // (3)
         std::copy(other.mArray, other.mArray + newSize, newArray); // (3)</p>
<div class="code"><pre class="code literal-block"><span class="w">     </span><span class="c1">// replace the old data (all are non-throwing)</span>
<span class="w">     </span><span class="nb">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">mArray</span><span class="p">;</span>
<span class="w">     </span><span class="n">mSize</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">newSize</span><span class="p">;</span>
<span class="w">     </span><span class="n">mArray</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">newArray</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
</pre></div>

<p>}</p>
</li>
<li>
<p>代码扩展了！这就引出了第三个问题：代码重复。</p>
</li>
</ol>
<p>我们的赋值运算符有效地复制了我们已经在其他地方编写的所有代码，这是一件很糟糕的事情。</p>
<p>在我们的例子中，它的核心只有两行（分配和复制），但是对于更复杂的资源，这个代码膨胀可能会很麻烦。我们应该努力不重复自己。</p>
<p>（有人可能想知道：如果正确管理一个资源需要这么多代码，如果我的类管理多个资源怎么办？虽然<br>
这似乎是一个有效的问题，而且确实需要不平凡的<code>try</code>/<code>catch</code>子句，但这是一个非-问题。<br>
那是因为一个类应该 <em>只管理一个资源</em> ！）</p>
<h4>一个成功的解决方案</h4>
<p>如前所述，复制和交换习惯用法将解决所有这些问题。但是现在，我们拥有所有要求，除了一个：函数<code>swap</code>。虽然三原则成功地包含了我们的复制构造函数、赋值运算符和析构函数的存在，但它实际上应该被称为“三大半”：任何时候你的类管理一个资源，提供一个函数也是有意义<code>swap</code>的.</p>
<p>We need to add swap functionality to our class, and we do that as follows†:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">dumb_array</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>

<span class="w">    </span><span class="n">friend</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="n">dumb_array</span><span class="err">&amp;</span><span class="w"> </span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">dumb_array</span><span class="err">&amp;</span><span class="w"> </span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">nothrow</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="n">ADL</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">necessary</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">our</span><span class="w"> </span><span class="n">case</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">good</span><span class="w"> </span><span class="n">practice</span><span class="p">)</span>
<span class="w">        </span><span class="n">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">swapping</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">members</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">two</span><span class="w"> </span><span class="err">objects,</span>
<span class="w">        </span><span class="err">//</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">two</span><span class="w"> </span><span class="err">objects</span><span class="w"> </span><span class="err">are</span><span class="w"> </span><span class="err">effectively</span><span class="w"> </span><span class="err">swapped</span>
<span class="w">        </span><span class="err">swap(first.mSize,</span><span class="w"> </span><span class="err">second.mSize)</span><span class="p">;</span>
<span class="w">        </span><span class="err">swap(first.mArray,</span><span class="w"> </span><span class="err">second.mArray)</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>(Here is the explanation why <code>public friend swap</code>.) Now not only can we swap
our <code>dumb_array</code>'s, but swaps in general can be more efficient; it merely
swaps pointers and sizes, rather than allocating and copying entire arrays.
Aside from this bonus in functionality and efficiency, we are now ready to
implement the copy-and-swap idiom.</p>
<p>Without further ado, our assignment operator is:</p>
<div class="code"><pre class="code literal-block"><span class="nv">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="nv">operator</span><span class="o">=</span><span class="ss">(</span><span class="nv">dumb_array</span><span class="w"> </span><span class="nv">other</span><span class="ss">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span>
{
<span class="w">    </span><span class="nv">swap</span><span class="ss">(</span><span class="o">*</span><span class="nv">this</span>,<span class="w"> </span><span class="nv">other</span><span class="ss">)</span><span class="c1">; // (2)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="nv">this</span><span class="c1">;</span>
}
</pre></div>

<p>And that's it! With one fell swoop, all three problems are elegantly tackled
at once.</p>
<h4>Why does it work?</h4>
<p>We first notice an important choice: the parameter argument is taken <em>by-
value</em>. While one could just as easily do the following (and indeed, many
naive implementations of the idiom do):</p>
<div class="code"><pre class="code literal-block"><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dumb_array</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="w"> </span><span class="n">temp</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>We lose an important optimization opportunity. Not only that, but this choice
is critical in C++11, which is discussed later. (On a general note, a
remarkably useful guideline is as follows: if you're going to make a copy of
something in a function, let the compiler do it in the parameter list.‡)</p>
<p>Either way, this method of obtaining our resource is the key to eliminating
code duplication: we get to use the code from the copy-constructor to make the
copy, and never need to repeat any bit of it. Now that the copy is made, we
are ready to swap.</p>
<p>Observe that upon entering the function that all the new data is already
allocated, copied, and ready to be used. This is what gives us a strong
exception guarantee for free: we won't even enter the function if construction
of the copy fails, and it's therefore not possible to alter the state of
<code>*this</code>. (What we did manually before for a strong exception guarantee, the
compiler is doing for us now; how kind.)</p>
<p>At this point we are home-free, because <code>swap</code> is non-throwing. We swap our
current data with the copied data, safely altering our state, and the old data
gets put into the temporary. The old data is then released when the function
returns. (Where upon the parameter's scope ends and its destructor is called.)</p>
<p>Because the idiom repeats no code, we cannot introduce bugs within the
operator. Note that this means we are rid of the need for a self-assignment
check, allowing a single uniform implementation of <code>operator=</code>. (Additionally,
we no longer have a performance penalty on non-self-assignments.)</p>
<p>And that is the copy-and-swap idiom.</p>
<h3>What about C++11?</h3>
<p>The next version of C++, C++11, makes one very important change to how we
manage resources: the Rule of Three is now <strong>The Rule of Four</strong> (and a half).
Why? Because not only do we need to be able to copy-construct our resource, we
need to move-construct it as well.</p>
<p>Luckily for us, this is easy:</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">dumb_array</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">constructor</span>
<span class="w">    </span><span class="n">dumb_array</span><span class="p">(</span><span class="n">dumb_array</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="n">noexcept</span><span class="w"> </span><span class="err">††</span>
<span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="n">dumb_array</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">initialize</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="n">constructor</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="mi">11</span><span class="w"> </span><span class="n">only</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="p">};</span>
</pre></div>

<p>What's going on here? Recall the goal of move-construction: to take the
resources from another instance of the class, leaving it in a state guaranteed
to be assignable and destructible.</p>
<p>So what we've done is simple: initialize via the default constructor (a C++11
feature), then swap with <code>other</code>; we know a default constructed instance of
our class can safely be assigned and destructed, so we know <code>other</code> will be
able to do the same, after swapping.</p>
<p>(Note that some compilers do not support constructor delegation; in this case,
we have to manually default construct the class. This is an unfortunate but
luckily trivial task.)</p>
<h4>Why does that work?</h4>
<p>That is the only change we need to make to our class, so why does it work?
Remember the ever-important decision we made to make the parameter a value and
not a reference:</p>
<div class="code"><pre class="code literal-block">dumb_array&amp; operator=(dumb_array other); // (1)
</pre></div>

<p>Now, if <code>other</code> is being initialized with an rvalue, <em>it will be move-
constructed</em>. Perfect. In the same way C++03 let us re-use our copy-
constructor functionality by taking the argument by-value, C++11 will
<em>automatically</em> pick the move-constructor when appropriate as well. (And, of
course, as mentioned in previously linked article, the copying/moving of the
value may simply be elided altogether.)</p>
<p>And so concludes the copy-and-swap idiom.</p>
<hr>
<h4>Footnotes</h4>
<p>*Why do we set <code>mArray</code> to null? Because if any further code in the operator throws, the destructor of <code>dumb_array</code> might be called; and if that happens without setting it to null, we attempt to delete memory that's already been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</p>
<p>†There are other claims that we should specialize <code>std::swap</code> for our type,
provide an in-class <code>swap</code> along-side a free-function <code>swap</code>, etc. But this is
all unnecessary: any proper use of <code>swap</code> will be through an unqualified call,
and our function will be found through ADL. One function will do.</p>
<p>‡The reason is simple: once you have the resource to yourself, you may swap
and/or move it (C++11) anywhere it needs to be. And by making the copy in the
parameter list, you maximize optimization.</p>
<p>††The move constructor should generally be <code>noexcept</code>, otherwise some code
(e.g. <code>std::vector</code> resizing logic) will use the copy constructor even when a
move would make sense. Of course, only mark it noexcept if the code inside
doesn't throw exceptions.</p>
<p><br></p>
<h3>更多建议</h3>
<p>赋值的核心是两个步骤： <strong> <em>拆除对象的旧状态</em></strong> ，并将其新状态构建为其他对象状态的 <strong> <em>副本。</em></strong></p>
<p>基本上，这就是 <strong> <em>析构函数</em></strong> 和 <strong> <em>复制构造函数</em></strong>
所做的，所以第一个想法是将工作委托给它们。然而，由于破坏一定不能失败，而构造可能会失败， <em>我们实际上想以相反的方式进行</em> ： <strong>
<em>首先执行建设性部分</em></strong> ，如果成功， <strong> <em>然后进行破坏性部分</em></strong> 。copy-and-swap
惯用语就是实现这一点的一种方法：它首先调用类的复制构造函数来创建一个临时对象，然后将其数据与临时对象交换，然后让临时对象的析构函数销毁旧状态。<br>
自从<code>swap()</code>应该永远不会失败，唯一可能失败的部分是复制构造。该操作首先执行，如果失败，则目标对象中不会发生任何更改。</p>
<p>在其改进的形式中，复制和交换是通过初始化赋值运算符的（非引用）参数来执行复制来实现的：</p>
<div class="code"><pre class="code literal-block"><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p><br><br><a href="../what-is-the-copy-and-swap-idiom/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/assignment-operator/" rel="tag">assignment-operator</a></li>
            <li><a class="tag p-category" href="../../categories/copy-and-swap/" rel="tag">copy-and-swap</a></li>
            <li><a class="tag p-category" href="../../categories/copy-constructor/" rel="tag">copy-constructor</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus-faq/" rel="tag">cPlusPlus-faq</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../postgresql-zai-postgresql-zhong-xian-shi-biao/" rel="prev" title="PostgreSQL：在 PostgreSQL 中显示表">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-jian-cha-dui-xiang-shi-fou-ju-you-shu-xing/" rel="next" title="如何检查对象是否具有属性？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
