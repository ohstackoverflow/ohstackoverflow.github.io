<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么是移动语义？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-yi-dong-yu-yi/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../angularjs-zhong-de-shu-ju-bang-ding-shi-ru-he-gong-zuo-de/" title="AngularJS 中的数据绑定是如何工作的？" type="text/html">
<link rel="next" href="../ru-he-yong-ling-tian-chong-zi-fu-chuan/" title="如何用零填充字符串？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么是移动语义？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-yi-dong-yu-yi/">
<meta property="og:description" content="我刚听完Scott Meyers关于C++0x的软件工程广播播客采访。大多数新功能对我来说都很有意义，我现在对 C++0x
感到非常兴奋，除了一个。我仍然不明白 移动语义......它到底是什么？

解答
我发现使用示例代码最容易理解移动语义。让我们从一个非常简单的字符串类开始，它只包含一个指向堆分配内存块的指针：
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T23:04:20+08:00">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="cPlusPlus11">
<meta property="article:tag" content="cPlusPlus-faq">
<meta property="article:tag" content="move-semantics">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么是移动语义？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T23:04:20+08:00" itemprop="datePublished" title="2023-02-16 23:04">2023-02-16 23:04</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我刚听完Scott Meyers关于C++0x的软件工程广播播客采访。大多数新功能对我来说都很有意义，我现在对 C++0x
感到非常兴奋，除了一个。我仍然不明白 <em>移动语义</em>......它到底是什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>我发现使用示例代码最容易理解移动语义。让我们从一个非常简单的字符串类开始，它只包含一个指向堆分配内存块的指针：</p>
<div class="code"><pre class="code literal-block"><span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">cstring</span><span class="o">&gt;</span>
<span class="n">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">algorithm</span><span class="o">&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="n">string</span>
<span class="err">{</span>
<span class="w">    </span><span class="nc">char</span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="p">;</span>

<span class="k">public</span><span class="err">:</span>

<span class="w">    </span><span class="n">string</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="nc">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">char</span><span class="o">[</span><span class="n">size</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">memcpy</span><span class="p">(</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">size</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
</pre></div>

<p>既然选择了自己管理内存，那么就需要遵循三法则。我打算推迟编写赋值运算符，现在只实现析构函数和复制构造函数：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">~</span><span class="n">string</span><span class="p">()</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="k">delete</span><span class="err">[]</span><span class="w"> </span><span class="k">data</span><span class="p">;</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="n">string</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">that</span><span class="p">)</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">size_t</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="k">data</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">char</span><span class="o">[</span><span class="n">size</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="nl">std</span><span class="p">:</span><span class="err">:</span><span class="n">memcpy</span><span class="p">(</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="k">size</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
</pre></div>

<p>复制构造函数定义复制字符串对象的含义。该参数<code>const string&amp; that</code>绑定到所有字符串类型的表达式，允许您在以下示例中进行复制：</p>
<div class="code"><pre class="code literal-block">string a(x);                                    // Line 1
string b(x + y);                                // Line 2
string c(some_function_returning_a_string());   // Line 3
</pre></div>

<p>现在是对移动语义的关键洞察。请注意，只有在我们复制的第一行才<code>x</code>真正需要这个深拷贝，因为我们可能想稍后检查，如果以某种方式发生了变化，<code>x</code>我们会感到非常惊讶。<code>x</code>您是否注意到我只是说了<code>x</code>三遍（如果包括这句话，则说了四遍）并且每次都指的是
<em>完全相同的对象？</em> 我们称这样的表达式为<code>x</code>“左值”。</p>
<p>第 2 行和第 3
行中的参数不是左值，而是右值，因为底层字符串对象没有名称，因此客户端无法在稍后的某个时间点再次检查它们。右值表示在下一个分号处销毁的临时对象（更准确地说：在词汇上包含右值的完整表达式的末尾）。<code>b</code>这很重要，因为在and的初始化期间<code>c</code>，我们可以对源字符串做任何我们想做的事情，而
<em>客户端无法区分</em> ！</p>
<p>C++0x
引入了一种称为“右值引用”的新机制，除其他外，它允许我们通过函数重载检测右值参数。我们所要做的就是编写一个带有右值引用参数的构造函数。在该构造函数中，我们可以对源做
<em>任何我们想做的事情</em> ，只要我们让它处于 <em>某种</em> 有效状态：</p>
<div class="code"><pre class="code literal-block">    string(string&amp;&amp; that)   // string&amp;&amp; is an rvalue reference to a string
    {
        data = that.data;
        that.data = nullptr;
    }
</pre></div>

<p>我们在这里做了什么？我们没有深度复制堆数据，而是复制了指针，然后将原始指针设置为
null（以防止源对象的析构函数中的“delete[]”释放我们的“刚刚被盗的数据”）。实际上，我们已经“窃取”了原本属于源字符串的数据。同样，关键的见解是，在任何情况下，客户端都无法检测到源已被修改。由于我们实际上并没有在这里进行复制，因此我们将此构造函数称为“移动构造函数”。它的工作是将资源从一个对象移动到另一个对象而不是复制它们。</p>
<p>恭喜，您现在了解移动语义的基础知识！让我们继续实现赋值运算符。如果您不熟悉copy and swap
idiom，学习它并回来，因为它是一个与异常安全相关的很棒的 C++ idiom。</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nt">string</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">operator</span><span class="o">=(</span><span class="nt">string</span><span class="w"> </span><span class="nt">that</span><span class="o">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">that</span><span class="err">.</span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">*this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>咦，就这？“右值引用在哪里？” 你可能会问。“我们这里不需要！” 是我的答案:)</p>
<p><code>that</code> <em>请注意，我们通过值</em>
传递参数，因此<code>that</code>必须像任何其他字符串对象一样进行初始化。究竟要如何<code>that</code>初始化？在过去的C++98时代，答案是“通过复制构造函数”。在
C++0x 中，编译器根据赋值运算符的参数是左值还是右值，在复制构造函数和移动构造函数之间进行选择。</p>
<p>所以如果你说<code>a = b</code>， <em>复制构造函数</em>
将初始化<code>that</code>（因为表达式<code>b</code>是一个左值），并且赋值运算符将内容与新创建的深层副本交换。这就是复制和交换习语的定义——制作一个副本，用副本交换内容，然后通过离开作用域来摆脱副本。这里没有什么新鲜事。</p>
<p>但是如果你说<code>a = x + y</code>， <em>移动构造函数</em> 将初始化<code>that</code>（因为表达式<code>x +
y</code>是一个右值），所以不涉及深度复制，只有一个高效的移动。<code>that</code>仍然是一个独立于参数的对象，但它的构造很简单，因为不必复制堆数据，只需移动即可。没有必要复制它，因为它<code>x
+ y</code>是一个右值，同样，可以从右值表示的字符串对象中移动。</p>
<p>总而言之，复制构造函数进行深复制，因为源必须保持不变。另一方面，移动构造函数可以只复制指针，然后将源中的指针设置为空。以这种方式“使”源对象“无效”是可以的，因为客户端无法再次检查该对象。</p>
<p>我希望这个例子能说明要点。右值引用和移动语义还有很多内容，我有意省略以保持简单。如果您想了解更多详细信息，请参阅我的补充答案。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我的第一个答案是对移动语义的极其简化的介绍，为了简单起见，故意省略了许多细节。但是，移动语义还有很多，我认为是时候给出第二个答案来填补空白了。第一个答案已经很老了，简单地用完全不同的文本替换它感觉不对。我认为它仍然可以很好地作为第一个介绍。但如果你想深入挖掘，请继续阅读
:)</p>
<p>Stephan T. Lavavej 花时间提供了宝贵的反馈。非常感谢，斯蒂芬！</p>
<h3>介绍</h3>
<p>移动语义允许对象在特定条件下取得其他对象外部资源的所有权。这在两个方面很重要：</p>
<ol>
<li>
<p>将昂贵的副本变成廉价的动作。有关示例，请参见我的第一个答案。请注意，如果对象不管理至少一个外部资源（直接或间接通过其成员对象），移动语义将不会提供任何优于复制语义的优势。在这种情况下，复制一个对象和移动一个对象意味着完全相同的事情：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">cannot_benefit_from_move_semantics</span>
</pre></div>

<p>{
    int a;        // moving an int means copying an int
    float b;      // moving a float means copying a float
    double c;     // moving a double means copying a double
    char d[64];   // moving a char array means copying a char array</p>
<div class="code"><pre class="code literal-block"><span class="c1">// ...</span>
</pre></div>

<p>};</p>
</li>
<li>
<p>实施安全的“仅移动”类型；也就是说，复制没有意义但移动有意义的类型。示例包括锁、文件句柄和具有唯一所有权语义的智能指针。注意：此答案讨论了一个已弃用的 C++98 标准库模板，在 C++11 中<code>std::auto_ptr</code>已被替换。<code>std::unique_ptr</code>中级 C++ 程序员可能至少有点熟悉<code>std::auto_ptr</code>，并且由于它显示的“移动语义”，它似乎是讨论 C++11 中的移动语义的良好起点。YMMV。</p>
</li>
</ol>
<h3>什么是举动？</h3>
<p>C++98 标准库提供了一个具有独特所有权语义的智能指针，称为<code>std::auto_ptr&lt;T&gt;</code>.
如果您不熟悉<code>auto_ptr</code>，它的目的是保证动态分配的对象始终被释放，即使在遇到异常时也是如此：</p>
<div class="code"><pre class="code literal-block"><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">arbitrary</span><span class="w"> </span><span class="err">code,</span><span class="w"> </span><span class="err">could</span><span class="w"> </span><span class="err">throw</span><span class="w"> </span><span class="err">exceptions</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span>
<span class="p">}</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="o">&lt;</span><span class="nt">---</span><span class="w"> </span><span class="nt">when</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">goes</span><span class="w"> </span><span class="nt">out</span><span class="w"> </span><span class="nt">of</span><span class="w"> </span><span class="nt">scope</span><span class="o">,</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">triangle</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">deleted</span><span class="w"> </span><span class="nt">automatically</span>
</pre></div>

<p>不寻常的<code>auto_ptr</code>是它的“复制”行为：</p>
<div class="code"><pre class="code literal-block"><span class="c">auto_ptr</span><span class="nv">&lt;</span><span class="c">Shape</span><span class="nv">&gt;</span><span class="c"> a(new Triangle);</span>

<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">      | triangle data |</span>
<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">        ^</span>
<span class="c">        |</span>
<span class="c">        |</span>
<span class="c">        |</span>
<span class="c">  </span><span class="nb">+-----</span><span class="c">|</span><span class="nb">---+</span>
<span class="c">  |   </span><span class="nb">+-</span><span class="c">|</span><span class="nb">-+</span><span class="c"> |</span>
<span class="c">a | p | | | |</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |</span>
<span class="c">  </span><span class="nb">+---------+</span>

<span class="c">auto_ptr</span><span class="nv">&lt;</span><span class="c">Shape</span><span class="nv">&gt;</span><span class="c"> b(a);</span>

<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">      | triangle data |</span>
<span class="c">      </span><span class="nb">+---------------+</span>
<span class="c">        ^</span>
<span class="c">        |</span>
<span class="c">        </span><span class="nb">+----------------------+</span>
<span class="c">                               |</span>
<span class="c">  </span><span class="nb">+---------+</span><span class="c">            </span><span class="nb">+-----</span><span class="c">|</span><span class="nb">---+</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |            |   </span><span class="nb">+-</span><span class="c">|</span><span class="nb">-+</span><span class="c"> |</span>
<span class="c">a | p |   | |          b | p | | | |</span>
<span class="c">  |   </span><span class="nb">+---+</span><span class="c"> |            |   </span><span class="nb">+---+</span><span class="c"> |</span>
<span class="c">  </span><span class="nb">+---------+</span><span class="c">            </span><span class="nb">+---------+</span>
</pre></div>

<p><code>b</code>请注意with的初始化如何<code>a</code>不 <em>复制</em> 三角形，而是将三角形的所有权从转移<code>a</code>到<code>b</code>。我们也说“<code>a</code>移入”或 <em>“</em> 三角形 <em>移</em> 自”
<em>。</em> 这听起来可能令人困惑，因为三角形本身始终位于内存中的同一位置。<code>b</code> <strong><code>a</code> </strong><code>b</code></p>
<blockquote>
<p>移动对象意味着将其管理的某些资源的所有权转移给另一个对象。</p>
</blockquote>
<p>的复制构造函数<code>auto_ptr</code>可能看起来像这样（有点简化）：</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="p">(</span><span class="n">auto_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">missing</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">source</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">longer</span><span class="w"> </span><span class="n">owns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">object</span>
<span class="p">}</span>
</pre></div>

<h3>危险而无害的动作</h3>
<p>危险的<code>auto_ptr</code>是，语法上看起来像副本的东西实际上是一个动作。尝试在移出对象上调用成员函数<code>auto_ptr</code>将调用未定义的行为，因此您必须非常小心，不要<code>auto_ptr</code>在移出后使用
an：</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span><span class="w">   </span><span class="c1">// create triangle</span>
<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">              </span><span class="c1">// move a into b</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span><span class="w">           </span><span class="c1">// undefined behavior</span>
</pre></div>

<p>但<code>auto_ptr</code>并不 <em>总是</em> 危险的。工厂函数是一个非常好的用例<code>auto_ptr</code>：</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">make_triangle</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">Triangle</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">make_triangle</span><span class="p">());</span><span class="w">      </span><span class="c1">// move temporary into c</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_triangle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span><span class="w">   </span><span class="c1">// perfectly safe</span>
</pre></div>

<p>请注意这两个示例如何遵循相同的句法模式：</p>
<div class="code"><pre class="code literal-block"><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="n">variable</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
<span class="n">double</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expression</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>
</pre></div>

<p>然而，其中一个会调用未定义的行为，而另一个则不会。那么表达式<code>a</code>和之间有什么区别呢<code>make_triangle()</code>？两者不是同一类型吗？确实是，只是
<em>价值范畴</em> 不同而已。</p>
<h3>值类别</h3>
<p><code>a</code>显然，表示变量的表达式与表示调用按值返回函数的<code>auto_ptr</code>表达式之间一定存在一些深刻的区别，因此每次调用时都会创建一个新的临时对象。
<em>是左值</em> 的例子，而是 <em>右值</em> 的例子。<code>make_triangle()``auto_ptr``auto_ptr``a</code>
<strong><code>make_triangle()</code> </strong></p>
<p>从左值如 移动<code>a</code>是危险的，因为我们稍后可以尝试通过 调用成员函数<code>a</code>，调用未定义的行为。另一方面，从右值如
移动<code>make_triangle()</code>是完全安全的，因为在复制构造函数完成其工作后，我们不能再次使用临时值。没有表示临时的表达；如果我们简单地再写<code>make_triangle()</code>一次，我们会得到一个
<em>不同的</em> 临时文件。事实上，移出的临时文件已经在下一行消失了：</p>
<div class="code"><pre class="code literal-block">auto_ptr&lt;Shape&gt; c(make_triangle());
                                  ^ the moved-from temporary dies right here
</pre></div>

<p>请注意，字母<code>l</code>和<code>r</code>在作业的左侧和右侧具有历史渊源。这在 C++
中不再适用，因为有些左值不能出现在赋值的左侧（如数组或没有赋值运算符的用户定义类型），并且有些右值可以（类类型的所有右值）与赋值运算符）。</p>
<blockquote>
<p>类类型的右值是一个表达式，其计算创建一个临时对象。在正常情况下，同一范围内的其他表达式不会表示同一临时对象。</p>
</blockquote>
<h3>右值引用</h3>
<p>我们现在明白从左值转移是有潜在危险的，但是从右值转移是无害的。如果 C++ 有语言支持来区分左值参数和右值参数，我们可以完全禁止从左值移动，或者至少在调用点
<em>明确地</em> 从左值移动，这样我们就不会再意外移动了。</p>
<p>C++11 对这个问题的回答是 <em>右值引用</em> 。右值引用是一种仅绑定到右值的新型引用，语法为<code>X&amp;&amp;</code>. 旧的引用<code>X&amp;</code>现在被称为 <em>左值引用</em>
。（请注意，这 <em>不是</em><code>X&amp;&amp;</code>对引用的引用；C++ 中没有这样的东西。） __</p>
<p>如果我们<code>const</code>加入混合，我们已经有四种不同的参考。<code>X</code>它们可以绑定到哪些类型的表达式？</p>
<div class="code"><pre class="code literal-block"><span class="w">            </span><span class="n">lvalue</span><span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">lvalue</span><span class="w">   </span><span class="n">rvalue</span><span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">rvalue</span>
<span class="o">---------------------------------------------------------</span><span class="w">              </span>
<span class="n">X</span><span class="o">&amp;</span><span class="w">          </span><span class="n">yes</span>
<span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="w">    </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span><span class="w">            </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span>
<span class="n">X</span><span class="o">&amp;&amp;</span><span class="w">                                 </span><span class="n">yes</span>
<span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="w">                           </span><span class="n">yes</span><span class="w">      </span><span class="n">yes</span>
</pre></div>

<p>在实践中，你可以忘记<code>const X&amp;&amp;</code>. 限制从右值读取不是很有用。</p>
<blockquote>
<p>右值引用<code>X&amp;&amp;</code>是一种仅绑定到右值的新型引用。</p>
</blockquote>
<h3>隐式转换</h3>
<p>右值引用经历了多个版本。从 2.1 版开始，右值引用<code>X&amp;&amp;</code>也绑定到不同类型的所有值类别，前提是存在从到
的<code>Y</code>隐式转换。在这种情况下，将创建一个临时类型，并将右值引用绑定到该临时类型：<code>Y``X``X</code></p>
<div class="code"><pre class="code literal-block"><span class="nt">void</span><span class="w"> </span><span class="nt">some_function</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">string</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">r</span><span class="o">);</span>

<span class="nt">some_function</span><span class="o">(</span><span class="s2">"hello world"</span><span class="o">);</span>
</pre></div>

<p>在上面的示例中，<code>"hello world"</code>是类型的左值<code>const char[12]</code>。由于存在从 到 的隐式转换<code>const
char[12]</code>，<code>const
char*</code>因此创建了<code>std::string</code>一个临时类型，并绑定到该临时类型。这是右值（表达式）和临时值（对象）之间的区别有点模糊的情况之一。<code>std::string``r</code></p>
<h3>移动构造函数</h3>
<p>带参数的函数的一个有用示例<code>X&amp;&amp;</code>是 <em>移动构造</em> <code>X::X(X&amp;&amp; source)</code>函数。其目的是将托管资源的所有权从源转移到当前对象。</p>
<p>在 C++11 中，<code>std::auto_ptr&lt;T&gt;</code>已替换为<code>std::unique_ptr&lt;T&gt;</code>which takes advantage of
rvalue references。我将开发和讨论<code>unique_ptr</code>. 首先，我们封装了一个原始指针并重载了运算符<code>-&gt;</code>and
<code>*</code>，所以我们的类感觉就像一个指针：</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="n">unique_ptr</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">operator</span><span class="o">-&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>

<p>构造函数获取对象的所有权，析构函数删除它：</p>
<div class="code"><pre class="code literal-block">    explicit unique_ptr(T* p = nullptr)
    {
        ptr = p;
    }

    ~unique_ptr()
    {
        delete ptr;
    }
</pre></div>

<p>现在是有趣的部分，移动构造函数：</p>
<div class="code"><pre class="code literal-block">    unique_ptr(unique_ptr&amp;&amp; source)   // note the rvalue reference
    {
        ptr = source.ptr;
        source.ptr = nullptr;
    }
</pre></div>

<p>此移动构造函数与复制构造函数完全相同<code>auto_ptr</code>，但它只能提供右值：</p>
<div class="code"><pre class="code literal-block">unique_ptr&lt;Shape&gt; a(new Triangle);
unique_ptr&lt;Shape&gt; b(a);                 // error
unique_ptr&lt;Shape&gt; c(make_triangle());   // okay
</pre></div>

<p>The second line fails to compile, because <code>a</code> is an lvalue, but the parameter
<code>unique_ptr&amp;&amp; source</code> can only be bound to rvalues. This is exactly what we
wanted; dangerous moves should never be implicit. The third line compiles just
fine, because <code>make_triangle()</code> is an rvalue. The move constructor will
transfer ownership from the temporary to <code>c</code>. Again, this is exactly what we
wanted.</p>
<blockquote>
<p>The move constructor transfers ownership of a managed resource into the
current object.</p>
</blockquote>
<h3>Move assignment operators</h3>
<p>The last missing piece is the move assignment operator. Its job is to release
the old resource and acquire the new resource from its argument:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="n">unique_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">   </span><span class="c1">// note the rvalue reference</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">source</span><span class="p">)</span><span class="w">    </span><span class="c1">// beware of self-assignment</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w">         </span><span class="c1">// release the old resource</span>

<span class="w">            </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span><span class="w">   </span><span class="c1">// acquire the new resource</span>
<span class="w">            </span><span class="n">source</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>Note how this implementation of the move assignment operator duplicates logic
of both the destructor and the move constructor. Are you familiar with the
copy-and-swap idiom? It can also be applied to move semantics as the move-and-
swap idiom:</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="nt">unique_ptr</span><span class="o">&amp;</span><span class="w"> </span><span class="nt">operator</span><span class="o">=(</span><span class="nt">unique_ptr</span><span class="w"> </span><span class="nt">source</span><span class="o">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">note</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">missing</span><span class="w"> </span><span class="nt">reference</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">swap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="err">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">*this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Now that <code>source</code> is a variable of type <code>unique_ptr</code>, it will be initialized
by the move constructor; that is, the argument will be moved into the
parameter. The argument is still required to be an rvalue, because the move
constructor itself has an rvalue reference parameter. When control flow
reaches the closing brace of <code>operator=</code>, <code>source</code> goes out of scope,
releasing the old resource automatically.</p>
<blockquote>
<p>The move assignment operator transfers ownership of a managed resource into
the current object, releasing the old resource. The move-and-swap idiom
simplifies the implementation.</p>
</blockquote>
<h3>Moving from lvalues</h3>
<p>Sometimes, we want to move from lvalues. That is, sometimes we want the
compiler to treat an lvalue as if it were an rvalue, so it can invoke the move
constructor, even though it could be potentially unsafe. For this purpose,
C++11 offers a standard library function template called <code>std::move</code> inside
the header <code>&lt;utility&gt;</code>. This name is a bit unfortunate, because <code>std::move</code>
simply casts an lvalue to an rvalue; it does <em>not</em> move anything by itself. It
merely <em>enables</em> moving. Maybe it should have been named <code>std::cast_to_rvalue</code>
or <code>std::enable_move</code>, but we are stuck with the name by now.</p>
<p>Here is how you explicitly move from an lvalue:</p>
<div class="code"><pre class="code literal-block"><span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">a</span><span class="o">(</span><span class="nt">new</span><span class="w"> </span><span class="nt">Triangle</span><span class="o">);</span>
<span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">b</span><span class="o">(</span><span class="nt">a</span><span class="o">);</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="nt">still</span><span class="w"> </span><span class="nt">an</span><span class="w"> </span><span class="nt">error</span>
<span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">c</span><span class="o">(</span><span class="nt">std</span><span class="p">::</span><span class="nd">move</span><span class="o">(</span><span class="nt">a</span><span class="o">));</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">okay</span>
</pre></div>

<p>Note that after the third line, <code>a</code> no longer owns a triangle. That's okay,
because by <em>explicitly</em> writing <code>std::move(a)</code>, we made our intentions clear:
"Dear constructor, do whatever you want with <code>a</code> in order to initialize <code>c</code>; I
don't care about <code>a</code> anymore. Feel free to have your way with <code>a</code>."</p>
<blockquote>
<p><code>std::move(some_lvalue)</code> casts an lvalue to an rvalue, thus enabling a
subsequent move.</p>
</blockquote>
<h3>Xvalues</h3>
<p>Note that even though <code>std::move(a)</code> is an rvalue, its evaluation does <em>not</em>
create a temporary object. This conundrum forced the committee to introduce a
third value category. Something that can be bound to an rvalue reference, even
though it is not an rvalue in the traditional sense, is called an <em>xvalue</em>
(eXpiring value). The traditional rvalues were renamed to <em>prvalues</em> (Pure
rvalues).</p>
<p>Both prvalues and xvalues are rvalues. Xvalues and lvalues are both <em>glvalues</em>
(Generalized lvalues). The relationships are easier to grasp with a diagram:</p>
<div class="code"><pre class="code literal-block">        expressions
          /     \
         /       \
        /         \
    glvalues   rvalues
      /  \       /  \
     /    \     /    \
    /      \   /      \
lvalues   xvalues   prvalues
</pre></div>

<p>Note that only xvalues are really new; the rest is just due to renaming and
grouping.</p>
<blockquote>
<p>C++98 rvalues are known as prvalues in C++11. Mentally replace all
occurrences of "rvalue" in the preceding paragraphs with "prvalue".</p>
</blockquote>
<h3>Moving out of functions</h3>
<p>So far, we have seen movement into local variables, and into function
parameters. But moving is also possible in the opposite direction. If a
function returns by value, some object at call site (probably a local variable
or a temporary, but could be any kind of object) is initialized with the
expression after the <code>return</code> statement as an argument to the move
constructor:</p>
<div class="code"><pre class="code literal-block"><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">make_triangle</span><span class="ss">()</span>
{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">new</span><span class="w"> </span><span class="nv">Triangle</span><span class="ss">)</span><span class="c1">;</span>
}<span class="w">          </span>\<span class="o">-----------------------------/</span>
<span class="w">                  </span><span class="o">|</span>
<span class="w">                  </span><span class="o">|</span><span class="w"> </span><span class="nv">temporary</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">moved</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">c</span>
<span class="w">                  </span><span class="o">|</span>
<span class="w">                  </span><span class="nv">v</span>
<span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">c</span><span class="ss">(</span><span class="nv">make_triangle</span><span class="ss">())</span><span class="c1">;</span>
</pre></div>

<p>Perhaps surprisingly, automatic objects (local variables that are not declared
as <code>static</code>) can also be <em>implicitly</em> moved out of functions:</p>
<div class="code"><pre class="code literal-block"><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nv">make_square</span><span class="ss">()</span>
{
<span class="w">    </span><span class="nv">unique_ptr</span><span class="o">&lt;</span><span class="nv">Shape</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">result</span><span class="ss">(</span><span class="nv">new</span><span class="w"> </span><span class="nv">Square</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">result</span><span class="c1">;   // note the missing std::move</span>
}
</pre></div>

<p>How come the move constructor accepts the lvalue <code>result</code> as an argument? The
scope of <code>result</code> is about to end, and it will be destroyed during stack
unwinding. Nobody could possibly complain afterward that <code>result</code> had changed
somehow; when control flow is back at the caller, <code>result</code> does not exist
anymore! For that reason, C++11 has a special rule that allows returning
automatic objects from functions without having to write <code>std::move</code>. In fact,
you should <em>never</em> use <code>std::move</code> to move automatic objects out of functions,
as this inhibits the "named return value optimization" (NRVO).</p>
<blockquote>
<p>Never use <code>std::move</code> to move automatic objects out of functions.</p>
</blockquote>
<p>Note that in both factory functions, the return type is a value, not an rvalue
reference. Rvalue references are still references, and as always, you should
never return a reference to an automatic object; the caller would end up with
a dangling reference if you tricked the compiler into accepting your code,
like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">unique_ptr</span><span class="o">&lt;</span><span class="nt">Shape</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="nt">flawed_attempt</span><span class="o">()</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">DO</span><span class="w"> </span><span class="nt">NOT</span><span class="w"> </span><span class="nt">DO</span><span class="w"> </span><span class="nt">THIS</span><span class="o">!</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">very_bad_idea(new</span><span class="w"> </span><span class="err">Square)</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">very_bad_idea</span><span class="p">);</span><span class="w">   </span><span class="err">//</span><span class="w"> </span><span class="err">WRONG!</span>
<span class="p">}</span>
</pre></div>

<blockquote>
<p>Never return automatic objects by rvalue reference. Moving is exclusively
performed by the move constructor, not by <code>std::move</code>, and not by merely
binding an rvalue to an rvalue reference.</p>
</blockquote>
<h3>Moving into members</h3>
<p>Sooner or later, you are going to write code like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Foo</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">member</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="nf">Foo</span><span class="p">(</span><span class="n">unique_ptr</span><span class="err">&lt;</span><span class="n">Shape</span><span class="err">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">parameter</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">error</span>
<span class="w">    </span><span class="err">{</span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>Basically, the compiler will complain that <code>parameter</code> is an lvalue. If you
look at its type, you see an rvalue reference, but an rvalue reference simply
means "a reference that is bound to an rvalue"; it does <em>not</em> mean that the
reference itself is an rvalue! Indeed, <code>parameter</code> is just an ordinary
variable with a name. You can use <code>parameter</code> as often as you like inside the
body of the constructor, and it always denotes the same object. Implicitly
moving from it would be dangerous, hence the language forbids it.</p>
<blockquote>
<p>A named rvalue reference is an lvalue, just like any other variable.</p>
</blockquote>
<p>The solution is to manually enable the move:</p>
<div class="code"><pre class="code literal-block"><span class="nt">class</span><span class="w"> </span><span class="nt">Foo</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">unique_ptr&lt;Shape&gt;</span><span class="w"> </span><span class="err">member</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>

<span class="w">    </span><span class="nf">Foo</span><span class="p">(</span><span class="n">unique_ptr</span><span class="err">&lt;</span><span class="n">Shape</span><span class="err">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">parameter</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="n">std</span><span class="err">::</span><span class="kc">move</span><span class="err">(</span><span class="n">parameter</span><span class="p">))</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kc">move</span>
<span class="w">    </span><span class="err">{</span><span class="p">}</span>
<span class="err">}</span><span class="o">;</span>
</pre></div>

<p>You could argue that <code>parameter</code> is not used anymore after the initialization
of <code>member</code>. Why is there no special rule to silently insert <code>std::move</code> just
as with return values? Probably because it would be too much burden on the
compiler implementors. For example, what if the constructor body was in
another translation unit? By contrast, the return value rule simply has to
check the symbol tables to determine whether or not the identifier after the
<code>return</code> keyword denotes an automatic object.</p>
<p>You can also pass the <code>parameter</code> by value. For move-only types like
<code>unique_ptr</code>, it seems there is no established idiom yet. Personally, I prefer
to pass by value, as it causes less clutter in the interface.</p>
<h3>Special member functions</h3>
<p>C++98 implicitly declares three special member functions on demand, that is,
when they are needed somewhere: the copy constructor, the copy assignment
operator, and the destructor.</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="p">::</span><span class="n">X</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">constructor</span>
<span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">operator</span>
<span class="n">X</span><span class="p">::</span><span class="o">~</span><span class="n">X</span><span class="p">();</span><span class="w">                     </span><span class="o">//</span><span class="w"> </span><span class="n">destructor</span>
</pre></div>

<p>Rvalue references went through several versions. Since version 3.0, C++11
declares two additional special member functions on demand: the move
constructor and the move assignment operator. Note that neither VC10 nor VC11
conforms to version 3.0 yet, so you will have to implement them yourself.</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="p">::</span><span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w">                   </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">constructor</span>
<span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">operator</span>
</pre></div>

<p>These two new special member functions are only implicitly declared if none of
the special member functions are declared manually. Also, if you declare your
own move constructor or move assignment operator, neither the copy constructor
nor the copy assignment operator will be declared implicitly.</p>
<p>What do these rules mean in practice?</p>
<blockquote>
<p>If you write a class without unmanaged resources, there is no need to
declare any of the five special member functions yourself, and you will get
correct copy semantics and move semantics for free. Otherwise, you will have
to implement the special member functions yourself. Of course, if your class
does not benefit from move semantics, there is no need to implement the
special move operations.</p>
</blockquote>
<p>Note that the copy assignment operator and the move assignment operator can be
fused into a single, unified assignment operator, taking its argument by
value:</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="o">&amp;</span><span class="w"> </span><span class="n">X</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w">    </span><span class="c1">// unified assignment operator</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="n">source</span><span class="p">);</span><span class="w">            </span><span class="c1">// see my first answer for an explanation</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>This way, the number of special member functions to implement drops from five
to four. There is a tradeoff between exception-safety and efficiency here, but
I am not an expert on this issue.</p>
<h3>Forwarding references (previously known as <em>Universal references</em> )</h3>
<p>Consider the following function template:</p>
<div class="code"><pre class="code literal-block">template&lt;typename T&gt;
void foo(T&amp;&amp;);
</pre></div>

<p>You might expect <code>T&amp;&amp;</code> to only bind to rvalues, because at first glance, it
looks like an rvalue reference. As it turns out though, <code>T&amp;&amp;</code> also binds to
lvalues:</p>
<div class="code"><pre class="code literal-block">foo(make_triangle());   // T is unique_ptr&lt;Shape&gt;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;&amp;
unique_ptr&lt;Shape&gt; a(new Triangle);
foo(a);                 // T is unique_ptr&lt;Shape&gt;&amp;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;
</pre></div>

<p>If the argument is an rvalue of type <code>X</code>, <code>T</code> is deduced to be <code>X</code>, hence
<code>T&amp;&amp;</code> means <code>X&amp;&amp;</code>. This is what anyone would expect. But if the argument is an
lvalue of type <code>X</code>, due to a special rule, <code>T</code> is deduced to be <code>X&amp;</code>, hence
<code>T&amp;&amp;</code> would mean something like <code>X&amp; &amp;&amp;</code>. But since C++ still has no notion of
references to references, the type <code>X&amp; &amp;&amp;</code> is <em>collapsed</em> into <code>X&amp;</code>. This may
sound confusing and useless at first, but reference collapsing is essential
for <em>perfect forwarding</em> (which will not be discussed here).</p>
<blockquote>
<p>T&amp;&amp; is not an rvalue reference, but a forwarding reference. It also binds to
lvalues, in which case <code>T</code> and <code>T&amp;&amp;</code> are both lvalue references.</p>
</blockquote>
<p>If you want to constrain a function template to rvalues, you can combine
SFINAE with type traits:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kr">void</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>

<h3>Implementation of move</h3>
<p>Now that you understand reference collapsing, here is how <code>std::move</code> is
implemented:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">T</span><span class="o">&gt;</span>
<span class="nt">typename</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">remove_reference</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">type</span><span class="o">&amp;&amp;</span>
<span class="nt">move</span><span class="o">(</span><span class="nt">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nt">t</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">static_cast&lt;typename</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>As you can see, <code>move</code> accepts any kind of parameter thanks to the forwarding
reference <code>T&amp;&amp;</code>, and it returns an rvalue reference. The
<code>std::remove_reference&lt;T&gt;::type</code> meta-function call is necessary because
otherwise, for lvalues of type <code>X</code>, the return type would be <code>X&amp; &amp;&amp;</code>, which
would collapse into <code>X&amp;</code>. Since <code>t</code> is always an lvalue (remember that a named
rvalue reference is an lvalue), but we want to bind <code>t</code> to an rvalue
reference, we have to explicitly cast <code>t</code> to the correct return type. The call
of a function that returns an rvalue reference is itself an xvalue. Now you
know where xvalues come from ;)</p>
<blockquote>
<p>The call of a function that returns an rvalue reference, such as
<code>std::move</code>, is an xvalue.</p>
</blockquote>
<p>Note that returning by rvalue reference is fine in this example, because <code>t</code>
does not denote an automatic object, but instead an object that was passed in
by the caller.</p>
<p><br><br><a href="../what-is-move-semantics/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus11/" rel="tag">cPlusPlus11</a></li>
            <li><a class="tag p-category" href="../../categories/cplusplus-faq/" rel="tag">cPlusPlus-faq</a></li>
            <li><a class="tag p-category" href="../../categories/move-semantics/" rel="tag">move-semantics</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../angularjs-zhong-de-shu-ju-bang-ding-shi-ru-he-gong-zuo-de/" rel="prev" title="AngularJS 中的数据绑定是如何工作的？">Previous post</a>
            </li>
            <li class="next">
                <a href="../ru-he-yong-ling-tian-chong-zi-fu-chuan/" rel="next" title="如何用零填充字符串？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
