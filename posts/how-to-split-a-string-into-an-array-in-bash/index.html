<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>How to split a string into an array in Bash? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/how-to-split-a-string-into-an-array-in-bash/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchronous-code-reference/" title="Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference" type="text/html">
<link rel="next" href="../how-to-initialize-hashset-values-by-construction/" title="How to initialize HashSet values by construction?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="How to split a string into an array in Bash?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/how-to-split-a-string-into-an-array-in-bash/">
<meta property="og:description" content="In a Bash script, I would like to split a line into pieces and store them in
an array.
For example, given the line:
Paris, France, Europe


I would like to have the resulting array to look like so:
ar">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T10:23:09+08:00">
<meta property="article:tag" content="arrays">
<meta property="article:tag" content="bash">
<meta property="article:tag" content="split">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">How to split a string into an array in Bash?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T10:23:09+08:00" itemprop="datePublished" title="2023-02-17 10:23">2023-02-17 10:23</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>In a Bash script, I would like to split a line into pieces and store them in
an array.</p>
<p>For example, given the line:</p>
<div class="code"><pre class="code literal-block">Paris, France, Europe
</pre></div>

<p>I would like to have the resulting array to look like so:</p>
<div class="code"><pre class="code literal-block">array[0] = Paris
array[1] = France
array[2] = Europe
</pre></div>

<p>A simple implementation is preferable; speed does not matter. How can I do it?</p>
<p><br><br></p>
<h2>Answer</h2>
<div class="code"><pre class="code literal-block">IFS=', ' read -r -a array &lt;&lt;&lt; "$string"
</pre></div>

<p>Note that the characters in <code>$IFS</code> are treated individually as separators so
that in this case fields may be separated by <em>either</em> a comma or a space
rather than the sequence of the two characters. Interestingly though, empty
fields aren't created when comma-space appears in the input because the space
is treated specially.</p>
<p>To access an individual element:</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="cp">}</span>"
</pre></div>

<p>To iterate over the elements:</p>
<div class="code"><pre class="code literal-block">for<span class="w"> </span>element<span class="w"> </span>in<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">@</span><span class="p">]</span><span class="cp">}</span>"
do
<span class="w">    </span>echo<span class="w"> </span>"<span class="nv">$element</span>"
done
</pre></div>

<p>To get both the index and the value:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="ss">"${!array[@]}"</span>
<span class="n">do</span>
<span class="w">    </span><span class="n">echo</span><span class="w"> </span><span class="ss">"$index ${array[index]}"</span>
<span class="n">done</span>
</pre></div>

<p>The last example is useful because Bash arrays are sparse. In other words, you
can delete an element or add an element and then the indices are not
contiguous.</p>
<div class="code"><pre class="code literal-block">unset "array[1]"
array[42]=Earth
</pre></div>

<p>To get the number of elements in an array:</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="c1">#array[@]</span><span class="cp">}</span>"
</pre></div>

<p>As mentioned above, arrays can be sparse so you shouldn't use the length to
get the last element. Here's how you can in Bash 4.2 and later:</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="cp">}</span>"
</pre></div>

<p>in any version of Bash (from somewhere after 2.05b):</p>
<div class="code"><pre class="code literal-block">echo<span class="w"> </span>"<span class="cp">${</span><span class="n">array</span><span class="p">[</span><span class="o">@</span><span class="p">]:</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="cp">}</span>"
</pre></div>

<p>Larger negative offsets select farther from the end of the array. Note the
space before the minus sign in the older form. It is required.</p>
<p><br></p>
<h3>Suggest</h3>
<p>All of the answers to this question are wrong in one way or another.</p>
<hr>
<p><strong><em>Wrong answer #1</em></strong></p>
<div class="code"><pre class="code literal-block">IFS=', ' read -r -a array &lt;&lt;&lt; "$string"
</pre></div>

<p><strong>1:</strong> This is a misuse of <code>$IFS</code>. The value of the <code>$IFS</code> variable is <strong>not</strong>
taken as a <em>single variable-length</em> string separator, rather it is taken as a
<em>set</em> of <em>single-character</em> string separators, where each field that <code>read</code>
splits off from the input line can be terminated by <em>any</em> character in the set
(comma <strong>or</strong> space, in this example).</p>
<p>Actually, for the real sticklers out there, the full meaning of <code>$IFS</code> is
slightly more involved. From the bash manual:</p>
<blockquote>
<p>The shell treats each character of <strong>IFS</strong> as a delimiter, and splits the
results of the other expansions into words using these characters as field
terminators. If <strong>IFS</strong> is unset, or its value is exactly <strong>&lt;
space&gt;<tab><newline></newline></tab></strong>, the default, then sequences of <strong>&lt; space&gt;</strong>, <strong>&lt;
tab&gt;</strong>, and <strong>&lt; newline&gt;</strong> at the beginning and end of the results of the
previous expansions are ignored, and any sequence of <strong>IFS</strong> characters not
at the beginning or end serves to delimit words. If <strong>IFS</strong> has a value
other than the default, then sequences of the whitespace characters <strong>&lt;
space&gt;</strong>, <strong>&lt; tab&gt;</strong>, and <strong>&lt; newline&gt;</strong> are ignored at the beginning and
end of the word, as long as the whitespace character is in the value of
<strong>IFS</strong> (an <strong>IFS</strong> whitespace character). Any character in <strong>IFS</strong> that is
not <strong>IFS</strong> whitespace, along with any adjacent <strong>IFS</strong> whitespace
characters, delimits a field. A sequence of <strong>IFS</strong> whitespace characters is
also treated as a delimiter. If the value of <strong>IFS</strong> is null, no word
splitting occurs.</p>
</blockquote>
<p>Basically, for non-default non-null values of <code>$IFS</code>, fields can be separated
with either (1) a sequence of one or more characters that are all from the set
of "IFS whitespace characters" (that is, whichever of <strong>&lt; space&gt;</strong>, <strong>&lt;
tab&gt;</strong>, and <strong>&lt; newline&gt;</strong> ("newline" meaning line feed (LF)) are present
anywhere in <code>$IFS</code>), or (2) any non-"IFS whitespace character" that's present
in <code>$IFS</code> along with whatever "IFS whitespace characters" surround it in the
input line.</p>
<p>For the OP, it's possible that the second separation mode I described in the
previous paragraph is exactly what he wants for his input string, but we can
be pretty confident that the first separation mode I described is not correct
at all. For example, what if his input string was <code>'Los Angeles, United
States, North America'</code>?</p>
<div class="code"><pre class="code literal-block">IFS=', ' read -ra a &lt;&lt;&lt;'Los Angeles, United States, North America'; declare -p a;
## declare -a a=([0]="Los" [1]="Angeles" [2]="United" [3]="States" [4]="North" [5]="America")
</pre></div>

<p><strong>2:</strong> Even if you were to use this solution with a single-character separator
(such as a comma by itself, that is, with no following space or other
baggage), if the value of the <code>$string</code> variable happens to contain any LFs,
then <code>read</code> will stop processing once it encounters the first LF. The <code>read</code>
builtin only processes one line per invocation. This is true even if you are
piping or redirecting input <em>only</em> to the <code>read</code> statement, as we are doing in
this example with the here-string mechanism, and thus unprocessed input is
guaranteed to be lost. The code that powers the <code>read</code> builtin has no
knowledge of the data flow within its containing command structure.</p>
<p>You could argue that this is unlikely to cause a problem, but still, it's a
subtle hazard that should be avoided if possible. It is caused by the fact
that the <code>read</code> builtin actually does two levels of input splitting: first
into lines, then into fields. Since the OP only wants one level of splitting,
this usage of the <code>read</code> builtin is not appropriate, and we should avoid it.</p>
<p><strong>3:</strong> A non-obvious potential issue with this solution is that <code>read</code> always
drops the trailing field if it is empty, although it preserves empty fields
otherwise. Here's a demo:</p>
<div class="code"><pre class="code literal-block">string=', , a, , b, c, , , '; IFS=', ' read -ra a &lt;&lt;&lt;"$string"; declare -p a;
## declare -a a=([0]="" [1]="" [2]="a" [3]="" [4]="b" [5]="c" [6]="" [7]="")
</pre></div>

<p>Maybe the OP wouldn't care about this, but it's still a limitation worth
knowing about. It reduces the robustness and generality of the solution.</p>
<p>This problem can be solved by appending a dummy trailing delimiter to the
input string just prior to feeding it to <code>read</code>, as I will demonstrate later.</p>
<hr>
<p><strong><em>Wrong answer #2</em></strong></p>
<div class="code"><pre class="code literal-block">string="1:2:3:4:5"
set<span class="w"> </span>-f<span class="w">                     </span>#<span class="w"> </span>avoid<span class="w"> </span>globbing<span class="w"> </span>(expansion<span class="w"> </span>of<span class="w"> </span>*).
array=(<span class="cp">${</span><span class="n">string</span><span class="o">//</span><span class="p">:</span><span class="o">/</span> <span class="cp">}</span>)
</pre></div>

<p>Similar idea:</p>
<div class="code"><pre class="code literal-block">t="one,two,three"
a=($(echo $t | tr ',' "\n"))
</pre></div>

<p>(Note: I added the missing parentheses around the command substitution which
the answerer seems to have omitted.)</p>
<p>Similar idea:</p>
<div class="code"><pre class="code literal-block">string="1,2,3,4"
array=(`echo $string | sed 's/,/\n/g'`)
</pre></div>

<p>These solutions leverage word splitting in an array assignment to split the
string into fields. Funnily enough, just like <code>read</code>, general word splitting
also uses the <code>$IFS</code> special variable, although in this case it is implied
that it is set to its default value of <strong>&lt; space&gt;<tab><newline></newline></tab></strong>, and
therefore any sequence of one or more IFS characters (which are all whitespace
characters now) is considered to be a field delimiter.</p>
<p>This solves the problem of two levels of splitting committed by <code>read</code>, since
word splitting by itself constitutes only one level of splitting. But just as
before, the problem here is that the individual fields in the input string can
already contain <code>$IFS</code> characters, and thus they would be improperly split
during the word splitting operation. This happens to not be the case for any
of the sample input strings provided by these answerers (how convenient...),
but of course that doesn't change the fact that any code base that used this
idiom would then run the risk of blowing up if this assumption were ever
violated at some point down the line. Once again, consider my counterexample
of <code>'Los Angeles, United States, North America'</code> (or <code>'Los Angeles:United
States:North America'</code>).</p>
<p>Also, word splitting is normally followed by filename expansion ( <em>aka</em>
pathname expansion <em>aka</em> globbing), which, if done, would potentially corrupt
words containing the characters <code>*</code>, <code>?</code>, or <code>[</code> followed by <code>]</code> (and, if
<code>extglob</code> is set, parenthesized fragments preceded by <code>?</code>, <code>*</code>, <code>+</code>, <code>@</code>, or
<code>!</code>) by matching them against file system objects and expanding the words
("globs") accordingly. The first of these three answerers has cleverly
undercut this problem by running <code>set -f</code> beforehand to disable globbing.
Technically this works (although you should probably add <code>set +f</code> afterward to
reenable globbing for subsequent code which may depend on it), but it's
undesirable to have to mess with global shell settings in order to hack a
basic string-to-array parsing operation in local code.</p>
<p>Another issue with this answer is that all empty fields will be lost. This may
or may not be a problem, depending on the application.</p>
<p>Note: If you're going to use this solution, it's better to use the
<code>${string//:/ }</code> "pattern substitution" form of parameter expansion, rather
than going to the trouble of invoking a command substitution (which forks the
shell), starting up a pipeline, and running an external executable (<code>tr</code> or
<code>sed</code>), since parameter expansion is purely a shell-internal operation. (Also,
for the <code>tr</code> and <code>sed</code> solutions, the input variable should be double-quoted
inside the command substitution; otherwise word splitting would take effect in
the <code>echo</code> command and potentially mess with the field values. Also, the
<code>$(...)</code> form of command substitution is preferable to the old <code>...</code> form
since it simplifies nesting of command substitutions and allows for better
syntax highlighting by text editors.)</p>
<hr>
<p><strong><em>Wrong answer #3</em></strong></p>
<div class="code"><pre class="code literal-block">str="a,<span class="w"> </span>b,<span class="w"> </span>c,<span class="w"> </span>d"<span class="w">  </span>#<span class="w"> </span>assuming<span class="w"> </span>there<span class="w"> </span>is<span class="w"> </span>a<span class="w"> </span>space<span class="w"> </span>after<span class="w"> </span>','<span class="w"> </span>as<span class="w"> </span>in<span class="w"> </span>Q
arr=(<span class="cp">${</span><span class="nb">str</span><span class="o">//</span><span class="p">,</span><span class="o">/</span><span class="cp">}</span>)<span class="w">  </span>#<span class="w"> </span>delete<span class="w"> </span>all<span class="w"> </span>occurrences<span class="w"> </span>of<span class="w"> </span>','
</pre></div>

<p>This answer is almost the same as <strong>#2</strong>. The difference is that the answerer
has made the assumption that the fields are delimited by two characters, one
of which being represented in the default <code>$IFS</code>, and the other not. He has
solved this rather specific case by removing the non-IFS-represented character
using a pattern substitution expansion and then using word splitting to split
the fields on the surviving IFS-represented delimiter character.</p>
<p>This is not a very generic solution. Furthermore, it can be argued that the
comma is really the "primary" delimiter character here, and that stripping it
and then depending on the space character for field splitting is simply wrong.
Once again, consider my counterexample: <code>'Los Angeles, United States, North
America'</code>.</p>
<p>Also, again, filename expansion could corrupt the expanded words, but this can
be prevented by temporarily disabling globbing for the assignment with <code>set
-f</code> and then <code>set +f</code>.</p>
<p>Also, again, all empty fields will be lost, which may or may not be a problem
depending on the application.</p>
<hr>
<p><strong><em>Wrong answer #4</em></strong></p>
<div class="code"><pre class="code literal-block">string='first<span class="w"> </span>line
second<span class="w"> </span>line
third<span class="w"> </span>line'

oldIFS="<span class="nv">$IFS</span>"
IFS='
'
IFS=<span class="cp">${</span><span class="n">IFS</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="cp">}</span><span class="w"> </span>#<span class="w"> </span>this<span class="w"> </span>is<span class="w"> </span>useful<span class="w"> </span>to<span class="w"> </span>format<span class="w"> </span>your<span class="w"> </span>code<span class="w"> </span>with<span class="w"> </span>tabs
lines=(<span class="w"> </span><span class="nv">$string</span><span class="w"> </span>)
IFS="<span class="nv">$oldIFS</span>"
</pre></div>

<p>This is similar to <strong>#2</strong> and <strong>#3</strong> in that it uses word splitting to get the
job done, only now the code explicitly sets <code>$IFS</code> to contain only the single-
character field delimiter present in the input string. It should be repeated
that this cannot work for multicharacter field delimiters such as the OP's
comma-space delimiter. But for a single-character delimiter like the LF used
in this example, it actually comes close to being perfect. The fields cannot
be unintentionally split in the middle as we saw with previous wrong answers,
and there is only one level of splitting, as required.</p>
<p>One problem is that filename expansion will corrupt affected words as
described earlier, although once again this can be solved by wrapping the
critical statement in <code>set -f</code> and <code>set +f</code>.</p>
<p>Another potential problem is that, since LF qualifies as an "IFS whitespace
character" as defined earlier, all empty fields will be lost, just as in
<strong>#2</strong> and <strong>#3</strong>. This would of course not be a problem if the delimiter
happens to be a non-"IFS whitespace character", and depending on the
application it may not matter anyway, but it does vitiate the generality of
the solution.</p>
<p>So, to sum up, assuming you have a one-character delimiter, and it is either a
non-"IFS whitespace character" or you don't care about empty fields, and you
wrap the critical statement in <code>set -f</code> and <code>set +f</code>, then this solution
works, but otherwise not.</p>
<p>(Also, for information's sake, assigning a LF to a variable in bash can be
done more easily with the <code>$'...'</code> syntax, e.g. <code>IFS=$'\n';</code>.)</p>
<hr>
<p><strong><em>Wrong answer #5</em></strong></p>
<div class="code"><pre class="code literal-block">countries='Paris, France, Europe'
OIFS="$IFS"
IFS=', ' array=($countries)
IFS="$OIFS"
</pre></div>

<p>Similar idea:</p>
<div class="code"><pre class="code literal-block">IFS=', ' eval 'array=($string)'
</pre></div>

<p>This solution is effectively a cross between <strong>#1</strong> (in that it sets <code>$IFS</code> to
comma-space) and <strong>#2-4</strong> (in that it uses word splitting to split the string
into fields). Because of this, it suffers from most of the problems that
afflict all of the above wrong answers, sort of like the worst of all worlds.</p>
<p>Also, regarding the second variant, it may seem like the <code>eval</code> call is
completely unnecessary, since its argument is a single-quoted string literal,
and therefore is statically known. But there's actually a very non-obvious
benefit to using <code>eval</code> in this way. Normally, when you run a simple command
which consists of a variable assignment <em>only</em> , meaning without an actual
command word following it, the assignment takes effect in the shell
environment:</p>
<div class="code"><pre class="code literal-block">IFS=', '; ## changes $IFS in the shell environment
</pre></div>

<p>This is true even if the simple command involves <em>multiple</em> variable
assignments; again, as long as there's no command word, all variable
assignments affect the shell environment:</p>
<div class="code"><pre class="code literal-block">IFS=', ' array=($countries); ## changes both $IFS and $array in the shell environment
</pre></div>

<p>But, if the variable assignment is attached to a command name (I like to call
this a "prefix assignment") then it does <em>not</em> affect the shell environment,
and instead only affects the environment of the executed command, regardless
whether it is a builtin or external:</p>
<div class="code"><pre class="code literal-block"><span class="n">IFS</span><span class="o">=</span><span class="p">',</span><span class="w"> </span><span class="p">'</span><span class="w"> </span><span class="o">:</span><span class="p">;</span><span class="w"> </span><span class="p">##</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">builtin</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">$IFS</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">it</span>
<span class="n">IFS</span><span class="o">=</span><span class="p">',</span><span class="w"> </span><span class="p">'</span><span class="w"> </span><span class="n">env</span><span class="p">;</span><span class="w"> </span><span class="p">##</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">external</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">$IFS</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">outlive</span><span class="w"> </span><span class="n">it</span>
</pre></div>

<p>Relevant quote from the bash manual:</p>
<blockquote>
<p>If no command name results, the variable assignments affect the current
shell environment. Otherwise, the variables are added to the environment of
the executed command and do not affect the current shell environment.</p>
</blockquote>
<p>It is possible to exploit this feature of variable assignment to change <code>$IFS</code>
only temporarily, which allows us to avoid the whole save-and-restore gambit
like that which is being done with the <code>$OIFS</code> variable in the first variant.
But the challenge we face here is that the command we need to run is itself a
mere variable assignment, and hence it would not involve a command word to
make the <code>$IFS</code> assignment temporary. You might think to yourself, well why
not just add a no-op command word to the statement like the <code>: builtin</code> to
make the <code>$IFS</code> assignment temporary? This does not work because it would then
make the <code>$array</code> assignment temporary as well:</p>
<div class="code"><pre class="code literal-block">IFS=', ' array=($countries) :; ## fails; new $array value never escapes the : command
</pre></div>

<p>So, we're effectively at an impasse, a bit of a catch-22. But, when <code>eval</code>
runs its code, it runs it in the shell environment, as if it was normal,
static source code, and therefore we can run the <code>$array</code> assignment inside
the <code>eval</code> argument to have it take effect in the shell environment, while the
<code>$IFS</code> prefix assignment that is prefixed to the <code>eval</code> command will not
outlive the <code>eval</code> command. This is exactly the trick that is being used in
the second variant of this solution:</p>
<div class="code"><pre class="code literal-block">IFS=', ' eval 'array=($string)'; ## $IFS does not outlive the eval command, but $array does
</pre></div>

<p>So, as you can see, it's actually quite a clever trick, and accomplishes
exactly what is required (at least with respect to assignment effectation) in
a rather non-obvious way. I'm actually not against this trick in general,
despite the involvement of <code>eval</code>; just be careful to single-quote the
argument string to guard against security threats.</p>
<p>But again, because of the "worst of all worlds" agglomeration of problems,
this is still a wrong answer to the OP's requirement.</p>
<hr>
<p><strong><em>Wrong answer #6</em></strong></p>
<div class="code"><pre class="code literal-block">IFS=', '; array=(Paris, France, Europe)

IFS=' ';declare -a array=(Paris France Europe)
</pre></div>

<p>Um... what? The OP has a string variable that needs to be parsed into an
array. This "answer" starts with the verbatim contents of the input string
pasted into an array literal. I guess that's one way to do it.</p>
<p>It looks like the answerer may have assumed that the <code>$IFS</code> variable affects
all bash parsing in all contexts, which is not true. From the bash manual:</p>
<blockquote>
<p><strong>IFS</strong> The Internal Field Separator that is used for word splitting after
expansion and to split lines into words with the <strong>read</strong> builtin command.
The default value is <strong>&lt; space&gt;<tab><newline></newline></tab></strong>.</p>
</blockquote>
<p>So the <code>$IFS</code> special variable is actually only used in two contexts: (1) word
splitting that is performed <em>after expansion</em> (meaning <em>not</em> when parsing bash
source code) and (2) for splitting input lines into words by the <code>read</code>
builtin.</p>
<p>Let me try to make this clearer. I think it might be good to draw a
distinction between <em>parsing</em> and <em>execution</em>. Bash must first <em>parse</em> the
source code, which obviously is a <em>parsing</em> event, and then later it
<em>executes</em> the code, which is when expansion comes into the picture. Expansion
is really an <em>execution</em> event. Furthermore, I take issue with the description
of the <code>$IFS</code> variable that I just quoted above; rather than saying that word
splitting is performed <em>after expansion</em> , I would say that word splitting is
performed <em>during</em> expansion, or, perhaps even more precisely, word splitting
is <em>part of</em> the expansion process. The phrase "word splitting" refers only to
this step of expansion; it should never be used to refer to the parsing of
bash source code, although unfortunately the docs do seem to throw around the
words "split" and "words" a lot. Here's a relevant excerpt from the
linux.die.net version of the bash manual:</p>
<blockquote>
<p>Expansion is performed on the command line after it has been split into
words. There are seven kinds of expansion performed: <em>brace expansion</em> ,
<em>tilde expansion</em> , <em>parameter and variable expansion</em> , <em>command
substitution</em> , <em>arithmetic expansion</em> , <em>word splitting</em> , and <em>pathname
expansion</em>.</p>
<p>The order of expansions is: brace expansion; tilde expansion, parameter and
variable expansion, arithmetic expansion, and command substitution (done in
a left-to-right fashion); word splitting; and pathname expansion.</p>
</blockquote>
<p>You could argue the GNU version of the manual does slightly better, since it
opts for the word "tokens" instead of "words" in the first sentence of the
Expansion section:</p>
<blockquote>
<p>Expansion is performed on the command line after it has been split into
tokens.</p>
</blockquote>
<p>The important point is, <code>$IFS</code> does not change the way bash parses source
code. Parsing of bash source code is actually a very complex process that
involves recognition of the various elements of shell grammar, such as command
sequences, command lists, pipelines, parameter expansions, arithmetic
substitutions, and command substitutions. For the most part, the bash parsing
process cannot be altered by user-level actions like variable assignments
(actually, there are some minor exceptions to this rule; for example, see the
various <code>compatxx</code> shell settings, which can change certain aspects of parsing
behavior on-the-fly). The upstream "words"/"tokens" that result from this
complex parsing process are then expanded according to the general process of
"expansion" as broken down in the above documentation excerpts, where word
splitting of the expanded (expanding?) text into downstream words is simply
one step of that process. Word splitting only touches text that has been spit
out of a preceding expansion step; it does not affect literal text that was
parsed right off the source bytestream.</p>
<hr>
<p><strong><em>Wrong answer #7</em></strong></p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span><span class="err">'first line</span>
<span class="err">        second line</span>
<span class="w">        </span><span class="nv">third</span><span class="w"> </span><span class="nv">line</span><span class="err">'</span>

<span class="err">while read -r line; do lines+=("$line"); done &lt;&lt;&lt;"$string"</span>
</pre></div>

<p>This is one of the best solutions. Notice that we're back to using <code>read</code>.
Didn't I say earlier that <code>read</code> is inappropriate because it performs two
levels of splitting, when we only need one? The trick here is that you can
call <code>read</code> in such a way that it effectively only does one level of
splitting, specifically by splitting off only one field per invocation, which
necessitates the cost of having to call it repeatedly in a loop. It's a bit of
a sleight of hand, but it works.</p>
<p>But there are problems. First: When you provide at least one <em>NAME</em> argument
to <code>read</code>, it automatically ignores leading and trailing whitespace in each
field that is split off from the input string. This occurs whether <code>$IFS</code> is
set to its default value or not, as described earlier in this post. Now, the
OP may not care about this for his specific use-case, and in fact, it may be a
desirable feature of the parsing behavior. But not everyone who wants to parse
a string into fields will want this. There is a solution, however: A somewhat
non-obvious usage of <code>read</code> is to pass zero <em>NAME</em> arguments. In this case,
<code>read</code> will store the entire input line that it gets from the input stream in
a variable named <code>$REPLY</code>, and, as a bonus, it does <em>not</em> strip leading and
trailing whitespace from the value. This is a very robust usage of <code>read</code>
which I've exploited frequently in my shell programming career. Here's a
demonstration of the difference in behavior:</p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span>$<span class="s1">'  a  b  \n  c  d  \n  e  f  '</span><span class="c1">; ## input string</span>

<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -r line; do a+=("$line"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"a  b"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">"c  d"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">"e  f"</span><span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">read</span><span class="w"> </span><span class="nv">trimmed</span><span class="w"> </span><span class="nv">surrounding</span><span class="w"> </span><span class="nv">whitespace</span>

<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -r; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"  a  b  "</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">"  c  d  "</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">"  e  f  "</span><span class="ss">)</span><span class="w"> </span>##<span class="w"> </span><span class="nv">no</span><span class="w"> </span><span class="nv">trimming</span>
</pre></div>

<p>The second issue with this solution is that it does not actually address the
case of a custom field separator, such as the OP's comma-space. As before,
multicharacter separators are not supported, which is an unfortunate
limitation of this solution. We could try to at least split on comma by
specifying the separator to the <code>-d</code> option, but look what happens:</p>
<div class="code"><pre class="code literal-block"><span class="nv">string</span><span class="o">=</span><span class="s1">'Paris, France, Europe'</span><span class="c1">;</span>
<span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="ss">)</span>
</pre></div>

<p>Predictably, the unaccounted surrounding whitespace got pulled into the field
values, and hence this would have to be corrected subsequently through
trimming operations (this could also be done directly in the while-loop). But
there's another obvious error: Europe is missing! What happened to it? The
answer is that <code>read</code> returns a failing return code if it hits end-of-file (in
this case we can call it end-of-string) without encountering a final field
terminator on the final field. This causes the while-loop to break prematurely
and we lose the final field.</p>
<p>Technically this same error afflicted the previous examples as well; the
difference there is that the field separator was taken to be LF, which is the
default when you don't specify the <code>-d</code> option, and the <code>&lt;&lt;&lt;</code> ("here-string")
mechanism automatically appends a LF to the string just before it feeds it as
input to the command. Hence, in those cases, we sort of <em>accidentally</em> solved
the problem of a dropped final field by unwittingly appending an additional
dummy terminator to the input. Let's call this solution the "dummy-terminator"
solution. We can apply the dummy-terminator solution manually for any custom
delimiter by concatenating it against the input string ourselves when
instantiating it in the here-string:</p>
<div class="code"><pre class="code literal-block"><span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,; do a+=("$REPLY"); done &lt;&lt;&lt;"$string,"; declare -p a;</span>
<span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span><span class="s2">" Europe"</span><span class="ss">)</span>
</pre></div>

<p>There, problem solved. Another solution is to only break the while-loop if
both (1) <code>read</code> returned failure and (2) <code>$REPLY</code> is empty, meaning <code>read</code> was
not able to read any characters prior to hitting end-of-file. Demo:</p>
<div class="code"><pre class="code literal-block"><span class="nv">a</span><span class="o">=</span><span class="ss">()</span><span class="c1">; while read -rd,|| [[ -n "$REPLY" ]]; do a+=("$REPLY"); done &lt;&lt;&lt;"$string"; declare -p a;</span>
##<span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="nv">a</span><span class="o">=</span><span class="ss">(</span>[<span class="mi">0</span>]<span class="o">=</span><span class="s2">"Paris"</span><span class="w"> </span>[<span class="mi">1</span>]<span class="o">=</span><span class="s2">" France"</span><span class="w"> </span>[<span class="mi">2</span>]<span class="o">=</span>$<span class="s1">' Europe\n'</span><span class="ss">)</span>
</pre></div>

<p>This approach also reveals the secretive LF that automatically gets appended
to the here-string by the <code>&lt;&lt;&lt;</code> redirection operator. It could of course be
stripped off separately through an explicit trimming operation as described a
moment ago, but obviously the manual dummy-terminator approach solves it
directly, so we could just go with that. The manual dummy-terminator solution
is actually quite convenient in that it solves both of these two problems (the
dropped-final-field problem and the appended-LF problem) in one go.</p>
<p>So, overall, this is quite a powerful solution. It's only remaining weakness
is a lack of support for multicharacter delimiters, which I will address
later.</p>
<hr>
<p><strong><em>Wrong answer #8</em></strong></p>
<div class="code"><pre class="code literal-block">string='first line
        second line
        third line'

readarray -t lines &lt;&lt;&lt;"$string"
</pre></div>

<p>(This is actually from the same post as <strong>#7</strong> ; the answerer provided two
solutions in the same post.)</p>
<p>The <code>readarray</code> builtin, which is a synonym for <code>mapfile</code>, is ideal. It's a
builtin command which parses a bytestream into an array variable in one shot;
no messing with loops, conditionals, substitutions, or anything else. And it
doesn't surreptitiously strip any whitespace from the input string. And (if
<code>-O</code> is not given) it conveniently clears the target array before assigning to
it. But it's still not perfect, hence my criticism of it as a "wrong answer".</p>
<p>First, just to get this out of the way, note that, just like the behavior of
<code>read</code> when doing field-parsing, <code>readarray</code> drops the trailing field if it is
empty. Again, this is probably not a concern for the OP, but it could be for
some use-cases. I'll come back to this in a moment.</p>
<p>Second, as before, it does not support multicharacter delimiters. I'll give a
fix for this in a moment as well.</p>
<p>Third, the solution as written does not parse the OP's input string, and in
fact, it cannot be used as-is to parse it. I'll expand on this momentarily as
well.</p>
<p>For the above reasons, I still consider this to be a "wrong answer" to the
OP's question. Below I'll give what I consider to be the right answer.</p>
<hr>
<p><strong>Right answer</strong></p>
<p>Here's a naïve attempt to make <strong>#8</strong> work by just specifying the <code>-d</code> option:</p>
<div class="code"><pre class="code literal-block">string='Paris, France, Europe';
readarray -td, a &lt;&lt;&lt;"$string"; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=$' Europe\n')
</pre></div>

<p>We see the result is identical to the result we got from the double-
conditional approach of the looping <code>read</code> solution discussed in <strong>#7</strong>. We
can <em>almost</em> solve this with the manual dummy-terminator trick:</p>
<div class="code"><pre class="code literal-block">readarray -td, a &lt;&lt;&lt;"$string,"; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=" Europe" [3]=$'\n')
</pre></div>

<p>The problem here is that <code>readarray</code> preserved the trailing field, since the
<code>&lt;&lt;&lt;</code> redirection operator appended the LF to the input string, and therefore
the trailing field was <em>not</em> empty (otherwise it would've been dropped). We
can take care of this by explicitly unsetting the final array element after-
the-fact:</p>
<div class="code"><pre class="code literal-block">readarray -td, a &lt;&lt;&lt;"$string,"; unset 'a[-1]'; declare -p a;
## declare -a a=([0]="Paris" [1]=" France" [2]=" Europe")
</pre></div>

<p>The only two problems that remain, which are actually related, are (1) the
extraneous whitespace that needs to be trimmed, and (2) the lack of support
for multicharacter delimiters.</p>
<p>The whitespace could of course be trimmed afterward (for example, see How to
trim whitespace from a Bash variable?). But if we can hack a multicharacter
delimiter, then that would solve both problems in one shot.</p>
<p>Unfortunately, there's no <em>direct</em> way to get a multicharacter delimiter to
work. The best solution I've thought of is to preprocess the input string to
replace the multicharacter delimiter with a single-character delimiter that
will be guaranteed not to collide with the contents of the input string. The
only character that has this guarantee is the NUL byte. This is because, in
bash (though not in zsh, incidentally), variables cannot contain the NUL byte.
This preprocessing step can be done inline in a process substitution. Here's
how to do it using awk:</p>
<div class="code"><pre class="code literal-block">readarray -td '' a &lt; &lt;(awk '{ gsub(/, /,"\0"); print; }' &lt;&lt;&lt;"$string, "); unset 'a[-1]';
declare -p a;
## declare -a a=([0]="Paris" [1]="France" [2]="Europe")
</pre></div>

<p>There, finally! This solution will not erroneously split fields in the middle,
will not cut out prematurely, will not drop empty fields, will not corrupt
itself on filename expansions, will not automatically strip leading and
trailing whitespace, will not leave a stowaway LF on the end, does not require
loops, and does not settle for a single-character delimiter.</p>
<hr>
<p><strong>Trimming solution</strong></p>
<p>Lastly, I wanted to demonstrate my own fairly intricate trimming solution
using the obscure <code>-C callback</code> option of <code>readarray</code>. Unfortunately, I've run
out of room against Stack Overflow's draconian 30,000 character post limit, so
I won't be able to explain it. I'll leave that as an exercise for the reader.</p>
<div class="code"><pre class="code literal-block">function<span class="w"> </span>mfcb<span class="w"> </span>{<span class="w"> </span>local<span class="w"> </span>val="$4";<span class="w"> </span>"$1";<span class="w"> </span>eval<span class="w"> </span>"$2[$3]=\<span class="nv">$val</span>;";<span class="w"> </span>};
function<span class="w"> </span>val_ltrim<span class="w"> </span>{<span class="w"> </span>if<span class="w"> </span>[[<span class="w"> </span>"<span class="nv">$val</span>"<span class="w"> </span>=~<span class="w"> </span>^[[:space:]]+<span class="w"> </span>]];<span class="w"> </span>then<span class="w"> </span>val="<span class="cp">${</span><span class="n">val</span><span class="p">:</span><span class="err">$</span><span class="p">{</span><span class="c1">#BASH_REMATCH[0]</span><span class="cp">}</span>}";<span class="w"> </span>fi;<span class="w"> </span>};
function<span class="w"> </span>val_rtrim<span class="w"> </span>{<span class="w"> </span>if<span class="w"> </span>[[<span class="w"> </span>"<span class="nv">$val</span>"<span class="w"> </span>=~<span class="w"> </span>[[:space:]]+$<span class="w"> </span>]];<span class="w"> </span>then<span class="w"> </span>val="<span class="cp">${</span><span class="n">val</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="err">$</span><span class="p">{</span><span class="c1">#val</span><span class="cp">}</span>-<span class="cp">${</span><span class="c1">#BASH_REMATCH[0]</span><span class="cp">}</span>}";<span class="w"> </span>fi;<span class="w"> </span>};
function<span class="w"> </span>val_trim<span class="w"> </span>{<span class="w"> </span>val_ltrim;<span class="w"> </span>val_rtrim;<span class="w"> </span>};
readarray<span class="w"> </span>-c1<span class="w"> </span>-C<span class="w"> </span>'mfcb<span class="w"> </span>val_trim<span class="w"> </span>a'<span class="w"> </span>-td,<span class="w"> </span><span class="err">&lt;&lt;&lt;</span>"<span class="nv">$string</span>,";<span class="w"> </span>unset<span class="w"> </span>'a[-1]';<span class="w"> </span>declare<span class="w"> </span>-p<span class="w"> </span>a;
##<span class="w"> </span>declare<span class="w"> </span>-a<span class="w"> </span>a=([0]="Paris"<span class="w"> </span>[1]="France"<span class="w"> </span>[2]="Europe")
</pre></div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/arrays/" rel="tag">arrays</a></li>
            <li><a class="tag p-category" href="../../categories/bash/" rel="tag">bash</a></li>
            <li><a class="tag p-category" href="../../categories/split/" rel="tag">split</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../why-is-my-variable-unaltered-after-i-modify-it-inside-of-a-function-asynchronous-code-reference/" rel="prev" title="Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-to-initialize-hashset-values-by-construction/" rel="next" title="How to initialize HashSet values by construction?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
