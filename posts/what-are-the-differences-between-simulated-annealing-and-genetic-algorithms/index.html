<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What are the differences between simulated annealing and genetic algorithms? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-are-the-differences-between-simulated-annealing-and-genetic-algorithms/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../manhattan-distance-is-over-estimating-and-making-me-crazy/" title="Manhattan distance is over estimating and making me crazy" type="text/html">
<link rel="next" href="../algorithms-for-realtime-strategy-wargame-ai/" title="Algorithms for realtime strategy wargame AI" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What are the differences between simulated annealing and genetic algor">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-are-the-differences-between-simulated-annealing-and-genetic-algorithms/">
<meta property="og:description" content="What are the relevant differences, in terms of performance and use cases,
between simulated annealing (with bean search) and genetic algorithms?
I know that SA can be thought as GA where the populatio">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-28T02:48:52+08:00">
<meta property="article:tag" content="artificial-intelligence">
<meta property="article:tag" content="constraint-satisfaction">
<meta property="article:tag" content="genetic-algorithm">
<meta property="article:tag" content="simulated-annealing">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What are the differences between simulated annealing and genetic algorithms?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T02:48:52+08:00" itemprop="datePublished" title="2023-02-28 02:48">2023-02-28 02:48</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What are the relevant differences, in terms of performance and use cases,
between simulated annealing (with bean search) and genetic algorithms?</p>
<p>I know that SA can be thought as GA where the population size is only one, but
I don't know the key difference between the two.</p>
<p>Also, I am trying to think of a situation where SA will outperform GA or GA
will outperform SA. Just one simple example which will help me understand will
be enough.</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Well strictly speaking, these two things-- <strong>simulated annealing</strong> (SA) and
<strong>genetic algorithms</strong> are neither algorithms nor is their purpose 'data
mining'.</p>
<p>Both are <em>meta-heuristics</em> --a couple of levels above 'algorithm' on the
abstraction scale. In other words, both terms refer to high-level metaphors--
one borrowed from metallurgy and the other from evolutionary biology. In the
meta-heuristic taxonomy, SA is a <em>single-state method</em> and GA is a <em>population
method</em> (in a sub-class along with PSO, ACO, et al, usually referred to as
<em>biologically-inspired meta-heuristics</em> ).</p>
<p>These two meta-heuristics are used to solve optimization problems,
particularly (though not exclusively) in <em>combinatorial optimization</em> (aka
<em>constraint-satisfaction programming</em> ). Combinatorial optimization refers to
optimization by selecting from among a set of discrete items--in other words,
there is no continuous function to minimize. The knapsack problem, traveling
salesman problem, cutting stock problem--are all combinatorial optimization
problems.</p>
<p>The connection to data mining is that the core of many (most?) supervised
Machine Learning (ML) algorithms is the solution of an optimization
problem--(Multi-Layer Perceptron and Support Vector Machines for instance).</p>
<p>Any solution technique to solve cap problems, regardless of the algorithm,
will consist essentially of these steps (which are typically coded as a single
block within a recursive loop):</p>
<ol>
<li>
<p>encode the domain-specific details in a cost function (it's the step-wise minimization of the value returned from this function that constitutes a 'solution' to the c/o problem);</p>
</li>
<li>
<p>evaluate the cost function passing in an initial 'guess' (to begin iteration);</p>
</li>
<li>
<p>based on the value returned from the cost function, generate a subsequent candidate solution (or more than one, depending on the meta-heuristic) to the cost function;</p>
</li>
<li>
<p>evaluate each candidate solution by passing it in an argument set, to the cost function;</p>
</li>
<li>
<p>repeat steps (iii) and (iv) until either some convergence criterion is satisfied or a maximum number of iterations is reached.</p>
</li>
</ol>
<p>Meta-heuristics are directed to step (iii) above; hence, SA and GA differ in
how they generate candidate solutions for evaluation by the cost function. In
other words, that's the place to look to understand how these two meta-
heuristics differ.</p>
<p>Informally, the essence of an algorithm directed to solution of combinatorial
optimization is how it handles a candidate solution whose value returned from
the cost function is <strong><em>worse</em></strong> than the current best candidate solution (the
one that returns the lowest value from the cost function). The simplest way
for an optimization algorithm to handle such a candidate solution is to reject
it outright--that's what the hill climbing algorithm does. But by doing this,
simple hill climbing will always miss a better solution separated from the
current solution by a hill. Put another way, a sophisticated optimization
algorithm has to include a technique for (temporarily) accepting a candidate
solution worse than (i.e., uphill from) the current best solution because an
even better solution than the current one might lie along a path through that
worse solution.</p>
<hr>
<p>So how do SA and GA generate candidate solutions?</p>
<p>The essence of SA is usually expressed in terms of the probability that a
higher-cost candidate solution will be accepted (the entire expression inside
the double parenthesis is an exponent:</p>
<div class="code"><pre class="code literal-block">p = e((-highCost - lowCost)/temperature)
</pre></div>

<p>Or in python:</p>
<div class="code"><pre class="code literal-block">p = pow(math.e, (-hiCost - loCost) / T)
</pre></div>

<p>The 'temperature' term is a variable whose value decays during progress of the
optimization--and therefore, the probability that SA will accept a worse
solution decreases as iteration number increases.</p>
<p>Put another way, when the algorithm begins iterating, T is very large, which
as you can see, causes the algorithm to move to every newly created candidate
solution, whether better or worse than the current best solution--i.e., it is
doing a <em>random walk</em> in the solution space. As iteration number increases
(i.e., as the temperature cools) the algorithm's search of the solution space
becomes less permissive, until at T = 0, the behavior is identical to a simple
hill-climbing algorithm (i.e., only solutions better than the current best
solution are accepted).</p>
<p><strong><em>Genetic Algorithms</em></strong> are very different. For one thing--and this is a big
thing--it generates not a single candidate solution but an entire 'population
of them'. It works like this: GA calls the cost function on each member
(candidate solution) of the population. It then ranks them, from best to
worse, ordered by the value returned from the cost function ('best' has the
lowest value). From these ranked values (and their corresponding candidate
solutions) the next population is created. New members of the population are
created in essentially one of three ways. The first is usually referred to as
'elitism' and in practice usually refers to just taking the highest ranked
candidate solutions and passing them straight through--unmodified--to the next
generation. The other two ways that new members of the population are usually
referred to as 'mutation' and 'crossover'. Mutation usually involves a change
in one element in a candidate solution vector from the current population to
create a solution vector in the new population, e.g., [4, 5, 1, 0, 2] =&gt; [4,
5, 2, 0, 2]. The result of the crossover operation is like what would happen
if vectors could have sex--i.e., a new child vector whose elements are
comprised of some from each of two parents.</p>
<p>So those are the algorithmic differences between GA and SA. What about the
differences in performance?</p>
<p>In practice: (my observations are limited to combinatorial optimization
problems) GA nearly always beats SA (returns a lower 'best' return value from
the cost function--ie, a value close to the solution space's global minimum),
but at a higher computation cost. As far as i am aware, the textbooks and
technical publications recite the same conclusion on resolution.</p>
<p>but here's the thing: GA is inherently parallelizable; what's more, it's
trivial to do so because the individual "search agents" comprising each
population do not need to exchange messages--ie, they work independently of
each other. Obviously that means <em>GA computation can be distributed</em> , which
means <strong>in practice, you can get much better results (closer to the global
minimum) and better performance (execution speed).</strong></p>
<p>In what circumstances might SA outperform GA? The general scenario i think
would be those optimization problems having a small solution space so that the
result from SA and GA are practically the same, yet the execution context
(e.g., hundreds of similar problems run in batch mode) favors the faster
algorithm (which should always be SA).</p>
<p><br></p>
<h3>Suggest</h3>
<p>It is really difficult to compare the two since they were inspired from
different domains..</p>
<p>A Genetic Algorithm maintains a population of possible solutions, and at each
step, selects pairs of possible solution, combines them (crossover), and
applies some random changes (mutation). The algorithm is based the idea of
"survival of the fittest" where the selection process is done according to a
fitness criteria (usually in optimization problems it is simply the value of
the objective function evaluated using the current solution). The crossover is
done in hope that two good solutions, when combined, might give even better
solution.</p>
<p>On the other hand, Simulated Annealing only tracks one solution in the space
of possible solutions, and at each iteration considers whether to move to a
neighboring solution or stay in the current one according to some
probabilities (which decays over time). This is different from a heuristic
search (say greedy search) in that it doesn't suffer from the problems of
local optimum since it can get unstuck from cases where all neighboring
solutions are worst the current one.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/artificial-intelligence/" rel="tag">artificial-intelligence</a></li>
            <li><a class="tag p-category" href="../../categories/constraint-satisfaction/" rel="tag">constraint-satisfaction</a></li>
            <li><a class="tag p-category" href="../../categories/genetic-algorithm/" rel="tag">genetic-algorithm</a></li>
            <li><a class="tag p-category" href="../../categories/simulated-annealing/" rel="tag">simulated-annealing</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../manhattan-distance-is-over-estimating-and-making-me-crazy/" rel="prev" title="Manhattan distance is over estimating and making me crazy">Previous post</a>
            </li>
            <li class="next">
                <a href="../algorithms-for-realtime-strategy-wargame-ai/" rel="next" title="Algorithms for realtime strategy wargame AI">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
