<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>什么是 Python 中的“命名元组”？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-python-zhong-de-ming-ming-yuan-zu/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-an-zhuang-npm-bao-de-xian-qian-que-qie-ban-ben/" title="如何安装 NPM 包的先前确切版本？" type="text/html">
<link rel="next" href="../jiang-json-fan-xu-lie-hua-wei-c-dong-tai-dui-xiang/" title="将 JSON 反序列化为 C# 动态对象？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="什么是 Python 中的“命名元组”？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/shi-yao-shi-python-zhong-de-ming-ming-yuan-zu/">
<meta property="og:description" content="什么是命名元组以及如何使用它们？
我什么时候应该使用命名元组而不是普通元组，反之亦然？
也有“名单”吗？（即可变的命名元组）


对于最后一个问题，另请参阅Python 中是否存在可变命名元组？.

解答
命名元组基本上是易于创建的轻量级对象类型。可以使用类对象变量取消引用或标准元组语法来引用命名元组实例。struct它们可以与其他常见记录类型类似地使用，除了它们是不可变的。它们是在
Python">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:05:17+08:00">
<meta property="article:tag" content="namedtuple">
<meta property="article:tag" content="python">
<meta property="article:tag" content="tuples">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">什么是 Python 中的“命名元组”？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:05:17+08:00" itemprop="datePublished" title="2023-02-17 05:05">2023-02-17 05:05</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <ul>
<li>什么是命名元组以及如何使用它们？</li>
<li>我什么时候应该使用命名元组而不是普通元组，反之亦然？</li>
<li>也有“名单”吗？（即可变的命名元组）</li>
</ul>
<hr>
<p>对于最后一个问题，另请参阅Python 中是否存在可变命名元组？.</p>
<p><br><br></p>
<h2>解答</h2>
<p>命名元组基本上是易于创建的轻量级对象类型。可以使用类对象变量取消引用或标准元组语法来引用命名元组实例。<code>struct</code>它们可以与其他常见记录类型类似地使用，除了它们是不可变的。它们是在
Python 2.6 和 Python 3.0 中添加的，尽管在 Python 2.4 中有实现的方法。</p>
<p>例如，通常将一个点表示为一个元组<code>(x, y)</code>。这导致如下代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">pt1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">line_length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>使用命名元组，它变得更具可读性：</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="n">Point</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Point'</span><span class="p">,</span> <span class="s1">'x y'</span><span class="p">)</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">line_length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="n">pt2</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="n">pt2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>但是，命名元组仍然向后兼容普通元组，因此以下内容仍然有效：</p>
<div class="code"><pre class="code literal-block"><span class="n">Point</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Point'</span><span class="p">,</span> <span class="s1">'x y'</span><span class="p">)</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="c1"># use index referencing</span>
<span class="n">line_length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
 <span class="c1"># use tuple unpacking</span>
<span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pt1</span>
</pre></div>

<p>因此， <strong>您应该在任何您认为对象表示法会使您的代码更 pythonic 和更易于阅读的地方使用命名元组而不是元组</strong>
。我个人已经开始使用它们来表示非常简单的值类型，尤其是将它们作为参数传递给函数时。它使函数更具可读性，而无需查看元组打包的上下​​文。</p>
<p>此外， <strong>您还可以用它们替换 没有函数 __</strong>、只有字段的普通 <strong> <em>不可变类。</em></strong> 您甚至可以将命名的元组类型用作基类：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Point</span>(<span class="n">namedtuple</span>(<span class="s">'Point'</span>, <span class="s">'x y'</span>)):
    [...]
</pre></div>

<p>然而，与元组一样，命名元组中的属性是不可变的：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; Point = namedtuple('Point', 'x y')
&gt;&gt;&gt; pt1 = Point(1.0, 5.0)
&gt;&gt;&gt; pt1.x = 2.0
AttributeError: can't set attribute
</pre></div>

<p>如果您希望能够更改值，则需要另一种类型。可变记录类型有一个方便的方法，它允许您为属性设置新值。</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">rcdtype</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Point</span> <span class="o">=</span> <span class="n">recordtype</span><span class="p">(</span><span class="s1">'Point'</span><span class="p">,</span> <span class="s1">'x y'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pt1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pt1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pt1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="mf">2.0</span>
</pre></div>

<p>但是，我不知道有任何形式的“命名列表”可以让您添加新字段。在这种情况下，您可能只想使用字典。<code>pt1._asdict()</code>命名元组可以使用which
返回转换为字典<code>{'x': 1.0, 'y': 5.0}</code>，并且可以使用所有常用的字典函数对其进行操作。</p>
<p>如前所述，您应该查看文档以获取构建这些示例的更多信息。</p>
<p><br></p>
<h3>更多建议</h3>
<blockquote>
<h3>什么是命名元组？</h3>
</blockquote>
<p>命名元组是一个元组。</p>
<p>它做元组能做的一切。</p>
<p>但它不仅仅是一个元组。</p>
<p>它是根据您的规范以编程方式创建的元组的特定子类，具有命名字段和固定长度。</p>
<p>例如，这创建了一个元组的子类，除了具有固定长度（在本例中为三个）之外，它还可以在任何使用元组的地方使用而不会中断。这被称为 Liskov 可替代性。</p>
<p><em>Python 3.6 中的新功能</em> ，我们可以使用类定义来<code>typing.NamedTuple</code>创建命名元组：</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="k">class</span> <span class="nc">ANamedTuple</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""a docstring"""</span>
    <span class="n">foo</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">bar</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">baz</span><span class="p">:</span> <span class="nb">list</span>
</pre></div>

<p>上面和 一样<code>collections.namedtuple</code>，只是上面额外有类型注解和文档字符串。以下内容在 Python 2+ 中可用：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">class_name</span> <span class="o">=</span> <span class="s1">'ANamedTuple'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fields</span> <span class="o">=</span> <span class="s1">'foo bar baz'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ANamedTuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>
</pre></div>

<p>这将它实例化：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; ant = ANamedTuple(1, 'bar', [])
</pre></div>

<p>我们可以检查它并使用它的属性：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; ant
ANamedTuple(foo=1, bar='bar', baz=[])
&gt;&gt;&gt; ant.foo
1
&gt;&gt;&gt; ant.bar
'bar'
&gt;&gt;&gt; ant.baz.append('anything')
&gt;&gt;&gt; ant.baz
['anything']
</pre></div>

<h3>更深入的解释</h3>
<p>要理解命名元组，首先需要知道什么是元组。元组本质上是一个不可变的（不能在内存中就地更改）列表。</p>
<p>以下是使用常规元组的方法：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; student_tuple = 'Lisa', 'Simpson', 'A'
&gt;&gt;&gt; student_tuple
('Lisa', 'Simpson', 'A')
&gt;&gt;&gt; student_tuple[0]
'Lisa'
&gt;&gt;&gt; student_tuple[1]
'Simpson'
&gt;&gt;&gt; student_tuple[2]
'A'
</pre></div>

<p>您可以使用可迭代解包来扩展元组：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; first, last, grade = student_tuple
&gt;&gt;&gt; first
'Lisa'
&gt;&gt;&gt; last
'Simpson'
&gt;&gt;&gt; grade
'A'
</pre></div>

<p>命名元组是允许通过名称而不仅仅是索引来访问其元素的元组！</p>
<p>你像这样创建一个命名元组：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Student</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Student'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'first'</span><span class="p">,</span> <span class="s1">'last'</span><span class="p">,</span> <span class="s1">'grade'</span><span class="p">])</span>
</pre></div>

<p>您还可以使用名称以空格分隔的单个字符串，API 的可读性稍强一些：</p>
<div class="code"><pre class="code literal-block">&gt;&gt;&gt; Student = namedtuple('Student', 'first last grade')
</pre></div>

<blockquote>
<h3>如何使用它们？</h3>
</blockquote>
<p>您可以做元组可以做的所有事情（见上文）以及做以下事情：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Student</span><span class="p">(</span><span class="s1">'Lisa'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Simpson'</span><span class="p">,</span><span class="w"> </span><span class="s1">'A'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="o">.</span><span class="n">first</span>
<span class="s1">'Lisa'</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="o">.</span><span class="n">last</span>
<span class="s1">'Simpson'</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="o">.</span><span class="n">grade</span>
<span class="s1">'A'</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">'first'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Lisa'</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s1">'last'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Simpson'</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s1">'grade'</span><span class="p">,</span><span class="w"> </span><span class="s1">'A'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">vars</span><span class="p">(</span><span class="n">named_student_tuple</span><span class="p">)</span>
<span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">'first'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Lisa'</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s1">'last'</span><span class="p">,</span><span class="w"> </span><span class="s1">'Simpson'</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s1">'grade'</span><span class="p">,</span><span class="w"> </span><span class="s1">'A'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">new_named_student_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">named_student_tuple</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="s1">'Bart'</span><span class="p">,</span><span class="w"> </span><span class="n">grade</span><span class="o">=</span><span class="s1">'C'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">new_named_student_tuple</span>
<span class="n">Student</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="s1">'Bart'</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="o">=</span><span class="s1">'Simpson'</span><span class="p">,</span><span class="w"> </span><span class="n">grade</span><span class="o">=</span><span class="s1">'C'</span><span class="p">)</span>
</pre></div>

<p>一位评论者问道：</p>
<blockquote>
<p>在大型脚本或程序中，通常在哪里定义命名元组？</p>
</blockquote>
<p>您创建的类型<code>namedtuple</code>基本上是您可以使用简单的速记创建的类。像对待班级一样对待他们。在模块级别定义它们，以便 pickle
和其他用户可以找到它们。</p>
<p>全局模块级别的工作示例：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">NT</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">'NT'</span><span class="p">,</span> <span class="s1">'foo bar'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">NT</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'bar'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pickle</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">nt</span><span class="p">))</span>
<span class="n">NT</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s1">'foo'</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
</pre></div>

<p>这表明无法查找定义：</p>
<div class="code"><pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">foo</span><span class="p">():</span>
<span class="o">...</span><span class="w">     </span><span class="n">LocalNT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">'LocalNT'</span><span class="p">,</span><span class="w"> </span><span class="s1">'foo bar'</span><span class="p">)</span>
<span class="o">...</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">LocalNT</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span><span class="w"> </span><span class="s1">'bar'</span><span class="p">)</span>
<span class="o">...</span><span class="w"> </span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">foo</span><span class="p">()))</span>
<span class="n">Traceback</span><span class="w"> </span><span class="p">(</span><span class="n">most</span><span class="w"> </span><span class="n">recent</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">last</span><span class="p">):</span>
<span class="w">  </span><span class="n">File</span><span class="w"> </span><span class="s2">"&lt;stdin&gt;"</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="n">_pickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">:</span><span class="w"> </span><span class="n">Can</span><span class="s1">'t pickle &lt;class '</span><span class="n">__main__</span><span class="o">.</span><span class="n">LocalNT</span><span class="s1">'&gt;: attribute lookup LocalNT on __main__ failed</span>
</pre></div>

<blockquote>
<h3>为什么/什么时候应该使用命名元组而不是普通元组？</h3>
</blockquote>
<p>当它改进您的代码以在您的代码中表达元组元素的语义时使用它们。</p>
<p>如果您要使用具有不变数据属性且没有功能的对象，则可以使用它们而不是对象。</p>
<p>您还可以将它们子类化以添加功能，例如：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">'Point'</span><span class="p">,</span><span class="w"> </span><span class="s1">'x y'</span><span class="p">))</span><span class="err">:</span>
<span class="w">    </span><span class="ss">"""adding functionality to a named tuple"""</span>
<span class="w">        </span><span class="n">__slots__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="nv">@property</span>
<span class="w">        </span><span class="n">def</span><span class="w"> </span><span class="n">hypot</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mf">0.5</span>
<span class="w">        </span><span class="n">def</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s1">'Point: x=%6.3f  y=%6.3f  hypot=%6.3f'</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">hypot</span><span class="p">)</span>
</pre></div>

<blockquote>
<h3>为什么/什么时候应该使用普通元组而不是命名元组？</h3>
</blockquote>
<p>从使用命名元组切换到元组可能是一种回归。前期设计决策的核心是使用元组时所涉及的额外代码的成本是否值得提高可读性。</p>
<p>命名元组与元组相比没有使用额外的内存。</p>
<blockquote>
<h3>是否有任何类型的“命名列表”（命名元组的可变版本）？</h3>
</blockquote>
<p>您正在寻找一个实现静态大小列表的所有功能的带槽对象，或者一个像命名元组一样工作的子类列表（并且以某种方式阻止列表改变大小。）</p>
<p>第一个现在扩展的，甚至可能是 Liskov 替代的例子：</p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">class</span> <span class="nc">MutableTuple</span><span class="p">(</span><span class="n">Sequence</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">"""Abstract Base Class for objects that work like mutable</span>
<span class="sd">    namedtuples. Subclass and define your named fields with </span>
<span class="sd">    __slots__ and away you go.</span>
<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">slot</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="c1"># more direct __iter__ than Sequence's</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="c1"># Sequence requires __getitem__ &amp; __len__:</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span>
</pre></div>

<p>要使用，只需子类化并定义<code>__slots__</code>：</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Student</span>(<span class="n">MutableTuple</span>):
    <span class="n">__slots__</span> = <span class="s">'first'</span>, <span class="s">'last'</span>, <span class="s">'grade'</span> <span class="c1"># customize</span>


&gt;&gt;&gt; <span class="n">student</span> = <span class="n">Student</span>(<span class="s">'Lisa'</span>, <span class="s">'Simpson'</span>, <span class="s">'A'</span>)
&gt;&gt;&gt; <span class="n">student</span>
<span class="n">Student</span>(<span class="s">'Lisa'</span>, <span class="s">'Simpson'</span>, <span class="s">'A'</span>)
&gt;&gt;&gt; <span class="nb">first</span>, <span class="nb">last</span>, <span class="n">grade</span> = <span class="n">student</span>
&gt;&gt;&gt; <span class="nb">first</span>
<span class="s">'Lisa'</span>
&gt;&gt;&gt; <span class="nb">last</span>
<span class="s">'Simpson'</span>
&gt;&gt;&gt; <span class="n">grade</span>
<span class="s">'A'</span>
&gt;&gt;&gt; <span class="n">student</span>[<span class="mi">0</span>]
<span class="s">'Lisa'</span>
&gt;&gt;&gt; <span class="n">student</span>[<span class="mi">2</span>]
<span class="s">'A'</span>
&gt;&gt;&gt; <span class="n">len</span>(<span class="n">student</span>)
<span class="mi">3</span>
&gt;&gt;&gt; <span class="s">'Lisa'</span> <span class="nb">in</span> <span class="n">student</span>
<span class="nb">True</span>
&gt;&gt;&gt; <span class="s">'Bart'</span> <span class="nb">in</span> <span class="n">student</span>
<span class="nb">False</span>
&gt;&gt;&gt; <span class="n">student</span>.<span class="nb">first</span> = <span class="s">'Bart'</span>
&gt;&gt;&gt; <span class="k">for</span> <span class="n">i</span> <span class="nb">in</span> <span class="n">student:</span> <span class="nb">print</span>(<span class="n">i</span>)
... 
<span class="n">Bart</span>
<span class="n">Simpson</span>
<span class="n">A</span>
</pre></div>

<p><br><br><a href="../what-are-named-tuples-in-python/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/namedtuple/" rel="tag">namedtuple</a></li>
            <li><a class="tag p-category" href="../../categories/python/" rel="tag">python</a></li>
            <li><a class="tag p-category" href="../../categories/tuples/" rel="tag">tuples</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-an-zhuang-npm-bao-de-xian-qian-que-qie-ban-ben/" rel="prev" title="如何安装 NPM 包的先前确切版本？">Previous post</a>
            </li>
            <li class="next">
                <a href="../jiang-json-fan-xu-lie-hua-wei-c-dong-tai-dui-xiang/" rel="next" title="将 JSON 反序列化为 C# 动态对象？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
