<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java核心库中GoF设计模式的例子 | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/javahe-xin-ku-zhong-gofshe-ji-mo-shi-de-li-zi/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../cong-github-ke-long-shi-geng-gai-wen-jian-jia-ming-cheng/" title="从 GitHub 克隆时更改文件夹名称？" type="text/html">
<link rel="next" href="../shi-yong-lie-biao-zhong-de-max-min-huo-qu-fan-hui-de-zui-da-huo-zui-xiao-xiang-de-suo-yin/" title="使用列表中的 max()/min() 获取返回的最大或最小项的索引" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Java核心库中GoF设计模式的例子">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/javahe-xin-ku-zhong-gofshe-ji-mo-shi-de-li-zi/">
<meta property="og:description" content="这个问题的答案是 社区的努力。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。
我正在学习 GoF Java 设计模式，我想看看它们的一些真实示例。Java 核心库中这些设计模式的一些很好的例子是什么？

解答
您可以在维基百科中找到许多设计模式的概述。它还提到 GoF 提到了哪些模式。我将在这里总结它们并尝试分配尽可能多的模式实现，这些实现在 Java SE 和
Java EE API ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T18:58:06+08:00">
<meta property="article:tag" content="design-patterns">
<meta property="article:tag" content="java">
<meta property="article:tag" content="oop">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java核心库中GoF设计模式的例子</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T18:58:06+08:00" itemprop="datePublished" title="2023-02-17 18:58">2023-02-17 18:58</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>我正在学习 GoF Java 设计模式，我想看看它们的一些真实示例。Java 核心库中这些设计模式的一些很好的例子是什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>您可以在维基百科中找到许多设计模式的概述。它还提到 GoF 提到了哪些模式。我将在这里总结它们并尝试分配尽可能多的模式实现，这些实现在 Java SE 和
Java EE API 中都可以找到。</p>
<hr>
<h3>创作模式</h3>
<h4>抽象工厂 （可通过返回工厂本身的创建方法识别，而工厂本身又可用于创建另一个抽象/接口类型）</h4>
<ul>
<li><code>javax.xml.parsers.DocumentBuilderFactory#newInstance()</code></li>
<li><code>javax.xml.transform.TransformerFactory#newInstance()</code></li>
<li><code>javax.xml.xpath.XPathFactory#newInstance()</code></li>
</ul>
<h4>生成器 （可通过返回实例本身的创建方法识别）</h4>
<ul>
<li>
<code>java.lang.StringBuilder#append()</code>（不同步）</li>
<li>
<code>java.lang.StringBuffer#append()</code>（同步）</li>
<li>
<code>java.nio.ByteBuffer#put()</code>（也在<code>CharBuffer</code>, <code>ShortBuffer</code>, <code>IntBuffer</code>,<code>LongBuffer</code>和<code>FloatBuffer</code>上<code>DoubleBuffer</code>）</li>
<li><code>javax.swing.GroupLayout.Group#addComponent()</code></li>
<li>的所有实现<code>java.lang.Appendable</code>
</li>
<li><code>java.util.stream.Stream.Builder</code></li>
</ul>
<h4>工厂方法 （可通过返回抽象/接口类型实现的创建方法识别）</h4>
<ul>
<li><code>java.util.Calendar#getInstance()</code></li>
<li><code>java.util.ResourceBundle#getBundle()</code></li>
<li><code>java.text.NumberFormat#getInstance()</code></li>
<li><code>java.nio.charset.Charset#forName()</code></li>
<li>
<code>java.net.URLStreamHandlerFactory#createURLStreamHandler(String)</code>（根据协议返回单例对象）</li>
<li><code>java.util.EnumSet#of()</code></li>
<li>
<code>javax.xml.bind.JAXBContext#createMarshaller()</code>和其他类似的方法</li>
</ul>
<h4>原型（可通过返回具有相同属性的自身的 <em>不同</em> 实例的创建方法来识别） __</h4>
<ul>
<li>
<code>java.lang.Object#clone()</code>（该类必须实施<code>java.lang.Cloneable</code>）</li>
</ul>
<h4>单例 （可通过每次返回 <em>相同</em> 实例（通常是其自身）的创建方法来识别）</h4>
<ul>
<li><code>java.lang.Runtime#getRuntime()</code></li>
<li><code>java.awt.Desktop#getDesktop()</code></li>
<li><code>java.lang.System#getSecurityManager()</code></li>
</ul>
<hr>
<h3>结构模式</h3>
<h4>适配器（可通过采用 <em>不同</em> 抽象/接口类型的实例并返回 <em>装饰/覆盖</em> 给定实例的自己的/另一个抽象/接口类型的实现的创建方法来识别） <strong> </strong>
</h4>
<ul>
<li><code>java.util.Arrays#asList()</code></li>
<li><code>java.util.Collections#list()</code></li>
<li><code>java.util.Collections#enumeration()</code></li>
<li>
<code>java.io.InputStreamReader(InputStream)</code>（返回一个<code>Reader</code>）</li>
<li>
<code>java.io.OutputStreamWriter(OutputStream)</code>（返回一个<code>Writer</code>）</li>
<li>
<code>javax.xml.bind.annotation.adapters.XmlAdapter#marshal()</code>和<code>#unmarshal()</code>
</li>
</ul>
<h4>桥（可通过采用 <em>不同</em> 抽象/接口类型的实例并返回 <em>委托/使用给</em> 定实例的自己的抽象/接口类型的实现的创建方法来识别） <strong> </strong>
</h4>
<ul>
<li>还没有想到。一个虚构的例子是<code>new LinkedHashMap(LinkedHashSet&lt;K&gt;, List&lt;V&gt;)</code>返回一个不可修改的链接地图，它不克隆项目，而是 <em>使用</em> 它们。<code>java.util.Collections#newSetFromMap()</code>然而，方法<code>singletonXXX()</code>很接近。</li>
</ul>
<h4>Composite （可通过将 <em>相同</em> 抽象/接口类型的实例带入树结构的行为方法识别） __</h4>
<ul>
<li>
<code>java.awt.Container#add(Component)</code>（因此几乎遍及整个 Swing）</li>
<li>
<code>javax.faces.component.UIComponent#getChildren()</code>（因此实际上遍及 JSF UI）</li>
</ul>
<h4>装饰器（可通过采用 <em>相同</em> 抽象/接口类型的实例的创建方法来识别，该实例添加了额外的行为） __</h4>
<ul>
<li>
<code>java.io.InputStream</code>、<code>OutputStream</code>和<code>Reader</code>的所有子类<code>Writer</code>都有一个采用相同类型实例的构造函数。</li>
<li>
<code>java.util.Collections</code>、<code>checkedXXX()</code>和<code>synchronizedXXX()</code>方法<code>unmodifiableXXX()</code>。</li>
<li>
<code>javax.servlet.http.HttpServletRequestWrapper</code>和<code>HttpServletResponseWrapper</code>
</li>
<li><code>javax.swing.JScrollPane</code></li>
</ul>
<h4>外观 （可通过内部使用 <em>不同</em> 独立抽象/接口类型实例的行为方法识别）</h4>
<ul>
<li>
<code>javax.faces.context.FacesContext</code>，它在内部使用抽象/接口类型<code>LifeCycle</code>，等等<code>ViewHandler</code>，<code>NavigationHandler</code>而最终用户不必担心它（但是可以通过注入覆盖）。</li>
<li>
<code>javax.faces.context.ExternalContext</code>, 内部使用<code>ServletContext</code>, <code>HttpSession</code>, <code>HttpServletRequest</code>,<code>HttpServletResponse</code>等</li>
</ul>
<h4>享元 （可通过返回缓存实例的创建方法识别，有点“multiton”的想法）</h4>
<ul>
<li>
<code>java.lang.Integer#valueOf(int)</code>（也在<code>Boolean</code>, <code>Byte</code>, <code>Character</code>,<code>Short</code>和<code>Long</code>上<code>BigDecimal</code>）</li>
</ul>
<h4>代理 （可通过返回给定抽象/接口类型的实现的创建方法识别，后者又 <em>委托/使用</em> 给定抽象/接口类型的 <em>不同</em> 实现）</h4>
<ul>
<li><code>java.lang.reflect.Proxy</code></li>
<li><code>java.rmi.*</code></li>
<li>
<code>javax.ejb.EJB</code>（这里解释）</li>
<li>
<code>javax.inject.Inject</code>（这里解释）</li>
<li><code>javax.persistence.PersistenceContext</code></li>
</ul>
<hr>
<h3>行为模式</h3>
<h4>责任链（可通过行为方法识别，这些方法（间接地） 在队列中 <em>相同抽象/接口类型的</em> <em>另一个</em> 实现中调用相同的方法） <strong> </strong>
</h4>
<ul>
<li><code>java.util.logging.Logger#log()</code></li>
<li><code>javax.servlet.Filter#doFilter()</code></li>
</ul>
<h4>Command (recognizeable by behavioral methods in an abstract/interface type</h4>
<p>which invokes a method in an implementation of a <em>different</em>
abstract/interface type which has been <em>encapsulated</em> by the command
implementation during its creation)</p>
<ul>
<li>All implementations of <code>java.lang.Runnable</code>
</li>
<li>All implementations of <code>javax.swing.Action</code>
</li>
</ul>
<h4>Interpreter (recognizeable by behavioral methods returning a</h4>
<p><em>structurally</em> different instance/type of the given instance/type; note that
parsing/formatting is not part of the pattern, determining the pattern and how
to apply it is)</p>
<ul>
<li><code>java.util.Pattern</code></li>
<li><code>java.text.Normalizer</code></li>
<li>All subclasses of <code>java.text.Format</code>
</li>
<li>All subclasses of <code>javax.el.ELResolver</code>
</li>
</ul>
<h4>Iterator (recognizeable by behavioral methods sequentially returning</h4>
<p>instances of a <em>different</em> type from a queue)</p>
<ul>
<li>All implementations of <code>java.util.Iterator</code> (thus among others also <code>java.util.Scanner</code>!).</li>
<li>All implementations of <code>java.util.Enumeration</code>
</li>
</ul>
<h4>Mediator (recognizeable by behavioral methods taking an instance of</h4>
<p>different abstract/interface type (usually using the command pattern) which
delegates/uses the given instance)</p>
<ul>
<li>
<code>java.util.Timer</code> (all <code>scheduleXXX()</code> methods)</li>
<li><code>java.util.concurrent.Executor#execute()</code></li>
<li>
<code>java.util.concurrent.ExecutorService</code> (the <code>invokeXXX()</code> and <code>submit()</code> methods)</li>
<li>
<code>java.util.concurrent.ScheduledExecutorService</code> (all <code>scheduleXXX()</code> methods)</li>
<li><code>java.lang.reflect.Method#invoke()</code></li>
</ul>
<h4>Memento (recognizeable by behavioral methods which internally changes the</h4>
<p>state of the <em>whole</em> instance)</p>
<ul>
<li>
<code>java.util.Date</code> (the setter methods do that, <code>Date</code> is internally represented by a <code>long</code> value)</li>
<li>All implementations of <code>java.io.Serializable</code>
</li>
<li>All implementations of <code>javax.faces.component.StateHolder</code>
</li>
</ul>
<h4>Observer (or Publish/Subscribe) (recognizeable by behavioral methods which</h4>
<p>invokes a method on an instance of <em>another</em> abstract/interface type,
depending on own state)</p>
<ul>
<li>
<code>java.util.Observer</code>/<code>java.util.Observable</code> (rarely used in real world though)</li>
<li>All implementations of <code>java.util.EventListener</code> (practically all over Swing thus)</li>
<li><code>javax.servlet.http.HttpSessionBindingListener</code></li>
<li><code>javax.servlet.http.HttpSessionAttributeListener</code></li>
<li><code>javax.faces.event.PhaseListener</code></li>
</ul>
<h4>State (recognizeable by behavioral methods which changes its behaviour</h4>
<p>depending on the instance's state which can be controlled externally)</p>
<ul>
<li>
<code>javax.faces.lifecycle.LifeCycle#execute()</code> (controlled by <code>FacesServlet</code>, the behaviour is dependent on current phase (state) of JSF lifecycle)</li>
</ul>
<h4>Strategy (recognizeable by behavioral methods in an abstract/interface</h4>
<p>type which invokes a method in an implementation of a <em>different</em>
abstract/interface type which has been <em>passed-in</em> as method argument into the
strategy implementation)</p>
<ul>
<li>
<code>java.util.Comparator#compare()</code>, executed by among others <code>Collections#sort()</code>.</li>
<li>
<code>javax.servlet.http.HttpServlet</code>, the <code>service()</code> and all <code>doXXX()</code> methods take <code>HttpServletRequest</code> and <code>HttpServletResponse</code> and the implementor has to process them (and not to get hold of them as instance variables!).</li>
<li><code>javax.servlet.Filter#doFilter()</code></li>
</ul>
<h4>Template method (recognizeable by behavioral methods which already have a</h4>
<p>"default" behaviour defined by an abstract type)</p>
<ul>
<li>All non-abstract methods of <code>java.io.InputStream</code>, <code>java.io.OutputStream</code>, <code>java.io.Reader</code> and <code>java.io.Writer</code>.</li>
<li>All non-abstract methods of <code>java.util.AbstractList</code>, <code>java.util.AbstractSet</code> and <code>java.util.AbstractMap</code>.</li>
<li>
<code>javax.servlet.http.HttpServlet</code>, all the <code>doXXX()</code> methods by default sends a HTTP 405 "Method Not Allowed" error to the response. You're free to implement none or any of them.</li>
</ul>
<h4>访问者 （可由两种 <em>不同的</em> 抽象/接口类型识别，它们定义了方法，这些方法相互采用 <em>其他</em>
</h4>
<p>抽象/接口类型；一个实际上调用另一个的方法，另一个在其上执行所需的策略）</p>
<ul>
<li>
<code>javax.lang.model.element.AnnotationValue</code>和<code>AnnotationValueVisitor</code>
</li>
<li>
<code>javax.lang.model.element.Element</code>和<code>ElementVisitor</code>
</li>
<li>
<code>javax.lang.model.type.TypeMirror</code>和<code>TypeVisitor</code>
</li>
<li>
<code>java.nio.file.FileVisitor</code>和<code>SimpleFileVisitor</code>
</li>
<li>
<code>javax.faces.component.visit.VisitContext</code>和<code>VisitCallback</code>
</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<ol>
<li>整个挥杆过程中的观察者模式 ( <code>Observable</code>, <code>Observer</code>)</li>
<li>MVC 也在摇摆不定</li>
<li>适配器模式：InputStreamReader 和 OutputStreamWriter 注意：<code>ContainerAdapter</code>, <code>ComponentAdapter</code>, <code>FocusAdapter</code>, <code>KeyAdapter</code>,<code>MouseAdapter</code>不是 <em>适配器</em> ；它们实际上是空对象。Sun 命名选择不当。</li>
<li>装饰器模式（<code>BufferedInputStream</code>可以装饰其他流如<code>FilterInputStream</code>）</li>
<li>AWT 工具包和 Swing 可插入外观类的抽象工厂模式</li>
<li>
<code>java.lang.Runtime#getRuntime()</code>是单例</li>
<li>
<code>ButtonGroup</code>对于中介者模式</li>
<li>
<code>Action</code>,<code>AbstractAction</code>可用于不同的视觉表示以执行相同的代码 -&gt; 命令模式</li>
<li>Interned Strings or CellRender in JTable for Flyweight Pattern（还要考虑各种池——线程池、连接池、EJB对象池——享元实际上是关于共享资源的管理）</li>
<li>Java 1.0 事件模型是责任链的一个示例，Servlet 过滤器也是如此。</li>
<li>集合框架中的迭代器模式</li>
<li>AWT/Swing 中的嵌套容器使用 Composite 模式</li>
<li>AWT/Swing 中的布局管理器是策略的一个例子</li>
</ol>
<p>我想还有更多</p>
<p><br><br><a href="../examples-of-gof-design-patterns-in-java-s-core-libraries/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/design-patterns/" rel="tag">design-patterns</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/oop/" rel="tag">oop</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../cong-github-ke-long-shi-geng-gai-wen-jian-jia-ming-cheng/" rel="prev" title="从 GitHub 克隆时更改文件夹名称？">Previous post</a>
            </li>
            <li class="next">
                <a href="../shi-yong-lie-biao-zhong-de-max-min-huo-qu-fan-hui-de-zui-da-huo-zui-xiao-xiang-de-suo-yin/" rel="next" title="使用列表中的 max()/min() 获取返回的最大或最小项的索引">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
