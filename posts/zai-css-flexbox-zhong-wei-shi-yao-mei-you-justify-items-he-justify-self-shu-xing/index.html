<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>在 CSS Flexbox 中，为什么没有“justify-items”和“justify-self”属性？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/zai-css-flexbox-zhong-wei-shi-yao-mei-you-justify-items-he-justify-self-shu-xing/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ru-he-cong-grep-r-zhong-pai-chu-mu-lu/" title="如何从 grep -R 中排除目录？" type="text/html">
<link rel="next" href="../t-shuang-fu-hao-zai-c-11-zhong-shi-shi-yao-yi-si/" title="T&amp;&amp;（双符号）在 C++11 中是什么意思？" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="在 CSS Flexbox 中，为什么没有“justify-items”和“justify-self”属性？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/zai-css-flexbox-zhong-wei-shi-yao-mei-you-justify-items-he-justify-self-shu-xing/">
<meta property="og:description" content="考虑一个弹性容器的主轴和交叉轴：
 资料来源：W3C
要沿主轴对齐弹性项目，有一个属性：

justify-content

要沿交叉轴对齐弹性项目，需要三个属性：

align-content
align-items
align-self

在上图中，主轴是水平的，交叉轴是垂直的。这些是弹性容器的默认方向。
但是，这些方向可以很容易地与flex-direction酒店互换。
/* main ax">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T07:13:31+08:00">
<meta property="article:tag" content="css">
<meta property="article:tag" content="flexbox">
<meta property="article:tag" content="language-lawyer">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">在 CSS Flexbox 中，为什么没有“justify-items”和“justify-self”属性？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T07:13:31+08:00" itemprop="datePublished" title="2023-02-17 07:13">2023-02-17 07:13</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>考虑一个弹性容器的主轴和交叉轴：</p>
<p><img alt="应用于 row flex 容器的各种方向和大小术语的图示" src="../../images/9Oxw7.png"> 资料来源：W3C</p>
<p>要沿主轴对齐弹性项目，有一个属性：</p>
<ul>
<li><code>justify-content</code></li>
</ul>
<p>要沿交叉轴对齐弹性项目，需要三个属性：</p>
<ul>
<li><code>align-content</code></li>
<li><code>align-items</code></li>
<li><code>align-self</code></li>
</ul>
<p>在上图中，主轴是水平的，交叉轴是垂直的。这些是弹性容器的默认方向。</p>
<p>但是，这些方向可以很容易地与<code>flex-direction</code>酒店互换。</p>
<div class="code"><pre class="code literal-block"><span class="o">/*</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">horizontal</span><span class="p">,</span><span class="w"> </span><span class="nb">cross</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">vertical</span><span class="w"> </span><span class="o">*/</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">row</span><span class="p">;</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">row</span><span class="o">-</span><span class="n">reverse</span><span class="p">;</span>

<span class="o">/*</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">vertical</span><span class="p">,</span><span class="w"> </span><span class="nb">cross</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">horizontal</span><span class="w"> </span><span class="o">*/</span><span class="w">    </span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">column</span><span class="p">;</span>
<span class="n">flex</span><span class="o">-</span><span class="n">direction</span><span class="p">:</span><span class="w"> </span><span class="n">column</span><span class="o">-</span><span class="n">reverse</span><span class="p">;</span>
</pre></div>

<p>（横轴始终垂直于主轴。）</p>
<p>我在描述轴如何工作时的观点是，这两个方向似乎都没有什么特别之处。主轴，横轴，两者的重要性相当，<code>flex-direction</code>来回切换也很方便。</p>
<p><em>那么为什么横轴会获得两个额外的对齐属性呢？</em></p>
<p><em>为什么 和<code>align-content</code>合并<code>align-items</code>为主轴的一个属性？</em></p>
<p><em>为什么主轴没有得到属性<code>justify-self</code>？</em></p>
<hr>
<p>这些属性有用的场景：</p>
<ul>
<li>
<p>将弹性项目放在弹性容器的角落<br><code>#box3 { align-self: flex-end; justify-self: flex-end; }</code></p>
</li>
<li>
<p>使一组弹性项目右对齐（<code>justify-content: flex-end</code>）但第一个项目左对齐（<code>justify-self: flex-start</code>）</p>
</li>
</ul>
<p><em>考虑带有一组导航项和徽标的标题部分。 徽标<code>justify-
self</code>可以左对齐，而导航项保持在最右边，并且整个事物可以平滑地调整（“弯曲”）以适应不同的屏幕尺寸。</em></p>
<ul>
<li>在一排三个弹性项目中，将中间项目固定到容器的中心 ( <code>justify-content: center</code>) 并将相邻项目与容器边缘对齐 (<code>justify-self: flex-start</code>和<code>justify-self: flex-end</code>)。</li>
</ul>
<p><em>请注意，如果相邻项的宽度不同， values<code>space-around</code>和<code>space-
between</code>on属性将不会使中间项以容器为中心。<code>justify-content</code></em></p>
<p>显示代码片段</p>
<div class="code"><pre class="code literal-block">#container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>space-between;
<span class="w">  </span>background-color:<span class="w"> </span>lightyellow;
}
.box<span class="w"> </span>{
<span class="w">  </span>height:<span class="w"> </span>50px;
<span class="w">  </span>width:<span class="w"> </span>75px;
<span class="w">  </span>background-color:<span class="w"> </span>springgreen;
}
.box1<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>100px;
}
.box3<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>200px;
}
#center<span class="w"> </span>{
<span class="w">  </span>text-align:<span class="w"> </span>center;
<span class="w">  </span>margin-bottom:<span class="w"> </span>5px;
}
#center<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{
<span class="w">  </span>background-color:<span class="w"> </span>aqua;
<span class="w">  </span>padding:<span class="w"> </span>2px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"center"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>TRUE<span class="w"> </span>CENTER<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box1"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box2"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box3"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;p&gt;</span>note<span class="w"> </span>that<span class="w"> </span>the<span class="w"> </span>middlebox<span class="w"> </span>will<span class="w"> </span>only<span class="w"> </span>be<span class="w"> </span>truly<span class="w"> </span>centered<span class="w"> </span>if<span class="w"> </span>adjacent<span class="w"> </span>boxes<span class="w"> </span>are<span class="w"> </span>equal<span class="w"> </span>width<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p>jsFiddle版本</p>
<hr>
<p>在撰写本文时， flexbox 规范中没有提到<code>justify-self</code>or 。<code>justify-items</code></p>
<p>然而，在CSS Box Alignment Module中，这是 W3C 未完成的提议，旨在建立一组通用的对齐属性以供所有盒子模型使用，其中有：</p>
<p><img alt="在此处输入图像描述" src="../../images/uu2tP.png"> 资料来源：W3C</p>
<p>你会注意到<code>justify-self</code>和<code>justify-items</code>正在被考虑...... <em>但不是 flexbox</em> 。</p>
<hr>
<p>最后，我将重申主要问题：</p>
<blockquote>
<p>为什么没有“justify-items”和“justify-self”属性？</p>
</blockquote>
<p><br><br></p>
<h2>解答</h2>
<h3>沿主轴对齐 Flex 项目的方法</h3>
<p>如问题所述：</p>
<blockquote>
<p>要沿主轴对齐弹性项目，有一个属性：<code>justify-content</code></p>
<p>要沿交叉轴对齐弹性项目，需要三个属性：<code>align-content</code>,<code>align-items</code>和<code>align-self</code>。</p>
</blockquote>
<p>问题接着问：</p>
<blockquote>
<p>为什么没有<code>justify-items</code>and<code>justify-self</code>属性？</p>
</blockquote>
<p>一个答案可能是： <em>因为它们不是必需的。</em></p>
<p>flexbox规范提供了 <em>两种</em> 沿主轴对齐弹性项目的方法：</p>
<ol>
<li>关键字<code>justify-content</code>属性，以及</li>
<li>
<code>auto</code>边距</li>
</ol>
<hr>
<p>__</p>
<h3><em>证明内容</em></h3>
<p>该<code>justify-content</code>属性沿弹性容器的主轴对齐弹性项目。</p>
<p>它应用于 flex 容器，但只影响 flex 项目。</p>
<p>有五个对齐选项：</p>
<ul>
<li>
<strong><code>flex-start</code></strong> ~ Flex 项目被打包到行的开头。</li>
</ul>
<p><img alt="在此处输入图像描述" src="../../images/YOzeU.png"></p>
<ul>
<li>
<strong><code>flex-end</code></strong> ~ Flex 项目被打包到生产线的末尾。</li>
</ul>
<p><img alt="在此处输入图像描述" src="../../images/13Z1u.png"></p>
<ul>
<li>
<strong><code>center</code></strong> ~ Flex 项目被包装到线的中心。</li>
</ul>
<p><img alt="在此处输入图像描述" src="../../images/oKi7M.png"></p>
<ul>
<li>
<strong><code>space-between</code></strong> ~ 弹性项目均匀分布，第一个项目与容器的一个边缘对齐，最后一个项目与相对的边缘对齐。第一项和最后一项使用的边缘取决于<code>flex-direction</code>书写模式（<code>ltr</code>或<code>rtl</code>）。</li>
</ul>
<p><img alt="在此处输入图像描述" src="../../images/0mQqd.png"></p>
<ul>
<li>
<strong><code>space-around</code></strong> ~<code>space-between</code>除了两端有一半大小的空间外，其他都一样。</li>
</ul>
<p><img alt="在此处输入图像描述" src="../../images/u4BH6.png"></p>
<hr>
<h3>自动保证金</h3>
<p>有了<code>auto</code>margins，弹性项目可以居中，间隔开或打包成子组。</p>
<p><code>justify-content</code>与适用于 flex 容器的不同， <code>auto</code>margins 用于 flex 项目。</p>
<p>它们通过消耗指定方向上的所有可用空间来工作。</p>
<hr>
<h4>将一组弹性项目向右对齐，但第一个项目向左对齐</h4>
<p>问题场景：</p>
<blockquote>
<ul>
<li>使一组弹性项目右对齐（<code>justify-content: flex-end</code>）但第一个项目左对齐（<code>justify-self: flex-
start</code>）</li>
</ul>
<p><em>考虑带有一组导航项和徽标的标题部分。 徽标<code>justify-
self</code>可以左对齐，而导航项保持在最右边，并且整个事物可以平滑地调整（“弯曲”）以适应不同的屏幕尺寸。</em></p>
</blockquote>
<p><img alt="在此处输入图像描述" src="../../images/D3Vnv.png"></p>
<p><img alt="在此处输入图像描述" src="../../images/Um8DM.png"></p>
<hr>
<p><strong><em>其他有用的场景：</em></strong></p>
<p><img alt="在此处输入图像描述" src="../../images/qLzgU.png"></p>
<p><img alt="在此处输入图像描述" src="../../images/HtaOc.png"></p>
<p><img alt="在此处输入图像描述" src="../../images/M2WkZ.png"></p>
<hr>
<h4>在角落放置一个弹性项目</h4>
<p>问题场景：</p>
<blockquote>
<ul>
<li>将弹性项目放在角落<code>.box { align-self: flex-end; justify-self: flex-end; }</code>
</li>
</ul>
</blockquote>
<p><img alt="在此处输入图像描述" src="../../images/BtbfK.png"></p>
<hr>
<h4>垂直和水平居中弹性项目</h4>
<p><img alt="在此处输入图像描述" src="../../images/lV9a0.png"></p>
<p><code>margin: auto``justify-content: center</code>是and的替代品<code>align-items: center</code>。</p>
<p>而不是 flex 容器上的这段代码：</p>
<div class="code"><pre class="code literal-block"><span class="na">.container</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">justify-content:</span><span class="w"> </span><span class="nf">center</span><span class="c1">;</span>
<span class="w">    </span><span class="nl">align-items:</span><span class="w"> </span><span class="nf">center</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p>您可以在弹性项目上使用它：</p>
<div class="code"><pre class="code literal-block"><span class="na">.box56</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">margin:</span><span class="w"> </span><span class="nf">auto</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>

<p><strong>当将溢出容器的弹性项目居中时，</strong> 此替代方案很有用。</p>
<hr>
<h4>居中弹性项目，并在第一个和边缘之间居中第二个弹性项目</h4>
<p>A flex container aligns flex items by distributing free space.</p>
<p>Hence, in order to create <em>equal balance</em> , so that a middle item can be
centered in the container with a single item alongside, a counterbalance must
be introduced.</p>
<p>In the examples below, invisible third flex items (boxes 61 &amp; 68) are
introduced to balance out the "real" items (box 63 &amp; 66).</p>
<p><img alt="在此处输入图像描述" src="../../images/3IeTy.png"></p>
<p><img alt="在此处输入图像描述" src="../../images/BmtRt.png"></p>
<p>Of course, this method is nothing great in terms of semantics.</p>
<p>Alternatively, you can use a pseudo-element instead of an actual DOM element.
Or you can use absolute positioning. All three methods are covered here:
<strong>Center and bottom-align flex items</strong></p>
<p><em>NOTE: The examples above will only work – in terms of true centering – when
the outermost items are equal height/width. When flex items are different
lengths, see next example.</em></p>
<hr>
<h4>Center a flex item when adjacent items vary in size</h4>
<p>Scenario from the question:</p>
<blockquote>
<ul>
<li>in a row of three flex items, affix the middle item to the center of the
container (<code>justify-content: center</code>) and align the adjacent items to the
container edges (<code>justify-self: flex-start</code> and <code>justify-self: flex-end</code>).</li>
</ul>
<p><em>Note that values<code>space-around</code> and <code>space-between</code> on <code>justify-content</code>
property will not keep the middle item centered in relation to the container
if the adjacent items have different widths (see demo).</em></p>
</blockquote>
<p>As noted, unless all flex items are of equal width or height (depending on
<code>flex-direction</code>), the middle item cannot be truly centered. This problem
makes a strong case for a <code>justify-self</code> property (designed to handle the
task, of course).</p>
<p>显示代码片段</p>
<div class="code"><pre class="code literal-block">#container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>space-between;
<span class="w">  </span>background-color:<span class="w"> </span>lightyellow;
}
.box<span class="w"> </span>{
<span class="w">  </span>height:<span class="w"> </span>50px;
<span class="w">  </span>width:<span class="w"> </span>75px;
<span class="w">  </span>background-color:<span class="w"> </span>springgreen;
}
.box1<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>100px;
}
.box3<span class="w"> </span>{
<span class="w">  </span>width:<span class="w"> </span>200px;
}
#center<span class="w"> </span>{
<span class="w">  </span>text-align:<span class="w"> </span>center;
<span class="w">  </span>margin-bottom:<span class="w"> </span>5px;
}
#center<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{
<span class="w">  </span>background-color:<span class="w"> </span>aqua;
<span class="w">  </span>padding:<span class="w"> </span>2px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"center"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;span&gt;</span>TRUE<span class="w"> </span>CENTER<span class="nt">&lt;/span&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box1"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box2"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box3"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;p&gt;</span>The<span class="w"> </span>middle<span class="w"> </span>box<span class="w"> </span>will<span class="w"> </span>be<span class="w"> </span>truly<span class="w"> </span>centered<span class="w"> </span>only<span class="w"> </span>if<span class="w"> </span>adjacent<span class="w"> </span>boxes<span class="w"> </span>are<span class="w"> </span>equal<span class="w"> </span>width.<span class="nt">&lt;/p&gt;</span>
</pre></div>

<p><em>Here are two methods for solving this problem:</em></p>
<p><strong><em>Solution #1: Absolute Positioning</em></strong></p>
<p>The flexbox spec allows for absolute positioning of flex items. This allows
for the middle item to be perfectly centered regardless of the size of its
siblings.</p>
<p>Just keep in mind that, like all absolutely positioned elements, the items are
removed from the document flow. This means they don't take up space in the
container and can overlap their siblings.</p>
<p>In the examples below, the middle item is centered with absolute positioning
and the outer items remain in-flow. But the same layout can be achieved in
reverse fashion: Center the middle item with <code>justify-content: center</code> and
absolutely position the outer items.</p>
<p><img alt="在此处输入图像描述" src="../../images/U1eLb.png"></p>
<p><strong><em>Solution #2: Nested Flex Containers (no absolute positioning)</em></strong></p>
<div class="code"><pre class="code literal-block">.container<span class="w"> </span>{
<span class="w">  </span>display:<span class="w"> </span>flex;
}
.box<span class="w"> </span>{
<span class="w">  </span>flex:<span class="w"> </span>1;
<span class="w">  </span>display:<span class="w"> </span>flex;
<span class="w">  </span>justify-content:<span class="w"> </span>center;
}
.box71<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{<span class="w"> </span>margin-right:<span class="w"> </span>auto;<span class="w"> </span>}
.box73<span class="w"> </span>&gt;<span class="w"> </span>span<span class="w"> </span>{<span class="w"> </span>margin-left:<span class="w"> </span>auto;<span class="w">  </span>}

/*<span class="w"> </span>non-essential<span class="w"> </span>*/
.box<span class="w"> </span>{
<span class="w">  </span>align-items:<span class="w"> </span>center;
<span class="w">  </span>border:<span class="w"> </span>1px<span class="w"> </span>solid<span class="w"> </span>#ccc;
<span class="w">  </span>background-color:<span class="w"> </span>lightgreen;
<span class="w">  </span>height:<span class="w"> </span>40px;
}


<span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box71"</span><span class="nt">&gt;&lt;span&gt;</span>71<span class="w"> </span>short<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box72"</span><span class="nt">&gt;&lt;span&gt;</span>72<span class="w"> </span>centered<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="w">  </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">"box box73"</span><span class="nt">&gt;&lt;span&gt;</span>73<span class="w"> </span>loooooooooooooooong<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>

<p>运行代码片段隐藏结果</p>
<p>Here's how it works:</p>
<ul>
<li>The top-level div (<code>.container</code>) is a flex container.</li>
<li>Each child div (<code>.box</code>) is now a flex item.</li>
<li>Each <code>.box</code> item is given <code>flex: 1</code> in order to distribute container space equally.</li>
<li>Now the items are consuming all space in the row and are equal width.</li>
<li>Make each item a (nested) flex container and add <code>justify-content: center</code>.</li>
<li>Now each <code>span</code> element is a centered flex item.</li>
<li>Use flex <code>auto</code> margins to shift the outer <code>span</code>s left and right.</li>
</ul>
<p>You could also forgo <code>justify-content</code> and use <code>auto</code> margins exclusively.</p>
<p>But <code>justify-content</code> can work here because <code>auto</code> margins always have
priority. From the spec:</p>
<blockquote>
<p><strong>8.1. Aligning with<code>auto</code> margins</strong></p>
<p>Prior to alignment via <code>justify-content</code> and <code>align-self</code>, any positive free
space is distributed to auto margins in that dimension.</p>
</blockquote>
<hr>
<p>__</p>
<h4><em>justify-content: space-same (concept)</em></h4>
<p>Going back to <code>justify-content</code> for a minute, here's an idea for one more
option.</p>
<ul>
<li>
<strong><code>space-same</code></strong> ~ A hybrid of <code>space-between</code> and <code>space-around</code>. Flex items are evenly spaced (like <code>space-between</code>), except instead of half-size spaces on both ends (like <code>space-around</code>), there are full-size spaces on both ends.</li>
</ul>
<p>This layout can be achieved with <code>::before</code> and <code>::after</code> pseudo-elements on
the flex container.</p>
<p><img alt="在此处输入图像描述" src="../../images/Jjw9w.png"></p>
<p><em>(credit: @oriol for the code, and @crl for the label)</em></p>
<p><strong>UPDATE:</strong> Browsers have begun implementing <strong><code>space-evenly</code></strong> , which
accomplishes the above. See this post for details: Equal space between flex
items</p>
<hr>
<p><strong>PLAYGROUND</strong> (includes code for all examples above)</p>
<p><br></p>
<h3>更多建议</h3>
<p>我知道这不是一个答案，但我愿意为这件事的价值做出贡献。<code>justify-self</code>如果他们可以发布flexbox 使其真正灵活，那就太好了。</p>
<p>我相信当轴上有多个项目时，最合乎逻辑的<code>justify-self</code>行为方式是将自己与其最近的邻居（或边缘）对齐，如下所示。</p>
<p>我真的希望 W3C 注意到这一点并且至少会考虑它。=)</p>
<p><img alt="在此处输入图像描述" src="../../images/wpSsJ.jpg"></p>
<p>这样你就可以拥有一个真正居中的项目，而不管左右框的大小。当其中一个盒子到达中心盒子的点时，它会简单地推动它，直到没有更多的空间可以分配。</p>
<p><img alt="在此处输入图像描述" src="../../images/NgobL.gif"></p>
<p>制作很棒的布局的便利是无穷无尽的，看看这个“复杂”的例子。</p>
<p><img alt="在此处输入图像描述" src="../../images/U2ELF.png"></p>
<p><br><br><a href="../in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/css/" rel="tag">css</a></li>
            <li><a class="tag p-category" href="../../categories/flexbox/" rel="tag">flexbox</a></li>
            <li><a class="tag p-category" href="../../categories/language-lawyer/" rel="tag">language-lawyer</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ru-he-cong-grep-r-zhong-pai-chu-mu-lu/" rel="prev" title="如何从 grep -R 中排除目录？">Previous post</a>
            </li>
            <li class="next">
                <a href="../t-shuang-fu-hao-zai-c-11-zhong-shi-shi-yao-yi-si/" rel="next" title="T&amp;&amp;（双符号）在 C++11 中是什么意思？">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
