<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What is the scope of variables in JavaScript? | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/what-is-the-scope-of-variables-in-javascript/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../how-can-i-git-stash-a-specific-file/" title="How can I git stash a specific file?" type="text/html">
<link rel="next" href="../how-do-i-delete-an-exported-environment-variable/" title="How do I delete an exported environment variable?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="What is the scope of variables in JavaScript?">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/what-is-the-scope-of-variables-in-javascript/">
<meta property="og:description" content="What is the scope of variables in javascript? Do they have the same scope
inside as opposed to outside a function? Or does it even matter? Also, where
are the variables stored if they are defined glob">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-16T22:20:39+08:00">
<meta property="article:tag" content="function">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="scope">
<meta property="article:tag" content="var">
<meta property="article:tag" content="variables">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">What is the scope of variables in JavaScript?</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-16T22:20:39+08:00" itemprop="datePublished" title="2023-02-16 22:20">2023-02-16 22:20</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>What is the scope of variables in javascript? Do they have the same scope
inside as opposed to outside a function? Or does it even matter? Also, where
are the variables stored if they are defined globally?</p>
<p><br><br></p>
<h2>Answer</h2>
<h3>TLDR</h3>
<p>JavaScript has lexical (also called static) scoping and closures. This means
you can tell the scope of an identifier by looking at the source code.</p>
<p>The four scopes are:</p>
<ol>
<li>Global - visible by everything</li>
<li>Function - visible within a function (and its sub-functions and blocks)</li>
<li>Block - visible within a block (and its sub-blocks)</li>
<li>Module - visible within a module</li>
</ol>
<p>Outside of the special cases of global and module scope, variables are
declared using <code>var</code> (function scope), <code>let</code> (block scope), and <code>const</code> (block
scope). Most other forms of identifier declaration have block scope in strict
mode.</p>
<h3>Overview</h3>
<p>Scope is the region of the codebase over which an identifier is valid.</p>
<p>A lexical environment is a mapping between identifier names and the values
associated with them.</p>
<p>Scope is formed of a linked nesting of lexical environments, with each level
in the nesting corresponding to a lexical environment of an ancestor execution
context.</p>
<p>These linked lexical environments form a scope "chain". Identifier resolution
is the process of searching along this chain for a matching identifier.</p>
<p>Identifier resolution only occurs in one direction: outwards. In this way,
outer lexical environments cannot "see" into inner lexical environments.</p>
<p>There are three pertinent factors in deciding the scope of an identifier in
JavaScript:</p>
<ol>
<li>How an identifier was declared</li>
<li>Where an identifier was declared</li>
<li>Whether you are in strict mode or non-strict mode</li>
</ol>
<p>Some of the ways identifiers can be declared:</p>
<ol>
<li>
<code>var</code>, <code>let</code> and <code>const</code>
</li>
<li>Function parameters</li>
<li>Catch block parameter</li>
<li>Function declarations</li>
<li>Named function expressions</li>
<li>Implicitly defined properties on the global object (i.e., missing out <code>var</code> in non-strict mode)</li>
<li>
<code>import</code> statements</li>
<li><code>eval</code></li>
</ol>
<p>Some of the locations identifiers can be declared:</p>
<ol>
<li>Global context</li>
<li>Function body</li>
<li>Ordinary block</li>
<li>The top of a control structure (e.g., loop, if, while, etc.)</li>
<li>Control structure body</li>
<li>Modules</li>
</ol>
<h3>Declaration Styles</h3>
<h4>var</h4>
<p>Identifiers declared using <code>var</code> <strong>have function scope</strong> , apart from when
they are declared directly in the global context, in which case they are added
as properties on the global object and have global scope. There are separate
rules for their use in <code>eval</code> functions.</p>
<h4>let and const</h4>
<p>Identifiers declared using <code>let</code> and <code>const</code> <strong>have block scope</strong> , apart from
when they are declared directly in the global context, in which case they have
global scope.</p>
<p>Note: <code>let</code>, <code>const</code> and <code>var</code> are all hoisted. This means that their logical
position of definition is the top of their enclosing scope (block or
function). However, variables declared using <code>let</code> and <code>const</code> cannot be read
or assigned to until control has passed the point of declaration in the source
code. The interim period is known as the temporal dead zone.</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">function</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">g</span><span class="p">()</span>
<span class="err">}</span>
<span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">hoisted</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">though</span><span class="w"> </span><span class="n">declared</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n n-Quoted">`let`</span><span class="o">!</span>
</pre></div>

<h4>Function parameter names</h4>
<p>Function parameter names are scoped to the function body. Note that there is a
slight complexity to this. Functions declared as default arguments close over
the parameter list, and not the body of the function.</p>
<h4>Function declarations</h4>
<p>Function declarations have block scope in strict mode and function scope in
non-strict mode. Note: non-strict mode is a complicated set of emergent rules
based on the quirky historical implementations of different browsers.</p>
<h4>Named function expressions</h4>
<p>Named function expressions are scoped to themselves (e.g., for the purpose of
recursion).</p>
<h4>Implicitly defined properties on the global object</h4>
<p>In non-strict mode, implicitly defined properties on the global object have
global scope, because the global object sits at the top of the scope chain. In
strict mode, these are not permitted.</p>
<h4>eval</h4>
<p>In <code>eval</code> strings, variables declared using <code>var</code> will be placed in the
current scope, or, if <code>eval</code> is used indirectly, as properties on the global
object.</p>
<h3>Examples</h3>
<p>The following will throw a ReferenceError because the names<code>x</code>, <code>y</code>, and <code>z</code>
have no meaning outside of the function <code>f</code>.</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="p">}</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">typeof</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">(</span><span class="n">because</span><span class="w"> </span><span class="k">var</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">scope</span><span class="o">!</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">typeof</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">(</span><span class="n">because</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">block</span><span class="p">)</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">typeof</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">(</span><span class="n">because</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">block</span><span class="p">)</span>
</pre></div>

<p>The following will throw a ReferenceError for <code>y</code> and <code>z</code>, but not for <code>x</code>,
because the visibility of <code>x</code> is not constrained by the block. Blocks that
define the bodies of control structures like <code>if</code>, <code>for</code>, and <code>while</code>, behave
similarly.</p>
<div class="code"><pre class="code literal-block"><span class="err">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">1</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`y`</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="k">block</span><span class="w"> </span><span class="n">scope</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`z`</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="k">block</span><span class="w"> </span><span class="n">scope</span>
</pre></div>

<p>In the following, <code>x</code> is visible outside of the loop because <code>var</code> has
function scope:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="n">note</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">loop</span><span class="o">!</span><span class="p">)</span>
</pre></div>

<p>...because of this behavior, you need to be careful about closing over
variables declared using <code>var</code> in loops. There is only one instance of
variable <code>x</code> declared here, and it sits logically outside of the loop.</p>
<p>The following prints <code>5</code>, five times, and then prints <code>5</code> a sixth time for the
<code>console.log</code> outside the loop:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="n">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">set</span><span class="n">Timeout</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">closes</span><span class="w"> </span><span class="k">over</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n n-Quoted">`x`</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">logically</span><span class="w"> </span><span class="n">positioned</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">enclosing</span><span class="w"> </span><span class="n">scope</span><span class="p">,</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">loop</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">note</span><span class="o">:</span><span class="w"> </span><span class="k">visible</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">loop</span>
</pre></div>

<p>The following prints <code>undefined</code> because <code>x</code> is block-scoped. The callbacks
are run one by one asynchronously. New behavior for <code>let</code> variables means that
each anonymous function closed over a different variable named <code>x</code> (unlike it
would have done with <code>var</code>), and so integers <code>0</code> through <code>4</code> are printed.:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="k">set</span><span class="n">Timeout</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`let`</span><span class="w"> </span><span class="n">declarations</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">re</span><span class="o">-</span><span class="n">declared</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">per</span><span class="o">-</span><span class="n">iteration</span><span class="w"> </span><span class="n">basis</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">closures</span><span class="w"> </span><span class="n">capture</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="k">variables</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span>
</pre></div>

<p>The following will NOT throw a <code>ReferenceError</code> because the visibility of <code>x</code>
is not constrained by the block; it will, however, print <code>undefined</code> because
the variable has not been initialised (because of the <code>if</code> statement).</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="p">(</span><span class="no">false</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">here</span><span class="p">,</span><span class="w"> </span><span class="n n-Quoted">`x`</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">declared</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">initialised</span>
</pre></div>

<p>A variable declared at the top of a <code>for</code> loop using <code>let</code> is scoped to the
body of the loop:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">{}</span><span class="w"> </span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`x`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">block</span><span class="o">-</span><span class="n">scoped</span>
</pre></div>

<p>The following will throw a <code>ReferenceError</code> because the visibility of <code>x</code> is
constrained by the block:</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="p">(</span><span class="no">false</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`x`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">block</span><span class="o">-</span><span class="n">scoped</span>
</pre></div>

<p>Variables declared using <code>var</code>, <code>let</code> or <code>const</code> are all scoped to modules:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span> <span class="n">module1</span><span class="o">.</span><span class="n">js</span>

<span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">export</span> <span class="n">function</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="o">//</span><span class="n">module2</span><span class="o">.</span><span class="n">js</span>

<span class="kn">import</span> <span class="nn">f</span> <span class="kn">from</span> <span class="s1">'module1.js'</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="n">throws</span> <span class="ne">ReferenceError</span>
</pre></div>

<p>The following will declare a property on the global object because variables
declared using <code>var</code> within the global context are added as properties to the
global object:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="s1">'x'</span><span class="p">))</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="bp">true</span>
</pre></div>

<p><code>let</code> and <code>const</code> in the global context do not add properties to the global
object, but still have global scope:</p>
<div class="code"><pre class="code literal-block">let x = 1
console.log(window.hasOwnProperty('x')) // false
</pre></div>

<p>Function parameters can be considered to be declared in the function body:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">{}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`x`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">scoped</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">function</span>
</pre></div>

<p>Catch block parameters are scoped to the catch-block body:</p>
<div class="code"><pre class="code literal-block"><span class="n">try</span><span class="w"> </span><span class="err">{}</span><span class="w"> </span><span class="n">catch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="err">{}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`e`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">scoped</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="k">block</span>
</pre></div>

<p>Named function expressions are scoped only to the expression itself:</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="err">}</span><span class="p">)()</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`foo`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">scoped</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">own</span><span class="w"> </span><span class="n">expression</span>
</pre></div>

<p>In non-strict mode, implicitly defined properties on the global object are
globally scoped. In strict mode, you get an error.</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">implicitly</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">global</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="p">(</span><span class="n">no</span><span class="w"> </span><span class="s2">"var"</span><span class="o">!</span><span class="p">)</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">1</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="s1">'x'</span><span class="p">))</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="bp">true</span>
</pre></div>

<p>In non-strict mode, function declarations have function scope. In strict mode,
they have block scope.</p>
<div class="code"><pre class="code literal-block"><span class="s1">'use strict'</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">function</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="err">{}</span>
<span class="err">}</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">typeof</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">undefined</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n n-Quoted">`foo`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">block</span><span class="o">-</span><span class="n">scoped</span>
</pre></div>

<h3>How it works under the hood</h3>
<p>Scope is defined as the lexical region of code over which an identifier is
valid.</p>
<p>In JavaScript, every function-object has a hidden <code>[[Environment]]</code> reference
that is a reference to the lexical environment of the execution context (stack
frame) within which it was created.</p>
<p>When you invoke a function, the hidden <code>[[Call]]</code> method is called. This
method creates a new execution context and establishes a link between the new
execution context and the lexical environment of the function-object. It does
this by copying the <code>[[Environment]]</code> value on the function-object, into an
outer reference field on the lexical environment of the new execution context.</p>
<p>Note that this link between the new execution context and the lexical
environment of the function object is called a closure.</p>
<p>Thus, in JavaScript, scope is implemented via lexical environments linked
together in a "chain" by outer references. This chain of lexical environments
is called the scope chain, and identifier resolution occurs by searching up
the chain for a matching identifier.</p>
<p>Find out more.</p>
<p><br></p>
<h3>Suggest</h3>
<p>Javascript uses scope chains to establish the scope for a given function.
There is typically one global scope, and each function defined has its own
nested scope. Any function defined within another function has a local scope
which is linked to the outer function. It's always the position in the source
that defines the scope.</p>
<p>An element in the scope chain is basically a Map with a pointer to its parent
scope.</p>
<p>When resolving a variable, javascript starts at the innermost scope and
searches outwards.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/function/" rel="tag">function</a></li>
            <li><a class="tag p-category" href="../../categories/javascript/" rel="tag">javascript</a></li>
            <li><a class="tag p-category" href="../../categories/scope/" rel="tag">scope</a></li>
            <li><a class="tag p-category" href="../../categories/var/" rel="tag">var</a></li>
            <li><a class="tag p-category" href="../../categories/variables/" rel="tag">variables</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../how-can-i-git-stash-a-specific-file/" rel="prev" title="How can I git stash a specific file?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-do-i-delete-an-exported-environment-variable/" rel="next" title="How do I delete an exported environment variable?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
