<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java 8 Iterable.forEach() vs foreach loop | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/java-8-iterable-foreach-vs-foreach-loop/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../ef-migrations-rollback-last-applied-migration/" title="EF Migrations: Rollback last applied migration?" type="text/html">
<link rel="next" href="../seeding-the-random-number-generator-in-javascript/" title="Seeding the random number generator in Javascript" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Java 8 Iterable.forEach() vs foreach loop">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/java-8-iterable-foreach-vs-foreach-loop/">
<meta property="og:description" content="Which of the following is better practice in Java 8?
Java 8:
joins.forEach(join -&gt; mIrc.join(mSession, join));


Java 7:
for (String join : joins) {
    mIrc.join(mSession, join);
}


I have lots of f">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-18T05:21:43+08:00">
<meta property="article:tag" content="for-loop">
<meta property="article:tag" content="java">
<meta property="article:tag" content="java-8">
<meta property="article:tag" content="java-stream">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Java 8 Iterable.forEach() vs foreach loop</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-18T05:21:43+08:00" itemprop="datePublished" title="2023-02-18 05:21">2023-02-18 05:21</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Which of the following is better practice in Java 8?</p>
<p>Java 8:</p>
<div class="code"><pre class="code literal-block"><span class="n">joins</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="nf">join</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">mIrc</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">mSession</span><span class="p">,</span><span class="w"> </span><span class="nf">join</span><span class="p">));</span>
</pre></div>

<p>Java 7:</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">String</span><span class="w"> </span><span class="nv">join</span><span class="w"> </span>:<span class="w"> </span><span class="nv">joins</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">mIrc</span>.<span class="nv">join</span><span class="ss">(</span><span class="nv">mSession</span>,<span class="w"> </span><span class="nv">join</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>I have lots of for loops that could be "simplified" with lambdas, but is there
really any advantage of using them? Would it improve their performance and
readability?</p>
<p><strong>EDIT</strong></p>
<p>I'll also extend this question to longer methods. I know that you can't return
or break the parent function from a lambda and this should also be taken into
consideration when comparing them, but is there anything else to be
considered?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The better practice is to use <code>for-each</code>. Besides violating the <em>Keep It
Simple, Stupid</em> principle, the new-fangled <code>forEach()</code> has at least the
following deficiencies:</p>
<ul>
<li>
<strong>Can't use non-final variables</strong>. So, code like the following can't be turned into a forEach lambda:</li>
</ul>
<blockquote>
<div class="code"><pre class="code literal-block"><span class="nv">Object</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">null</span><span class="c1">;</span>
<span class="k">for</span><span class="ss">(</span><span class="nv">Object</span><span class="w"> </span><span class="nv">curr</span><span class="w"> </span>:<span class="w"> </span><span class="nv">list</span><span class="ss">)</span>
{
<span class="w">    </span><span class="k">if</span><span class="ss">(</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">null</span><span class="w"> </span><span class="ss">)</span>
<span class="w">        </span><span class="nv">foo</span><span class="ss">(</span><span class="nv">prev</span>,<span class="w"> </span><span class="nv">curr</span><span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">curr</span><span class="c1">;</span>
}
</pre></div>

</blockquote>
<ul>
<li>
<p><strong>Can't handle checked exceptions</strong>. Lambdas aren't actually forbidden from throwing checked exceptions, but common functional interfaces like <code>Consumer</code> don't declare any. Therefore, any code that throws checked exceptions must wrap them in <code>try-catch</code> or <code>Throwables.propagate()</code>. But even if you do that, it's not always clear what happens to the thrown exception. It could get swallowed somewhere in the guts of <code>forEach()</code></p>
</li>
<li>
<p><strong>Limited flow-control</strong>. A <code>return</code> in a lambda equals a <code>continue</code> in a for-each, but there is no equivalent to a <code>break</code>. It's also difficult to do things like return values, short circuit, or <em>set flags</em> (which would have alleviated things a bit, if it wasn't a violation of the <em>no non-final variables</em> rule). "This is not just an optimization, but critical when you consider that some sequences (like reading the lines in a file) may have side-effects, or you may have an infinite sequence."</p>
</li>
<li>
<p><strong>Might execute in parallel</strong> , which is a horrible, horrible thing for all but the 0.1% of your code that needs to be optimized. Any parallel code has to be thought through (even if it doesn't use locks, volatiles, and other particularly nasty aspects of traditional multi-threaded execution). Any bug will be tough to find.</p>
</li>
<li>
<p><strong>Might hurt performance</strong> , because the JIT can't optimize forEach()+lambda to the same extent as plain loops, especially now that lambdas are new. By "optimization" I do not mean the overhead of calling lambdas (which is small), but to the sophisticated analysis and transformation that the modern JIT compiler performs on running code.</p>
</li>
<li>
<p><strong>If you do need parallelism, it is probably much faster and not much more difficult to use an ExecutorService</strong>. Streams are both automagical (read: don't know much about your problem) <em>and</em> use a specialized (read: inefficient for the general case) parallelization strategy (fork-join recursive decomposition).</p>
</li>
<li>
<p><strong>Makes debugging more confusing</strong> , because of the nested call hierarchy and, god forbid, parallel execution. The debugger may have issues displaying variables from the surrounding code, and things like step-through may not work as expected.</p>
</li>
<li>
<p><strong>Streams in general are more difficult to code, read, and debug</strong>. Actually, this is true of complex "fluent" APIs in general. The combination of complex single statements, heavy use of generics, and lack of intermediate variables conspire to produce confusing error messages and frustrate debugging. Instead of "this method doesn't have an overload for type X" you get an error message closer to "somewhere you messed up the types, but we don't know where or how." Similarly, you can't step through and examine things in a debugger as easily as when the code is broken into multiple statements, and intermediate values are saved to variables. Finally, reading the code and understanding the types and behavior at each stage of execution may be non-trivial.</p>
</li>
<li>
<p><strong>Sticks out like a sore thumb</strong>. The Java language already has the for-each statement. Why replace it with a function call? Why encourage hiding side-effects somewhere in expressions? Why encourage unwieldy one-liners? Mixing regular for-each and new forEach willy-nilly is bad style. Code should speak in idioms (patterns that are quick to comprehend due to their repetition), and the fewer idioms are used the clearer the code is and less time is spent deciding which idiom to use (a big time-drain for perfectionists like myself!).</p>
</li>
</ul>
<p>As you can see, I'm not a big fan of the forEach() except in cases when it
makes sense.</p>
<p>Particularly offensive to me is the fact that <code>Stream</code> does not implement
<code>Iterable</code> (despite actually having method <code>iterator</code>) and cannot be used in a
for-each, only with a forEach(). I recommend casting Streams into Iterables
with <code>(Iterable&lt;T&gt;)stream::iterator</code>. A better alternative is to use StreamEx
which fixes a number of Stream API problems, including implementing
<code>Iterable</code>.</p>
<p>That said, <code>forEach()</code> is useful for the following:</p>
<ul>
<li>
<p><strong>Atomically iterating over a synchronized list</strong>. Prior to this, a list generated with <code>Collections.synchronizedList()</code> was atomic with respect to things like get or set, but was not thread-safe when iterating.</p>
</li>
<li>
<p><strong>Parallel execution (using an appropriate parallel stream)</strong>. This saves you a few lines of code vs using an ExecutorService, if your problem matches the performance assumptions built into Streams and Spliterators.</p>
</li>
<li>
<p><strong>Specific containers which</strong> , like the synchronized list, benefit from being in control of iteration (although this is largely theoretical unless people can bring up more examples)</p>
</li>
<li>
<p><strong>Calling a single function more cleanly</strong> by using <code>forEach()</code> and a method reference argument (ie, <code>list.forEach (obj::someMethod)</code>). However, keep in mind the points on checked exceptions, more difficult debugging, and reducing the number of idioms you use when writing code.</p>
</li>
</ul>
<p>Articles I used for reference:</p>
<ul>
<li>Everything about Java 8</li>
<li>Iteration Inside and Out (as pointed out by another poster)</li>
</ul>
<p><strong>EDIT:</strong> Looks like some of the original proposals for lambdas (such as
http://www.javac.info/closures-v06a.html Google Cache) solved some of the
issues I mentioned (while adding their own complications, of course).</p>
<p><br></p>
<h3>Suggest</h3>
<p>The advantage comes into account when the operations can be executed in
parallel. (See http://java.dzone.com/articles/devoxx-2012-java-8-lambda-and -
the section about internal and external iteration)</p>
<ul>
<li>
<p>The main advantage from my point of view is that the implementation of what is to be done within the loop can be defined without having to decide if it will be executed in parallel or sequential</p>
</li>
<li>
<p>If you want your loop to be executed in parallel you could simply write</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="n">joins</span><span class="p">.</span><span class="n">parallelStream</span><span class="p">().</span><span class="n">forEach</span><span class="p">(</span><span class="nf">join</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">mIrc</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">mSession</span><span class="p">,</span><span class="w"> </span><span class="nf">join</span><span class="p">));</span>
</pre></div>

</li>
</ul>
<p>You will have to write some extra code for thread handling etc.</p>
<p><strong>Note:</strong> For my answer I assumed joins implementing the <code>java.util.Stream</code>
interface. If joins implements only the <code>java.util.Iterable</code> interface this is
no longer true.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/for-loop/" rel="tag">for-loop</a></li>
            <li><a class="tag p-category" href="../../categories/java/" rel="tag">java</a></li>
            <li><a class="tag p-category" href="../../categories/java-8/" rel="tag">java-8</a></li>
            <li><a class="tag p-category" href="../../categories/java-stream/" rel="tag">java-stream</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ef-migrations-rollback-last-applied-migration/" rel="prev" title="EF Migrations: Rollback last applied migration?">Previous post</a>
            </li>
            <li class="next">
                <a href="../seeding-the-random-number-generator-in-javascript/" rel="next" title="Seeding the random number generator in Javascript">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
