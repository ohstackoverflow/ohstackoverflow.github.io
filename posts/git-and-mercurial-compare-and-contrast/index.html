<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Git and Mercurial - Compare and Contrast | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/git-and-mercurial-compare-and-contrast/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../what-is-a-stackoverflowerror/" title="What is a StackOverflowError?" type="text/html">
<link rel="next" href="../how-to-determine-the-current-iphone-device-model/" title="How to determine the current iPhone/device model?" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="Git and Mercurial - Compare and Contrast">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/git-and-mercurial-compare-and-contrast/">
<meta property="og:description" content="For a while now I've been using subversion for my personal projects.
More and more I keep hearing great things about Git and Mercurial, and DVCS in
general.
I'd like to give the whole DVCS thing a whi">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-03-03T03:11:39+08:00">
<meta property="article:tag" content="dvcs">
<meta property="article:tag" content="git">
<meta property="article:tag" content="mercurial">
<meta property="article:tag" content="version-control">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Git and Mercurial - Compare and Contrast</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T03:11:39+08:00" itemprop="datePublished" title="2023-03-03 03:11">2023-03-03 03:11</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>For a while now I've been using subversion for my personal projects.</p>
<p>More and more I keep hearing great things about Git and Mercurial, and DVCS in
general.</p>
<p>I'd like to give the whole DVCS thing a whirl, but I'm not too familiar with
either option.</p>
<p>What are some of the differences between Mercurial and Git?</p>
<p>Note: I'm <strong>not</strong> trying to find out which one is "best" or even which one I
should start with. I'm mainly looking for key areas where they are similar,
and where they are different, because I am interested to know how they differ
in terms of implementation and philosophy.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Disclaimer:</strong> <em>I use Git, follow Git development on git mailing list, and
even contribute a bit to Git (gitweb mainly). I know Mercurial from
documentation and some from discussion on #revctrl IRC channel on FreeNode.</em></p>
<p><em>Thanks to all people on on #mercurial IRC channel who provided help about
Mercurial for this writeup</em></p>
<hr>
<hr>
<h3>Summary</h3>
<p><em>Here it would be nice to have some syntax for table, something like in
PHPMarkdown / MultiMarkdown / Maruku extension of Markdown</em></p>
<ul>
<li>
<strong>Repository structure:</strong> Mercurial doesn't allow octopus merges (with more than two parents), nor tagging non-commit objects.</li>
<li>
<strong>Tags:</strong> Mercurial uses versioned <code>.hgtags</code> file with special rules for per-repository tags, and has also support for local tags in <code>.hg/localtags</code>; in Git tags are refs residing in <code>refs/tags/</code> namespace, and by default are autofollowed on fetching and require explicit pushing.</li>
<li>
<strong>Branches:</strong> In Mercurial basic workflow is based on <em>anonymous heads</em> ; Git uses lightweight named branches, and has special kind of branches ( <em>remote-tracking branches</em> ) that follow branches in remote repository.</li>
<li>
<strong>Revision naming and ranges:</strong> Mercurial provides <em>revision numbers</em> , local to repository, and bases relative revisions (counting from tip, i.e. current branch) and revision ranges on this <em>local</em> numbering; Git provides a way to refer to revision relative to branch tip, and revision ranges are topological (based on graph of revisions)</li>
<li>Mercurial uses <strong>rename tracking</strong> , while Git uses <strong>rename detection</strong> to deal with file renames</li>
<li>
<strong>Network:</strong> Mercurial supports SSH and HTTP "smart" protocols, and static HTTP protocol; modern Git supports SSH, HTTP and GIT "smart" protocols, and HTTP(S) "dumb" protocol. Both have support for bundles files for off-line transport.</li>
<li>Mercurial uses <strong>extensions</strong> (plugins) and established API; Git has <strong>scriptability</strong> and established formats.</li>
</ul>
<hr>
<p>There are a few things that differ Mercurial from Git, but there are other
things that make them similar. Both projects borrow ideas from each other. For
example <code>hg bisect</code> command in Mercurial (formerly bisect extension) was
inspired by <code>git bisect</code> command in Git, while idea of <code>git bundle</code> was
inspired by <code>hg bundle</code>.</p>
<h3>Repository structure, storing revisions</h3>
<p>In Git there are four types of objects in its object database: <em>blob</em> objects
which contain contents of a file, hierarchical <em>tree</em> objects which store
directory structure, including file names and relevant parts of file
permissions (executable permission for files, being a symbolic link), <em>commit</em>
object which contain authorship info, pointer to snapshot of state of
repository at revision represented by a commit (via a tree object of top
directory of project) and references to zero or more parent commits, and <em>tag</em>
objects which reference other objects and can be signed using PGP / GPG.</p>
<p>Git uses two ways of storing objects: <em>loose</em> format, where each object is
stored in a separate file (those files are written once, and never modified),
and <em>packed</em> format where many objects are stored delta-compressed in a single
file. Atomicity of operations is provided by the fact, that reference to a new
object is written (atomically, using create + rename trick) after writing an
object.</p>
<p>Git repositories require periodic maintenance using <code>git gc</code> (to reduce disk
space and improve performance), although nowadays Git does that automatically.
(This method provides better compression of repositories.)</p>
<p>Mercurial (as far as I understand it) stores history of a file in a <em>filelog</em>
(together, I think, with extra metadata like rename tracking, and some helper
information); it uses flat structure called <em>manifest</em> to store directory
structure, and structure called <em>changelog</em> which store information about
changesets (revisions), including commit message and zero, one or two parents.</p>
<p>Mercurial uses <em>transaction journal</em> to provide atomicity of operations, and
relies on <em>truncating</em> files to clean-up after failed or interrupted
operation. Revlogs are append-only.</p>
<p>Looking at repository structure in Git versus in Mercurial, one can see that
Git is more like object database (or a content-addressed filesystem), and
Mercurial more like traditional fixed-field relational database.</p>
<p><strong>Differences:</strong><br>
In Git the <em>tree</em> objects form a <strong>hierarchical</strong> structure; in Mercurial
<em>manifest</em> file is <strong>flat</strong> structure. In Git <em>blob</em> object store <strong>one
version</strong> of a contents of a file; in Mercurial <em>filelog</em> stores <strong>whole
history of a single file</strong> (if we do not take into account here any
complications with renames). This means that there are different areas of
operations where Git would be faster than Mercurial, all other things
considered equal (like merges, or showing history of a project), and areas
where Mercurial would be faster than Git (like applying patches, or showing
history of a single file). <em>This issue might be not important for end user.</em></p>
<p>Because of the fixed-record structure of Mercurial's <em>changelog</em> structure,
commits in Mercurial can have only <strong>up to two parents</strong> ; commits in Git can
have more than two parents (so called "octopus merge"). While you can (in
theory) replace octopus merge by a series of two-parent merges, this might
cause complications when converting between Mercurial and Git repositories.</p>
<p>As far as I know Mercurial doesn't have equivalent of <strong>annotated tags</strong> (tag
objects) from Git. A special case of annotated tags are <strong>signed tags</strong> (with
PGP / GPG signature); equivalent in Mercurial can be done using GpgExtension,
which extension is being distributed along with Mercurial. You can't <strong>tag
non-commit object</strong> in Mercurial like you can in Git, but that is not very
important, I think (some git repositories use tagged blob to distribute public
PGP key to use to verify signed tags).</p>
<h3>References: branches and tags</h3>
<p>In Git references (branches, remote-tracking branches and tags) reside outside
DAG of commits (as they should). References in <code>refs/heads/</code> namespace (
<strong>local branches</strong> ) point to commits, and are usually updated by "git
commit"; they point to the tip (head) of branch, that's why such name.
References in <code>refs/remotes/&lt;remotename&gt;/</code> namespace ( <strong>remote-tracking
branches</strong> ) point to commit, follow branches in remote repository
<code>&lt;remotename&gt;</code>, and are updated by "git fetch" or equivalent. References in
<code>refs/tags/</code> namespace ( <strong>tags</strong> ) point usually to commits (lightweight
tags) or tag objects (annotated and signed tags), and are not meant to change.</p>
<h4>Tags</h4>
<p>In Mercurial you can give persistent name to revision using <strong>tag</strong> ; tags are
stored similarly to the ignore patterns. It means that globally visible tags
are stored in revision-controlled <code>.hgtags</code> file in your repository. That has
two consequences: first, Mercurial has to use special rules for this file to
get current list of all tags and to update such file (e.g. it reads the most
recently committed revision of the file, not currently checked out version);
second, you have to commit changes to this file to have new tag visible to
other users / other repositories (as far as I understand it).</p>
<p>Mercurial also supports <em>local tags</em> , stored in <code>hg/localtags</code>, which are not
visible to others (and of course are not transferable)</p>
<p>In Git tags are fixed (constant) named references to other objects (usually
tag objects, which in turn point to commits) stored in <code>refs/tags/</code> namespace.
By default when fetching or pushing a set of revision, git automatically
fetches or pushes tags which point to revisions being fetched or pushed.
Nevertheless you can <em>control</em> to some extent <em>which tags are fetched</em> or
pushed.</p>
<p>Git treats lightweight tags (pointing directly to commits) and annotated tags
(pointing to tag objects, which contain tag message which optionally includes
PGP signature, which in turn point to commit) slightly differently, for
example by default it considers only annotated tags when describing commits
using "git describe".</p>
<p>Git doesn't have a strict equivalent of local tags in Mercurial. Nevertheless
git best practices recommend to setup separate public bare repository, into
which you push ready changes, and from which others clone and fetch. This
means that tags (and branches) that you don't push, are private to your
repository. On the other hand you can also use namespace other than <code>heads</code>,
<code>remotes</code> or <code>tags</code>, for example <code>local-tags</code> for local tags.</p>
<p><strong>Personal opinion:</strong> In my opinion tags should reside outside revision graph,
as they are external to it (they are pointers into graph of revisions). Tags
should be non-versioned, but transferable. Mercurial's choice of using a
mechanism similar to the one for ignoring files, means that it either has to
treat <code>.hgtags</code> specially (file in-tree is transferable, but ordinary it is
versioned), or have tags which are local only (<code>.hg/localtags</code> is non-
versioned, but untransferable).</p>
<h4>Branches</h4>
<p>In Git <strong>local branch</strong> (branch tip, or branch head) is a named reference to a
commit, where one can grow new commits. Branch can also mean active line of
development, i.e. all commits reachable from branch tip. Local branches reside
in <code>refs/heads/</code> namespace, so e.g. fully qualified name of 'master' branch is
'refs/heads/master'.</p>
<p>Current branch in Git (meaning checked out branch, and branch where new commit
will go) is the branch which is referenced by the HEAD ref. One can have HEAD
pointing directly to a commit, rather than being symbolic reference; this
situation of being on an anonymous unnamed branch is called <em>detached HEAD</em>
("git branch" shows that you are on '(no branch)').</p>
<p>In Mercurial there are anonymous branches (branch heads), and one can use
bookmarks (via bookmark extension). Such <strong>bookmark branches</strong> are purely
local, and those names were (up to version 1.6) not transferable using
Mercurial. You can use rsync or scp to copy the <code>.hg/bookmarks</code> file to a
remote repository. You can also use <code>hg id -r &lt;bookmark&gt; &lt;url&gt;</code> to get the
revision id of a current tip of a bookmark.</p>
<p>Since 1.6 bookmarks can be pushed/pulled. The BookmarksExtension page has a
section on Working With Remote Repositories. There is a difference in that in
Mercurial bookmark names are <em>global</em> , while definition of 'remote' in Git
describes also <em>mapping of branch names</em> from the names in remote repository
to the names of local remote-tracking branches; for example
<code>refs/heads/*:refs/remotes/origin/*</code> mapping means that one can find state of
'master' branch ('refs/heads/master') in the remote repository in the
'origin/master' remote-tracking branch ('refs/remotes/origin/master').</p>
<p>Mercurial has also so called <em>named branches</em> , where the branch name is
<strong>embedded</strong> in a commit (in a changeset). Such name is global (transferred on
fetch). Those branch names are permanently recorded as part of the
changeset\u2019s metadata. With modern Mercurial you can close "named branch"
and stop recording branch name. In this mechanism tips of branches are
calculated on the fly.</p>
<p>Mercurial's "named branches" should in my opinion be called <em><strong>commit
labels</strong></em> instead, because it is what they are. There are situations where
"named branch" can have multiple tips (multiple childless commits), and can
also consist of several disjoint parts of graph of revisions.</p>
<p>There is no equivalent of those Mercurial "embedded branches" in Git; moreover
Git's philosophy is that while one can say that branch includes some commit,
it doesn't mean that a commit belongs to some branch.</p>
<p>Note that Mercurial documentation still proposes to use separate clones
(separate repositories) at least for long-lived branches (single branch per
repository workflow), aka <em>branching by cloning</em>.</p>
<h4>Branches in pushing</h4>
<p>Mercurial by default pushes <strong>all heads</strong>. If you want to push a single branch
( <strong>single head</strong> ), you have to specify tip revision of the branch you want
to push. You can specify branch tip by its revision number (local to
repository), by revision identifier, by bookmark name (local to repository,
doesn't get transferred), or by embedded branch name (named branch).</p>
<p>As far as I understand it, if you push a range of revisions that contain
commits marked as being on some "named branch" in Mercurial parlance, you will
have this "named branch" in the repository you push to. This means that names
of such embedded branches ("named branches") are <em>global</em> (with respect to
clones of given repository / project).</p>
<p>By default (subject to <code>push.default</code> configuration variable) "git push" or
"git push &lt; <em>remote</em> &gt;" Git would push <strong>matching branches</strong> , i.e. only those
local branches that have their equivalent already present in remote repository
you push into. You can use <code>--all</code> option to git-push ("git push --all") to
push <strong>all branches</strong> , you can use "git push &lt; <em>remote</em> &gt; &lt; <em>branch</em> &gt;" to
push a <strong>given single branch</strong> , and you can use "git push &lt; <em>remote</em> &gt; HEAD"
to push <strong>current branch</strong>.</p>
<p>All of the above assumes that Git isn't configured which branches to push via
<code>remote.&lt;remotename&gt;.push</code> configuration variables.</p>
<h4>Branches in fetching</h4>
<p><em><strong>Note:</strong> here I use Git terminology where "fetch" means downloading changes
from remote repository _without</em> integrating those changes with local work.
This is what "<code>git fetch</code>" and "<code>hg pull</code>" does._</p>
<p>If I understand it correctly, by default Mercurial fetches <strong>all heads</strong> from
remote repository, but you can specify branch to fetch via "<code>hg pull --rev
&lt;rev&gt; &lt;url&gt;</code>" or "<code>hg pull &lt;url&gt;#&lt;rev&gt;</code>" to get <strong>single branch</strong>. You can
specify <rev> using revision identifier, "named branch" name (branch embedded
in changelog), or bookmark name. Bookmark name however (at least currently)
doesn't get transferred. All "named branches" revisions you get belong to get
transferred. "hg pull" stores tips of branches it fetched as anonymous,
unnamed heads.</rev></p>
<p>In Git by default (for 'origin' remote created by "git clone", and for remotes
created using "git remote add") "<code>git fetch</code>" (or "<code>git fetch &lt;remote&gt;</code>") gets
<strong>all branches</strong> from remote repository (from <code>refs/heads/</code> namespace), and
stores them in <code>refs/remotes/</code> namespace. This means for example that branch
named 'master' (full name: 'refs/heads/master') in remote 'origin' would get
stored (saved) as 'origin/master' <em>remote-tracking branch</em> (full name:
'refs/remotes/origin/master').</p>
<p>You can fetch <strong>single branch</strong> in Git by using <code>git fetch &lt;remote&gt; &lt;branch&gt;</code>
- Git would store requested branch(es) in FETCH_HEAD, which is something
similar to Mercurial unnamed heads.</p>
<p>Those are but examples of default cases of powerful <strong>refspec</strong> Git syntax:
with refspecs you can specify and/or configure which branches one want to
fetch, and where to store them. For example default "fetch all branches" case
is represented by '+refs/heads/<em>:refs/remotes/origin/</em>' wildcard refspec, and
"fetch single branch" is shorthand for 'refs/heads/<branch>:'. Refspecs are
used to map names of branches (refs) in remote repository to local refs names.
But you don't need to know (much) about refspecs to be able to work
effectively with Git (thanks mainly to "git remote" command).</branch></p>
<p><strong>Personal opinion:</strong> I personally think that "named branches" (with branch
names embedded in changeset metadata) in Mercurial are misguided design with
its global namespace, especially for a <em>distributed</em> version control system.
For example let's take case where both Alice and Bob have "named branch" named
'for-joe' in their repositories, branches which have nothing in common. In
Joe's repository however those two branches would be mistreated as a single
branch. So you have somehow come up with convention protecting against branch
name clashes. This is not problem with Git, where in Joe's repository 'for-
joe' branch from Alice would be 'alice/for-joe', and from Bob it would be
'bob/for-joe'. See also Separating branch name from branch identity issue
raised on Mercurial wiki.</p>
<p>Mercurial's "bookmark branches" currently lack in-core distribution mechanism.</p>
<p><strong>Differences:</strong><br>
This area is one of the main differences between Mercurial and Git, as james
woodyatt and Steve Losh said in their answers. Mercurial, by default, uses
anonymous lightweight codelines, which in its terminology are called "heads".
Git uses lightweight named branches, with injective mapping to map names of
branches in remote repository to names of remote-tracking branches. Git
"forces" you to name branches (well, with exception of single unnamed branch,
situation called detached HEAD), but I think this works better with branch-
heavy workflows such as topic branch workflow, meaning multiple branches in
single repository paradigm.</p>
<h3>Naming revisions</h3>
<p>In Git there are many ways of naming revisions (described e.g. in git rev-
parse manpage):</p>
<ul>
<li>The full SHA1 object name (40-byte hexadecimal string), or a substring of such that is unique within the repository</li>
<li>A symbolic ref name, e.g. 'master' (referring to 'master' branch), or 'v1.5.0' (referring to tag), or 'origin/next' (referring to remote-tracking branch)</li>
<li>A suffix <code>^</code> to revision parameter means the first parent of a commit object, <code>^n</code> means n-th parent of a merge commit. A suffix <code>~n</code> to revision parameter means n-th ancestor of a commit in straight first-parent line. Those suffixes can be combined, to form revision specifier following path from a symbolic reference, e.g. 'pu~3^2~3'</li>
<li>Output of "git describe", i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a 'g', and an abbreviated object name, for example 'v1.6.5.1-75-g5bf8097'.</li>
</ul>
<p>There are also revision specifiers involving reflog, not mentioned here. In
Git each object, be it commit, tag, tree or blob has its SHA-1 identifier;
there is special syntax like e.g. 'next:Documentation' or 'next:README' to
refer to tree (directory) or blob (file contents) at specified revision.</p>
<p>Mercurial also has many ways of naming changesets (described e.g. in hg
manpage):</p>
<ul>
<li>A plain integer is treated as a revision number. One need to remember that revision numbers are <em>local to given repository</em> ; in other repository they can be different.</li>
<li>Negative integers are treated as sequential offsets from the tip, with -1 denoting the tip, -2 denoting the revision prior to the tip, and so forth. They are also <em>local</em> to repository.</li>
<li>An unique revision identifier (40-digit hexadecimal string) or its unique prefix.</li>
<li>A tag name (symbolic name associated with given revision), or a bookmark name (with extension: symbolic name associated with given head, local to repository), or a "named branch" (commit label; revision given by "named branch" is tip (childless commit) of all commits with given commit label, with largest revision number if there are more than one such tip)</li>
<li>The reserved name "tip" is a special tag that always identifies the most recent revision.</li>
<li>The reserved name "null" indicates the null revision.</li>
<li>The reserved name "." indicates the working directory parent.</li>
</ul>
<p><strong>Differences</strong><br>
As you can see comparing above lists Mercurial offers revision numbers, local
to repository, while Git doesn't. On the other hand Mercurial offers relative
offsets only from 'tip' (current branch), which are local to repository (at
least without ParentrevspecExtension), while Git allows to specify any commit
following from any tip.</p>
<p>The most recent revision is named HEAD in Git, and "tip" in Mercurial; there
is no null revision in Git. Both Mercurial and Git can have many root (can
have more than one parentless commits; this is usually result of formerly
separate projects joining).</p>
<p><strong>See also:</strong> Many different kinds of revision specifiers article on Elijah's
Blog (newren's).</p>
<p><strong>Personal opinion:</strong> I think that <em>revision numbers</em> are overrated (at least
for distributed development and/or nonlinear / branchy history). First, for a
distributed version control system they have to be either local to repository,
or require treating some repository in a special way as a central numbering
authority. Second, larger projects, with longer history, can have number of
revisions in 5 digits range so they are offer only slight advantage over
shortened to 6-7 character revision identifiers, and imply strict ordering
while revisions are only partially ordered (I mean here that revisions n and
n+1 doesn't need to be parent and child).</p>
<h4>Revision ranges</h4>
<p>In Git revision ranges are <strong>topological</strong>. Commonly seen <code>A..B</code> syntax, which
for linear history means revision range starting at A (but excluding A), and
ending at B (i.e. range is <em>open from below</em> ), is shorthand ("syntactic
sugar") for <code>^A B</code>, which for history traversing commands mean all commits
reachable from B, excluding those reachable from A. This means that the
behavior of <code>A..B</code> range is entirely predictable (and quite useful) even if A
is not ancestor of B: <code>A..B</code> means then range of revisions from common
ancestor of A and B (merge base) to revision B.</p>
<p>In Mercurial revision ranges are based on range of <strong>revision numbers</strong>. Range
is specified using <code>A:B</code> syntax, and contrary to Git range acts as a <em>closed
interval</em>. Also range B:A is the range A:B in reverse order, which is not the
case in Git (but see below note on <code>A...B</code> syntax). But such simplicity comes
with a price: revision range A:B makes sense only if A is ancestor of B or
vice versa, i.e. with linear history; otherwise (I guess that) the range is
unpredictable, and the result is local to repository (because revision numbers
are local to repository).</p>
<p>This is fixed with Mercurial 1.6, which has new <strong>topological revision range</strong>
, where 'A..B' (or 'A::B') is understood as the set of changesets that are
both descendants of X and ancestors of Y. This is, I guess, equivalent to '--
ancestry-path A..B' in Git.</p>
<p>Git also has notation <code>A...B</code> for symmetric difference of revisions; it means
<code>A B --not $(git merge-base A B)</code>, which means all commits reachable from
either A or B, but excluding all commits reachable from both of them
(reachable from common ancestors).</p>
<h3>Renames</h3>
<p>Mercurial uses <strong>rename tracking</strong> to deal with file renames. This means that
the information about the fact that a file was renamed is saved at the commit
time; in Mercurial this information is saved in the "enhanced diff" form in
<em>filelog</em> (file revlog) metadata. The consequence of this is that you have to
use <code>hg rename</code> / <code>hg mv</code>... or you need to remember to run <code>hg addremove</code> to
do similarity based rename detection.</p>
<p>Git is unique among version control systems in that it uses <strong>rename
detection</strong> to deal with file renames. This means that the fact that file was
renamed is detected at time it is needed: when doing a merge, or when showing
a diff (if requested / configured). This has the advantage that rename
detection algorithm can be improved, and is not frozen at time of commit.</p>
<p>Both Git and Mercurial require using <code>--follow</code> option to follow renames when
showing history of a single file. Both can follow renames when showing line-
wise history of a file in <code>git blame</code> / <code>hg annotate</code>.</p>
<p>In Git the <code>git blame</code> command is able to follow code movement, also moving
(or copying) code from one file to the other, even if the code movement is not
part of wholesome file rename. <em>As far as I know this feature is unique to Git
(at the time of writing, October 2009).</em></p>
<h3>Network protocols</h3>
<p>Both Mercurial and Git have support for fetching from and pushing to
repositories on the same filesystem, where repository URL is just a filesystem
path to repository. Both also have support for fetching from <em>bundle files</em>.</p>
<p>Mercurial support fetching and pushing via SSH and via HTTP protocols. For SSH
one needs an accessible shell account on the destination machine and a copy of
hg installed / available. For HTTP access the <code>hg-serve</code> or Mercurial CGI
script running is required, and Mercurial needs to be installed on server
machine.</p>
<p>Git supports two kinds of protocols used to access remote repository:</p>
<ul>
<li>
<em>"smart" protocols</em> , which include access via SSH and via custom git:// protocol (by <code>git-daemon</code>), require having git installed on server. The exchange in those protocols consist of client and server negotiating about what objects they have in common, and then generating and sending a packfile. Modern Git includes support for "smart" HTTP protocol.</li>
<li>
<em>"dumb" protocols</em> , which include HTTP and FTP (only for fetching), and HTTPS (for pushing via WebDAV), do not require git installed on server, but they do require that repository contains extra information generated by <code>git update-server-info</code> (usually run from a hook). The exchange consist of client walking the commit chain and downloading loose objects and packfiles as needed. The downside is that it downloads more than strictly required (e.g. in corner case when there is only single packfile it would get downloaded whole even when fetching only a few revisions), and that it can require many connections to finish.</li>
</ul>
<h3>Extending: scriptability vs extensions (plugins)</h3>
<p>Mercurial is implemented in <strong>Python</strong> , with some core code written in C for
performance. It provides API for writing <strong>extensions</strong> (plugins) as a way of
adding extra features. Some of functionality, like "bookmark branches" or
signing revisions, is provided in extensions distributed with Mercurial and
requires turning it on.</p>
<p>Git is implemented in <strong>C</strong> , <strong>Perl</strong> and <strong>shell scripts</strong>. Git provides
many low level commands ( <em>plumbing</em> ) suitable to use in scripts. The usual
way of introducing new feature is to write it as Perl or shell script, and
when user interface stabilizes rewrite it in C for performance, portability,
and in the case of shell script avoiding corner cases (this procedure is
called <em>builtinification</em> ).</p>
<p>Git relies and is built around [repository] formats and [network] protocols.
Instead of language bindings there are (partial or complete)
<em>reimplementations</em> of Git in other languages (some of those are partially
reimplementations, and partially wrappers around git commands): JGit (Java,
used by EGit, Eclipse Git Plugin), Grit (Ruby), Dulwich (Python), git# (C#).</p>
<hr>
<p>TL;DR</p>
<p><br></p>
<h3>Suggest</h3>
<p>I think you can get a feeling of what those systems are similar or different
in by whatching those two videos:</p>
<p>Linus Torvalds on Git (http://www.youtube.com/watch?v=4XpnKHJAok8)<br>
Bryan O'Sullivan on Mercurial (http://www.youtube.com/watch?v=JExtkqzEoHY)</p>
<p>Both of them are very similar in design but very different in implementations.</p>
<p>I use Mercurial. As far as I understand Git, one major thing git is different
is that it tracks contents of files instead of files themselves. Linus says
that if you move a function from one file to another, Git will tell you the
history of that single function across the move.</p>
<p>They also say that git is slower over HTTP but it has it's own network
protocol and server.</p>
<p>Git works better as an SVN thick client than Mercurial. You can pull and push
against an SVN server. This functionality is still under development in
Mercurial</p>
<p>Both Mercurial and Git have very nice web hosting solutions available
(BitBucket and GitHub), but Google Code supports Mercurial only. By the way,
they have a very detailed comparison of Mercurial and Git they did for
deciding which one to support
(http://code.google.com/p/support/wiki/DVCSAnalysis). It has a lot of good
info.</p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/dvcs/" rel="tag">dvcs</a></li>
            <li><a class="tag p-category" href="../../categories/git/" rel="tag">git</a></li>
            <li><a class="tag p-category" href="../../categories/mercurial/" rel="tag">mercurial</a></li>
            <li><a class="tag p-category" href="../../categories/version-control/" rel="tag">version-control</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../what-is-a-stackoverflowerror/" rel="prev" title="What is a StackOverflowError?">Previous post</a>
            </li>
            <li class="next">
                <a href="../how-to-determine-the-current-iphone-device-model/" rel="next" title="How to determine the current iPhone/device model?">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
