<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>可以在其范围之外访问局部变量的内存吗？ | StackOverflow Snapshot</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/posts/ke-yi-zai-qi-fan-wei-zhi-wai-fang-wen-ju-bu-bian-liang-de-nei-cun-ma/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Arya">
<link rel="prev" href="../shi-yong-fan-she-cong-zi-fu-chuan-zhong-huo-qu-shu-xing-zhi/" title="使用反射从字符串中获取属性值" type="text/html">
<link rel="next" href="../zai-rest-api-shi-ji-chang-jing-zhong-shi-yong-put-yu-patch-fang-fa/" title="在 REST API 实际场景中使用 PUT 与 PATCH 方法" type="text/html">
<meta property="og:site_name" content="StackOverflow Snapshot">
<meta property="og:title" content="可以在其范围之外访问局部变量的内存吗？">
<meta property="og:url" content="https://ohstackoverflow.netlify.app/posts/ke-yi-zai-qi-fan-wei-zhi-wai-fang-wen-ju-bu-bian-liang-de-nei-cun-ma/">
<meta property="og:description" content="我有以下代码。
#include &lt;iostream&gt;

int * foo()
{
    int a = 5;
    return &amp;a;
}

int main()
{
    int* p = foo();
    std::cout &lt;&lt; *p;
    *p = 8;
    std::cout &lt;&lt; *p;
}


而且代码只是在运行，没有运行时异常！
输出是58
怎么会这样？局部">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2023-02-17T05:14:00+08:00">
<meta property="article:tag" content="cPlusPlus">
<meta property="article:tag" content="dangling-pointer">
<meta property="article:tag" content="local-variables">
<meta property="article:tag" content="memory-management">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../archive.html">Archive</a>
                </li>
<li>
<a href="../../categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">可以在其范围之外访问局部变量的内存吗？</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    <a class="u-url" href="../../authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T05:14:00+08:00" itemprop="datePublished" title="2023-02-17 05:14">2023-02-17 05:14</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>我有以下代码。</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kr">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>而且代码只是在运行，没有运行时异常！</p>
<p>输出是<code>58</code></p>
<p>怎么会这样？局部变量的内存不是在其函数之外不可访问吗？</p>
<p><br><br></p>
<h2>解答</h2>
<blockquote>
<p>怎么会这样？局部变量的内存不是在其函数之外不可访问吗？</p>
</blockquote>
<p>你租了一个旅馆房间。你把一本书放在床头柜最上面的抽屉里，然后去睡觉。您第二天早上退房，但“忘记”归还钥匙。你偷了钥匙！</p>
<p>一周后，你回到酒店，没有办理入住手续，拿着偷来的钥匙溜进你原来的房间，查看抽屉。你的书还在。惊人！</p>
<p><strong>怎么可能？ 如果你没有租房间，酒店房间抽屉里的东西是不是无法访问？</strong></p>
<p>好吧，显然这种情况可以在现实世界中发生，这没问题。当您不再被授权进入房间时，没有神秘的力量会导致您的书消失。也没有神秘的力量阻止你用偷来的钥匙进入房间。</p>
<p>酒店管理人员无需 <em>删除</em>
您的图书。您没有与他们签订合同，说如果您留下东西，他们会为您切碎。如果您使用偷来的钥匙非法重新进入您的房间以取回它，酒店保安人员不需要 <em>抓住</em>
您偷偷溜进来的情况。您没有与他们签订合同说“如果我试图偷偷溜回我的房间”房间待会儿，你必须阻止我。”
而是你和他们签了一份“我保证以后不偷偷溜回我房间”的契约， <em>你违约了</em> 。</p>
<p>在这种情况下 <strong>任何事情都有可能发生</strong>
。这本书可以在那里——你很幸运。别人的书可能在那里，而你的书可能在旅馆的炉子里。当你进来的时候，可能有人就在那里，把你的书撕成碎片。酒店本可以完全移除桌子和预订，并用衣柜取而代之。整个酒店可能即将被拆除，取而代之的是一个足球场，而你在偷偷摸摸的时候会在爆炸中丧生。</p>
<p>你不知道会发生什么；当你退房并偷了一把钥匙以后非法使用时，你就放弃了生活在一个可预测的、安全的世界中的权利，因为 <em>你</em> 选择了打破系统的规则。</p>
<p><strong>C++ 不是一种安全的语言</strong>
。它会愉快地允许你打破系统的规则。如果你试图做一些非法和愚蠢的事情，比如回到一个你无权进入的房间，并在一张可能不再存在的桌子上翻找，C++ 不会阻止你。比
C++ 更安全的语言通过限制您的权力来解决这个问题——例如，通过对密钥进行更严格的控制。</p>
<h3>更新</h3>
<p>天哪，这个答案引起了很多关注。（我不确定为什么——我认为这只是一个“有趣”的小类比，但无论如何。）</p>
<p>我认为用更多的技术思想来稍微更新一下可能是密切相关的。</p>
<p>编译器负责生成代码，该代码管理由该程序操作的数据的存储。有许多不同的方法可以生成代码来管理内存，但随着时间的推移，有两种基本技术已经根深蒂固。</p>
<p>第一个是拥有某种“长期存在”的存储区域，其中存储中每个字节的“生命周期”——即它与某个程序变量有效关联的时间段——不能轻易提前预测.
编译器生成对“堆管理器”的调用，它知道如何在需要时动态分配存储并在不再需要时回收它。</p>
<p>第二种方法是拥有一个“短期”存储区域，其中每个字节的生命周期都是众所周知的。在这里，生命周期遵循“嵌套”模式。这些短寿命变量中寿命最长的将在任何其他短寿命变量之前分配，并将最后释放。寿命较短的变量将在寿命最长的变量之后分配，并在它们之前被释放。这些寿命较短的变量的生命周期“嵌套”在寿命较长的变量的生命周期中。</p>
<p>局部变量遵循后一种模式；当进入一个方法时，它的局部变量就会活跃起来。当该方法调用另一个方法时，新方法的局部变量就会生效。它们会在第一个方法的局部变量死掉之前死掉。可以提前计算出与局部变量相关的存储生命周期开始和结束的相对顺序。</p>
<p>出于这个原因，局部变量通常生成为存储在“堆栈”数据结构上，因为堆栈具有这样的属性，即第一个压入它的东西将是最后一个弹出的东西。</p>
<p>就好比酒店决定只按顺序出租房间，等比你号高的人都退房了你才能退房。</p>
<p>因此，让我们考虑一下堆栈。在许多操作系统中，每个线程都有一个堆栈，并且堆栈被分配为某个固定大小。当你调用一个方法时，东西被压入堆栈。如果您随后将指向堆栈的指针传递回您的方法，就像原始海报在这里所做的那样，那只是指向某个完全有效的百万字节内存块中间的指针。在我们的类比中，您退房；当你这样做时，你只是检查了编号最高的房间。如果没有其他人在您之后登记入住，而您又非法返回您的房间，那么您的所有物品保证仍然
<em>在这家酒店</em> 。</p>
<p>我们将堆栈用于临时商店，因为它们真的很便宜也很容易。不需要 C++ 的实现来使用堆栈来存储局部变量；它可以使用堆。它不会，因为那会使程序变慢。</p>
<p>C++
的实现不需要让你留在堆栈上的垃圾保持原样，这样你以后就可以非法回来取它；编译器生成将您刚刚腾出的“房间”中的所有内容归零的代码是完全合法的。又不是因为那会很贵。</p>
<p>不需要 C++
的实现来确保当堆栈在逻辑上收缩时，曾经有效的地址仍然映射到内存中。允许该实现告诉操作系统“我们现在已经完成了使用此堆栈页面。除非我另有说明，否则如果有人触及先前有效的堆栈页面，则发出一个异常来破坏进程”。同样，实现实际上并没有这样做，因为它很慢而且没有必要。</p>
<p>相反，实现让你犯错并侥幸逃脱。大多数时候。直到有一天，真正可怕的事情出了问题，这个过程爆炸了。</p>
<p>这是有问题的。有很多规则，很容易不小心打破它们。我当然有很多次。更糟糕的是，问题通常只有在内存损坏发生数十亿纳秒后检测到损坏时才会出现，此时很难找出是谁搞砸了。</p>
<p>更多内存安全的语言通过限制你的权力来解决这个问题。在“普通”C#
中，根本无法获取本地地址并将其返回或存储以备后用。您可以获取本地地址，但语言设计巧妙，因此在本地生命周期结束后无法使用它。为了获取本地地址并将其传回，您必须将编译器置于特殊的“不安全”模式，
<em>并</em> 在您的程序中添加“不安全”一词，以提醒您注意您可能正在做的事实可能违反规则的危险事物。</p>
<p>进一步阅读：</p>
<ul>
<li>如果 C# 确实允许返回引用怎么办？巧合的是，这是今天博客文章的主题：</li>
</ul>
<p><em>Ref 返回和 ref 局部变量</em></p>
<ul>
<li>为什么要用栈来管理内存？C# 中的值类型是否始终存储在堆栈中？虚拟内存是如何工作的？以及有关 C# 内存管理器工作原理的更多主题。其中许多文章也与 C++ 程序员密切相关：</li>
</ul>
<p><em>内存管理</em></p>
<p><br></p>
<h3>更多建议</h3>
<p>您只是简单地读取和写入 <em>曾经</em> 是 的地址的内存<code>a</code>。现在您在
之外<code>foo</code>，它只是指向某个随机内存区域的指针。碰巧在您的示例中，该内存区域确实存在并且目前没有其他人在使用它。</p>
<p>继续使用它不会破坏任何东西，而且还没有其他东西覆盖它。因此，<code>5</code>仍然存在。在真实的程序中，该内存几乎会立即被重用，这样做会破坏某些东西（尽管症状可能要到很久以后才会出现！）。</p>
<p>当您从
返回时<code>foo</code>，您告诉操作系统您不再使用该内存并且可以将其重新分配给其他内存。如果你很幸运并且它永远不会被重新分配，并且操作系统没有发现你再次使用它，那么你就可以摆脱谎言。尽管您最终可能会覆盖以该地址结尾的任何其他内容。</p>
<p>现在如果你想知道为什么编译器不报错，那可能是因为<code>foo</code>被优化淘汰了。它通常会警告你这种事情。<code>a</code>C
假定您知道自己在做什么，并且从技术上讲，您在这里没有违反范围（在 之外没有对自身的引用<code>foo</code>），只有内存访问规则，它只会触发警告而不是错误。</p>
<p>简而言之：这通常不会奏效，但有时会偶然发生。</p>
<p><br><br><a href="../can-a-local-variable-s-memory-be-accessed-outside-its-scope/">查看原文</a></p>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/cplusplus/" rel="tag">cPlusPlus</a></li>
            <li><a class="tag p-category" href="../../categories/dangling-pointer/" rel="tag">dangling-pointer</a></li>
            <li><a class="tag p-category" href="../../categories/local-variables/" rel="tag">local-variables</a></li>
            <li><a class="tag p-category" href="../../categories/memory-management/" rel="tag">memory-management</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../shi-yong-fan-she-cong-zi-fu-chuan-zhong-huo-qu-shu-xing-zhi/" rel="prev" title="使用反射从字符串中获取属性值">Previous post</a>
            </li>
            <li class="next">
                <a href="../zai-rest-api-shi-ji-chang-jing-zhong-shi-yong-put-yu-patch-fang-fa/" rel="next" title="在 REST API 实际场景中使用 PUT 与 PATCH 方法">Next post</a>
            </li>
        </ul></nav></aside></article>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="../../assets/js/search.js"></script>
</body>
</html>
