<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1971) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1971.html">
<link rel="prev" href="index-1972.html" type="text/html">
<link rel="next" href="index-1970.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/asp-net-mvc-controller-actions-that-return-json-or-partial-html/" class="u-url">ASP.NET MVC controller actions that return JSON or partial html</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/asp-net-mvc-controller-actions-that-return-json-or-partial-html/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:46:53+08:00" itemprop="datePublished" title="2023-03-03 13:46">2023-03-03 13:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I am trying to create controller actions which will return either JSON or
partial html depending upon a parameter. What is the best way to get the
result returned to an MVC page asynchronously?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>In your action method, return Json(object) to return JSON to your page.</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">ActionResult</span><span class="w"> </span><span class="nv">SomeActionMethod</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">Json</span><span class="ss">(</span><span class="nv">new</span><span class="w"> </span>{<span class="nv">foo</span><span class="o">=</span><span class="s2">"bar"</span>,<span class="w"> </span><span class="nv">baz</span><span class="o">=</span><span class="s2">"Blech"</span>}<span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>Then just call the action method using Ajax. You could use one of the helper
methods from the ViewPage such as</p>
<div class="code"><pre class="code literal-block"><span class="cp">&lt;%=</span><span class="w"> </span><span class="no">Ajax</span><span class="o">.</span><span class="n">ActionLink</span><span class="p">(</span><span class="s2">"SomeActionMethod"</span><span class="p">,</span><span class="w"> </span><span class="kp">new</span><span class="w"> </span><span class="no">AjaxOptions</span><span class="w"> </span><span class="p">{</span><span class="no">OnSuccess</span><span class="o">=</span><span class="s2">"somemethod"</span><span class="p">})</span><span class="w"> </span><span class="cp">%&gt;</span>
</pre></div>

<p>SomeMethod would be a javascript method that then evaluates the Json object
returned.</p>
<p>If you want to return a plain string, you can just use the ContentResult:</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">ActionResult</span><span class="w"> </span><span class="nv">SomeActionMethod</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">Content</span><span class="ss">(</span><span class="s2">"hello world!"</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>

<p>ContentResult by default returns a text/plain as its contentType.<br>
This is overloadable so you can also do:</p>
<div class="code"><pre class="code literal-block">return<span class="w"> </span>Content("<span class="nt">&lt;xml&gt;</span>This<span class="w"> </span>is<span class="w"> </span>poorly<span class="w"> </span>formatted<span class="w"> </span>xml.<span class="nt">&lt;/xml&gt;</span>",<span class="w"> </span>"text/xml");
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p>I think you should consider the AcceptTypes of the request. I am using it in
my current project to return the correct content type as follows.</p>
<p>Your action on the controller can test it as on the request object</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">Request</span>.<span class="nv">AcceptTypes</span>.<span class="nv">Contains</span><span class="ss">(</span><span class="s2">"text/html"</span><span class="ss">))</span><span class="w"> </span>{
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nv">View</span><span class="ss">()</span><span class="c1">;</span>
}
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">Request</span>.<span class="nv">AcceptTypes</span>.<span class="nv">Contains</span><span class="ss">(</span><span class="s2">"application/json"</span><span class="ss">))</span>
{
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nv">Json</span><span class="ss">(</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span>{<span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="mi">1</span>,<span class="w"> </span><span class="nv">value</span><span class="o">=</span><span class="s2">"new"</span><span class="w"> </span>}<span class="w"> </span><span class="ss">)</span><span class="c1">;</span>
}
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">Request</span>.<span class="nv">AcceptTypes</span>.<span class="nv">Contains</span><span class="ss">(</span><span class="s2">"application/xml"</span><span class="ss">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>
<span class="w">         </span><span class="nv">Request</span>.<span class="nv">AcceptTypes</span>.<span class="nv">Contains</span><span class="ss">(</span><span class="s2">"text/xml"</span><span class="ss">))</span>
{
<span class="w">   </span><span class="o">//</span>
}
</pre></div>

<p>You can then implement the aspx of the view to cater for the partial xhtml
response case.</p>
<p>Then in jQuery you can fetch it passing the type parameter as json:</p>
<div class="code"><pre class="code literal-block">$.get(url, null, function(data, textStatus) {
        console.log('got %o with status %s', data, textStatus);
        }, "json"); // or xml, html, script, json, jsonp or text
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-reversibly-store-and-load-a-pandas-dataframe-to-from-disk/" class="u-url">How to reversibly store and load a Pandas dataframe to/from disk</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-reversibly-store-and-load-a-pandas-dataframe-to-from-disk/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:46:27+08:00" itemprop="datePublished" title="2023-03-03 13:46">2023-03-03 13:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Right now I'm importing a fairly large <code>CSV</code> as a dataframe every time I run
the script. Is there a good solution for keeping that dataframe constantly
available in between runs so I don't have to spend all that time waiting for
the script to run?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The easiest way is to pickle it using <code>to_pickle</code>:</p>
<div class="code"><pre class="code literal-block">df.to_pickle(file_name)  # where to save it, usually as a .pkl
</pre></div>

<p>Then you can load it back using:</p>
<div class="code"><pre class="code literal-block">df = pd.read_pickle(file_name)
</pre></div>

<p><em>Note: before 0.11.1<code>save</code> and <code>load</code> were the only way to do this (they are
now deprecated in favor of <code>to_pickle</code> and <code>read_pickle</code> respectively).</em></p>
<hr>
<p>Another popular choice is to use HDF5 (pytables) which offers very fast access
times for large datasets:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">HDFStore</span><span class="p">(</span><span class="s1">'store.h5'</span><span class="p">)</span>

<span class="n">store</span><span class="p">[</span><span class="s1">'df'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>  <span class="c1"># save it</span>
<span class="n">store</span><span class="p">[</span><span class="s1">'df'</span><span class="p">]</span>  <span class="c1"># load it</span>
</pre></div>

<p><em>More advanced strategies are discussed in the cookbook.</em></p>
<hr>
<p>Since 0.13 there's also msgpack which may be be better for interoperability,
as a faster alternative to JSON, or if you have python object/text-heavy data
(see this question).</p>
<p><br></p>
<h3>Suggest</h3>
<p>Although there are already some answers I found a nice comparison in which
they tried several ways to serialize Pandas DataFrames: Efficiently Store
Pandas DataFrames.</p>
<p>They compare:</p>
<ul>
<li>pickle: original ASCII data format</li>
<li>cPickle, a C library</li>
<li>pickle-p2: uses the newer binary format</li>
<li>json: standardlib json library</li>
<li>json-no-index: like json, but without index</li>
<li>msgpack: binary JSON alternative</li>
<li>CSV</li>
<li>hdfstore: HDF5 storage format</li>
</ul>
<p>In their experiment, they serialize a DataFrame of 1,000,000 rows with the two
columns tested separately: one with text data, the other with numbers. Their
disclaimer says:</p>
<blockquote>
<p>You should not trust that what follows generalizes to your data. You should
look at your own data and run benchmarks yourself</p>
</blockquote>
<p>The source code for the test which they refer to is available online. Since
this code did not work directly I made some minor changes, which you can get
here: serialize.py I got the following results:</p>
<p><img alt="time comparison results" src="images/T9JEL.png"></p>
<p>They also mention that with the conversion of text data to categorical data
the serialization is much faster. In their test about 10 times as fast (also
see the test code).</p>
<p><strong>Edit</strong> : The higher times for pickle than CSV can be explained by the data
format used. By default <code>pickle</code> uses a printable ASCII representation, which
generates larger data sets. As can be seen from the graph however, pickle
using the newer binary data format (version 2, <code>pickle-p2</code>) has much lower
load times.</p>
<p>Some other references:</p>
<ul>
<li>In the question Fastest Python library to read a CSV file there is a very detailed answer which compares different libraries to read csv files with a benchmark. The result is that for reading csv files <code>numpy.fromfile</code> is the fastest.</li>
<li>Another serialization test shows msgpack, ujson, and cPickle to be the quickest in serializing.</li>
</ul>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-a-view-faster-than-a-simple-query/" class="u-url">Is a view faster than a simple query?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-a-view-faster-than-a-simple-query/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T13:46:02+08:00" itemprop="datePublished" title="2023-03-03 13:46">2023-03-03 13:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Is a</p>
<div class="code"><pre class="code literal-block">select *  from myView
</pre></div>

<p>faster than the query itself to create the view (in order to have the same
resultSet):</p>
<div class="code"><pre class="code literal-block">select * from ([query to create same resultSet as myView])
</pre></div>

<p>?</p>
<p>It's not totally clear to me if the view uses some sort of caching making it
faster compared to a simple query.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Yes</strong> , views <em>can</em> have a clustered index assigned and, when they do,
they'll store temporary results that can speed up resulting queries.</p>
<p>Microsoft's own documentation makes it very clear that Views can improve
performance.</p>
<p>First, most views that people create are <em>simple</em> views and do not use this
feature, and are therefore no different to querying the base tables directly.
Simple views are expanded in place and so <strong>do not directly contribute to
performance improvements</strong> - that much is true. <strong>However,</strong> indexed views
can <em>dramatically</em> improve performance.</p>
<p>Let me go directly to the documentation:</p>
<blockquote>
<p>After a unique clustered index is created on the view, the view's result set
is materialized immediately and persisted in physical storage in the
database, saving the overhead of performing this costly operation at
execution time.</p>
</blockquote>
<p>Second, these indexed views can work <em>even when they are not directly
referenced by another query</em> as the optimizer will use them in place of a
table reference when appropriate.</p>
<p>Again, the documentation:</p>
<blockquote>
<p>The indexed view can be used in a query execution in two ways. The query can
reference the indexed view directly, or, more importantly, the query
optimizer can select the view if it determines that the view can be
substituted for some or all of the query in the lowest-cost query plan. In
the second case, the indexed view is used instead of the underlying tables
and their ordinary indexes. The view does not need to be referenced in the
query for the query optimizer to use it during query execution. This allows
existing applications to benefit from the newly created indexed views
without changing those applications.</p>
</blockquote>
<p>This documentation, as well as charts demonstrating performance improvements,
can be found here.</p>
<p><strong>Update 2:</strong> the answer has been criticized on the basis that it is the
"index" that provides the performance advantage, not the "View." However, this
is easily refuted.</p>
<p>Let us say that we are a software company in a small country; I'll use
Lithuania as an example. We sell software worldwide and keep our records in a
SQL Server database. We're very successful and so, in a few years, we have
1,000,000+ records. However, we often need to report sales for tax purposes
and we find that we've only sold 100 copies of our software in our home
country. By creating an indexed view of just the Lithuanian records, we get to
keep the records we need in an indexed cache as described in the MS
documentation. When we run our reports for Lithuanian sales in 2008, our query
will search through an index with a depth of just 7 (Log2(100) with some
unused leaves). If we were to do the same without the VIEW and just relying on
an index into the table, we'd have to traverse an index tree with a search
depth of 21!</p>
<p>Clearly, the View itself would provide us with a performance advantage (3x)
over the simple use of the index alone. I've tried to use a real-world example
but you'll note that a simple list of Lithuanian sales would give us an even
greater advantage.</p>
<p>Note that I'm just using a straight b-tree for my example. While I'm fairly
certain that SQL Server uses some variant of a b-tree, I don't know the
details. Nonetheless, the point holds.</p>
<p><strong>Update 3:</strong> The question has come up about whether an Indexed View just uses
an index placed on the underlying table. That is, to paraphrase: "an indexed
view is just the equivalent of a standard index and it offers nothing new or
unique to a view." If this was true, of course, then the above analysis would
be incorrect! Let me provide a quote from the Microsoft documentation that
demonstrate why I think this criticism is not valid or true:</p>
<blockquote>
<p>Using indexes to improve query performance is not a new concept; however,
indexed views provide additional performance benefits that cannot be
achieved using standard indexes.</p>
</blockquote>
<p>Together with the above quote regarding the persistence of data in physical
storage and other information in the documentation about how indices are
created on Views, I think it is safe to say that an Indexed View is <strong>not</strong>
just a cached SQL Select that happens to use an index defined on the main
table. Thus, I continue to stand by this answer.</p>
<p><br></p>
<h3>Suggest</h3>
<p><strong>Generally speaking, no.</strong> Views are primarily used for convenience and
security, and won't (by themselves) produce any speed benefit.</p>
<p>That said, SQL Server 2000 and above do have a feature called <strong>Indexed
Views</strong> that <em>can</em> greatly improve performance, with a few caveats:</p>
<ol>
<li>Not every view can be made into an indexed view; they have to follow a specific set of guidelines, which (among other restrictions) means you can't include common query elements like <code>COUNT</code>, <code>MIN</code>, <code>MAX</code>, or <code>TOP</code>.</li>
<li>Indexed views use physical space in the database, just like indexes on a table.</li>
</ol>
<p>This article describes additional benefits and limitations of indexed views:</p>
<blockquote>
<p><strong>You Can…</strong></p>
<ul>
<li>The view definition can reference one or more tables in the same
database.</li>
<li>Once the unique clustered index is created, additional nonclustered
indexes can be created against the view.</li>
<li>You can update the data in the underlying tables – including inserts,
updates, deletes, and even truncates.
</li>
</ul>
<p><strong>You Can’t…</strong></p>
<ul>
<li>The view definition can’t reference other views, or tables in other
databases.</li>
<li>It can’t contain COUNT, MIN, MAX, TOP, outer joins, or a few other
keywords or elements.</li>
<li>You can’t modify the underlying tables and columns. The view is created
with the WITH SCHEMABINDING option.</li>
<li>You can’t always predict what the query optimizer will do. If you’re
using Enterprise Edition, it will automatically consider the unique
clustered index as an option for a query – but if it finds a “better” index,
that will be used. You could force the optimizer to use the index through
the WITH NOEXPAND hint – but be cautious when using any hint.
</li>
</ul>
</blockquote>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1972.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1970.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
