<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1439) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1439.html">
<link rel="prev" href="index-1440.html" type="text/html">
<link rel="next" href="index-1438.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-should-we-use-rnns-instead-of-markov-models/" class="u-url">Why should we use RNNs instead of Markov models?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-should-we-use-rnns-instead-of-markov-models/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:53:54+08:00" itemprop="datePublished" title="2023-02-28 03:53">2023-02-28 03:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Recently I stumbled across this article, and I was wondering what the
difference between the results you would get from a recurrent neural net, like
the ones described above, and a simple Markov chain would be.</p>
<p>I don't really understand the linear algebra happening under the hood in an
RNN, but it seems that you are basically just designing a super convoluted way
of making a statistical model for what the next letter is going to be based on
the previous letters, something that is done very simply in a Markov Chain.</p>
<p>Why are RNNs interesting? Is it just because they are a more generalizable
solution, or is there something happening that I am missing?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>The Markov chain assumes the Markov property, it's "memoryless". The
probability of the next symbol is calculated based on the k previous symbols.
In practice k is limited to low values (let's say 3-5), because the transition
matrix grows exponentially. Therefore sentences generated by a Hidden Markov
Model are very inconsistent.</p>
<p>On the other hand, RNNs (e.g. with LSTM units) are not bound by the Markov
property. Their rich internal state allows them to keep track of long-distant
dependencies.</p>
<p>Karpathy's blog post lists C-sourcecode generated by an RNN character by
character. The model impressively captures the dependencies of things like
opening and closing brackets.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/is-it-reasonable-to-view-highly-autonomous-actors-as-agents/" class="u-url">Is it reasonable to view highly autonomous actors as agents?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/is-it-reasonable-to-view-highly-autonomous-actors-as-agents/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:53:37+08:00" itemprop="datePublished" title="2023-02-28 03:53">2023-02-28 03:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Coming from an academic background in mutli-agent systems (developed in Java
using JADE) I have only been peripherally aware of the Actor concurrency
paradigm. Now that I've started exploring Scala I couldn't help but be struck
by the similarities between the Agent and Actor approaches.</p>
<p>I'm very tempted to use Scala's Actor library for my next research project
rather than simply calling the JADE libraries as this would force me to get to
deeper grips with the language. Furthermore JADE's focus on defining
everything in terms of behaviours isn't very appropriate to my problem.</p>
<p>Is there something fundamentally different between a highly autonomous Actor
and an Agent that I am missing?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Yes, there are differences. For very simple agents, actors and agents might be
the same thing. However, by "autonomous agents" one, or, at least, I, usually
assume something like, <em>for example</em> , a Belief-Desire-Intention model, where
the agent models internally an abstraction of the environment it finds itself
in, and the agents it interacts with, so that it can make plans on how to
interact with that environment to achieve it's goals.</p>
<p>While an actor can sure have all this, a single agent might just as well be
composed of multiple actors, acting jointly to handle different parts of the
BDI framework. An actor is, for all intents, a scheduling unit. If your agents
are essentially linear and single-thread, they fit. If they do parallel work
internally, you want multiple actors for each agent.</p>
<p>So, what do actors and agents have in common?</p>
<ul>
<li>
<p>They both communicate by passing messages.</p>
</li>
<li>
<p>They both (usually) have an internal state -- even if implicit in the execution state.</p>
</li>
<li>
<p>They both are expected not to share state with other actors/agents.</p>
</li>
<li>
<p>They both are expected to be scheduled independently of other actors/agents.</p>
</li>
</ul>
<p>What do agents have more than actors?</p>
<ul>
<li>
<p>Agents usually follow models that dictate an agent's behavior -- such as, for example, BDI -- and actors usually don't. Reactive agents, though, are similar to actors in this respect.</p>
</li>
<li>
<p>Agents may have more than one internal unit of scheduling. Agents that do not, though, are similar to actors in this respect.</p>
</li>
</ul>
<p>What do actors have more than agents?</p>
<ul>
<li>Nothing that I can think of, though Scala actors can share state.</li>
</ul>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-does-a-path-finding-sometimes-go-in-straight-lines-and-sometimes-diagonals-java/" class="u-url">Why does A* path finding sometimes go in straight lines and sometimes diagonals? (Java)</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-does-a-path-finding-sometimes-go-in-straight-lines-and-sometimes-diagonals-java/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-28T03:53:15+08:00" itemprop="datePublished" title="2023-02-28 03:53">2023-02-28 03:53</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I'm in the process of developing a simple 2d grid based sim game, and have
fully functional path finding.</p>
<p>I used the answer found in my previous question as my basis for implementing
A* path finding. (Pathfinding 2D Java game?).</p>
<p>To show you really what I'm asking, I need to show you this video screen
capture that I made. I was just testing to see how the person would move to a
location and back again, and this was the result...</p>
<p>http://www.screenjelly.com/watch/Bd7d7pObyFo</p>
<p>Different choice of path depending on the direction, an unexpected result. Any
ideas?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>If you're looking for a simple-ish solution, may I suggest a bit of
randomization?</p>
<p>What I mean is this: in the cokeandcode code example, there is the nested-for-
loops that generate the "successor states" (to use the AI term). I refer to
the point where it loops over the 3x3 square around the "current" state,
adding new locations on the pile to consider.</p>
<p>A relatively simple fix would (should :)) be isolate that code a bit, and have
it, say, generated a linkedlist of nodes before the rest of the processing
step. Then Containers.Shuffle (or is it Generics.Shuffle?) that linked list,
and continue the processing there. Basically, have a routine say,
"createNaiveNeighbors(node)" that returns a LinkedList = {(node.x-1,node.y),
(node.x, node.y-1)... } (please pardon the pidgin Java, I'm trying (and always
failing) to be brief.</p>
<p>Once you build the linked list, however, you should just be able to do a "for
(Node n : myNewLinkedList)" instead of the</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">x</span><span class="o">=-</span><span class="mi">1</span><span class="c1">;x&lt;2;x++) {</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">y</span><span class="o">=-</span><span class="mi">1</span><span class="c1">;y&lt;2;y++) {</span>
</pre></div>

<p>And still use the exact same body code!</p>
<p>What this would do, ideally, is sort of "shake up" the order of nodes
considered, and create paths closer to the diagonal, but without having to
change the heuristic. The paths will still be the most efficient, but
<em>usually</em> closer to the diagonal.</p>
<p>The downside is, of course, if you go from A to B multiple times, a different
path may be taken. If that is unnacceptable, you may need to consider a more
drastic modification.</p>
<p>Hope this helps! -Agor</p>
<p><br></p>
<h3>Suggest</h3>
<p>Both of the paths are of the same length, so the algorithm is doing its job
just fine - it's finding a shortest path. However the A* algorithm doesn't
specify WHICH shortest path it will take. Implementations normally take the
"first" shortest path. Without seeing yours, it's impossible to know exactly
why, but if you want the same results each time you're going to have to add
priority rules of some sort (so that you're desired path comes up first in the
search).</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1440.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1438.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
