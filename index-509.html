<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 509) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-509.html">
<link rel="prev" href="index-510.html" type="text/html">
<link rel="next" href="index-508.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yao-shi-yan-ge-de-bie-ming-gui-ze/" class="u-url">什么是严格的别名规则？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yao-shi-yan-ge-de-bie-ming-gui-ze/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:48:03+08:00" itemprop="datePublished" title="2023-02-17 08:48">2023-02-17 08:48</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>当询问C 中常见的未定义行为时，人们有时会提到严格的别名规则。<br>
他们在说什么？</p>
<p><br><br></p>
<h2>解答</h2>
<p>遇到严格别名问题的典型情况是将结构（如设备/网络消息）覆盖到系统字长的缓冲区（如指向 s 或 s
的指针）<code>uint32_t</code>上<code>uint16_t</code>。当您将结构覆盖到这样的缓冲区上，或者通过指针转换将缓冲区覆盖到这样的结构上时，您很容易违反严格的别名规则。</p>
<p>所以在这种设置中，如果我想向某物发送消息，我必须有两个不兼容的指针指向同一块内存。然后我可能会天真地编写这样的代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">typedef</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="n">Msg</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Msg</span><span class="p">;</span>

<span class="n">void</span><span class="w"> </span><span class="n">SendWord</span><span class="p">(</span><span class="n">uint32_t</span><span class="p">);</span>

<span class="n">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Get a 32-bit buffer from the system</span>
<span class="w">    </span><span class="n">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">buff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">Msg</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Alias that buffer through message</span>
<span class="w">    </span><span class="n">Msg</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Msg</span><span class="o">*</span><span class="p">)(</span><span class="n">buff</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Send a bunch of messages    </span>
<span class="w">    </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">   </span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>严格的别名规则使此设置非法：取消引用别名对象的指针，该对象不是兼容类型或C 2011 6.5 第 7
1段允许的其他类型之一是未定义的行为。不幸的是，您仍然可以用这种方式编写代码， <em>可能</em> 会收到一些警告，编译正常，但在运行代码时只会出现奇怪的意外行为。</p>
<p>（GCC 在发出别名警告的能力上似乎有些不一致，有时会给我们一个友好的警告，有时则不会。）</p>
<p>要了解为什么此行为未定义，我们必须考虑严格的别名规则为编译器带来了什么。基本上，有了这个规则，它就不必考虑插入指令来刷新<code>buff</code>每次循环运行的内容。取而代之的是，在优化时，使用一些令人讨厌的关于别名的非强制性假设，它可以省略这些指令，在循环运行之前加载<code>buff[0]</code>并<code>buff[1]</code>进入
CPU
寄存器一次，并加速循环体。在引入严格别名之前，编译器不得不处于一种偏执状态，即其内容<code>buff</code>可能会被任何先前的内存存储更改。因此，为了获得额外的性能优势，并假设大多数人不使用双关语指针，引入了严格的别名规则。</p>
<p>请记住，如果您认为该示例是人为设计的，那么如果您将缓冲区传递给另一个为您发送的函数（如果您有的话），甚至可能会发生这种情况。</p>
<div class="code"><pre class="code literal-block"><span class="n">void</span><span class="w"> </span><span class="n">SendMessage</span><span class="p">(</span><span class="n">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">size32</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size32</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">SendWord</span><span class="p">(</span><span class="n">buff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</pre></div>

<p>并重写了我们之前的循环以利用这个方便的功能</p>
<div class="code"><pre class="code literal-block"><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="n">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">SendMessage</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>编译器可能会或可能不会或足够聪明地尝试内联 SendMessage 并且它可能会或可能不会决定再次加载或不加载
buff。如果<code>SendMessage</code>是另一个单独编译的 API 的一部分，它可能有加载 buff 内容的指令。再一次，也许你在 C++
中，这是编译器认为它可以内联的一些模板化头文件实现。或者它可能只是您为了方便而在 .c
文件中编写的内容。无论如何，未定义的行为可能仍会随之而来。即使我们知道引擎盖下发生的一些事情，它仍然违反规则，因此不能保证明确定义的行为。因此，仅通过包装一个采用我们的单词分隔缓冲区的函数并不一定有帮助。</p>
<p><strong>那么我该如何解决这个问题呢？</strong></p>
<ul>
<li>
<p>使用工会。大多数编译器都支持这一点，而不会抱怨严格的别名。这在 C99 中是允许的，并且在 C11 中是明确允许的。</p>
<div class="code"><pre class="code literal-block">  union {
  Msg msg;
  unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];
</pre></div>

<p>};</p>
</li>
<li>
<p>您可以在编译器中禁用严格别名（ gcc 中的f[no-]strict-aliasing））</p>
</li>
<li>
<p>您可以使用<code>char*</code>别名代替系统的字词。规则允许例外<code>char*</code>（包括<code>signed char</code>和<code>unsigned char</code>）。总是假定<code>char*</code>别名其他类型。然而，这不会以另一种方式起作用：没有假设您的结构别名是字符缓冲区。</p>
</li>
</ul>
<p><strong>初学者当心</strong></p>
<p>当两种类型相互叠加时，这只是一个潜在的雷区。您还应该了解字节顺序、单词对齐以及如何通过正确打包结构来处理对齐问题。</p>
<h3>脚注</h3>
<p>1 C 2011 6.5 7 允许左值访问的类型是：</p>
<ul>
<li>与对象的有效类型兼容的类型，</li>
<li>与对象的有效类型兼容的类型的限定版本，</li>
<li>一个类型，它是与对象的有效类型相对应的有符号或无符号类型，</li>
<li>一个类型，它是与对象的有效类型的限定版本相对应的有符号或无符号类型，</li>
<li>在其成员中包含上述类型之一的聚合或联合类型（递归地包括子聚合或包含的联合的成员），或</li>
<li>一种字符类型。</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p>我找到的最好的解释是 Mike Acton 的Understanding Strict Aliasing。它稍微专注于 PS3 开发，但基本上只是 GCC。</p>
<p>从文章：</p>
<blockquote>
<p>“严格别名是 C（或 C++）编译器做出的假设，即取消引用指向不同类型对象的指针永远不会引用相同的内存位置（即彼此别名。）”</p>
</blockquote>
<p>所以基本上，如果你有一个<code>int*</code>指向某个包含 an 的内存<code>int</code>，然后你将 a 指向<code>float*</code>那个内存并将它用作
a，<code>float</code>你就违反了规则。如果您的代码不遵守这一点，那么编译器的优化器很可能会破坏您的代码。</p>
<p>该规则的例外是 a <code>char*</code>，它可以指向任何类型。</p>
<p><br><br><a href="posts/what-is-the-strict-aliasing-rule/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/qing-can-yue-chrome-kai-fa-zhe-gong-ju-zhong-de-xuan-ting-zhuang-tai/" class="u-url">请参阅 Chrome 开发者工具中的悬停状态</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/qing-can-yue-chrome-kai-fa-zhe-gong-ju-zhong-de-xuan-ting-zhuang-tai/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:47:34+08:00" itemprop="datePublished" title="2023-02-17 08:47">2023-02-17 08:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想查看我在 <strong>Chrome</strong><code>:hover</code>中悬停的锚点的样式。在 <strong>Firebug</strong> 中，有一个样式下拉列表允许我为元素选择不同的状态。</p>
<hr>
<blockquote>
<p>我似乎无法在 Chrome 中找到任何类似的东西。我错过了什么吗？</p>
</blockquote>
<p><br><br></p>
<h2>解答</h2>
<p>现在您可以看到伪类规则并将它们强制应用于元素。</p>
<p><code>:hover</code>要查看样式窗格中的规则，请单击<code>:hov</code>右上角的小文本。</p>
<p><img alt="切换元素状态" src="images/NwulC.png"></p>
<p>要强制元素进入<code>:hover</code>状态，请右键单击它并选择<code>:hover</code>。</p>
<p><img alt="力元状态" src="images/XzMCB.png"></p>
<p>Chrome 开发人员工具快捷方式中元素面板的其他提示。</p>
<p><br></p>
<h3>更多建议</h3>
<h4>编辑：这个答案是在错误修复之前，请参阅 tnothcutt 的答案。</h4>
<p>这有点棘手，但这里是：</p>
<ul>
<li>右键单击元素，但不要将鼠标指针从元素上移开，使其保持悬停状态。</li>
<li>通过键盘选择检查元素，如点击向上箭头，然后按 Enter 键。</li>
<li>在匹配的 CSS 规则下查看开发人员工具，您应该能够看到：悬停。</li>
</ul>
<p><em>PS：我在你的一个问题标签上试过这个。</em></p>
<p><br><br><a href="posts/see-hover-state-in-chrome-developer-tools/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-lie-chu-javascript-dui-xiang-de-shu-xing/" class="u-url">如何列出 JavaScript 对象的属性？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-lie-chu-javascript-dui-xiang-de-shu-xing/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T08:47:04+08:00" itemprop="datePublished" title="2023-02-17 08:47">2023-02-17 08:47</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>假设我这样创建了一个对象：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">myObject</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="p">{</span><span class="s2">"ircEvent"</span><span class="p">:</span><span class="w"> </span><span class="s2">"PRIVMSG"</span><span class="p">,</span><span class="w"> </span><span class="s2">"method"</span><span class="p">:</span><span class="w"> </span><span class="s2">"newURI"</span><span class="p">,</span><span class="w"> </span><span class="s2">"regex"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^http://.*"</span><span class="p">};</span>
</pre></div>

<p>检索属性名称列表的最佳方法是什么？即我想以一些可变的“键”结束，这样：</p>
<div class="code"><pre class="code literal-block"><span class="n">keys</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">[</span><span class="s">"ircEvent"</span><span class="p">,</span><span class="w"> </span><span class="s">"method"</span><span class="p">,</span><span class="w"> </span><span class="s">"regex"</span><span class="p">]</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>在现代浏览器（IE9+、FF4+、Chrome5+、Opera12+、Safari5+）中，您可以使用内置的Object.keys方法：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">myObject</span><span class="p">);</span>
</pre></div>

<p>上面有一个完整的 polyfill 但简化版本是：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">getKeys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span>
<span class="w">   </span><span class="k">var</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">obj</span><span class="p">){</span>
<span class="w">      </span><span class="n">keys</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">keys</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>或者替换<code>var
getKeys</code>为<code>Object.prototype.keys</code>以允许您调用<code>.keys()</code>任何对象。扩展原型有一些副作用，我不建议这样做。</p>
<p><br></p>
<h3>更多建议</h3>
<p>正如slashnick所指出的，您可以使用“for in”结构来遍历对象的属性名称。但是，您将遍历对象原型链中的所有属性名称。如果只想遍历 <strong>对象</strong>
自身的属性，可以使用Object#hasOwnProperty()方法。于是有了以下。</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">hasOwnProperty</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">/*</span><span class="w"> </span><span class="n">useful</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="o">*/</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p><br><br><a href="posts/how-to-list-the-properties-of-a-javascript-object/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-510.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-508.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
