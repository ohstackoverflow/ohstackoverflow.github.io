<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 2771) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-2771.html">
<link rel="prev" href="index-2772.html" type="text/html">
<link rel="next" href="index-2770.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-implement-classic-sorting-algorithms-in-modern-c/" class="u-url">How to implement classic sorting algorithms in modern C++?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-implement-classic-sorting-algorithms-in-modern-c/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T16:43:43+08:00" itemprop="datePublished" title="2023-03-05 16:43">2023-03-05 16:43</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>The <code>std::sort</code> algorithm (and its cousins <code>std::partial_sort</code> and
<code>std::nth_element</code>) from the C++ Standard Library is in most implementations a
complicated and hybrid amalgamation of more elementary sorting algorithms,
such as selection sort, insertion sort, quick sort, merge sort, or heap sort.</p>
<p>There are many questions here and on sister sites such as
https://codereview.stackexchange.com/ related to bugs, complexity and other
aspects of implementations of these classic sorting algorithms. Most of the
offered implementations consist of raw loops, use index manipulation and
concrete types, and are generally non-trivial to analyse in terms of
correctness and efficiency.</p>
<p><strong>Question</strong> : how can the above mentioned classic sorting algorithms be
implemented using modern C++?</p>
<ul>
<li>
<strong>no raw loops</strong> , but combining the Standard Library's algorithmic building blocks from <code>&lt;algorithm&gt;</code>
</li>
<li>
<strong>iterator interface</strong> and use of <strong>templates</strong> instead of index manipulation and concrete types</li>
<li>
<strong>C++14 style</strong> , including the full Standard Library, as well as syntactic noise reducers such as <code>auto</code>, template aliases, transparent comparators and polymorphic lambdas.</li>
</ul>
<p><strong>Notes</strong> :</p>
<ul>
<li>for further references on implementations of sorting algorithms see Wikipedia, Rosetta Code or http://www.sorting-algorithms.com/ </li>
<li>according to <strong>Sean Parent's conventions</strong> (slide 39), a raw loop is a <code>for</code>-loop longer than composition of two functions with an operator. So <code>f(g(x));</code> or <code>f(x); g(x);</code> or <code>f(x) + g(x);</code> are not raw loops, and neither are the loops in <code>selection_sort</code> and <code>insertion_sort</code> below.</li>
<li>I follow Scott Meyers's terminology to denote the current C++1y already as C++14, and to denote C++98 and C++03 both as C++98, so don't flame me for that.</li>
<li>As suggested in the comments by @Mehrdad, I provide four implementations as a Live Example at the end of the answer: C++14, C++11, C++98 and Boost and C++98. </li>
<li>The answer itself is presented in terms of C++14 only. Where relevant, I denote the syntactic and library differences where the various language versions differ.</li>
</ul>
<p><br><br></p>
<h2>Answer</h2>
<h3>Algorithmic building blocks</h3>
<p>We begin by assembling the algorithmic building blocks from the Standard
Library:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span><span class="c1">    // min_element, iter_swap, </span>
<span class="w">                        </span><span class="c1">// upper_bound, rotate, </span>
<span class="w">                        </span><span class="c1">// partition, </span>
<span class="w">                        </span><span class="c1">// inplace_merge,</span>
<span class="w">                        </span><span class="c1">// make_heap, sort_heap, push_heap, pop_heap,</span>
<span class="w">                        </span><span class="c1">// is_heap, is_sorted</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span><span class="c1">      // assert </span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1">   // less</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iterator&gt;</span><span class="c1">     // distance, begin, end, next</span>
</pre></div>

<ul>
<li>the iterator tools such as non-member <code>std::begin()</code> / <code>std::end()</code> as well as with <code>std::next()</code> are only available as of C++11 and beyond. For C++98, one needs to write these himself. There are substitutes from Boost.Range in <code>boost::begin()</code> / <code>boost::end()</code>, and from Boost.Utility in <code>boost::next()</code>. </li>
<li>the <code>std::is_sorted</code> algorithm is only available for C++11 and beyond. For C++98, this can be implemented in terms of <code>std::adjacent_find</code> and a hand-written function object. Boost.Algorithm also provides a <code>boost::algorithm::is_sorted</code> as a substitute.</li>
<li>the <code>std::is_heap</code> algorithm is only available for C++11 and beyond.</li>
</ul>
<h3>Syntactical goodies</h3>
<p>C++14 provides <strong>transparent comparators</strong> of the form <code>std::less&lt;&gt;</code> that act
polymorphically on their arguments. This avoids having to provide an
iterator's type. This can be used in combination with C++11's <strong>default
function template arguments</strong> to create <strong>a single overload</strong> for sorting
algorithms that take <code>&lt;</code> as comparison and those that have a user-defined
comparison function object.</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">It</span><span class="o">,</span><span class="w"> </span><span class="nt">class</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">xxx_sort</span><span class="o">(</span><span class="nt">It</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">It</span><span class="w"> </span><span class="nt">last</span><span class="o">,</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="nt">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Compare</span><span class="p">{}</span><span class="o">);</span>
</pre></div>

<p>In C++11, one can define a reusable <strong>template alias</strong> to extract an
iterator's value type which adds minor clutter to the sort algorithms'
signatures:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">It</span><span class="o">&gt;</span>
<span class="nt">using</span><span class="w"> </span><span class="nt">value_type_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">typename</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">iterator_traits</span><span class="o">&lt;</span><span class="nt">It</span><span class="o">&gt;</span><span class="p">::</span><span class="nd">value_type</span><span class="o">;</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">It</span><span class="o">,</span><span class="w"> </span><span class="nt">class</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">less</span><span class="o">&lt;</span><span class="nt">value_type_t</span><span class="o">&lt;</span><span class="nt">It</span><span class="o">&gt;&gt;&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">xxx_sort</span><span class="o">(</span><span class="nt">It</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">It</span><span class="w"> </span><span class="nt">last</span><span class="o">,</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="nt">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Compare</span><span class="p">{}</span><span class="o">);</span>
</pre></div>

<p>In C++98, one needs to write two overloads and use the verbose <code>typename
xxx&lt;yyy&gt;::type</code> syntax</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">It</span><span class="o">,</span><span class="w"> </span><span class="nt">class</span><span class="w"> </span><span class="nt">Compare</span><span class="o">&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">xxx_sort</span><span class="o">(</span><span class="nt">It</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">It</span><span class="w"> </span><span class="nt">last</span><span class="o">,</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="nt">cmp</span><span class="o">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nt">general</span><span class="w"> </span><span class="nt">implementation</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">It</span><span class="o">&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">xxx_sort</span><span class="o">(</span><span class="nt">It</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">It</span><span class="w"> </span><span class="nt">last</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">xxx_sort(first,</span><span class="w"> </span><span class="err">last,</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">less</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>Another syntactical nicety is that C++14 facilitates wrapping user-defined comparators through <strong>polymorphic lambdas</strong> (with <code>auto</code> parameters that are deduced like function template arguments). </li>
<li>C++11 only has monomorphic lambdas, that require the use of the above template alias <code>value_type_t</code>. </li>
<li>In C++98, one either needs to write a standalone function object or resort to the verbose <code>std::bind1st</code> / <code>std::bind2nd</code> / <code>std::not1</code> type of syntax. </li>
<li>Boost.Bind improves this with <code>boost::bind</code> and <code>_1</code> / <code>_2</code> placeholder syntax.</li>
<li>C++11 and beyond also have <code>std::find_if_not</code>, whereas C++98 needs <code>std::find_if</code> with a <code>std::not1</code> around a function object.</li>
</ul>
<h3>C++ Style</h3>
<p>There is no generally acceptable C++14 style yet. For better or for worse, I
closely follow Scott Meyers's <strong>draft Effective Modern C++</strong> and Herb Sutter's
<strong>revamped GotW</strong>. I use the following style recommendations:</p>
<ul>
<li>Herb Sutter's <strong>"Almost Always Auto"</strong> and Scott Meyers's <strong>"Prefer auto to specific type declarations"</strong> recommendation, for which the brevity is unsurpassed, although its clarity is sometimes <strong>disputed</strong>.</li>
<li>Scott Meyers's <strong>"Distinguish<code>()</code> and <code>{}</code> when creating objects"</strong> and consistently choose braced-initialization <code>{}</code> instead of the good old parenthesized initialization <code>()</code> (in order to side-step all most-vexing-parse issues in generic code).</li>
<li>Scott Meyers's <strong>"Prefer alias declarations to typedefs"</strong>. For templates this is a must anyway, and using it everywhere instead of <code>typedef</code> saves time and adds consistency.</li>
<li>I use a <code>for (auto it = first; it != last; ++it)</code> pattern in some places, in order to allow for loop invariant checking for already sorted sub-ranges. In production code, the use of <code>while (first != last)</code> and a <code>++first</code> somewhere inside the loop might be slightly better.</li>
</ul>
<h3>Selection sort</h3>
<p><strong>Selection sort</strong> does not adapt to the data in any way, so its runtime is
always <code>O(N²)</code>. However, selection sort has the property of <strong>minimizing the
number of swaps</strong>. In applications where the cost of swapping items is high,
selection sort very well may be the algorithm of choice.</p>
<p>To implement it using the Standard Library, repeatedly use <code>std::min_element</code>
to find the remaining minimum element, and <code>iter_swap</code> to swap it into place:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">FwdIt</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">selection_sort</span><span class="p">(</span><span class="n">FwdIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">FwdIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Compare</span><span class="p">{})</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="p">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Note that <code>selection_sort</code> has the already processed range <code>[first, it)</code>
sorted as its loop invariant. The minimal requirements are <strong>forward
iterators</strong> , compared to <code>std::sort</code>'s random access iterators.</p>
<p><strong>Details omitted</strong> :</p>
<ul>
<li>selection sort can be optimized with an early test <code>if (std::distance(first, last) &lt;= 1) return;</code> (or for forward / bidirectional iterators: <code>if (first == last || std::next(first) == last) return;</code>).</li>
<li>for <strong>bidirectional iterators</strong> , the above test can be combined with a loop over the interval <code>[first, std::prev(last))</code>, because the last element is guaranteed to be the minimal remaining element and doesn't require a swap.</li>
</ul>
<h3>Insertion sort</h3>
<p>Although it is one of the elementary sorting algorithms with <code>O(N²)</code> worst-
case time, <strong>insertion sort</strong> is the algorithm of choice either when the data
is nearly sorted (because it is <strong>adaptive</strong> ) or when the problem size is
small (because it has low overhead). For these reasons, and because it is also
<strong>stable</strong> , insertion sort is often used as the recursive base case (when the
problem size is small) for higher overhead divide-and-conquer sorting
algorithms, such as merge sort or quick sort.</p>
<p>To implement <code>insertion_sort</code> with the Standard Library, repeatedly use
<code>std::upper_bound</code> to find the location where the current element needs to go,
and use <code>std::rotate</code> to shift the remaining elements upward in the input
range:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">FwdIt</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">insertion_sort</span><span class="p">(</span><span class="n">FwdIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">FwdIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Compare</span><span class="p">{})</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">insertion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="p">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">insertion</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">));</span><span class="w"> </span>
<span class="w">        </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">),</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Note that <code>insertion_sort</code> has the already processed range <code>[first, it)</code>
sorted as its loop invariant. Insertion sort also works with forward
iterators.</p>
<p><strong>Details omitted</strong> :</p>
<ul>
<li>insertion sort can be optimized with an early test <code>if (std::distance(first, last) &lt;= 1) return;</code> (or for forward / bidirectional iterators: <code>if (first == last || std::next(first) == last) return;</code>) and a loop over the interval <code>[std::next(first), last)</code>, because the first element is guaranteed to be in place and doesn't require a rotate.</li>
<li>for <strong>bidirectional iterators</strong> , the binary search to find the insertion point can be replaced with a <strong>reverse linear search</strong> using the Standard Library's <code>std::find_if_not</code> algorithm. </li>
</ul>
<p>Four <strong>Live Examples</strong> ( <strong>C++14</strong> , <strong>C++11</strong> , <strong>C++98 and Boost</strong> ,
<strong>C++98</strong> ) for the fragment below:</p>
<div class="code"><pre class="code literal-block"><span class="n">using</span><span class="w"> </span><span class="n">RevIt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">BiDirIt</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">insertion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">find_if_not</span><span class="p">(</span><span class="n">RevIt</span><span class="p">(</span><span class="n">it</span><span class="p">),</span><span class="w"> </span><span class="n">RevIt</span><span class="p">(</span><span class="n">first</span><span class="p">),</span><span class="w"> </span>
<span class="w">    </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cmp</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">)</span><span class="o">.</span><span class="n">base</span><span class="p">();</span>
</pre></div>

<ul>
<li>For random inputs this gives <code>O(N²)</code> comparisons, but this improves to <code>O(N)</code> comparisons for almost sorted inputs. The binary search always uses <code>O(N log N)</code> comparisons. </li>
<li>For small input ranges, the better memory locality (cache, prefetching) of a linear search might also dominate a binary search (one should test this, of course).</li>
</ul>
<h3>Quick sort</h3>
<p>When carefully implemented, <strong>quick sort</strong> is robust and has <code>O(N log N)</code>
expected complexity, but with <code>O(N²)</code> worst-case complexity that can be
triggered with adversarially chosen input data. When a stable sort is not
needed, quick sort is an excellent general-purpose sort.</p>
<p>Even for the simplest versions, quick sort is quite a bit more complicated to
implement using the Standard Library than the other classic sorting
algorithms. The approach below uses a few iterator utilities to locate the
<strong>middle element</strong> of the input range <code>[first, last)</code> as the pivot, then use
two calls to <code>std::partition</code> (which are <code>O(N)</code>) to three-way partition the
input range into segments of elements that are smaller than, equal to, and
larger than the selected pivot, respectively. Finally the two outer segments
with elements smaller than and larger than the pivot are recursively sorted:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">FwdIt</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">FwdIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">FwdIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Compare</span><span class="p">{})</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">std</span><span class="p">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">middle1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">partition</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">){</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cmp</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="n">pivot</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">middle2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">partition</span><span class="p">(</span><span class="n">middle1</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">elem</span><span class="p">){</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span><span class="w"> </span><span class="n">elem</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">middle1</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">middle1</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">middle2</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">middle2</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>However, quick sort is rather tricky to get correct and efficient, as each of
the above steps has to be carefully checked and optimized for production level
code. In particular, for <code>O(N log N)</code> complexity, the pivot has to result into
a balanced partition of the input data, which cannot be guaranteed in general
for an <code>O(1)</code> pivot, but which can be guaranteed if one sets the pivot as the
<code>O(N)</code> median of the input range.</p>
<p><strong>Details omitted</strong> :</p>
<ul>
<li>the above implementation is particularly vulnerable to special inputs, e.g. it has <code>O(N^2)</code> complexity for the " <strong>organ pipe</strong> " input <code>1, 2, 3, ..., N/2, ... 3, 2, 1</code> (because the middle is always larger than all other elements).</li>
<li>
<strong>median-of-3</strong> pivot selection from <strong>randomly chosen elements</strong> from the input range guards against almost sorted inputs for which the complexity would otherwise deteriorate to <code>O(N^2)</code>.</li>
<li>
<strong>3-way partitioning</strong> (separating elements smaller than, equal to and larger than the pivot) as shown by the two calls to <code>std::partition</code> is not the most efficient <code>O(N)</code> algorithm to achieve this result. </li>
<li>for <strong>random access iterators</strong> , a guaranteed <code>O(N log N)</code> complexity can be achieved through <strong>median pivot selection</strong> using <code>std::nth_element(first, middle, last)</code>, followed by recursive calls to <code>quick_sort(first, middle, cmp)</code> and <code>quick_sort(middle, last, cmp)</code>. </li>
<li>this guarantee comes at a cost, however, because the constant factor of the <code>O(N)</code> complexity of <code>std::nth_element</code> can be more expensive than that of the <code>O(1)</code> complexity of a median-of-3 pivot followed by an <code>O(N)</code> call to <code>std::partition</code> (which is a cache-friendly single forward pass over the data).</li>
</ul>
<h3>Merge sort</h3>
<p>If using <code>O(N)</code> extra space is of no concern, then <strong>merge sort</strong> is an
excellent choice: it is the only <strong>stable</strong> <code>O(N log N)</code> sorting algorithm.</p>
<p>It is simple to implement using Standard algorithms: use a few iterator
utilities to locate the middle of the input range <code>[first, last)</code> and combine
two recursively sorted segments with a <code>std::inplace_merge</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="n">BiDirIt</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nb nb-Type">void</span><span class="w"> </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">BiDirIt</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">BiDirIt</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Compare</span><span class="p">{})</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">                   </span>
<span class="w">    </span><span class="n">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">middle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">middle</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">middle</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="n">merge_sort</span><span class="p">(</span><span class="n">middle</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">middle</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">inplace_merge</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">middle</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">assert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>Merge sort requires bidirectional iterators, the bottleneck being the
<code>std::inplace_merge</code>. Note that when sorting linked lists, merge sort requires
only <code>O(log N)</code> extra space (for recursion). The latter algorithm is
implemented by <code>std::list&lt;T&gt;::sort</code> in the Standard Library.</p>
<h3>Heap sort</h3>
<p><strong>Heap sort</strong> is simple to implement, performs an <code>O(N log N)</code> in-place sort,
but is not stable.</p>
<p>The first loop, <code>O(N)</code> "heapify" phase, puts the array into heap order. The
second loop, the <code>O(N log N</code>) "sortdown" phase, repeatedly extracts the
maximum and restores heap order. The Standard Library makes this extremely
straightforward:</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">RandomIt</span><span class="o">,</span><span class="w"> </span><span class="nt">class</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">heap_sort</span><span class="o">(</span><span class="nt">RandomIt</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">RandomIt</span><span class="w"> </span><span class="nt">last</span><span class="o">,</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="nt">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Compare</span><span class="p">{}</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">lib</span><span class="p">:</span><span class="o">:</span><span class="nf">make_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="kc">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">assert(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">is_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="kc">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="w">    </span><span class="n">lib</span><span class="p">:</span><span class="o">:</span><span class="nf">sort_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="kc">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">assert(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">is_sorted</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="kc">last</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>In case you consider it "cheating" to use <code>std::make_heap</code> and
<code>std::sort_heap</code>, you can go one level deeper and write those functions
yourself in terms of <code>std::push_heap</code> and <code>std::pop_heap</code>, respectively:</p>
<div class="code"><pre class="code literal-block"><span class="nt">namespace</span><span class="w"> </span><span class="nt">lib</span><span class="w"> </span><span class="p">{</span>

<span class="err">//</span><span class="w"> </span><span class="n">NOTE</span><span class="p">:</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">O</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">N</span><span class="p">),</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">O</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_heap</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="w"> </span><span class="n">RandomIt</span><span class="p">,</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="n">void</span><span class="w"> </span><span class="nf">make_heap</span><span class="p">(</span><span class="n">RandomIt</span><span class="w"> </span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">RandomIt</span><span class="w"> </span><span class="kc">last</span><span class="p">,</span><span class="w"> </span><span class="n">Compare</span><span class="w"> </span><span class="n">cmp</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="n">Compare</span><span class="err">{}</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">for</span><span class="w"> </span><span class="p">(</span><span class="kc">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">first</span><span class="p">;</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="err">!=</span><span class="w"> </span><span class="err">last</span><span class="p">;</span><span class="err">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">push_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="err">assert(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">is_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span><span class="w">           </span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span>

<span class="nt">template</span><span class="o">&lt;</span><span class="nt">class</span><span class="w"> </span><span class="nt">RandomIt</span><span class="o">,</span><span class="w"> </span><span class="nt">class</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">std</span><span class="p">::</span><span class="nd">less</span><span class="o">&lt;&gt;&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">sort_heap</span><span class="o">(</span><span class="nt">RandomIt</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">RandomIt</span><span class="w"> </span><span class="nt">last</span><span class="o">,</span><span class="w"> </span><span class="nt">Compare</span><span class="w"> </span><span class="nt">cmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Compare</span><span class="p">{}</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">for</span><span class="w"> </span><span class="err">(auto</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">last</span><span class="p">;</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="err">!=</span><span class="w"> </span><span class="err">first</span><span class="p">;</span><span class="err">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">pop_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">--</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
<span class="w">        </span><span class="err">assert(</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">is_heap</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span><span class="p">));</span><span class="w">           </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="err">}</span>

<span class="err">}</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="nt">namespace</span><span class="w"> </span><span class="nt">lib</span>
</pre></div>

<p>The Standard Library specifies both <code>push_heap</code> and <code>pop_heap</code> as complexity
<code>O(log N)</code>. Note however that the outer loop over the range <code>[first, last)</code>
results in <code>O(N log N)</code> complexity for <code>make_heap</code>, whereas <code>std::make_heap</code>
has only <code>O(N)</code> complexity. For the overall <code>O(N log N)</code> complexity of
<code>heap_sort</code> it doesn't matter.</p>
<p><strong>Details omitted</strong> : <strong><code>O(N)</code> implementation of <code>make_heap</code></strong></p>
<h3>Testing</h3>
<p>Here are four <strong>Live Examples</strong> ( <strong>C++14</strong> , <strong>C++11</strong> , <strong>C++98 and Boost</strong>
, <strong>C++98</strong> ) testing all five algorithms on a variety of inputs (not meant to
be exhaustive or rigorous). Just note the huge differences in the LOC:
C++11/C++14 need around 130 LOC, C++98 and Boost 190 (+50%) and C++98 more
than 270 (+100%).</p>
<p><br></p>
<h3>Suggest</h3>
<p>Another small and rather elegant one originally found on code review. I
thought it was worth sharing.</p>
<h3>Counting sort</h3>
<p>While it is rather specialized, counting sort is a simple integer sorting
algorithm and can often be really fast provided the values of the integers to
sort are not too far apart. It's probably ideal if one ever needs to sort a
collection of one million integers known to be between 0 and 100 for example.</p>
<p>To implement a very simple counting sort that works with both signed and
unsigned integers, one needs to find the smallest and greatest elements in the
collection to sort; their difference will tell the size of the array of counts
to allocate. Then, a second pass through the collection is done to count the
number of occurrences of every element. Finally, we write back the required
number of every integer back to the original collection.</p>
<div class="code"><pre class="code literal-block"><span class="nt">template</span><span class="o">&lt;</span><span class="nt">typename</span><span class="w"> </span><span class="nt">ForwardIterator</span><span class="o">&gt;</span>
<span class="nt">void</span><span class="w"> </span><span class="nt">counting_sort</span><span class="o">(</span><span class="nt">ForwardIterator</span><span class="w"> </span><span class="nt">first</span><span class="o">,</span><span class="w"> </span><span class="nt">ForwardIterator</span><span class="w"> </span><span class="nt">last</span><span class="o">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(first</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">last</span><span class="w"> </span><span class="err">||</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">next</span><span class="p">(</span><span class="kc">first</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">last</span><span class="p">)</span><span class="w"> </span><span class="n">return</span><span class="p">;</span>

<span class="w">    </span><span class="err">auto</span><span class="w"> </span><span class="err">minmax</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">minmax_element</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="kc">last</span><span class="p">);</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="err">avoid</span><span class="w"> </span><span class="err">if</span><span class="w"> </span><span class="err">possible.</span>
<span class="w">    </span><span class="err">auto</span><span class="w"> </span><span class="err">min</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">*minmax.first</span><span class="p">;</span>
<span class="w">    </span><span class="err">auto</span><span class="w"> </span><span class="err">max</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">*minmax.second</span><span class="p">;</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(min</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">max)</span><span class="w"> </span><span class="err">return</span><span class="p">;</span>

<span class="w">    </span><span class="err">using</span><span class="w"> </span><span class="err">difference_type</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">typename</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">ForwardIterator</span><span class="o">&gt;::</span><span class="n">difference_type</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">difference_type</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">counts</span><span class="p">(</span><span class="n">max</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="err">for</span><span class="w"> </span><span class="err">(auto</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">first</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="err">it</span><span class="w"> </span><span class="err">!=</span><span class="w"> </span><span class="err">last</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="err">++it)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">++counts</span><span class="cp">[</span><span class="o">*</span><span class="nx">it</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">min</span><span class="cp">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nt">for</span><span class="w"> </span><span class="o">(</span><span class="nt">auto</span><span class="w"> </span><span class="nt">count</span><span class="o">:</span><span class="w"> </span><span class="nt">counts</span><span class="o">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">first</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">fill_n</span><span class="p">(</span><span class="kc">first</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="o">++</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span>
</pre></div>

<p>While it is only useful when the range of the integers to sort is known to be
small (generally not larger than the size of the collection to sort), making
counting sort more generic would make it slower for its best cases. If the
range is not known to be small, another algorithm such a radix sort, ska_sort
or spreadsort can be used instead.</p>
<p><strong>Details omitted</strong> :</p>
<ul>
<li>
<p>We could have passed the bounds of the range of values accepted by the algorithm as parameters to totally get rid of the first <code>std::minmax_element</code> pass through the collection. This will make the algorithm even faster when a usefully-small range limit is known by other means. (It doesn't have to be exact; passing a constant 0 to 100 is still <em>much</em> better than an extra pass over a million elements to find out that the true bounds are 1 to 95. Even 0 to 1000 would be worth it; the extra elements are written once with zero and read once).</p>
</li>
<li>
<p>Growing <code>counts</code> on the fly is another way to avoid a separate first pass. Doubling the <code>counts</code> size each time it has to grow gives amortized O(1) time per sorted element (see hash table insertion cost analysis for the proof that exponential grown is the key). Growing at the end for a new <code>max</code> is easy with <code>std::vector::resize</code> to add new zeroed elements. Changing <code>min</code> on the fly and inserting new zeroed elements at the front can be done with <code>std::copy_backward</code> after growing the vector. Then <code>std::fill</code> to zero the new elements.</p>
</li>
<li>
<p>The <code>counts</code> increment loop is a histogram. If the data is likely to be highly repetitive, and the number of bins is small, it can be worth unrolling over multiple arrays to reduce the serializing data dependency bottleneck of store/reload to the same bin. This means more counts to zero at the start, and more to loop over at the end, but should be worth it on most CPUs for our example of millions of 0 to 100 numbers, especially if the input might already be (partially) sorted and have long runs of the same number.</p>
</li>
<li>
<p>In the algorithm above, we use a <code>min == max</code> check to return early when every element has the same value (in which case the collection is sorted). It is actually possible to instead fully check whether the collection is already sorted while finding the extreme values of a collection with no additional time wasted (if the first pass is still memory bottlenecked with the extra work of updating min and max). However such an algorithm does not exist in the standard library and writing one would be more tedious than writing the rest of counting sort itself. It is left as an exercise for the reader.</p>
</li>
<li>
<p>Since the algorithm only works with integer values, static assertions could be used to prevent users from making obvious type mistakes. In some contexts, a substitution failure with <code>std::enable_if_t</code> might be preferred. </p>
</li>
<li>
<p>While modern C++ is cool, future C++ could be even cooler: structured bindings and some parts of the Ranges TS would make the algorithm even cleaner.</p>
</li>
</ul>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-should-i-make-a-copy-of-a-data-frame-in-pandas/" class="u-url">why should I make a copy of a data frame in pandas</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-should-i-make-a-copy-of-a-data-frame-in-pandas/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T16:42:04+08:00" itemprop="datePublished" title="2023-03-05 16:42">2023-03-05 16:42</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>When selecting a sub dataframe from a parent dataframe, I noticed that some
programmers make a copy of the data frame using the <code>.copy()</code> method. For
example,</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_dataframe</span><span class="o">[</span><span class="n">features_list</span><span class="o">]</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>

<p>...instead of just</p>
<div class="code"><pre class="code literal-block"><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_dataframe</span><span class="o">[</span><span class="n">features_list</span><span class="o">]</span>
</pre></div>

<p>Why are they making a copy of the data frame? What will happen if I don't make
a copy?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>This expands on Paul's answer. In Pandas, indexing a DataFrame returns a
reference to the initial DataFrame. Thus, changing the subset will change the
initial DataFrame. Thus, you'd want to use the copy if you want to make sure
the initial DataFrame shouldn't change. Consider the following code:</p>
<div class="code"><pre class="code literal-block">df = DataFrame({'x': [1,2]})
df_sub = df[0:1]
df_sub.x = -1
print(df)
</pre></div>

<p>You'll get:</p>
<div class="code"><pre class="code literal-block">   x
0 -1
1  2
</pre></div>

<p>In contrast, the following leaves df unchanged:</p>
<div class="code"><pre class="code literal-block">df_sub_copy = df[0:1].copy()
df_sub_copy.x = -1
</pre></div>

<p>This answer has been deprecated in newer versions of pandas. See docs</p>
<p><br></p>
<h3>Suggest</h3>
<p>Because if you don't make a copy then the indices can still be manipulated
elsewhere even if you assign the dataFrame to a different name.</p>
<p>For example:</p>
<div class="code"><pre class="code literal-block">df2 = df
func1(df2)
func2(df)
</pre></div>

<p>func1 can modify df by modifying df2, so to avoid that:</p>
<div class="code"><pre class="code literal-block">df2 = df.copy()
func1(df2)
func2(df)
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-can-i-handle-many-to-many-relationships-in-a-restful-api/" class="u-url">How can I handle many-to-many relationships in a RESTful API?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-can-i-handle-many-to-many-relationships-in-a-restful-api/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-05T16:40:47+08:00" itemprop="datePublished" title="2023-03-05 16:40">2023-03-05 16:40</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Imagine you have two entities, <strong>Player</strong> and <strong>Team</strong> , where players can be
on multiple teams. In my data model, I have a table for each entity, and a
join table to maintain the relationships. Hibernate is fine at handling this,
but how might I expose this relationship in a RESTful API?</p>
<p>I can think of a couple of ways. First, I might have each entity contain a
list of the other, so a Player object would have a list of Teams it belongs
to, and each Team object would have a list of Players that belong to it. So to
add a Player to a Team, you would just POST the player's representation to an
endpoint, something like POST <code>/player</code> or POST <code>/team</code> with the appropriate
object as the payload of the request. This seems the most "RESTful" to me, but
feels a little weird.</p>
<div class="code"><pre class="code literal-block">/api/team/0:

{
    name: 'Boston Celtics',
    logo: '/img/Celtics.png',
    players: [
        '/api/player/20',
        '/api/player/5',
        '/api/player/34'
    ]
}

/api/player/20:

{
    pk: 20,
    name: 'Ray Allen',
    birth: '1975-07-20T02:00:00Z',
    team: '/api/team/0'
}
</pre></div>

<p>The other way I can think of to do this would be to expose the relationship as
a resource in its own right. So to see a list of all the players on a given
team, you might do a GET <code>/playerteam/team/{id}</code> or something like that and
get back a list of PlayerTeam entities. To add a player to a team, POST
<code>/playerteam</code> with an appropriately built PlayerTeam entity as the payload.</p>
<div class="code"><pre class="code literal-block">/api/team/0:

{
    name: 'Boston Celtics',
    logo: '/img/Celtics.png'
}

/api/player/20:

{
    pk: 20,
    name: 'Ray Allen',
    birth: '1975-07-20T02:00:00Z',
    team: '/api/team/0'
}

/api/player/team/0/:

[
    '/api/player/20',
    '/api/player/5',
    '/api/player/34'
]
</pre></div>

<p>What is the best practice for this?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>In a RESTful interface, you can return documents that describe the
relationships between resources by encoding those relationships as links.
Thus, a team can be said to have a document resource (<code>/team/{id}/players</code>)
that is a list of links to players (<code>/player/{id}</code>) on the team, and a player
can have a document resource (<code>/player/{id}/teams</code>) that is a list of links to
teams that the player is a member of. Nice and symmetric. You can the map
operations on that list easily enough, even giving a relationship its own IDs
(arguably they'd have two IDs, depending on whether you're thinking about the
relationship team-first or player-first) if that makes things easier. The only
tricky bit is that you've got to remember to delete the relationship from the
other end as well if you delete it from one end, but rigorously handling this
by using an underlying data model and then having the REST interface be a view
of that model is going to make that easier.</p>
<p>Relationship IDs probably ought to be based on UUIDs or something equally long
and random, irrespective of whatever type of IDs you use for teams and
players. That will let you use the same UUID as the ID component for each end
of the relationship without worrying about collisions (small integers do <em>not</em>
have that advantage). If these membership relationships have any properties
other than the bare fact that they relate a player and a team in a
bidirectional fashion, they should have their own identity that is independent
of both players and teams; a GET on the player»team view
(<code>/player/{playerID}/teams/{teamID}</code>) could then do an HTTP redirect to the
bidirectional view (<code>/memberships/{uuid}</code>).</p>
<p>I recommend writing links in any XML documents you return (if you happen to be
producing XML of course) using XLink <code>xlink:href</code> attributes.</p>
<p><br></p>
<h3>Suggest</h3>
<p>In a RESTful interface, you can return documents that describe the
relationships between resources by encoding those relationships as links.
Thus, a team can be said to have a document resource (<code>/team/{id}/players</code>)
that is a list of links to players (<code>/player/{id}</code>) on the team, and a player
can have a document resource (<code>/player/{id}/teams</code>) that is a list of links to
teams that the player is a member of. Nice and symmetric. You can the map
operations on that list easily enough, even giving a relationship its own IDs
(arguably they'd have two IDs, depending on whether you're thinking about the
relationship team-first or player-first) if that makes things easier. The only
tricky bit is that you've got to remember to delete the relationship from the
other end as well if you delete it from one end, but rigorously handling this
by using an underlying data model and then having the REST interface be a view
of that model is going to make that easier.</p>
<p>Relationship IDs probably ought to be based on UUIDs or something equally long
and random, irrespective of whatever type of IDs you use for teams and
players. That will let you use the same UUID as the ID component for each end
of the relationship without worrying about collisions (small integers do <em>not</em>
have that advantage). If these membership relationships have any properties
other than the bare fact that they relate a player and a team in a
bidirectional fashion, they should have their own identity that is independent
of both players and teams; a GET on the player»team view
(<code>/player/{playerID}/teams/{teamID}</code>) could then do an HTTP redirect to the
bidirectional view (<code>/memberships/{uuid}</code>).</p>
<p>I recommend writing links in any XML documents you return (if you happen to be
producing XML of course) using XLink <code>xlink:href</code> attributes.</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2772.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2770.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
