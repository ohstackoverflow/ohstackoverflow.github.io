<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1855) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1855.html">
<link rel="prev" href="index-1856.html" type="text/html">
<link rel="next" href="index-1854.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/why-does-a-base64-encoded-string-have-an-sign-at-the-end/" class="u-url">Why does a base64 encoded string have an = sign at the end</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/why-does-a-base64-encoded-string-have-an-sign-at-the-end/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T10:56:59+08:00" itemprop="datePublished" title="2023-03-03 10:56">2023-03-03 10:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I know what <code>base64</code> encoding is and how to calculate <code>base64</code> encoding in C#,
however I have seen several times that when I convert a string into base64,
there is an <code>=</code> at the end.</p>
<p>A few questions came up:</p>
<ol>
<li>Does a <code>base64</code> string always end with <code>=</code>?</li>
<li>Why does an <code>=</code> get appended at the end?</li>
</ol>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Q Does a base64 string always end with<code>=</code>?</strong></p>
<p>A: No. (the word <code>usb</code> is base64 encoded into <code>dXNi</code>)</p>
<p><strong>Q Why does an<code>=</code> get appended at the end?</strong></p>
<p>A: As a short answer:<br>
The last character (<code>=</code> sign) is added only as a complement (padding) in the
final process of encoding a message with a <em>special</em> number of characters.</p>
<p>You will not have an <code>=</code> sign if your string has a multiple of 3 characters,
because <code>Base64</code> encoding takes each <strong>three</strong> bytes (a character=1 byte) and
represents them as <strong>four</strong> printable characters in the ASCII standard.</p>
<p><strong>Example</strong> :</p>
<p><strong>(a)</strong> If you want to encode</p>
<p><strong>ABCDEFG</strong> &lt;=&gt; [<code>ABC</code>] [<code>DEF</code>] [<code>G</code>]</p>
<p><code>Base64</code> deals with the first block (producing 4 characters) and the second
(as they are complete). But for the third, it will add a double <strong><code>==</code></strong> in
the output in order to complete the 4 needed characters. Thus, the result will
be <strong>QUJD</strong> <strong>REVG</strong> <strong>Rw==</strong> (without spaces).</p>
<p>[<code>ABC</code>] =&gt; <code>QUJD</code></p>
<p>[<code>DEF</code>] =&gt; <code>REVG</code></p>
<p>[<code>G</code>] =&gt; <code>Rw==</code></p>
<p><strong>(b)</strong> If you want to encode <strong>ABCDEFGH</strong> &lt;=&gt; [<code>ABC</code>] [<code>DEF</code>] [<code>GH</code>]</p>
<p>similarly, it will add one <code>=</code> at the end of the output to get 4 characters.</p>
<p>The result will be <strong>QUJD</strong> <strong>REVG</strong> <strong>R0g=</strong> (without spaces).</p>
<p>[<code>ABC</code>] =&gt; <code>QUJD</code></p>
<p>[<code>DEF</code>] =&gt; <code>REVG</code></p>
<p>[<code>GH</code>] =&gt; <code>R0g=</code></p>
<p><br></p>
<h3>Suggest</h3>
<p>It serves as padding.</p>
<p>A more complete answer is that a base64 encoded string doesn't <em>always</em> end
with a <code>=</code>, it will only end with one or two <code>=</code> if they are required to pad
the string out to the proper length.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/how-to-generate-a-random-string-of-a-fixed-length-in-go/" class="u-url">How to generate a random string of a fixed length in Go?</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/how-to-generate-a-random-string-of-a-fixed-length-in-go/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T10:56:32+08:00" itemprop="datePublished" title="2023-03-03 10:56">2023-03-03 10:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I want a random string of characters only (uppercase or lowercase), no
numbers, in Go. What is the fastest and simplest way to do this?</p>
<p><br><br></p>
<h2>Answer</h2>
<p>Paul's solution provides a <em>simple</em> , general solution.</p>
<p>The question asks for the <em>"the fastest and simplest way"</em>. Let's address the
<em>fastest</em> part too. We'll arrive at our final, fastest code in an iterative
manner. Benchmarking each iteration can be found at the end of the answer.</p>
<p>All the solutions and the benchmarking code can be found on the Go Playground.
The code on the Playground is a test file, not an executable. You have to save
it into a file named <code>XX_test.go</code> and run it with</p>
<div class="code"><pre class="code literal-block"><span class="k">go</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">-</span><span class="n">bench</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">-</span><span class="n">benchmem</span>
</pre></div>

<p><strong>Foreword</strong> :</p>
<blockquote>
<p>The fastest solution is not a go-to solution if you just need a random
string. For that, Paul's solution is perfect. This is if performance does
matter. Although the first 2 steps ( <strong>Bytes</strong> and <strong>Remainder</strong> ) might be
an acceptable compromise: they do improve performance by like 50% (see exact
numbers in the <strong>II. Benchmark</strong> section), and they don't increase
complexity significantly.</p>
</blockquote>
<p>Having said that, even if you don't need the fastest solution, reading through
this answer might be adventurous and educational.</p>
<h3>I. Improvements</h3>
<h4>1. Genesis (Runes)</h4>
<p>As a reminder, the original, general solution we're improving is this:</p>
<div class="code"><pre class="code literal-block"><span class="k">func</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rand</span><span class="o">.</span><span class="n">Seed</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">var</span><span class="w"> </span><span class="n">letterRunes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="n">rune</span><span class="p">(</span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="p">)</span>

<span class="k">func</span><span class="w"> </span><span class="n">RandStringRunes</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">([]</span><span class="n">rune</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb">range</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterRunes</span><span class="p">[</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">letterRunes</span><span class="p">))]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h4>2. Bytes</h4>
<p>If the characters to choose from and assemble the random string contains only
the uppercase and lowercase letters of the English alphabet, we can work with
bytes only because the English alphabet letters map to bytes 1-to-1 in the
UTF-8 encoding (which is how Go stores strings).</p>
<p>So instead of:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">letters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="n">rune</span><span class="p">(</span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="p">)</span>
</pre></div>

<p>we can use:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">letters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="n">byte</span><span class="p">(</span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="p">)</span>
</pre></div>

<p>Or even better:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">letters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
</pre></div>

<p>Now this is already a big improvement: we could achieve it to be a <code>const</code>
(there are <code>string</code> constants but there are no slice constants). As an extra
gain, the expression <code>len(letters)</code> will also be a <code>const</code>! (The expression
<code>len(s)</code> is constant if <code>s</code> is a string constant.)</p>
<p>And at what cost? Nothing at all. <code>string</code>s can be indexed which indexes its
bytes, perfect, exactly what we want.</p>
<p>Our next destination looks like this:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">letterBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>

<span class="k">func</span><span class="w"> </span><span class="n">RandStringBytes</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb">range</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="p">[</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">))]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h4>3. Remainder</h4>
<p>Previous solutions get a random number to designate a random letter by calling
<code>rand.Intn()</code> which delegates to <code>Rand.Intn()</code> which delegates to
<code>Rand.Int31n()</code>.</p>
<p>This is much slower compared to <code>rand.Int63()</code> which produces a random number
with 63 random bits.</p>
<p>So we could simply call <code>rand.Int63()</code> and use the remainder after dividing by
<code>len(letterBytes)</code>:</p>
<div class="code"><pre class="code literal-block"><span class="n">func</span><span class="w"> </span><span class="n">RandStringBytesRmndr</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="err">[]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="o">[</span><span class="n">rand.Int63() % int64(len(letterBytes))</span><span class="o">]</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="err">}</span>
</pre></div>

<p>This works and is significantly faster, the disadvantage is that the
probability of all the letters will not be exactly the same (assuming
<code>rand.Int63()</code> produces all 63-bit numbers with equal probability). Although
the distortion is extremely small as the number of letters <code>52</code> is much-much
smaller than <code>1&lt;&lt;63 - 1</code>, so in practice this is perfectly fine.</p>
<p>To make this understand easier: let's say you want a random number in the
range of <code>0..5</code>. Using 3 random bits, this would produce the numbers <code>0..1</code>
with double probability than from the range <code>2..5</code>. Using 5 random bits,
numbers in range <code>0..1</code> would occur with <code>6/32</code> probability and numbers in
range <code>2..5</code> with <code>5/32</code> probability which is now closer to the desired.
Increasing the number of bits makes this less significant, when reaching 63
bits, it is negligible.</p>
<h4>4. Masking</h4>
<p>Building on the previous solution, we can maintain the equal distribution of
letters by using only as many of the lowest bits of the random number as many
is required to represent the number of letters. So for example if we have 52
letters, it requires 6 bits to represent it: <code>52 = 110100b</code>. So we will only
use the lowest 6 bits of the number returned by <code>rand.Int63()</code>. And to
maintain equal distribution of letters, we only "accept" the number if it
falls in the range <code>0..len(letterBytes)-1</code>. If the lowest bits are greater, we
discard it and query a new random number.</p>
<p>Note that the chance of the lowest bits to be greater than or equal to
<code>len(letterBytes)</code> is less than <code>0.5</code> in general (<code>0.25</code> on average), which
means that even if this would be the case, repeating this "rare" case
decreases the chance of not finding a good number. After <code>n</code> repetition, the
chance that we still don't have a good index is much less than <code>pow(0.5, n)</code>,
and this is just an upper estimation. In case of 52 letters the chance that
the 6 lowest bits are not good is only <code>(64-52)/64 = 0.19</code>; which means for
example that chances to not have a good number after 10 repetition is <code>1e-8</code>.</p>
<p>So here is the solution:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">letterBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
<span class="k">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">letterIdxBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w">                    </span><span class="o">//</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">represent</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">letter</span><span class="w"> </span><span class="n">index</span>
<span class="w">    </span><span class="n">letterIdxMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">letterIdxBits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="mi">1</span><span class="o">-</span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">many</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="p">)</span>

<span class="k">func</span><span class="w"> </span><span class="n">RandStringBytesMask</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Int63</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">letterIdxMask</span><span class="p">);</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h4>5. Masking Improved</h4>
<p>The previous solution only uses the lowest 6 bits of the 63 random bits
returned by <code>rand.Int63()</code>. This is a waste as getting the random bits is the
slowest part of our algorithm.</p>
<p>If we have 52 letters, that means 6 bits code a letter index. So 63 random
bits can designate <code>63/6 = 10</code> different letter indices. Let's use all those
10:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">letterBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
<span class="k">const</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">letterIdxBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w">                    </span><span class="o">//</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">represent</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">letter</span><span class="w"> </span><span class="n">index</span>
<span class="w">    </span><span class="n">letterIdxMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">letterIdxBits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="mi">1</span><span class="o">-</span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">many</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="w">    </span><span class="n">letterIdxMax</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">letterIdxBits</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="c1"># of letter indices fitting in 63 bits</span>
<span class="p">)</span>

<span class="k">func</span><span class="w"> </span><span class="n">RandStringBytesMaskImpr</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">rand</span><span class="o">.</span><span class="n">Int63</span><span class="p">()</span><span class="w"> </span><span class="n">generates</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="w"> </span><span class="n">letters</span><span class="o">!</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rand</span><span class="o">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="o">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="n">cache</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">letterIdxMask</span><span class="p">);</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="w">            </span><span class="n">i</span><span class="o">--</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">cache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="w">        </span><span class="n">remain</span><span class="o">--</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h4>6. Source</h4>
<p>The <strong>Masking Improved</strong> is pretty good, not much we can improve on it. We
could, but not worth the complexity.</p>
<p>Now let's find something else to improve. <strong>The source of random numbers.</strong></p>
<p>There is a <code>crypto/rand</code> package which provides a <code>Read(b []byte)</code> function,
so we could use that to get as many bytes with a single call as many we need.
This wouldn't help in terms of performance as <code>crypto/rand</code> implements a
cryptographically secure pseudorandom number generator so it's much slower.</p>
<p>So let's stick to the <code>math/rand</code> package. The <code>rand.Rand</code> uses a
<code>rand.Source</code> as the source of random bits. <code>rand.Source</code> is an interface
which specifies a <code>Int63() int64</code> method: exactly and the only thing we needed
and used in our latest solution.</p>
<p>So we don't really need a <code>rand.Rand</code> (either explicit or the global, shared
one of the <code>rand</code> package), a <code>rand.Source</code> is perfectly enough for us:</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="o">.</span><span class="n">NewSource</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span>

<span class="k">func</span><span class="w"> </span><span class="n">RandStringBytesMaskImprSrc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">src</span><span class="o">.</span><span class="n">Int63</span><span class="p">()</span><span class="w"> </span><span class="n">generates</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="w"> </span><span class="n">characters</span><span class="o">!</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="o">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="n">cache</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">letterIdxMask</span><span class="p">);</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="w">            </span><span class="n">i</span><span class="o">--</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">cache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="w">        </span><span class="n">remain</span><span class="o">--</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>Also note that this last solution doesn't require you to initialize (seed) the
global <code>Rand</code> of the <code>math/rand</code> package as that is not used (and our
<code>rand.Source</code> is properly initialized / seeded).</p>
<p>One more thing to note here: package doc of <code>math/rand</code> states:</p>
<blockquote>
<p>The default Source is safe for concurrent use by multiple goroutines.</p>
</blockquote>
<p>So the default source is slower than a <code>Source</code> that may be obtained by
<code>rand.NewSource()</code>, because the default source has to provide safety under
concurrent access / use, while <code>rand.NewSource()</code> does not offer this (and
thus the <code>Source</code> returned by it is more likely to be faster).</p>
<h4>7. Utilizing <code>strings.Builder</code>
</h4>
<p>All previous solutions return a <code>string</code> whose content is first built in a
slice (<code>[]rune</code> in <strong>Genesis</strong> , and <code>[]byte</code> in subsequent solutions), and
then converted to <code>string</code>. This final conversion has to make a copy of the
slice's content, because <code>string</code> values are immutable, and if the conversion
would not make a copy, it could not be guaranteed that the string's content is
not modified via its original slice. For details, see How to convert utf8
string to []byte? and golang: []byte(string) vs []byte(*string).</p>
<p>Go 1.10 introduced <code>strings.Builder</code>. <code>strings.Builder</code> is a new type we can
use to build contents of a <code>string</code> similar to <code>bytes.Buffer</code>. Internally it
uses a <code>[]byte</code> to build the content, and when we're done, we can obtain the
final <code>string</code> value using its <code>Builder.String()</code> method. But what's cool in
it is that it does this without performing the copy we just talked about
above. It dares to do so because the byte slice used to build the string's
content is not exposed, so it is guaranteed that no one can modify it
unintentionally or maliciously to alter the produced "immutable" string.</p>
<p>So our next idea is to not build the random string in a slice, but with the
help of a <code>strings.Builder</code>, so once we're done, we can obtain and return the
result without having to make a copy of it. This may help in terms of speed,
and it will definitely help in terms of memory usage and allocations.</p>
<div class="code"><pre class="code literal-block"><span class="n">func</span><span class="w"> </span><span class="n">RandStringBytesMaskImprSrcSB</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">sb</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">strings</span><span class="p">.</span><span class="n">Builder</span><span class="err">{}</span>
<span class="w">    </span><span class="n">sb</span><span class="p">.</span><span class="n">Grow</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">()</span><span class="w"> </span><span class="n">generates</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="w"> </span><span class="n">characters</span><span class="err">!</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="nc">int</span><span class="p">(</span><span class="n">cache</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">letterIdxMask</span><span class="p">);</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">sb</span><span class="p">.</span><span class="n">WriteByte</span><span class="p">(</span><span class="n">letterBytes</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">)</span>
<span class="w">            </span><span class="n">i</span><span class="o">--</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="n">cache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="w">        </span><span class="n">remain</span><span class="o">--</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sb</span><span class="p">.</span><span class="n">String</span><span class="p">()</span>
<span class="err">}</span>
</pre></div>

<p>Do note that after creating a new <code>strings.Buidler</code>, we called its
<code>Builder.Grow()</code> method, making sure it allocates a big-enough internal slice
(to avoid reallocations as we add the random letters).</p>
<h4>8. "Mimicing" <code>strings.Builder</code> with package <code>unsafe</code>
</h4>
<p><code>strings.Builder</code> builds the string in an internal <code>[]byte</code>, the same as we
did ourselves. So basically doing it via a <code>strings.Builder</code> has some
overhead, the only thing we switched to <code>strings.Builder</code> for is to avoid the
final copying of the slice.</p>
<p><code>strings.Builder</code> avoids the final copy by using package <code>unsafe</code>:</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">String</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">accumulated</span><span class="w"> </span><span class="n">string</span><span class="o">.</span>
<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="n">Builder</span><span class="p">)</span><span class="w"> </span><span class="nb nb-Type">String</span><span class="p">()</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">.</span><span class="n">buf</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>

<p>The thing is, we can also do this ourselves, too. So the idea here is to
switch back to building the random string in a <code>[]byte</code>, but when we're done,
don't convert it to <code>string</code> to return, but do an unsafe conversion: obtain a
<code>string</code> which points to our byte slice as the string data.</p>
<p>This is how it can be done:</p>
<div class="code"><pre class="code literal-block"><span class="n">func</span><span class="w"> </span><span class="n">RandStringBytesMaskImprSrcUnsafe</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="err">[]</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">()</span><span class="w"> </span><span class="n">generates</span><span class="w"> </span><span class="mi">63</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="w"> </span><span class="n">characters</span><span class="err">!</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">Int63</span><span class="p">(),</span><span class="w"> </span><span class="n">letterIdxMax</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="nc">int</span><span class="p">(</span><span class="n">cache</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">letterIdxMask</span><span class="p">);</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">letterBytes</span><span class="p">)</span><span class="w"> </span><span class="err">{</span>
<span class="w">            </span><span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">letterBytes</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span>
<span class="w">            </span><span class="n">i</span><span class="o">--</span>
<span class="w">        </span><span class="err">}</span>
<span class="w">        </span><span class="n">cache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">letterIdxBits</span>
<span class="w">        </span><span class="n">remain</span><span class="o">--</span>
<span class="w">    </span><span class="err">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)(</span><span class="n">unsafe</span><span class="p">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
<span class="err">}</span>
</pre></div>

<h4>(9. Using <code>rand.Read()</code>)</h4>
<p>Go 1.7 added a <code>rand.Read()</code> function and a <code>Rand.Read()</code> method. We should be
tempted to use these to read as many bytes as we need in one step, in order to
achieve better performance.</p>
<p>There is one small "problem" with this: how many bytes do we need? We could
say: as many as the number of output letters. We would think this is an upper
estimation, as a letter index uses less than 8 bits (1 byte). But at this
point we are already doing worse (as getting the random bits is the "hard
part"), and we're getting more than needed.</p>
<p>Also note that to maintain equal distribution of all letter indices, there
might be some "garbage" random data that we won't be able to use, so we would
end up skipping some data, and thus end up short when we go through all the
byte slice. We would need to further get more random bytes, "recursively". And
now we're even losing the "single call to <code>rand</code> package" advantage...</p>
<p>We could "somewhat" optimize the usage of the random data we acquire from
<code>math.Rand()</code>. We may estimate how many bytes (bits) we'll need. 1 letter
requires <code>letterIdxBits</code> bits, and we need <code>n</code> letters, so we need <code>n *
letterIdxBits / 8.0</code> bytes rounding up. We can calculate the probability of a
random index not being usable (see above), so we could request more that will
"more likely" be enough (if it turns out it's not, we repeat the process). We
can process the byte slice as a "bit stream" for example, for which we have a
nice 3rd party lib: <code>github.com/icza/bitio</code> (disclosure: I'm the author).</p>
<p>But Benchmark code still shows we're not winning. Why is it so?</p>
<p>The answer to the last question is because <code>rand.Read()</code> uses a loop and keeps
calling <code>Source.Int63()</code> until it fills the passed slice. Exactly what the
<code>RandStringBytesMaskImprSrc()</code> solution does, <em>without</em> the intermediate
buffer, and without the added complexity. That's why
<code>RandStringBytesMaskImprSrc()</code> remains on the throne. Yes,
<code>RandStringBytesMaskImprSrc()</code> uses an unsynchronized <code>rand.Source</code> unlike
<code>rand.Read()</code>. But the reasoning still applies; and which is proven if we use
<code>Rand.Read()</code> instead of <code>rand.Read()</code> (the former is also unsynchronzed).</p>
<h3>II. Benchmark</h3>
<p>All right, it's time for benchmarking the different solutions.</p>
<p>Moment of truth:</p>
<div class="code"><pre class="code literal-block">BenchmarkRunes-4                     2000000    723 ns/op   96 B/op   2 allocs/op
BenchmarkBytes-4                     3000000    550 ns/op   32 B/op   2 allocs/op
BenchmarkBytesRmndr-4                3000000    438 ns/op   32 B/op   2 allocs/op
BenchmarkBytesMask-4                 3000000    534 ns/op   32 B/op   2 allocs/op
BenchmarkBytesMaskImpr-4            10000000    176 ns/op   32 B/op   2 allocs/op
BenchmarkBytesMaskImprSrc-4         10000000    139 ns/op   32 B/op   2 allocs/op
BenchmarkBytesMaskImprSrcSB-4       10000000    134 ns/op   16 B/op   1 allocs/op
BenchmarkBytesMaskImprSrcUnsafe-4   10000000    115 ns/op   16 B/op   1 allocs/op
</pre></div>

<p>Just by switching from runes to bytes, we immediately have <strong>24%</strong> performance
gain, and memory requirement drops to <strong>one third</strong>.</p>
<p>Getting rid of <code>rand.Intn()</code> and using <code>rand.Int63()</code> instead gives another
<strong>20%</strong> boost.</p>
<p>Masking (and repeating in case of big indices) slows down a little (due to
repetition calls): <strong>-22%</strong>...</p>
<p>But when we make use of all (or most) of the 63 random bits (10 indices from
one <code>rand.Int63()</code> call): that speeds up big time: <strong>3 times</strong>.</p>
<p>If we settle with a (non-default, new) <code>rand.Source</code> instead of <code>rand.Rand</code>,
we again gain <strong>21%.</strong></p>
<p>If we utilize <code>strings.Builder</code>, we gain a tiny <strong>3.5%</strong> in <em>speed</em> , but we
also achieved <strong>50%</strong> reduction in memory usage and allocations! That's nice!</p>
<p>Finally if we dare to use package <code>unsafe</code> instead of <code>strings.Builder</code>, we
again gain a nice <strong>14%</strong>.</p>
<p>Comparing the final to the initial solution:
<code>RandStringBytesMaskImprSrcUnsafe()</code> is <strong>6.3 times faster</strong> than
<code>RandStringRunes()</code>, uses <strong>one sixth</strong> memory and <strong>half as few
allocations</strong>. Mission accomplished.</p>
<p><br></p>
<h3>Suggest</h3>
<p>You can just write code for it. This code can be a little simpler if you want
to rely on the letters all being single bytes when encoded in UTF-8.</p>
<div class="code"><pre class="code literal-block"><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s2">"fmt"</span>
    <span class="s2">"time"</span>
    <span class="s2">"math/rand"</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">rand</span><span class="o">.</span><span class="n">Seed</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">letters</span> <span class="o">=</span> <span class="p">[]</span><span class="n">rune</span><span class="p">(</span><span class="s2">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="p">)</span>

<span class="n">func</span> <span class="n">randSeq</span><span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">)</span> <span class="n">string</span> <span class="p">{</span>
    <span class="n">b</span> <span class="o">:=</span> <span class="n">make</span><span class="p">([]</span><span class="n">rune</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">range</span> <span class="n">b</span> <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">letters</span><span class="p">))]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">randSeq</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/dyld-library-not-loaded-usr-local-opt-openssl-lib-libssl-1-0-0-dylib/" class="u-url">dyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/dyld-library-not-loaded-usr-local-opt-openssl-lib-libssl-1-0-0-dylib/" rel="bookmark">
            <time class="published dt-published" datetime="2023-03-03T10:56:06+08:00" itemprop="datePublished" title="2023-03-03 10:56">2023-03-03 10:56</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>I installed vapor via homebrew and then immediately wanted to jump into a
project by executing <code>vapor new Hello</code> but then got the following message back
in the terminal:</p>
<div class="code"><pre class="code literal-block"><span class="n">dyld</span><span class="p">:</span><span class="w"> </span><span class="n">Library</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">loaded</span><span class="p">:</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">openssl</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">libssl</span><span class="o">.</span><span class="mf">1.0</span><span class="o">.</span><span class="mf">0.</span><span class="n">dylib</span>
<span class="n">Referenced</span><span class="w"> </span><span class="n">from</span><span class="p">:</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">vapor</span>
<span class="n">Reason</span><span class="p">:</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">found</span>
<span class="n">zsh</span><span class="p">:</span><span class="w"> </span><span class="n">abort</span><span class="w">      </span><span class="n">vapor</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Hello</span>
</pre></div>

<p>I tried some approaches to fix this like uninstalling and reinstalling openssl
via brew but that didn't work . Also tried something I found in the internet
but nothing worked. I assume it has something to do with vapor only working
with version 1.0.0 but not 1.1.1 and that's what I have. I guess I need to
downgrade to 1.0.0 but how'd I do that? I'm on MacOS Catalina if that matters.</p>
<p><br><br></p>
<h2>Answer</h2>
<p><strong>Update:</strong> As of <strong>December 2020</strong> and beyond, <code>brew switch</code> does not work,
so use the other answer by @angabriel:</p>
<div class="code"><pre class="code literal-block"><span class="n">brew</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">rbenv</span><span class="o">/</span><span class="n">tap</span><span class="o">/</span><span class="n">openssl</span><span class="mf">@1.0</span>
<span class="n">ln</span><span class="w"> </span><span class="o">-</span><span class="n">sfn</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">openssl</span><span class="mf">@1.0</span><span class="o">/</span><span class="mf">1.0.2</span><span class="n">t</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">openssl</span>
</pre></div>

<p><strong>Original Answer:</strong> Switch to an older openssl package</p>
<div class="code"><pre class="code literal-block">brew switch openssl 1.0.2s
</pre></div>

<p>Or, depending on your exact system configuration, you may need to switch to a
different version. Check the output of <code>ls -al /usr/local/Cellar/openssl</code> for
the version number to switch to.</p>
<div class="code"><pre class="code literal-block">brew switch openssl 1.0.2q
# or
brew switch openssl 1.0.2r
# or 
brew switch openssl 1.0.2s
# or
brew switch openssl 1.0.2t
# etc...
</pre></div>

<p><br></p>
<h3>Suggest</h3>
<p><strong>December 2020</strong> This thread has many answers, but none worked for me.<br>
The top answer also suggests a downgrade:  </p>
<p><code>brew switch ...</code> throws <code>Calling brew switch is disabled!</code></p>
<p><strong>this worked for me:</strong></p>
<div class="code"><pre class="code literal-block"><span class="n">brew</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">rbenv</span><span class="o">/</span><span class="n">tap</span><span class="o">/</span><span class="n">openssl</span><span class="mf">@1.0</span>
<span class="n">ln</span><span class="w"> </span><span class="o">-</span><span class="n">sfn</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">Cellar</span><span class="o">/</span><span class="n">openssl</span><span class="mf">@1.0</span><span class="o">/</span><span class="mf">1.0.2</span><span class="n">t</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">openssl</span>
</pre></div>

<p>found here: https://github.com/kelaberetiv/TagUI/issues/86<br>
(I need to run old mongodb 3.4 on OSX 10.13.x)</p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1856.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1854.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow中文网</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
