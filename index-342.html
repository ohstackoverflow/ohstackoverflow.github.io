<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 342) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-342.html">
<link rel="prev" href="index-343.html" type="text/html">
<link rel="next" href="index-341.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yong-unix-gong-ju-jie-xi-json/" class="u-url">使用 Unix 工具解析 JSON</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yong-unix-gong-ju-jie-xi-json/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:30:36+08:00" itemprop="datePublished" title="2023-02-17 04:30">2023-02-17 04:30</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我正在尝试解析从 curl 请求返回的 JSON，如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span><span class="w"> </span><span class="s1">'http://twitter.com/users/username.json'</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="n">sed</span><span class="w"> </span><span class="o">-</span><span class="n">e</span><span class="w"> </span><span class="s1">'s/[{}]/''/g'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>
<span class="w">    </span><span class="n">awk</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="ss">"text"</span><span class="w"> </span><span class="s1">'{n=split($0,a,","); for (i=1; i&lt;=n; i++) print a[i]}'</span>
</pre></div>

<p>上面将 JSON 拆分为字段，例如：</p>
<div class="code"><pre class="code literal-block"><span class="c">% ...</span>
<span class="s">"geo_enabled"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"friends_count"</span><span class="p">:</span><span class="mi">245</span>
<span class="s">"profile_text_color"</span><span class="p">:</span><span class="s">"000000"</span>
<span class="s">"status"</span><span class="p">:</span><span class="s">"in_reply_to_screen_name"</span><span class="p">:</span><span class="nb">null</span>
<span class="s">"source"</span><span class="p">:</span><span class="s">"web"</span>
<span class="s">"truncated"</span><span class="p">:</span><span class="nb">false</span>
<span class="s">"text"</span><span class="p">:</span><span class="s">"My status"</span>
<span class="s">"favorited"</span><span class="p">:</span><span class="nb">false</span>
<span class="c">% ...</span>
</pre></div>

<p>如何打印特定字段（由 表示<code>-v k=text</code>）？</p>
<p><br><br></p>
<h2>解答</h2>
<p>有许多专门设计用于从命令行操作 JSON 的工具，并且比使用 Awk 更容易和更可靠，例如<code>jq</code>：</p>
<div class="code"><pre class="code literal-block">curl -s 'https://api.github.com/users/lambda' | jq -r '.name'
</pre></div>

<p><code>json</code>您还可以使用系统上可能已经安装的工具来执行此操作，例如使用module 的Python ，从而避免任何额外的依赖项，同时仍然可以享受适当的
JSON 解析器的好处。以下假设您想要使用 UTF-8，原始 JSON 应该以这种方式进行编码，并且大多数现代终端也使用这种方式：</p>
<p>蟒蛇 3：</p>
<div class="code"><pre class="code literal-block"><span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python3</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print(json.load(sys.stdin)['name'])"</span>
</pre></div>

<p>蟒蛇2：</p>
<div class="code"><pre class="code literal-block"><span class="n">export</span> <span class="n">PYTHONIOENCODING</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">curl</span> <span class="o">-</span><span class="n">s</span> <span class="s1">'https://api.github.com/users/lambda'</span> <span class="o">|</span> \
    <span class="n">python2</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import sys, json; print json.load(sys.stdin)['name']"</span>
</pre></div>

<h3>经常问的问题</h3>
<h4>为什么不是纯 shell 解决方案？</h4>
<p>标准的POSIX/单一 Unix 规范
shell是一种非常有限的语言，它不包含表示序列（列表或数组）或关联数组（在其他一些语言中也称为哈希表、映射、字典或对象）的工具。这使得在可移植 shell
脚本中表示解析 JSON 的结果有些棘手。有一些 hacky 方法可以做到这一点，但如果键或值包含某些特殊字符，它们中的许多方法可能会失败。</p>
<p>Bash 4 及更高版本、zsh 和 ksh 支持数组和关联数组，但这些 shell 并非普遍可用（由于从 GPLv2 到 GPLv3，macOS 在
Bash 3 停止更新 Bash，而许多 Linux 系统没有zsh 开箱即用）。您可能可以编写一个可以在 Bash 4 或 zsh
中运行的脚本，其中之一在当今大多数 macOS、Linux 和 BSD 系统上都可用，但是很难编写适用于这种情况的 shebang 行多语言脚本。</p>
<p>最后，在 shell 中编写一个完整的 JSON 解析器将是一个足够重要的依赖项，您不妨只使用现有的依赖项，如 jq 或
Python。它不会是一行代码，甚至是一小段五行代码，就可以很好地实现。</p>
<h4>为什么不使用 awk、sed 或 grep？</h4>
<p>可以使用这些工具从具有已知形状并以已知方式格式化的 JSON 中进行一些快速提取，例如每行一个键。在其他答案中有几个对此建议的示例。</p>
<p>但是，这些工具是为基于行或基于记录的格式而设计的；它们不是为递归解析具有可能的转义字符的匹配定界符而设计的。</p>
<p>因此，这些使用 awk/sed/grep 的快速而肮脏的解决方案可能很脆弱，如果输入格式的某些方面发生变化，例如折叠空格，或向 JSON
对象添加额外的嵌套级别，或在其中转义引号，则会中断一个字符串。一个足以处理所有 JSON
输入而不中断的解决方案也将相当庞大和复杂，因此与添加对<code>jq</code>Python 或 Python 的另一个依赖没有太大区别。</p>
<p>我以前不得不处理由于 shell
脚本中的输入解析不佳而导致删除的大量客户数据，所以我从不推荐快速而肮脏的方法，因为这种方法可能很脆弱。如果您正在进行一次性处理，请参阅其他答案以获取建议，但我仍然强烈建议您只使用经过测试的现有
JSON 解析器。</p>
<h3>历史笔记</h3>
<p>这个答案最初推荐jsawk，它应该仍然有效，但使用起来比 更麻烦一点<code>jq</code>，并且取决于安装的独立 JavaScript 解释器，这比 Python
解释器更不常见，因此以上答案可能更可取：</p>
<div class="code"><pre class="code literal-block"><span class="nv">curl</span><span class="w"> </span><span class="o">-</span><span class="nv">s</span><span class="w"> </span><span class="s1">'https://api.github.com/users/lambda'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">jsawk</span><span class="w"> </span><span class="o">-</span><span class="nv">a</span><span class="w"> </span><span class="s1">'return this.name'</span>
</pre></div>

<p>这个答案最初也使用问题中的 Twitter API，但该 API 不再有效，因此很难复制示例进行测试，并且新的 Twitter API 需要 API
密钥，所以我转而使用 GitHub API无需 API 密钥即可轻松使用。原始问题的第一个答案是：</p>
<div class="code"><pre class="code literal-block">curl 'http://twitter.com/users/username.json' | jq -r '.text'
</pre></div>

<p><br></p>
<h3>更多建议</h3>
<p>为了快速提取特定键的值，我个人喜欢使用“grep -o”，它只返回正则表达式的匹配项。例如，要从推文中获取“文本”字段，类似于：</p>
<div class="code"><pre class="code literal-block">grep -Po '"text":.*?[^\\]",' tweets.json
</pre></div>

<p>这个正则表达式比你想象的更健壮；例如，它可以很好地处理在其中嵌入逗号和转义引号的字符串。我认为只要多做一点工作，你就可以做出一个实际上保证提取价值的东西，如果它是原子的。（如果它有嵌套，那么正则表达式当然不能这样做。）</p>
<p>为了进一步清理（尽管保持字符串的原始转义），您可以使用类似的东西<code>| perl -pe 's/"text"://; s/^"//;
s/",$//'</code>：（我为这个分析做了这个。）</p>
<p>对于所有坚持认为您应该使用真正的 JSON 解析器的仇恨者——是的，这对于正确性至关重要，但是</p>
<ol>
<li>要进行真正快速的分析，例如计算值以检查数据清理错误或获得对数据的总体感觉，在命令行上敲打一些东西会更快。打开编辑器编写脚本会让人分心。</li>
<li>
<code>grep -o</code>比 Python 标准<code>json</code>库快几个数量级，至少在对推文执行此操作时（每条约 2 KB）。我不确定这是否只是因为<code>json</code>速度慢（我应该在某个时候与 yajl 进行比较）；但原则上，正则表达式应该更快，因为它是有限状态并且更可优化，而不是必须支持递归的解析器，在这种情况下，会花费大量 CPU 为您不关心的结构构建树。（如果有人编写了一个有限状态转换器来进行适当的（深度受限的）JSON 解析，那就太棒了！与此同时我们有“grep -o”。）</li>
</ol>
<p>为了编写可维护的代码，我总是使用真正的解析库。我没有尝试过jsawk，但如果它运行良好，那将解决第 1 点。</p>
<p>最后一个更古怪的解决方案：我写了一个脚本，它使用
Python<code>json</code>并将你想要的键提取到制表符分隔的列中；然后我通过一个<code>awk</code>允许对列进行命名访问的包装器进行管道传输。在这里：json2tsv 和
tsvawk 脚本。所以对于这个例子，它将是：</p>
<div class="code"><pre class="code literal-block">json2tsv id text &lt; tweets.json | tsvawk '{print "tweet " $id " is: " $text}'
</pre></div>

<p>这种方法没有解决 #2，比单个 Python 脚本效率低，而且有点脆弱：它强制对字符串值中的换行符和制表符进行规范化，以与 awk
的字段/记录分隔的世界观相得益彰。但它确实让你留在命令行上，比<code>grep -o</code>.</p>
<p><br><br><a href="posts/parsing-json-with-unix-tools/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-jiang-huan-jing-bian-liang-chuan-di-gei-docker-rong-qi/" class="u-url">如何将环境变量传递给 Docker 容器？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-jiang-huan-jing-bian-liang-chuan-di-gei-docker-rong-qi/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:29:38+08:00" itemprop="datePublished" title="2023-02-17 04:29">2023-02-17 04:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何从容器访问外部数据库？是在连接字符串中进行硬编码的最佳方法吗？</p>
<div class="code"><pre class="code literal-block"># Dockerfile
ENV DATABASE_URL amazon:rds/connection?string
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>您可以使用标志将环境变量传递给您的容器<code>-e</code>。</p>
<p>启动脚本的示例：</p>
<div class="code"><pre class="code literal-block">sudo docker run -d -t -i -e REDIS_NAMESPACE='staging' \ 
-e POSTGRES_ENV_POSTGRES_PASSWORD='foo' \
-e POSTGRES_ENV_POSTGRES_USER='bar' \
-e POSTGRES_ENV_DB_NAME='mysite_staging' \
-e POSTGRES_PORT_5432_TCP_ADDR='docker-db-1.hidden.us-east-1.rds.amazonaws.com' \
-e SITE_URL='staging.mysite.com' \
-p 80:80 \
--link redis:redis \  
--name container_name dockerhub_id/image_name
</pre></div>

<p>或者，如果您不想在命令行上显示值<code>ps</code>，等等，<code>-e</code>可以从当前环境中提取值，如果您只是在没有 : 的情况下提供它<code>=</code>：</p>
<div class="code"><pre class="code literal-block">sudo PASSWORD='foo' docker run  [...] -e PASSWORD [...]
</pre></div>

<p>如果你有很多环境变量，特别是如果它们是秘密的，你可以使用 env-file：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>docker<span class="w"> </span>run<span class="w"> </span>--env-file<span class="w"> </span>./env.list<span class="w"> </span>ubuntu<span class="w"> </span>bash
</pre></div>

<blockquote>
<p>--env-file 标志将文件名作为参数，并期望每一行都采用 VAR=VAL 格式，模仿传递给 --env 的参数。注释行只需以 # 为前缀</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p>您可以使用此处提到的命令和勘误表中提到的<code>-e</code>命令传递 using参数。<code>docker run ..</code></p>
<p>但是，这种方法可能存在的缺点是您的凭据将显示在您运行它的进程列表中。</p>
<p>为了使其更安全，您可以将您的凭据写入配置文件并按照此处所述进行<code>docker
run</code>处理。然后您可以控制该配置文件的访问权限，以便其他有权访问该机器的人看不到您的凭据。<code>--env-file</code></p>
<p><br><br><a href="posts/how-do-i-pass-environment-variables-to-docker-containers/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ukkonen-de-hou-zhui-shu-suan-fa/" class="u-url">Ukkonen 的后缀树算法</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ukkonen-de-hou-zhui-shu-suan-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T04:29:12+08:00" itemprop="datePublished" title="2023-02-17 04:29">2023-02-17 04:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>此时我觉得有点厚。我花了好几天时间试图完全了解后缀树构造，但由于我没有数学背景，许多解释都让我难以理解，因为它们开始过度使用数学符号。我找到的最接近好的解释是
<em>Fast String Searching With Suffix Trees</em> ，但他掩盖了各个要点，算法的某些方面仍不清楚。</p>
<p>我敢肯定，在 Stack Overflow 上对这个算法的逐步解释对于除我之外的许多其他人来说都是无价的。</p>
<p>作为参考，这里是 Ukkonen
关于该算法的论文：http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf</p>
<p>到目前为止，我的基本理解是：</p>
<ul>
<li>我需要遍历给定字符串 T 的每个前缀 P</li>
<li>我需要遍历前缀 P 中的每个后缀 S 并将其添加到树中</li>
<li>要将后缀 S 添加到树中，我需要遍历 S 中的每个字符，迭代包括沿着以 S 中相同字符集 C 开头的现有分支走下去，并可能在我时将边拆分为后代节点在后缀中到达不同的字符，或者如果没有匹配的边可以向下走。当找不到为 C 向下走的匹配边时，为 C 创建一个新的叶边。</li>
</ul>
<p>基本算法似乎是 O(n 2 )，正如大多数解释中指出的那样，因为我们需要遍历所有前缀，然后我们需要遍历每个前缀的每个后缀。Ukkonen
的算法显然是独一无二的，因为他使用了后缀指针技术，尽管我认为 <em>这</em> 是我难以理解的地方。</p>
<p>我也无法理解：</p>
<ul>
<li>准确分配、使用和更改“活动点”的时间和方式</li>
<li>算法的规范化方面发生了什么</li>
<li>为什么我看到的实现需要“修复”他们正在使用的边界变量</li>
</ul>
<hr>
<p>这是完整的 <strong>C#</strong> 源代码。它不仅可以正常工作，而且支持自动规范化并呈现出更好看的输出文本图。源代码和示例输出位于：</p>
<blockquote>
<p><strong>https://gist.github.com/2373868</strong></p>
</blockquote>
<hr>
<p><strong>更新时间 2017-11-04</strong></p>
<p>多年后，我发现了后缀树的新用途，并在 <strong>JavaScript</strong> 中实现了该算法。要点如下。它应该没有错误。从同一位置将其转储到一个 js 文件中<code>npm
install chalk</code>，然后使用 node.js 运行以查看一些彩色输出。在同一个 Gist 中有一个精简版本，没有任何调试代码。</p>
<blockquote>
<p><strong>https://gist.github.com/axefrog/c347bf0f5e0723cbd09b1aaed6ec6fc6</strong></p>
</blockquote>
<p><br><br></p>
<h2>解答</h2>
<p>下面是对 Ukkonen 算法的一种尝试，首先展示当字符串很简单（即不包含任何重复字符）时它的作用，然后将其扩展到完整的算法。</p>
<p><strong>首先，一些初步声明。</strong></p>
<ol>
<li>
<p>我们正在构建的， <em>基本上</em> 就像一个搜索树。所以有一个根节点，从它出来的边通向新节点，还有从这些节点出来的更多边，等等</p>
</li>
<li>
<p><strong>但是</strong> ：与搜索树不同，边缘标签不是单个字符。相反，每条边都使用一对整数标记<code>[from,to]</code>。这些是文本的指针。从这个意义上说，每条边都带有一个任意长度的字符串标签，但只占用 O(1) 空间（两个指针）。</p>
</li>
</ol>
<h3>基本原则</h3>
<p>我想首先演示如何创建一个特别简单的字符串的后缀树，一个没有重复字符的字符串：</p>
<div class="code"><pre class="code literal-block">abc
</pre></div>

<p>该算法 <strong>从左到右按步骤工作</strong> 。 <strong>string 的每个字符</strong>
都有一个步骤。每个步骤可能涉及多个单独的操作，但我们会看到（参见最后的最终观察结果）操作总数为 O(n)。</p>
<p>所以，我们从左边开始 <em>，</em><code>a</code>首先通过创建从根节点（左边）到叶子的边来只插入单个字符，并将其标记为<code>[0,#]</code>，这意味着边表示从位置 0
开始到结束的子字符串在 <em>当前结束</em> 。我使用 符号<code>#</code>表示 <em>当前 end</em> ，它位于位置 1（紧接在 之后<code>a</code>）。</p>
<p>所以我们有一个初始树，它看起来像这样：</p>
<p><img alt="" src="images/aOwIL.png"></p>
<p>它的意思是：</p>
<p><img alt="" src="images/SZH4k.png"></p>
<p>现在我们前进到位置 2（紧随其后<code>b</code>）。 <strong>我们在每一步的目标</strong> 是将 <strong>所有后缀插入到当前位置</strong> 。我们这样做</p>
<ul>
<li>将现有的<code>a</code>-edge 扩展到<code>ab</code>
</li>
<li>插入一条新边<code>b</code>
</li>
</ul>
<p>在我们的表示中，这看起来像</p>
<p><img alt="在此处输入图像描述" src="images/onmqt.png"></p>
<p>它的意思是：</p>
<p><img alt="" src="images/tchAx.png"></p>
<p><strong>我们观察到</strong> 两件事：</p>
<ul>
<li>的边表示 <strong>与</strong> 初始树中的相同<code>ab</code>：。它的含义已经自动改变，因为我们将当前位置从 1 更新为 2。 ****<code>[0,#]``#</code>
</li>
<li>每条边占用 O(1) 空间，因为它只包含两个指向文本的指针，而不管它代表多少个字符。</li>
</ul>
<p><code>c</code>接下来，我们再次增加位置并通过将 a 附加到每条现有边并为新后缀插入一条新边来更新树<code>c</code>。</p>
<p>在我们的表示中，这看起来像</p>
<p><img alt="" src="images/wCEdI.png"></p>
<p>它的意思是：</p>
<p><img alt="" src="images/UpUFw.png"></p>
<p><strong>我们观察到：</strong></p>
<ul>
<li>树是每一步后 <em>到当前位置的正确后缀树</em>
</li>
<li>文中有多少字符就有多少步骤</li>
<li>每一步的工作量为 O(1)，因为所有现有边都会通过递增 自动更新<code>#</code>，并且可以在 O(1) 时间内为最终字符插入一条新边。因此对于长度为 n 的字符串，只需要 O(n) 时间。</li>
</ul>
<h3>第一个扩展：简单重复</h3>
<p>当然，这工作得很好只是因为我们的字符串不包含任何重复。我们现在来看一个更真实的字符串：</p>
<div class="code"><pre class="code literal-block">abcabxabcd
</pre></div>

<p><code>abc</code>它以前面示例中的开头，然后<code>ab</code>重复并后跟<code>x</code>，然后<code>abc</code>重复后跟<code>d</code>。</p>
<p><strong>步骤 1 到 3：</strong> 在前 3 个步骤之后，我们得到了上一个示例中的树：</p>
<p><img alt="" src="images/AclCh.png"></p>
<p><strong>第 4 步：</strong> 我们移动<code>#</code>到位置 4。这隐含地将所有现有边更新为：</p>
<p><img alt="" src="images/xhVMY.png"></p>
<p>我们需要<code>a</code>在根部插入当前步骤的最后一个后缀。</p>
<p>在我们这样做之前，我们 <strong>再引入两个变量</strong> （除了<code>#</code>），这两个变量当然一直存在，但到目前为止我们还没有使用它们：</p>
<ul>
<li>活动 <strong>点</strong> ，这是一个三重<code>(active_node,active_edge,active_length)</code>
</li>
<li>,这<code>remainder</code>是一个整数，表示我们需要插入多少个新的后缀</li>
</ul>
<p>这两个的确切含义很快就会变得清晰，但现在我们只说：</p>
<ul>
<li>在简单<code>abc</code>示例中，活动点始终为<code>(root,'\0x',0)</code>，即为<code>active_node</code>根节点，<code>active_edge</code>指定为空字符<code>'\0x'</code>，并且<code>active_length</code>为零。这样做的效果是，我们在每一步中插入的一条新边作为新创建的边插入到根节点。我们很快就会看到为什么需要三元组来表示此信息。</li>
<li>
<code>remainder</code>在每个步骤开始时始终设置为 1 。这意味着我们必须在每一步结束时主动插入的后缀数量为 1（始终只是最后一个字符）。</li>
</ul>
<p>现在这将改变。<code>a</code>当我们在根部插入当前的最终字符时，我们注意到已经有一个以 开头的出边<code>a</code>，具体来说：<code>abca</code>。这是我们在这种情况下所做的：</p>
<ul>
<li>我们 <strong>不在</strong><code>[4,#]</code>根节点插入新边。相反，我们只是注意到后缀<code>a</code>已经在我们的树中。它在较长边缘的中间结束，但我们并不为此烦恼。我们只是让事情保持原样。</li>
<li>我们 <strong>将活动点设置</strong> 为<code>(root,'a',1)</code>。这意味着活动点现在位于以 开头的根节点的传出边中间的某个位置<code>a</code>，具体来说，在该边上的位置 1 之后。我们注意到边缘仅由其第一个字符指定<code>a</code>。这就足够了，因为只能有 <em>一条</em> 边以任何特定字符开头（在阅读整个描述后确认这是真的）。</li>
<li>我们还递增<code>remainder</code>，因此在下一步开始时它将为 2。</li>
</ul>
<p><strong>观察：</strong> 当发现我们需要插入的最后一个 <strong>后缀已经存在于树中时</strong> ，树本身根本 <strong>没有改变</strong> （我们只更新活动点 和<code>remainder</code>）。
<em>该树不再是直到当前位置的</em> 后缀树的准确表示，但它 <strong>包含</strong> 所有后缀（因为最终后缀被
<em>隐式</em><code>a</code>包含）。因此，除了更新变量（它们都是固定长度的，所以这是 O(1)）之外，这一步没有做 <strong>任何工作。</strong> __ ****</p>
<p><strong>第 5 步：</strong> 我们将当前位置更新<code>#</code>为 5。这会自动将树更新为：</p>
<p><img alt="" src="images/XL6bg.png"></p>
<p>并且 <strong>因为<code>remainder</code>是 2</strong>，我们需要插入两个当前位置的最后后缀：<code>ab</code>和<code>b</code>。这主要是因为：</p>
<ul>
<li>
<code>a</code>从未正确插入上一步的后缀。所以它 <em>保持不变</em> ，并且由于我们前进了一步，它现在已经从 增长<code>a</code>到<code>ab</code>。</li>
<li>我们需要插入新的最终边缘<code>b</code>。</li>
</ul>
<p>实际上，这意味着我们转到活动点（指向<code>a</code>现在边缘的后面<code>abcab</code>），并插入当前的最终字符<code>b</code>。 <strong>但是：</strong>
同样，事实证明<code>b</code>也已经存在于同一条边上。</p>
<p>所以，再一次，我们不改变树。我们只是：</p>
<ul>
<li>将活动点更新为<code>(root,'a',2)</code>（与之前相同的节点和边，但现在我们指向后面<code>b</code>）</li>
<li>将 增加到<code>remainder</code>3，因为我们仍然没有正确插入上一步的最后一条边，而且我们也没有插入当前的最后一条边。</li>
</ul>
<p>需要明确的是：我们必须在当前步骤中插入<code>ab</code>和，但是因为已经找到了，所以我们更新了活动点并且甚至没有尝试插入。为什么？因为 if在树中，它的
<strong>每个后缀</strong> （包括）也必须在树中。也许只是 <em>隐含地</em> ，但它必须存在，因为我们到目前为止构建树的方式。<code>b``ab``b``ab</code> ****<code>b</code>
__</p>
<p>我们通过递增继续执行 <strong>步骤 6</strong><code>#</code>。树会自动更新为：</p>
<p><img alt="" src="images/bLLT9.png"></p>
<p>因为 <strong><code>remainder</code> 是
3</strong>，我们必须插入<code>abx</code>,<code>bx</code>和<code>x</code>。活动点告诉我们在哪里<code>ab</code>结束，所以我们只需要跳到那里并插入<code>x</code>.
事实上，<code>x</code>还没有，所以我们分割边<code>abcabx</code>并插入一个内部节点：</p>
<p><img alt="" src="images/6HYtR.png"></p>
<p>边缘表示仍然是指向文本的指针，因此可以在 O(1) 时间内完成拆分和插入内部节点。</p>
<p>所以我们已经处理<code>abx</code>并递减<code>remainder</code>到
2。现在我们需要插入下一个剩余的后缀，<code>bx</code>。但在我们这样做之前，我们需要更新活动点。在分割和插入一条边之后，此规则将在下面称为 <strong>规则 1</strong>
，只要是根，它就适用<code>active_node</code>（我们将在下面进一步了解其他情况的规则 3）。这是规则 1：</p>
<blockquote>
<p>从根插入后，</p>
<ul>
<li>
<code>active_node</code>仍然是根</li>
<li>
<code>active_edge</code>设置为我们需要插入的新后缀的第一个字符，即<code>b</code>
</li>
<li>
<code>active_length</code>减少 1
</li>
</ul>
</blockquote>
<p>Hence, the new active-point triple <code>(root,'b',1)</code> indicates that the next
insert has to be made at the <code>bcabx</code> edge, behind 1 character, i.e. behind
<code>b</code>. We can identify the insertion point in O(1) time and check whether <code>x</code> is
already present or not. If it was present, we would end the current step and
leave everything the way it is. But <code>x</code> is not present, so we insert it by
splitting the edge:</p>
<p><img alt="" src="images/YVvbJ.png"></p>
<p>Again, this took O(1) time and we update <code>remainder</code> to 1 and the active point
to <code>(root,'x',0)</code> as rule 1 states.</p>
<p>But there is one more thing we need to do. We'll call this <strong>Rule 2:</strong></p>
<blockquote>
<p>If we split an edge and insert a new node, and if that is <em>not the first
node</em> created during the current step, we connect the previously inserted
node and the new node through a special pointer, a <strong>suffix link</strong>. We will
later see why that is useful. Here is what we get, the suffix link is
represented as a dotted edge:</p>
</blockquote>
<p><img alt="" src="images/zL9yl.png"></p>
<p>We still need to insert the final suffix of the current step, <code>x</code>. Since the
<code>active_length</code> component of the active node has fallen to 0, the final insert
is made at the root directly. Since there is no outgoing edge at the root node
starting with <code>x</code>, we insert a new edge:</p>
<p><img alt="" src="images/992gV.png"></p>
<p>As we can see, in the current step all remaining inserts were made.</p>
<p>We proceed to <strong>step 7</strong> by setting <code>#</code>=7, which automatically appends the
next character, <code>a</code>, to all leaf edges, as always. Then we attempt to insert
the new final character to the active point (the root), and find that it is
there already. So we end the current step without inserting anything and
update the active point to <code>(root,'a',1)</code>.</p>
<p>In <strong>step 8</strong> , <code>#</code>=8, we append <code>b</code>, and as seen before, this only means we
update the active point to <code>(root,'a',2)</code> and increment <code>remainder</code> without
doing anything else, because <code>b</code> is already present. <strong>However,</strong> we notice
(in O(1) time) that the active point is now at the end of an edge. We reflect
this by re-setting it to <code>(node1,'\0x',0)</code>. Here, I use <code>node1</code> to refer to
the internal node the <code>ab</code> edge ends at.</p>
<p>Then, in <strong>step<code>#</code>=9</strong>, we need to insert 'c' and this will help us to
understand the final trick:</p>
<h3>Second extension: Using suffix links</h3>
<p>As always, the <code>#</code> update appends <code>c</code> automatically to the leaf edges and we
go to the active point to see if we can insert 'c'. It turns out 'c' exists
already at that edge, so we set the active point to <code>(node1,'c',1)</code>, increment
<code>remainder</code> and do nothing else.</p>
<p>Now in <strong>step<code>#</code>=10</strong>, <code>remainder</code> is 4, and so we first need to insert <code>abcd</code>
(which remains from 3 steps ago) by inserting <code>d</code> at the active point.</p>
<p>Attempting to insert <code>d</code> at the active point causes an edge split in O(1)
time:</p>
<p><img alt="" src="images/Rkdzd.png"></p>
<p>The <code>active_node</code>, from which the split was initiated, is marked in red above.
Here is the final rule, <strong>Rule 3:</strong></p>
<blockquote>
<p>After splitting an edge from an <code>active_node</code> that is not the root node, we
follow the suffix link going out of that node, if there is any, and reset
the <code>active_node</code> to the node it points to. If there is no suffix link, we
set the <code>active_node</code> to the root. <code>active_edge</code> and <code>active_length</code> remain
unchanged.</p>
</blockquote>
<p>So the active point is now <code>(node2,'c',1)</code>, and <code>node2</code> is marked in red
below:</p>
<p><img alt="" src="images/0IS5C.png"></p>
<p>Since the insertion of <code>abcd</code> is complete, we decrement <code>remainder</code> to 3 and
consider the next remaining suffix of the current step, <code>bcd</code>. Rule 3 has set
the active point to just the right node and edge so inserting <code>bcd</code> can be
done by simply inserting its final character <code>d</code> at the active point.</p>
<p>Doing this causes another edge split, and <strong>because of rule 2</strong> , we must
create a suffix link from the previously inserted node to the new one:</p>
<p><img alt="" src="images/DNVQO.png"></p>
<p><strong>We observe:</strong> Suffix links enable us to reset the active point so we can
make the next <em>remaining insert</em> at O(1) effort. Look at the graph above to
confirm that indeed node at label <code>ab</code> is linked to the node at <code>b</code> (its
suffix), and the node at <code>abc</code> is linked to <code>bc</code>.</p>
<p>The current step is not finished yet. <code>remainder</code> is now 2, and we need to
follow rule 3 to reset the active point again. Since the current <code>active_node</code>
(red above) has no suffix link, we reset to root. The active point is now
<code>(root,'c',1)</code>.</p>
<p>Hence the next insert occurs at the one outgoing edge of the root node whose
label starts with <code>c</code>: <code>cabxabcd</code>, behind the first character, i.e. behind
<code>c</code>. This causes another split:</p>
<p><img alt="" src="images/wZ7Bj.png"></p>
<p>And since this involves the creation of a new internal node,we follow rule 2
and set a new suffix link from the previously created internal node:</p>
<p><img alt="" src="images/urgol.png"></p>
<p>(I am using Graphviz Dot for these little graphs. The new suffix link caused
dot to re-arrange the existing edges, so check carefully to confirm that the
only thing that was inserted above is a new suffix link.)</p>
<p>With this, <code>remainder</code> can be set to 1 and since the <code>active_node</code> is root, we
use rule 1 to update the active point to <code>(root,'d',0)</code>. This means the final
insert of the current step is to insert a single <code>d</code> at root:</p>
<p><img alt="" src="images/TPxLe.png"></p>
<p>That was the final step and we are done. There are number of <strong>final
observations</strong> , though:</p>
<ul>
<li>
<p>In each step we move <code>#</code> forward by 1 position. This automatically updates all leaf nodes in O(1) time.</p>
</li>
<li>
<p>But it does not deal with a) any suffixes <em>remaining</em> from previous steps, and b) with the one final character of the current step.</p>
</li>
<li>
<p><code>remainder</code> tells us how many additional inserts we need to make. These inserts correspond one-to-one to the final suffixes of the string that ends at the current position <code>#</code>. We consider one after the other and make the insert. <strong>Important:</strong> Each insert is done in O(1) time since the active point tells us exactly where to go, and we need to add only one single character at the active point. Why? Because the other characters are <em>contained implicitly</em> (otherwise the active point would not be where it is).</p>
</li>
<li>
<p>After each such insert, we decrement <code>remainder</code> and follow the suffix link if there is any. If not we go to root (rule 3). If we are at root already, we modify the active point using rule 1. In any case, it takes only O(1) time.</p>
</li>
<li>
<p>If, during one of these inserts, we find that the character we want to insert is already there, we don't do anything and end the current step, even if <code>remainder</code>&gt;0. The reason is that any inserts that remain will be suffixes of the one we just tried to make. Hence they are all <em>implicit</em> in the current tree. The fact that <code>remainder</code>&gt;0 makes sure we deal with the remaining suffixes later.</p>
</li>
<li>
<p>What if at the end of the algorithm <code>remainder</code>&gt;0? This will be the case whenever the end of the text is a substring that occurred somewhere before. In that case we must append one extra character at the end of the string that has not occurred before. In the literature, usually the dollar sign <code>$</code> is used as a symbol for that. <strong>Why does that matter?</strong> --&gt; If later we use the completed suffix tree to search for suffixes, we must accept matches only if they <em>end at a leaf</em>. Otherwise we would get a lot of spurious matches, because there are <em>many</em> strings <em>implicitly</em> contained in the tree that are not actual suffixes of the main string. Forcing <code>remainder</code> to be 0 at the end is essentially a way to ensure that all suffixes end at a leaf node. <strong>However,</strong> if we want to use the tree to search for <em>general substrings</em> , not only <em>suffixes</em> of the main string, this final step is indeed not required, as suggested by the OP's comment below.</p>
</li>
<li>
<p>So what is the complexity of the entire algorithm? If the text is n characters in length, there are obviously n steps (or n+1 if we add the dollar sign). In each step we either do nothing (other than updating the variables), or we make <code>remainder</code> inserts, each taking O(1) time. Since <code>remainder</code> indicates how many times we have done nothing in previous steps, and is decremented for every insert that we make now, the total number of times we do something is exactly n (or n+1). Hence, the total complexity is O(n).</p>
</li>
<li>
<p>However, there is one small thing that I did not properly explain: It can happen that we follow a suffix link, update the active point, and then find that its <code>active_length</code> component does not work well with the new <code>active_node</code>. For example, consider a situation like this:</p>
</li>
</ul>
<p><img alt="" src="images/7t0dg.png"></p>
<p>(The dashed lines indicate the rest of the tree. The dotted line is a suffix
link.)</p>
<p>Now let the active point be <code>(red,'d',3)</code>, so it points to the place behind
the <code>f</code> on the <code>defg</code> edge. Now assume we made the necessary updates and now
follow the suffix link to update the active point according to rule 3. The new
active point is <code>(green,'d',3)</code>. However, the <code>d</code>-edge going out of the green
node is <code>de</code>, so it has only 2 characters. In order to find the correct active
point, we obviously need to follow that edge to the blue node and reset to
<code>(blue,'f',1)</code>.</p>
<p>In a particularly bad case, the <code>active_length</code> could be as large as
<code>remainder</code>, which can be as large as n. And it might very well happen that to
find the correct active point, we need not only jump over one internal node,
but perhaps many, up to n in the worst case. Does that mean the algorithm has
a hidden O(n2) complexity, because in each step <code>remainder</code> is generally O(n),
and the post-adjustments to the active node after following a suffix link
could be O(n), too?</p>
<p>No. The reason is that if indeed we have to adjust the active point (e.g. from
green to blue as above), that brings us to a new node that has its own suffix
link, and <code>active_length</code> will be reduced. As we follow down the chain of
suffix links we make the remaining inserts, <code>active_length</code> can only decrease,
and the number of active-point adjustments we can make on the way can't be
larger than <code>active_length</code> at any given time. Since <code>active_length</code> can never
be larger than <code>remainder</code>, and <code>remainder</code> is O(n) not only in every single
step, but the total sum of increments ever made to <code>remainder</code> over the course
of the entire process is O(n) too, the number of active point adjustments is
also bounded by O(n).</p>
<p><br></p>
<h3>更多建议</h3>
<p>我尝试使用 jogojapan
的回答中给出的方法来实现后缀树，但由于规则中使用的措辞，它在某些情况下不起作用。此外，我已经提到没有人设法使用这种方法实现绝对正确的后缀树。下面我将对
jogojapan 的答案进行“概述”，并对规则进行一些修改。 <strong> <em>我还将描述忘记创建重要</em></strong> 后缀链接的情况。</p>
<p><strong>使用的附加变量</strong></p>
<ol>
<li>
<strong>活动点</strong> - 三元组 (active_node; active_edge; active_length)，显示我们必须从哪里开始插入新后缀。</li>
<li>
<strong>remainder - 显示我们必须</strong> <em>显式</em> 添加的后缀数。例如，如果我们的单词是 'abcaabca'，并且余数 = 3，则意味着我们必须处理 3 个最后的后缀： <strong>bca</strong> 、 <strong>ca</strong> 和 <strong>a</strong> 。</li>
</ol>
<p><strong>让我们使用一个内部节点</strong> 的概念——所有的节点，除了 <em>根</em> 和 <em>叶子</em> 都是 <strong>内部节点</strong> 。</p>
<p><strong>观察 1</strong></p>
<p>当发现我们需要插入的最后一个后缀已经存在于树中时，树本身根本没有改变（我们只更新 和<code>active point</code>）<code>remainder</code>。</p>
<p><strong>观察2</strong></p>
<p>如果在某个点<code>active_length</code>大于或等于当前边的长度 ( <code>edge_length</code>)，我们<code>active
point</code>向下移动直到<code>edge_length</code>严格大于<code>active_length</code>。</p>
<p>现在，让我们重新定义规则：</p>
<p><strong>规则1</strong></p>
<blockquote>
<p><em>如果从活动节点</em> = <em>root</em> 插入后， <em>活动长度</em> 大于 0，则：</p>
<ol>
<li>
<em>活动节点</em> 没有改变</li>
<li>
<em>活动长度</em> 递减</li>
<li>
<em>活动边缘</em> 向右移动（到我们必须插入的下一个后缀的第一个字符）
</li>
</ol>
</blockquote>
<p><strong>规则 2</strong></p>
<blockquote>
<p>如果我们创建一个新的 <em>内部节点</em> <strong>或</strong> 从 <em>内部节点</em> 创建一个插入器，并且这不是当前步骤中的第一个 <strong>SUCH</strong> <em>内部节点</em>
，那么我们通过 <em>后缀链接将前一个</em> <strong>SUCH</strong> 节点与 <strong>THIS</strong> 节点链接起来。 __</p>
</blockquote>
<p>这个定义<code>Rule 2</code>与 jogojapan' 不同，因为这里我们不仅考虑了 <em>新创建的</em> 内部节点，还考虑了我们从中进行插入的内部节点。</p>
<p><strong>规则 3</strong></p>
<blockquote>
<p>从不是 <em>根节点的</em> <em>活动节点</em> 插入后，我们必须跟随后缀链接并将 <em>活动节点</em> 设置为它指向的节点。如果没有后缀链接，则将 <em>活动节点</em> 设置为
<em>根节点</em> 。无论哪种方式， <em>活动边缘</em> 和 <em>活动长度</em> 都保持不变。 <strong> </strong> <strong> </strong> <strong> </strong></p>
</blockquote>
<p>在这个定义中，<code>Rule 3</code>我们还考虑了叶节点的插入（不仅是分裂节点）。</p>
<p><strong>最后，观察 3：</strong></p>
<p>当我们要添加到树中的符号已经在边缘时，我们根据 ，<code>Observation 1</code>仅更新<code>active point</code>和<code>remainder</code>，而树保持不变。
<strong>但是</strong> 如果有一个 <em>内部节点</em> 标记为 <em>需要后缀链接</em><code>active node</code>，我们必须通过后缀链接将该节点与我们的当前节点连接起来。</p>
<p><strong>让我们看一下cdddcdc</strong> 的后缀树示例，如果我们在这种情况下添加后缀链接，如果我们不这样做：</p>
<ol>
<li>
<p>如果我们 <strong>不</strong> 通过后缀链接连接节点：</p>
<ul>
<li>在添加最后一个字母 <strong>c</strong> 之前：</li>
</ul>
</li>
</ol>
<p><img alt="" src="images/zPiF1.png"></p>
<div class="code"><pre class="code literal-block">* 添加最后一个字母 **c** 后：
</pre></div>

<p><img alt="" src="images/5fsmd.png"></p>
<ol>
<li>
<p>如果我们 <strong>确实</strong> 通过后缀链接连接节点：</p>
<ul>
<li>在添加最后一个字母 <strong>c</strong> 之前：</li>
</ul>
</li>
</ol>
<p><img alt="" src="images/lZrAF.png"></p>
<div class="code"><pre class="code literal-block">* 添加最后一个字母 **c** 后：
</pre></div>

<p><img alt="" src="images/XUFjk.png"></p>
<p>似乎没有显着差异：在第二种情况下，还有两个后缀链接。但是这些后缀链接是 <em>正确的</em> ，其中之一——从蓝色节点到红色节点——对我们使用
<strong>活动点的方法非常</strong> <strong>重要</strong> 。问题是，如果我们不在此处放置后缀链接，稍后，当我们向树中添加一些新字母时，由于
，我们可能会省略向树中添加一些节点，因为根据它，如果没有后缀链接，那么我们必须把. ****<code>Rule 3``active_node</code></p>
<p>当我们将最后一个字母添加到树中时，红色节点在我们从蓝色节点（标记为 <strong>'c'</strong> 的边）进行插入之前 <strong>已经存在</strong>
。由于有来自蓝色节点的插入，我们将其标记为 <em>需要后缀链接</em> 。然后，依靠 <strong>主动点</strong> 方法，将 设置为红色节点。但是我们不从红色节点插入，因为字母
<strong>“c”</strong> 已经在边缘上了。是不是说蓝色节点一定要留下没有后缀链接？不，我们必须通过后缀链接将蓝色节点与红色节点连接起来。为什么是正确的？因为
<strong>活跃点</strong> <strong><em>* __ </em></strong><em><code>active node</code> </em><strong><em> </em></strong><em>该方法保证我们到达正确的位置，即到达下一个我们必须处理 </em><em>更短</em>*
后缀插入的位置。</p>
<p>最后，这是我对后缀树的实现：</p>
<ol>
<li>爪哇</li>
<li>C++</li>
</ol>
<p>希望这个“概述”与 jogojapan 的详细答案相结合将帮助某人实现他自己的后缀树。</p>
<p><br><br><a href="posts/ukkonen-s-suffix-tree-algorithm-in-plain-english/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-343.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-341.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
