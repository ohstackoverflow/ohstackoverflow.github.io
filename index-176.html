<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 176) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-176.html">
<link rel="prev" href="index-177.html" type="text/html">
<link rel="next" href="index-175.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/c-zai-foreach-zhong-zhong-yong-bian-liang-shi-fou-you-yuan-yin/" class="u-url">C# 在 foreach 中重用变量是否有原因？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/c-zai-foreach-zhong-zhong-yong-bian-liang-shi-fou-you-yuan-yin/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T00:02:12+08:00" itemprop="datePublished" title="2023-02-17 00:02">2023-02-17 00:02</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在C#中使用lambda表达式或匿名方法时，我们要警惕访问 <em>修改闭</em> 包的陷阱。例如：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">query</span><span class="o">.</span><span class="n">Where</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">Prop</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">modified</span><span class="w"> </span><span class="n">closure</span>
<span class="w">   </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>由于修改了闭包，上述代码将导致<code>Where</code>查询中的所有子句都基于 的最终值<code>s</code>。</p>
<p>正如这里所解释的，发生这种情况是因为<code>s</code>在上面的循环中声明的变量<code>foreach</code>在编译器中被翻译成这样：</p>
<div class="code"><pre class="code literal-block"><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">enumerator</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enumerator</span><span class="o">.</span><span class="n">Current</span><span class="p">;</span>
<span class="w">   </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>而不是这样：</p>
<div class="code"><pre class="code literal-block"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">enumerator</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">   </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enumerator</span><span class="o">.</span><span class="n">Current</span><span class="p">;</span>
<span class="w">   </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>正如此处所指出的，在循环外声明变量没有性能优势，在正常情况下，我能想到的这样做的唯一原因是您打算在循环范围外使用变量：</p>
<div class="code"><pre class="code literal-block"><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">enumerator</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">())</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enumerator</span><span class="o">.</span><span class="n">Current</span><span class="p">;</span>
<span class="w">   </span><span class="o">...</span>
<span class="p">}</span>
<span class="k">var</span><span class="w"> </span><span class="n">finalString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
</pre></div>

<p>但是在<code>foreach</code>循环中定义的变量不能在循环外使用：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">var</span><span class="w"> </span><span class="n">finalString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">won</span><span class="s1">'t work: you'</span><span class="n">re</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">scope</span><span class="o">.</span>
</pre></div>

<p>因此，编译器声明变量的方式使其极易出现通常难以发现和调试的错误，同时不会产生明显的好处。</p>
<p>如果<code>foreach</code>循环是使用内部范围的变量编译的，那么你可以用这种方式对循环做一些你不能做的事情吗？或者这只是在匿名方法和 lambda
表达式可用或常见之前做出的任意选择从那以后有没有修改过？</p>
<p><br><br></p>
<h2>解答</h2>
<blockquote>
<p>编译器声明变量的方式使其极易出现通常难以发现和调试的错误，同时不会产生任何可察觉的好处。</p>
</blockquote>
<p>你的批评是完全有道理的。</p>
<p>我在这里详细讨论这个问题：</p>
<p>关闭被认为有害的循环变量</p>
<blockquote>
<p>是否可以通过这种方式对 foreach 循环执行某些操作，而如果它们是使用内部作用域变量编译的，则无法执行？或者这只是在匿名方法和 lambda
表达式可用或常见之前做出的任意选择，并且从那时起就没有修改过？</p>
</blockquote>
<p>后者。C# 1.0 规范实际上没有说明循环变量是在循环体内部还是外部，因为它没有明显的区别。在 C# 2.0
中引入闭包语义时，选择将循环变量放在循环之外，与“for”循环一致。</p>
<p>我认为公平地说，所有人都对那个决定感到遗憾。这是 C# 中最糟糕的“陷阱”之一， <strong>我们将采取重大更改来修复它。</strong> 在 C# 5 中，foreach
循环变量在逻辑上将位于 <em>循环</em> 体内，因此闭包每次都会获得一个新副本。</p>
<p>循环<code>for</code>不会更改，更改也不会“向后移植”到以前的 C# 版本。因此，您在使用这个成语时应该继续小心。</p>
<p><br></p>
<h3>更多建议</h3>
<p>Eric Lippert 在他的博客文章Closing over the loop variable considered harmful and its
sequel 中详细介绍了您要问的内容。</p>
<p>对我来说，最有说服力的论点是每次迭代中都有新变量将与<code>for(;;)</code>样式循环不一致。<code>int i</code>您是否希望在每次迭代中都有一个新的<code>for (int i
= 0; i &lt; 10; i++)</code>？</p>
<p>这种行为最常见的问题是对迭代变量进行闭包，它有一个简单的解决方法：</p>
<div class="code"><pre class="code literal-block"><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="k">var</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">var</span><span class="w"> </span><span class="n">s_for_closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">query</span><span class="o">.</span><span class="n">Where</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="n">Prop</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s_for_closure</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">modified</span><span class="w"> </span><span class="n">closure</span>
</pre></div>

<p>我关于此问题的博客文章：Closure over foreach variable in C#。</p>
<p><br><br><a href="posts/is-there-a-reason-for-c-s-reuse-of-the-variable-in-a-foreach/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-yong-like-cha-xun-mongodb/" class="u-url">如何用“like”查询MongoDB</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-yong-like-cha-xun-mongodb/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T00:01:44+08:00" itemprop="datePublished" title="2023-02-17 00:01">2023-02-17 00:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想用 SQL 的<code>like</code>查询查询一些东西：</p>
<div class="code"><pre class="code literal-block">SELECT * FROM users  WHERE name LIKE '%m%'
</pre></div>

<p>我怎样才能在 MongoDB 中实现相同的目标？<code>like</code>我在文档中找不到运算符。</p>
<p><br><br></p>
<h2>解答</h2>
<p>那必须是：</p>
<div class="code"><pre class="code literal-block">db.users.find({"name": /.*m.*/})
</pre></div>

<p>或者，类似的：</p>
<div class="code"><pre class="code literal-block">db.users.find({"name": /m/})
</pre></div>

<p>您正在寻找某处包含“m”的内容（SQL 的 ' <code>%</code>' 运算符等同于正则表达式 ' ' <code>.*</code>'），而不是将“m”锚定到字符串开头的内容。</p>
<p><strong>注意：</strong> MongoDB 使用比 SQL 中的“LIKE”更强大的正则表达式。使用正则表达式，您可以创建您想象的任何模式。</p>
<p>有关正则表达式的更多信息，请参阅 <em>正则表达式</em> (MDN)。</p>
<p><br></p>
<h3>更多建议</h3>
<div class="code"><pre class="code literal-block">db.users.insert({name: 'patrick'})
db.users.insert({name: 'petra'})
db.users.insert({name: 'pedro'})
</pre></div>

<p>所以：</p>
<p>为了：</p>
<div class="code"><pre class="code literal-block">db.users.find({name: /a/})  // Like '%a%'
</pre></div>

<p>输出： <em>patrick, petra</em></p>
<p>为了：</p>
<div class="code"><pre class="code literal-block">db.users.find({name: /^pa/}) // Like 'pa%'
</pre></div>

<p>输出： <em>帕特里克</em></p>
<p>为了：</p>
<div class="code"><pre class="code literal-block">db.users.find({name: /ro$/}) // Like '%ro'
</pre></div>

<p>输出： <em>佩德罗</em></p>
<p><br><br><a href="posts/how-to-query-mongodb-with-like/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wo-ying-gai-zai-html-biao-ji-zhong-de-shi-yao-di-fang-fang-zhi-script-biao-qian/" class="u-url">我应该在 HTML 标记中的什么地方放置 &lt;script&gt; 标签？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wo-ying-gai-zai-html-biao-ji-zhong-de-shi-yao-di-fang-fang-zhi-script-biao-qian/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T00:01:12+08:00" itemprop="datePublished" title="2023-02-17 00:01">2023-02-17 00:01</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>在 HTML 文档中嵌入 JavaScript 时，将<code>&lt;script&gt;</code>标签和包含的 JavaScript
放在哪里才是合适的？我似乎记得您不应该将它们放在该<code>&lt;head&gt;</code>部分中，但是放在该部分的开头<code>&lt;body&gt;</code>也是不好的，因为必须在页面完全呈现（或类似的东西）之前解析
JavaScript。这似乎将部分的 <em>末尾</em><code>&lt;body&gt;</code>作为标记的合理位置<code>&lt;script&gt;</code>。</p>
<p>那么，标签放在哪里 <em>才</em><code>&lt;script&gt;</code>合适呢？</p>
<p>（这个问题引用了这个问题，其中建议将 JavaScript 函数调用从<code>&lt;a&gt;</code>标签移动到<code>&lt;script&gt;</code>标签。我专门使用
jQuery，但更一般的答案也是合适的。）</p>
<p><br><br></p>
<h2>解答</h2>
<p>当浏览器加载带有标签的网站时会发生以下情况<code>&lt;script&gt;</code>：</p>
<ol>
<li>获取 HTML 页面（例如 <em>index.html</em> ）</li>
<li>开始解析 HTML</li>
<li>解析器遇到<code>&lt;script&gt;</code>引用外部脚本文件的标记。</li>
<li>浏览器请求脚本文件。同时，解析器会阻止并停止解析您页面上的其他 HTML。</li>
<li>一段时间后，脚本被下载并随后执行。</li>
<li>解析器继续解析 HTML 文档的其余部分。</li>
</ol>
<p>第 4 步会导致糟糕的用户体验。在您下载所有脚本之前，您的网站基本上会停止加载。如果有一件事是用户讨厌的，那就是等待网站加载。</p>
<h3>为什么会发生这种情况？</h3>
<p>任何脚本都可以通过或其他 DOM 操作插入自己的 HTML
<code>document.write()</code>。这意味着解析器必须等到脚本下载并执行后才能安全地解析文档的其余部分。毕竟，脚本 <em>可以</em> 在文档中插入自己的
HTML。</p>
<p>但是，大多数 JavaScript 开发人员不再在加载文档 <em>时操作 DOM。</em> 相反，他们会等到文档加载完毕后再进行修改。例如：</p>
<div class="code"><pre class="code literal-block"><span class="cm">&lt;!-- index.html --&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="w">    </span><span class="nt">&lt;head&gt;</span>
<span class="w">        </span><span class="nt">&lt;title&gt;</span>My<span class="w"> </span>Page<span class="nt">&lt;/title&gt;</span>
<span class="w">        </span><span class="nt">&lt;script</span><span class="w"> </span><span class="na">src=</span><span class="s">"my-script.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="w">    </span><span class="nt">&lt;/head&gt;</span>
<span class="w">    </span><span class="nt">&lt;body&gt;</span>
<span class="w">        </span><span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">"user-greeting"</span><span class="nt">&gt;</span>Welcome<span class="w"> </span>back,<span class="w"> </span>user<span class="nt">&lt;/div&gt;</span>
<span class="w">    </span><span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>

<p>脚本：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// my-script.js</span>
<span class="n">document</span><span class="p">.</span><span class="n">addEventListener</span><span class="p">(</span><span class="s">"DOMContentLoaded"</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// this function runs when the DOM is ready, i.e. when the document has been parsed</span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s">"user-greeting"</span><span class="p">).</span><span class="n">textContent</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">"Welcome back, Bart"</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>因为您的浏览器不知道 <em>my-script.js</em> 在下载和执行文档之前不会修改文档，所以解析器会停止解析。</p>
<h3>过时的建议</h3>
<p>解决此问题的旧方法是将<code>&lt;script&gt;</code>标记放在您的 的底部<code>&lt;body&gt;</code>，因为这样可以确保解析器直到最后才被阻塞。</p>
<p>这种方法有其自身的问题：在整个文档被解析之前，浏览器无法开始下载脚本。对于具有大型脚本和样式表的大型网站，能够尽快下载脚本对于性能非常重要。如果您的网站未在
2 秒内加载，人们将转到另一个网站。</p>
<p>在最佳解决方案中，浏览器会尽快开始下载您的脚本，同时解析文档的其余部分。</p>
<h3>现代方法</h3>
<p>今天，浏览器支持脚本的<code>async</code>和<code>defer</code>属性。这些属性告诉浏览器在下载脚本时继续解析是安全的。</p>
<h4>异步</h4>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;script</span><span class="w"> </span><span class="na">src=</span><span class="s">"path/to/script1.js"</span><span class="w"> </span><span class="err">async</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script</span><span class="w"> </span><span class="na">src=</span><span class="s">"path/to/script2.js"</span><span class="w"> </span><span class="err">async</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>具有 async 属性的脚本是异步执行的。这意味着脚本会在下载后立即执行，同时不会阻塞浏览器。这意味着脚本 2 有可能在脚本 1 之前下载和执行。</p>
<p>根据http://caniuse.com/#feat=script-async，97.78% 的浏览器都支持这个。</p>
<h4>推迟</h4>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;script</span><span class="w"> </span><span class="na">src=</span><span class="s">"path/to/script1.js"</span><span class="w"> </span><span class="err">defer</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script</span><span class="w"> </span><span class="na">src=</span><span class="s">"path/to/script2.js"</span><span class="w"> </span><span class="err">defer</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<p>具有 defer 属性的脚本按顺序执行（即首先执行脚本 1，然后执行脚本 2）。这也不会阻止浏览器。</p>
<p>与异步脚本不同，延迟脚本仅在加载整个文档后才执行。</p>
<p><em>（要了解更多信息并查看异步、延迟和普通脚本之间差异的一些非常有用的可视化表示，请查看此答案参考部分的前两个链接）</em></p>
<h2>结论</h2>
<p>当前最先进的技术是将脚本放在标记中<code>&lt;head&gt;</code>并使用<code>async</code>or<code>defer</code>属性。这允许您的脚本尽快下载而不会阻止您的浏览器。</p>
<p>好消息是您的网站仍应在不支持这些属性的 2% 浏览器上正确加载，同时加速其他 98%。</p>
<h3>参考</h3>
<ul>
<li>异步与延迟属性</li>
<li>使用 defer 和 async 高效加载 JavaScript</li>
<li>移除渲染阻塞 JavaScript</li>
<li>异步、延迟、模块：视觉备忘单</li>
</ul>
<p><br></p>
<h3>更多建议</h3>
<p><em>正如Put Scripts at the Bottom</em> 所述，就在结束 body 标签之前：</p>
<blockquote>
<p>将脚本放在底部</p>
<p>脚本引起的问题是它们会阻止并行下载。HTTP/1.1
规范建议浏览器为每个主机名并行下载不超过两个组件。如果您从多个主机名提供图像，则可以同时进行两次以上的下载。但是，在下载脚本时，浏览器不会开始任何其他下载，即使是在不同的主机名上也是如此。</p>
</blockquote>
<p><br><br><a href="posts/where-should-i-put-script-tags-in-html-markup/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-177.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-175.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
