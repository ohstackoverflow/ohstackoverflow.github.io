<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 1045) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-1045.html">
<link rel="prev" href="index-1046.html" type="text/html">
<link rel="next" href="index-1044.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wei-shi-yao-yao-shi-yong-yi-lai-zhu-ru/" class="u-url">为什么要使用依赖注入？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wei-shi-yao-yao-shi-yong-yi-lai-zhu-ru/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T23:55:36+08:00" itemprop="datePublished" title="2023-02-17 23:55">2023-02-17 23:55</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我试图理解依赖注入(DI)，但又一次失败了。这看起来很傻。我的代码永远不会一团糟；我几乎不写虚函数和接口（虽然我写过一次在蓝色的月亮上）并且我的所有配置都使用
json.net（有时使用 XML 序列化程序）神奇地序列化到一个类中。</p>
<p>我不太明白它解决了什么问题。它看起来像是在说：“嗨。当你遇到这个函数时，返回一个这种类型的对象并使用这些参数/数据。”<br>
但是……我为什么要用那个？请注意，我也从来不需要使用<code>object</code>，但我明白那是干什么用的。</p>
<p>在构建使用 DI
的网站或桌面应用程序时，有哪些真实情况？我可以很容易地想出一些案例来说明为什么有人可能想在游戏中使用接口/虚拟函数，但是在非游戏代码中使用它是极其罕见的（罕见到我记不起一个实例）。</p>
<p><br><br></p>
<h2>解答</h2>
<p>首先，我想解释一下我为这个答案所做的假设。这并不总是正确的，但经常是这样的：</p>
<blockquote>
<p>接口是形容词；类是名词。</p>
</blockquote>
<p>（实际上，也有接口是名词，但我想在这里概括一下。）</p>
<p>因此，例如，接口可能是诸如<code>IDisposable</code>,<code>IEnumerable</code>或
之类的东西<code>IPrintable</code>。类是这些接口中的一个或多个的实际实现：<code>List</code>或者<code>Map</code>两者都是<code>IEnumerable</code>.</p>
<p>要明白这一点：通常你的类相互依赖。例如，您可能有一个<code>Database</code>访问您的数据库的类（哈，惊喜！;-)），但您还希望此类记录有关访问数据库的日志。假设你有另一个类<code>Logger</code>，然后<code>Database</code>有一个依赖项<code>Logger</code>。</p>
<p>到目前为止，一切都很好。</p>
<p>您可以<code>Database</code>使用以下行在您的类中对这种依赖关系进行建模：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Logger</span><span class="p">();</span>
</pre></div>

<p>一切都很好。直到有一天你意识到你需要一堆记录器，这一切都很好：有时你想记录到控制台，有时想记录到文件系统，有时使用 TCP/IP
和远程日志服务器，等等......</p>
<p>当然，您不想 <em>更改</em> 所有代码（同时您拥有大量代码）并替换所有行</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Logger</span><span class="p">();</span>
</pre></div>

<p>经过：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">TcpLogger</span><span class="p">();</span>
</pre></div>

<p>首先，这并不好玩。其次，这很容易出错。第三，对于训练有素的猴子来说，这是愚蠢的重复性工作。所以你会怎么做？</p>
<p>显然，引入一个<code>ICanLog</code>由所有各种记录器实现的接口（或类似接口）是一个非常好的主意。因此，代码中的第 1 步是：</p>
<div class="code"><pre class="code literal-block">ICanLog logger = new Logger();
</pre></div>

<p>现在类型推断不再改变类型，你总是有一个单一的接口来开发。下一步是你不想<code>new
Logger()</code>一遍又一遍。所以你把创建新实例的可靠性放在一个单一的中央工厂类中，你会得到如下代码：</p>
<div class="code"><pre class="code literal-block">ICanLog logger = LoggerFactory.Create();
</pre></div>

<p>工厂自己决定创建什么样的记录器。您的代码不再关心，如果您想更改正在使用的记录器类型，只需更改 <em>一次</em> ：在工厂内部。</p>
<p>现在，当然，您可以概括这个工厂，并使其适用于任何类型：</p>
<div class="code"><pre class="code literal-block">ICanLog logger = TypeFactory.Create&lt;ICanLog&gt;();
</pre></div>

<p>在某个地方，这个 TypeFactory
需要配置数据，在请求特定接口类型时要实例化哪些实际类，因此您需要一个映射。当然，您可以在代码中执行此映射，但是类型更改意味着重新编译。但是你也可以把这个映射放在一个
XML 文件中，例如。这允许您甚至在编译时间（！）之后更改实际使用的类，这意味着动态地，无需重新编译！</p>
<p>给你一个有用的例子：想想一个不能正常登录的软件，但是当你的客户因为遇到问题而打电话寻求帮助时，你发送给他的只是一个更新的 XML
配置文件，现在他有启用日志记录，您的支持人员可以使用日志文件来帮助您的客户。</p>
<p>现在，当您稍微替换名称时，您最终会得到一个简单的 <em>服务定位器实现，它是</em> <em>控制反转的</em> 两种模式之一（因为您反转了对谁决定实例化哪个类的控制）。</p>
<p>总而言之，这减少了代码中的依赖性，但现在您的所有代码都依赖于中央单一服务定位器。</p>
<p><em>依赖注入</em> 现在是这一行的下一步：只需摆脱对服务定位器的这种单一依赖：而不是各种类向服务定位器请求特定接口的实现，你 - 再一次 -
恢复对谁实例化什么的控制.</p>
<p>通过依赖注入，您的<code>Database</code>类现在有一个需要类型参数的构造函数<code>ICanLog</code>：</p>
<div class="code"><pre class="code literal-block">public Database(ICanLog logger) { ... }
</pre></div>

<p>现在你的数据库总是有一个记录器可以使用，但它不再知道这个记录器来自哪里。</p>
<p>这就是 DI 框架发挥作用的地方：您再次配置您的映射，然后让您的 DI
框架为您实例化您的应用程序。由于该类<code>Application</code>需要一个<code>ICanPersistData</code>实现，因此注入了一个实例<code>Database</code>——但为此它必须首先创建一个为配置的记录器类型的实例<code>ICanLog</code>。等等
...</p>
<p>因此，长话短说：依赖注入是删除代码中依赖项的两种方法之一。它对于编译后的配置更改非常有用，对于单元测试也是一件好事（因为它使得注入存根和/或模拟变得非常容易）。</p>
<p>在实践中，有些事情如果没有服务定位器是做不到的（例如，如果您事先不知道特定接口需要多少个实例：DI
框架总是为每个参数注入一个实例，但您可以调用一个循环内的服务定位器，当然），因此大多数情况下每个 DI 框架也提供一个服务定位器。</p>
<p>但基本上，仅此而已。</p>
<p>PS：我在这里描述的是一种称为 <em>构造函数注入的</em> 技术，还有 <em>属性注入</em>
，其中不是构造函数参数，而是用于定义和解析依赖项的属性。将属性注入视为可选依赖项，将构造函数注入视为强制依赖项。但是对此的讨论超出了这个问题的范围。</p>
<p><br></p>
<h3>更多建议</h3>
<p>我认为很多时候人们对 <em>依赖注入</em> 和依赖注入 <em>框架</em> （或通常称为 <em>容器）之间的区别感到困惑。</em></p>
<p>依赖注入是一个非常简单的概念。而不是这段代码：</p>
<div class="code"><pre class="code literal-block"><span class="nv">public</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">A</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">private</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="nv">b</span><span class="c1">;</span>

<span class="w">  </span><span class="nv">public</span><span class="w"> </span><span class="nv">A</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">this</span>.<span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">B</span><span class="ss">()</span><span class="c1">; // A *depends on* B</span>
<span class="w">  </span>}

<span class="w">  </span><span class="nv">public</span><span class="w"> </span><span class="nv">void</span><span class="w"> </span><span class="nv">DoSomeStuff</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">Do</span><span class="w"> </span><span class="nv">something</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="nv">here</span>
<span class="w">  </span>}
}

<span class="nv">public</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">void</span><span class="w"> </span><span class="nv">Main</span><span class="ss">(</span><span class="nv">string</span>[]<span class="w"> </span><span class="nv">args</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">A</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">A</span><span class="ss">()</span><span class="c1">;</span>
<span class="w">  </span><span class="nv">a</span>.<span class="nv">DoSomeStuff</span><span class="ss">()</span><span class="c1">;</span>
}
</pre></div>

<p>你写这样的代码：</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">private</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">public</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">dependencies</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">arguments</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">look</span><span class="w"> </span><span class="n">ma</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="s2">"new"</span><span class="o">!</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">public</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">DoSomeStuff</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">here</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="n">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">B</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">constructed</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">instead</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="n">a</span><span class="o">.</span><span class="n">DoSomeStuff</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p><strong>就是这样。</strong>
严重地。这给了你很多优势。两个重要的是能够从一个中心位置（函数）控制功能<code>Main()</code>，而不是将其分散到整个程序，以及更容易地隔离测试每个类的能力（因为您可以将模拟或其他伪造的对象传递到它的构造函数中）的实际价值）。</p>
<p>当然，缺点是您现在拥有一个了解您的程序使用的所有类的宏功能。这就是 DI
框架可以提供的帮助。但是如果您无法理解为什么这种方法很有价值，我建议您首先从手动依赖注入开始，这样您就可以更好地了解各种框架可以为您做些什么。</p>
<p><br><br><a href="posts/why-does-one-use-dependency-injection/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/shi-yong-biao-zhun-c-c-11-14-17-c-jian-cha-wen-jian-shi-fou-cun-zai-de-zui-kuai-fang-fa/" class="u-url">使用标准 C++/C++11、14、17/C 检查文件是否存在的最快方法？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/shi-yong-biao-zhun-c-c-11-14-17-c-jian-cha-wen-jian-shi-fou-cun-zai-de-zui-kuai-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T23:55:03+08:00" itemprop="datePublished" title="2023-02-17 23:55">2023-02-17 23:55</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我想找到检查文件是否存在于标准 C++11、14、17 或 C
中的最快方法。我有数千个文件，在对它们进行操作之前，我需要检查它们是否全部存在。我可以写什么而不是<code>/* SOMETHING */</code>在以下函数中？</p>
<div class="code"><pre class="code literal-block"><span class="n">inline</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="n">exist</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="o">/*</span><span class="w"> </span><span class="n">SOMETHING</span><span class="w"> </span><span class="o">*/</span>
<span class="p">}</span>
</pre></div>

<p><br><br></p>
<h2>解答</h2>
<p>好吧，我拼凑了一个测试程序，该程序对这些方法中的每一个都运行了 100,000 次，一半在存在的文件上运行，另一半在不存在的文件上运行。</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/stat.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>

<span class="kr">inline</span><span class="w"> </span><span class="kr">bool</span><span class="w"> </span><span class="nf">exists_test0</span><span class="w"> </span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ifstream</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">good</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kr">bool</span><span class="w"> </span><span class="nf">exists_test1</span><span class="w"> </span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="s">"r"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kr">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kr">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w">   </span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kr">bool</span><span class="w"> </span><span class="nf">exists_test2</span><span class="w"> </span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">access</span><span class="p">(</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">F_OK</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="kr">bool</span><span class="w"> </span><span class="nf">exists_test3</span><span class="w"> </span><span class="p">(</span><span class="kr">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kr">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">struct</span><span class="w"> </span><span class="nc">stat</span><span class="w"> </span><span class="nf">buffer</span><span class="p">;</span><span class="w">   </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">stat</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">buffer</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>

<p>运行 100,000 次调用的总时间的结果平均超过 5 次运行，</p>
<table>
<thead><tr>
<th>方法</th>
<th>时间</th>
</tr></thead>
<tbody>
<tr>
<td>
<code>exists_test0</code>(ifstream)</td>
<td><strong>0.485秒</strong></td>
</tr>
<tr>
<td>
<code>exists_test1</code>（打开文件）</td>
<td><strong>0.302秒</strong></td>
</tr>
<tr>
<td>
<code>exists_test2</code>(posix 访问())</td>
<td><strong>0.202秒</strong></td>
</tr>
<tr>
<td>
<code>exists_test3</code>（posix 统计（））</td>
<td><strong>0.134s</strong></td>
</tr>
</tbody>
</table>
<p>该<code>stat()</code>函数在我的系统（Linux，使用 编译）上提供了最佳性能，如果您出于某种原因拒绝使用 POSIX
函数，<code>g++</code>则标准调用是您最好的选择。<code>fopen</code></p>
<p><br></p>
<h3>更多建议</h3>
<p>备注：在 C++14 中，一旦文件系统 TS完成并被采用，解决方案将是使用：</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">experimental</span><span class="p">::</span><span class="nd">filesystem</span><span class="p">::</span><span class="nd">exists</span><span class="o">(</span><span class="s2">"helloworld.txt"</span><span class="o">);</span>
</pre></div>

<p>从 C++17 开始，只有：</p>
<div class="code"><pre class="code literal-block"><span class="nt">std</span><span class="p">::</span><span class="nd">filesystem</span><span class="p">::</span><span class="nd">exists</span><span class="o">(</span><span class="s2">"helloworld.txt"</span><span class="o">);</span>
</pre></div>

<p><br><br><a href="posts/fastest-way-to-check-if-a-file-exists-using-standard-c-c-111417-c/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zhao-dao-diao-yong-dang-qian-fang-fa-de-fang-fa/" class="u-url">如何找到调用当前方法的方法？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zhao-dao-diao-yong-dang-qian-fang-fa-de-fang-fa/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T23:54:29+08:00" itemprop="datePublished" title="2023-02-17 23:54">2023-02-17 23:54</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>C#登录时，如何得知调用当前方法的方法名？我知道关于
的所有信息<code>System.Reflection.MethodBase.GetCurrentMethod()</code>，但我想在堆栈跟踪中更进一步。我已经考虑过解析堆栈跟踪，但我希望找到一种更清晰、更明确的方法，比如<code>Assembly.GetCallingAssembly()</code>but
for methods。</p>
<p><br><br></p>
<h2>解答</h2>
<p>尝试这个：</p>
<div class="code"><pre class="code literal-block">using System.Diagnostics;
// Get call stack
StackTrace stackTrace = new StackTrace(); 
// Get calling method name
Console.WriteLine(stackTrace.GetFrame(1).GetMethod().Name);
</pre></div>

<p>单线：</p>
<div class="code"><pre class="code literal-block">(new System.Diagnostics.StackTrace()).GetFrame(1).GetMethod().Name
</pre></div>

<p>它来自 <em>Get Calling Method using Reflection [C#]</em> 。</p>
<p><br></p>
<h3>更多建议</h3>
<p>在 C# 5 中，您可以使用caller info获取该信息：</p>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="k">using</span><span class="w"> </span><span class="k">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">CompilerServices</span><span class="p">;</span>
<span class="k">public</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="n">SendError</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">Message</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">CallerMemberName</span><span class="o">]</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">callerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">""</span><span class="p">)</span><span class="w"> </span>
<span class="err">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">callerName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">"called me."</span><span class="p">);</span><span class="w"> </span>
<span class="err">}</span>
</pre></div>

<p>您还可以获得<code>[CallerFilePath]</code>和<code>[CallerLineNumber]</code>。</p>
<p><br><br><a href="posts/how-can-i-find-the-method-that-called-the-current-method/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-1046.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1044.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
