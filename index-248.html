<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 248) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-248.html">
<link rel="prev" href="index-249.html" type="text/html">
<link rel="next" href="index-247.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/this-guan-jian-zi-shi-ru-he-gong-zuo-de-ying-gai-zai-shi-yao-shi-hou-shi-yong/" class="u-url">“this”关键字是如何工作的，应该在什么时候使用？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/this-guan-jian-zi-shi-ru-he-gong-zuo-de-ying-gai-zai-shi-yao-shi-hou-shi-yong/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:07:01+08:00" itemprop="datePublished" title="2023-02-17 02:07">2023-02-17 02:07</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我希望找到关于“this”关键字的作用以及如何正确使用它的清晰解释。</p>
<p>它似乎表现得很奇怪，我不完全明白为什么。</p>
<p>它是如何<code>this</code>工作的，应该在什么时候使用？</p>
<p><br><br></p>
<h2>解答</h2>
<p><code>this</code>是 JavaScript 中的关键字，它是执行上下文的属性。它的主要用途是在函数和构造函数中。的规则<code>this</code>非常简单（如果您坚持最佳实践）。</p>
<h3>
<code>this</code>规范中的技术描述</h3>
<p>ECMAScript标准<code>this</code>通过抽象操作（缩写为 <em>AO</em> ）定义ResolveThisBinding：</p>
<blockquote>
<p>[AO] ResolveThisBinding […] 使用正在运行的执行上下文<code>this</code>的
LexicalEnvironment确定关键字的绑定。[脚步]：</p>
<ol>
<li>令 <em>envRec</em> 为GetThisEnvironment ()。</li>
<li>返回 ？ <em>envRec.GetThisBinding</em> ()。
</li>
</ol>
</blockquote>
<p>Global Environment Records、模块 Environment Records和函数 Environment
Records每个都有自己的 GetThisBinding 方法。</p>
<p>GetThisEnvironment AO 找到当前运行的执行上下文的 LexicalEnvironment 并找到最近的具有 <em>this</em> 绑定（即
HasThisBinding 返回 <strong>true</strong> ）的上行环境记录（通过迭代访问它们的 [[OuterEnv]]
属性）。此过程以三种环境记录类型之一结束。 __ ****</p>
<p>的值<code>this</code>通常取决于代码是否处于严格模式。</p>
<p>GetThisBinding
的返回值反映了当前执行上下文的值<code>this</code>，因此无论何时建立新的执行上下文，<code>this</code>都会解析为不同的值。当当前执行上下文被修改时，也会发生这种情况。以下小节列出了可能发生这种情况的五种情况。</p>
<p>您可以将代码示例放在AST 资源管理器中，以跟随规范详细信息。</p>
<h4>1. 脚本中的全局执行上下文</h4>
<p>这是在顶层评估的脚本代码，例如直接在 a 中<code>&lt;script&gt;</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nt">&lt;script&gt;</span>
//<span class="w"> </span>Global<span class="w"> </span>context
console.log(this);<span class="w"> </span>//<span class="w"> </span>Logs<span class="w"> </span>global<span class="w"> </span>object.

setTimeout(function(){
<span class="w">  </span>console.log("Not<span class="w"> </span>global<span class="w"> </span>context");
});
<span class="nt">&lt;/script&gt;</span>
</pre></div>

<p>在脚本的初始全局执行上下文中，评估<code>this</code>会导致GetThisBinding采取以下步骤：</p>
<blockquote>
<p><em>全局环境记录envRec</em> […] [这样做]的 GetThisBinding 具体方法：</p>
<ol>
<li>返回 <em>envRec</em> .[[GlobalThisValue]]。
</li>
</ol>
</blockquote>
<p>全局环境记录的 [[GlobalThisValue]] 属性始终设置为主机定义的全局对象，可通过<code>globalThis</code>（<code>window</code>在 Web
上，<code>global</code>在 Node.js 上；文档在 MDN 上）访问。按照InitializeHostDefinedRealm的步骤了解
[[GlobalThisValue]] 属性是如何产生的。</p>
<h4>2.模块中的全局执行上下文</h4>
<p>ECMAScript 2015 中引入了模块。</p>
<p>这适用于模块，例如，当直接在一个 内部时<code>&lt;script type="module"&gt;</code>，而不是一个简单的<code>&lt;script&gt;</code>.</p>
<p>在模块的初始全局执行上下文中，评估<code>this</code>会导致GetThisBinding采取以下步骤：</p>
<blockquote>
<p>模块环境记录的 GetThisBinding 具体方法 [...] [这样做]：</p>
<ol>
<li>返回 <strong>未定义</strong> 。
</li>
</ol>
</blockquote>
<p>在模块中，的值<code>this</code>始终<code>undefined</code>在全局上下文中。模块隐含地处于严格模式。</p>
<h4>3.输入评估码</h4>
<p>调用有两种<code>eval</code>：直接调用和间接调用。这种区别自 ECMAScript 第 5 版以来就存在。</p>
<ul>
<li>直接<code>eval</code>呼叫通常看起来像<code>eval(</code>……<code>);</code>或<code>(eval)(</code>…… <code>);</code>（或<code>((eval))(</code>……<code>);</code>等）。1仅当调用表达式适合窄模式时才是 <em>直接的。</em> 2个</li>
<li>间接调用涉及以任何其他方式<code>eval</code>调用函数引用。<code>eval</code>它可能是<code>eval?.(</code>…… <code>)</code>、<code>(</code>…… <code>, eval)(</code>、…… 、 ……等。鉴于，它也将<code>)</code>是…… 、…… 。另外，给定，调用……也是间接的。<code>window.eval(``)``eval.call(``,``)``const aliasEval1 = eval; window.aliasEval2 = eval;``aliasEval1(``)``aliasEval2(``)``const originalEval = eval; window.eval = (x) =&gt; originalEval(x);``eval(``)</code>
</li>
</ul>
<p>请参阅chuckj 对 <em>“(1, eval)('this') vs eval('this') in JavaScript?”的回答。</em>
和德米特里·索什尼科夫 (Dmitry Soshnikov) 的 ECMA-262-5 的详细信息——第 2
章：严格模式（已存档），适用于您可能会使用间接<code>eval()</code>调用的情况。</p>
<p>PerformEval执行<code>eval</code>代码。它创建一个新的声明性环境记录作为其
LexicalEnvironment，这是GetThisEnvironment从中获取<code>this</code>值的地方。</p>
<p>然后，如果代码<code>this</code>中出现，则调用GetThisEnvironment<code>eval</code>找到的Environment
Record的GetThisBinding方法并返回其值。</p>
<p>而创建的声明式环境记录取决于<code>eval</code>调用是直接调用还是间接调用：</p>
<ul>
<li>在直接评估中，它将基于当前运行的执行上下文的 LexicalEnvironment。</li>
<li>在间接评估中，它将基于执行间接评估的领域记录的 [[GlobalEnv]] 属性（全局环境记录） 。</li>
</ul>
<p>意思是：</p>
<ul>
<li>在直接评估中，<code>this</code>值不会改变；它取自名为<code>eval</code>.</li>
<li>在间接求值中，<code>this</code>值是全局对象 ( <code>globalThis</code>)。</li>
</ul>
<p><em>怎么样<code>new Function</code>？</em> — <code>new
Function</code>类似于<code>eval</code>，但它不会立即调用代码；它创建了一个函数。this绑定不适用于此处的任何地方，除非函数被调用时正常工作，如下一小节所述
<em>。</em></p>
<h4>4、输入功能码</h4>
<p>输入函数代码发生在 <em>调用</em> 函数时。</p>
<p>调用函数有四种语法类别。</p>
<ul>
<li>针对这三个执行EvaluateCall AO ：3<ul>
<li>正常函数调用</li>
<li>可选的链接调用</li>
<li>标记模板</li>
</ul>
</li>
<li>并为此执行EvaluateNew ： 3<ul>
<li>构造函数调用</li>
</ul>
</li>
</ul>
<p>实际的函数调用发生在Call AO 处，它是用上下文确定的 <em>thisValue</em>
调用的；这个参数在一长串与调用相关的调用中传递。Call调用函数的[[Call]]内部槽。这会调用PrepareForOrdinaryCall
，其中会创建一个新的函数环境记录：</p>
<blockquote>
<p>函数 <em>环境记录</em> 是声明性环境记录，用于表示函数的顶级范围，如果函数不是 ArrowFunction <em>，</em> 则提供<code>this</code>绑定。如果函数不是
<em>ArrowFunction</em> 函数并引用<code>super</code>，则其函数 Environment Record
还包含用于<code>super</code>从函数内执行方法调用的状态。</p>
</blockquote>
<p>此外，在函数环境记录中还有 [[ThisValue]] 字段：</p>
<blockquote>
<p>这是<code>this</code>用于此函数调用的值。</p>
</blockquote>
<p>NewFunctionEnvironment调用还设置函数环境的 [[ThisBindingStatus]] 属性。</p>
<p>[[Call]]还调用OrdinaryCallBindThis，其中适当的 <em>thisArgument</em> 是根据以下条件确定的：</p>
<ul>
<li>原始参考，</li>
<li>功能的种类，以及</li>
<li>代码是否处于严格模式。</li>
</ul>
<p>一旦确定，对新创建的函数 Environment Record 的BindThisValue方法的最终调用实际上将 [[ThisValue]] 字段设置为
<em>thisArgument</em> 。</p>
<p>最后，这个字段是函数 Environment Record 的 GetThisBinding AO 从中获取值的地方<code>this</code>：</p>
<blockquote>
<p>函数 Environment Record <em>envRec</em> […] [do this] 的 GetThisBinding 具体方法：</p>
<p>[…]<br>
3. 返回 <em>envRec</em> .[[ThisValue]]。</p>
</blockquote>
<p>同样，如何准确地确定 <em>this</em> 值取决于许多因素；这只是一般概述。有了这个技术背景，让我们检查所有的具体例子。</p>
<h5>箭头函数</h5>
<p>评估箭头函数时，函数对象的 [[ThisMode]] 内部槽在OrdinaryFunctionCreate中设置为 <em>“词法”</em> 。</p>
<p>在OrdinaryCallBindThis中，它接受一个函数 <em>F</em> ：</p>
<blockquote>
<ol>
<li>设 <em>thisMode</em> 为 <em>F</em> .[[ThisMode]]。</li>
<li>如果 <em>thisMode</em> 是 <em>词法的</em> ，则返回 NormalCompletion( <code>undefined</code>)。[…]
</li>
</ol>
</blockquote>
<p><em>这仅意味着绑定此</em> 算法的其余部分将被跳过。箭头函数不绑定自己的 <em>this</em> 值。</p>
<p><code>this</code>那么，箭头函数里面有什么？回顾一下ResolveThisBinding和GetThisEnvironment，HasThisBinding
方法显式返回 <strong>false</strong> 。</p>
<blockquote>
<p>HasThisBinding 函数 Environment Record <em>envRec</em> […] [does this] 的具体方法：</p>
<ol>
<li>如果 <em>envRec</em> .[[ThisBindingStatus]] 是 <em>词法的</em> ，则返回 <strong>false</strong> ；否则，返回
<strong>true</strong> 。
</li>
</ol>
</blockquote>
<p>因此，而是迭代地查找外部环境。该过程将在具有 <em>this</em> 绑定的三个环境之一中结束。</p>
<p>这只是意味着， <strong>在箭头函数体中，<code>this</code>来自箭头函数的词法范围</strong>，或者换句话说（来自箭头函数 vs
函数声明/表达式：它们是等价的/可交换的吗？）：</p>
<blockquote>
<p>箭头函数没有自己的<code>this</code>[...] 绑定。相反，[此标识符] 像任何其他变量一样在词法范围内解析。这意味着在箭头函数内部， [指的是] 在箭头函数
<em>定义的</em> 环境中（即箭头函数“外部”）中的<code>this</code>[value of ]。<code>this</code> __</p>
</blockquote>
<h5>函数属性</h5>
<p>In normal functions (<code>function</code>, methods), <code>this</code> is determined <strong>by how the
function is called</strong>.</p>
<p>This is where these “syntax variants” come in handy.</p>
<p>Consider this object containing a function:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">refObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">func</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">      </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<p>Alternatively:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">refObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">func</span><span class="p">(){</span>
<span class="w">      </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<p>In any of the following function calls, the <code>this</code> value inside <code>func</code> will be
<code>refObj</code>.1</p>
<ul>
<li><code>refObj.func()</code></li>
<li><code>refObj["func"]()</code></li>
<li><code>refObj?.func()</code></li>
<li><code>refObj.func?.()</code></li>
<li>`refObj.func```</li>
</ul>
<p>If the called function is syntactically a property of a base object, then this
base will be the “reference” of the call, which, in usual cases, will be the
value of <code>this</code>. This is explained by the evaluation steps linked above; for
example, in <code>refObj.func()</code> (or <code>refObj["func"]()</code>), the
<em>CallMemberExpression</em> is the entire expression <code>refObj.func()</code>, which
consists of the <em>MemberExpression</em> <code>refObj.func</code> and the <em>Arguments</em> <code>()</code>.</p>
<p>But also, <code>refObj.func</code> and <code>refObj</code> play three roles, each:</p>
<ul>
<li>they’re both expressions,</li>
<li>they’re both references, and</li>
<li>they’re both values.</li>
</ul>
<p><code>refObj.func</code> as a <em>value</em> is the callable function object; the corresponding
<em>reference</em> is used to determine the <code>this</code> binding.</p>
<p>The optional chaining and tagged template examples work very similarly:
basically, the reference is everything before the <code>?.()</code>, before the <code>```, or
before the</code>()`.</p>
<p>EvaluateCall uses IsPropertyReference of that reference to determine if it is
a property of an object, syntactically. It’s trying to get the [[Base]]
property of the reference (which is e.g. <code>refObj</code>, when applied to
<code>refObj.func</code>; or <code>foo.bar</code> when applied to <code>foo.bar.baz</code>). If it is written
as a property, then GetThisValue will get this [[Base]] property and use it as
the <em>this</em> value.</p>
<p>Note: Getters / Setters work the same way as methods, regarding <code>this</code>. Simple
properties don’t affect the execution context, e.g. here, <code>this</code> is in global
scope:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="err">`</span><span class="n">globalThis</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="o">.</span>
<span class="w">    </span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">]:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Refers</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="err">`</span><span class="n">globalThis</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="o">.</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>

<h5>Calls without base reference, strict mode, and <code>with</code>
</h5>
<p>A call without a base reference is usually a function that isn’t called as a
property. For example:</p>
<div class="code"><pre class="code literal-block">func(); // As opposed to `refObj.func();`.
</pre></div>

<p>This also happens when passing or assigning methods, or using the comma
operator. This is where the difference between Reference Record and Value is
relevant.</p>
<p>Note function <code>j</code>: following the specification, you will notice that <code>j</code> can
only return the function object (Value) itself, but not a Reference Record.
Therefore the base reference <code>refObj</code> is lost.</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="k">const</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">;</span>

<span class="n">g</span><span class="p">(</span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">);</span>
<span class="n">h</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="n">j</span><span class="p">()();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">refObj</span><span class="o">.</span><span class="k">func</span><span class="p">)();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Another</span><span class="w"> </span><span class="n">common</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">remove</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">ref</span><span class="o">.</span>
</pre></div>

<dl>
<dt>EvaluateCall calls Call with a <em>thisValue</em> of <strong>undefined</strong> here. This makes a</dt>
<dt>difference in OrdinaryCallBindThis ( <em>F</em> : the function object; <em>thisArgument</em>
</dt>
<dd>the <em>thisValue</em> passed to Call):</dd>
</dl>
<blockquote>
<ol>
<li>Let <em>thisMode</em> be <em>F</em>.[[ThisMode]].
</li>
</ol>
<p>[…]</p>
<ol>
<li>If <em>thisMode</em> is <em>strict</em> , let <em>thisValue</em> be <em>thisArgument</em>.</li>
<li>Else,<ol>
<li>If <em>thisArgument</em> is <strong>undefined</strong> or <strong>null</strong> , then</li>
<li>Let <em>globalEnv</em> be <em>calleeRealm</em>.[[GlobalEnv]].</li>
<li>[…]</li>
<li>Let <em>thisValue</em> be <em>globalEnv</em>.[[GlobalThisValue]].</li>
<li>Else,</li>
<li>Let <em>thisValue</em> be ! ToObject(thisArgument).</li>
<li>NOTE: ToObject produces wrapper objects […].
</li>
</ol>
</li>
</ol>
<p>[…]</p>
</blockquote>
<p>Note: step 5 sets the actual value of <code>this</code> to the supplied <em>thisArgument</em> in
strict mode — <code>undefined</code> in this case. In “sloppy mode”, an undefined or null
<em>thisArgument</em> results in <code>this</code> being the global <em>this</em> value.</p>
<p>If IsPropertyReference returns <strong>false</strong> , then EvaluateCall takes these
steps:</p>
<blockquote>
<ol>
<li>Let <em>refEnv</em> be <em>ref</em>.[[Base]].</li>
<li>Assert: <em>refEnv</em> is an Environment Record.</li>
<li>Let <em>thisValue</em> be <em>refEnv</em>.WithBaseObject().
</li>
</ol>
</blockquote>
<p>This is where an undefined <em>thisValue</em> may come from:
<em>refEnv</em>.WithBaseObject() is always <strong>undefined</strong> , <em>except</em> in <code>with</code>
statements. In this case, <em>thisValue</em> will be the binding object.</p>
<p>There’s also <code>Symbol.unscopables</code> (Docs on MDN) to control the <code>with</code> binding
behavior.</p>
<p>To summarize, so far:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f1</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="k">function</span><span class="w"> </span><span class="n">f2</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="k">function</span><span class="w"> </span><span class="n">f3</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span>
<span class="w">    </span><span class="n">f1</span><span class="p">,</span>
<span class="w">    </span><span class="n">f2</span><span class="p">,</span>
<span class="w">    </span><span class="err">[</span><span class="n">Symbol</span><span class="p">.</span><span class="n">unscopables</span><span class="err">]</span><span class="o">:</span><span class="w"> </span><span class="err">{</span>
<span class="w">      </span><span class="n">f2</span><span class="o">:</span><span class="w"> </span><span class="no">true</span>
<span class="w">    </span><span class="err">}</span>
<span class="w">  </span><span class="err">}</span><span class="p">;</span>

<span class="n">f1</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>

<span class="k">with</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="err">{</span>
<span class="w">  </span><span class="n">f1</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`o`</span><span class="p">.</span>
<span class="w">  </span><span class="n">f2</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`f2`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">unscopable</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>
<span class="w">  </span><span class="n">f3</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`f3`</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n n-Quoted">`o`</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">logs</span><span class="w"> </span><span class="n n-Quoted">`globalThis`</span><span class="p">.</span>
<span class="err">}</span>
</pre></div>

<p>and:</p>
<div class="code"><pre class="code literal-block"><span class="s2">"use strict"</span><span class="p">;</span>

<span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`undefined`</span><span class="p">.</span>

<span class="o">//</span><span class="w"> </span><span class="n n-Quoted">`with`</span><span class="w"> </span><span class="n">statements</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">allowed</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">strict</span><span class="o">-</span><span class="k">mode</span><span class="w"> </span><span class="k">code</span><span class="p">.</span>
</pre></div>

<p>Note that when evaluating <code>this</code>, <strong>it doesn’t matter <em>where</em> a normal
function is defined</strong>.</p>
<h5>
<code>.call</code>, <code>.apply</code>, <code>.bind</code>, <em>thisArg</em> , and primitives</h5>
<p>Another consequence of step 5 of OrdinaryCallBindThis, in conjunction with
step 6.2 (6.b in the spec), is that a primitive <em>this</em> value is coerced to an
object <em>only</em> in “sloppy” mode.</p>
<p>To examine this, let’s introduce another source for the <em>this</em> value: the
three methods that override the <em>this</em> binding:4</p>
<ul>
<li><code>Function.prototype.apply(thisArg, argArray)</code></li>
<li>
<code>Function.prototype.</code> {<code>call</code>, <code>bind</code>} <code>(thisArg, ...args)</code>
</li>
</ul>
<p><code>.bind</code> creates a bound function, whose <em>this</em> binding is set to <em>thisArg</em> and
cannot change again. <code>.call</code> and <code>.apply</code> call the function immediately, with
the <em>this</em> binding set to <em>thisArg</em>.</p>
<p><code>.call</code> and <code>.apply</code> map directly to Call, using the specified <em>thisArg</em>.
<code>.bind</code> creates a bound function with BoundFunctionCreate. These have <em>their
own</em> [[Call]] method which looks up the function object’s [[BoundThis]]
internal slot.</p>
<p>Examples of setting a custom <em>this</em> value:</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="err">{</span>
<span class="w">  </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">myObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myObj</span><span class="p">),</span>
<span class="w">  </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">m</span><span class="p">();</span>

<span class="o">//</span><span class="w"> </span><span class="k">All</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`myObj`</span><span class="p">.</span>
<span class="n">g</span><span class="p">();</span>
<span class="n">f</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myObj</span><span class="p">)();</span>
<span class="n">f</span><span class="p">.</span><span class="k">call</span><span class="p">(</span><span class="n">myObj</span><span class="p">);</span>
<span class="n">h</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</pre></div>

<p>For objects, this is the same in strict and non-strict mode.</p>
<p>Now, try to supply a primitive value:</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">(){</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"s"</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>

<span class="n">g</span><span class="p">();</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="nb nb-Type">String</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"s"</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
<span class="n">f</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="nb nb-Type">String</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"s"</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>In non-strict mode, primitives are coerced to their object-wrapped form. It’s
the same kind of object you get when calling <code>Object("s")</code> or <code>new
String("s")</code>. In strict mode, you <em>can</em> use primitives:</p>
<div class="code"><pre class="code literal-block"><span class="s2">"use strict"</span><span class="p">;</span>

<span class="n">function</span><span class="w"> </span><span class="n">f</span><span class="p">(){</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">myString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"s"</span><span class="p">,</span>
<span class="w">  </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>

<span class="n">g</span><span class="p">();</span><span class="w">              </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="s2">"s"</span><span class="err">`</span><span class="o">.</span>
<span class="n">f</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="s2">"s"</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>Libraries make use of these methods, e.g. jQuery sets the <code>this</code> to the DOM
element selected here:</p>
<div class="code"><pre class="code literal-block">$("button").click(function(){
  console.log(this); // Logs the clicked button.
});
</pre></div>

<h5>Constructors, classes, and <code>new</code>
</h5>
<p>When calling a function as a constructor using the <code>new</code> operator, EvaluateNew
calls Construct, which calls the [[Construct]] method. If the function is a
base constructor (i.e. not a <code>class extends</code>…<code>{</code>…<code>}</code>), it sets <em>thisArgument</em>
to a new object created from the constructor’s prototype. Properties set on
<code>this</code> in the constructor will end up on the resulting instance object. <code>this</code>
is implicitly returned, unless you explicitly return your own non-primitive
value.</p>
<p>A <code>class</code> is a new way of creating constructor functions, introduced in
ECMAScript 2015.</p>
<div class="code"><pre class="code literal-block"><span class="n">function</span><span class="w"> </span><span class="n">Old</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
<span class="w">  </span><span class="n">this</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Old</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">o</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">Old</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>

<span class="k">class</span><span class="w"> </span><span class="n">New</span><span class="p">{</span>
<span class="w">  </span><span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">New</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">New</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<p>Class definitions are implicitly in strict mode:</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">A</span><span class="err">{</span>
<span class="w">  </span><span class="n">m1</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="n">m2</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="n">const</span><span class="w"> </span><span class="n">m1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">m1</span><span class="p">;</span>

<span class="w">    </span><span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">m1</span><span class="p">());</span>
<span class="w">  </span><span class="err">}</span>
<span class="err">}</span>

<span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">().</span><span class="n">m2</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Logs</span><span class="w"> </span><span class="n n-Quoted">`undefined`</span><span class="p">.</span>
</pre></div>

<h5><code>super</code></h5>
<p>The exception to the behavior with <code>new</code> is <code>class extends</code>…<code>{</code>…<code>}</code>, as
mentioned above. Derived classes do not immediately set their <em>this</em> value
upon invocation; they only do so once the base class is reached through a
series of <code>super</code> calls (happens implicitly without an own <code>constructor</code>).
Using <code>this</code> before calling <code>super</code> is not allowed.</p>
<p>Calling <code>super</code> calls the super constructor with the <em>this</em> value of the
lexical scope (the function Environment Record) of the call. GetThisValue has
a special rule for <code>super</code> calls. It uses BindThisValue to set <code>this</code> to that
Environment Record.</p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="n">DerivedNew</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">New</span><span class="p">{</span>
<span class="w">  </span><span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">){</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Using</span><span class="w"> </span><span class="err">`</span><span class="n">this</span><span class="err">`</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="err">`</span><span class="n">super</span><span class="err">`</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">ReferenceError</span><span class="o">.</span>
<span class="w">    </span><span class="n">super</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">DerivedNew</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Logs</span><span class="w"> </span><span class="err">`</span><span class="n">DerivedNew</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="err">`</span><span class="o">.</span>
</pre></div>

<h4>5. Evaluating class fields</h4>
<p>Instance fields and static fields were introduced in ECMAScript 2022.</p>
<p>When a <code>class</code> is evaluated, ClassDefinitionEvaluation is performed, modifying
the running execution context. For each <em>ClassElement</em> :</p>
<ul>
<li>if a field is static, then <code>this</code> refers to the class itself,</li>
<li>if a field is not static, then <code>this</code> refers to the instance.</li>
</ul>
<p>Private fields (e.g. <code>#x</code>) and methods are added to a PrivateEnvironment.</p>
<p>Static blocks are currently a TC39 stage 3 proposal. Static blocks work the
same as static fields and methods: <code>this</code> inside them refers to the class
itself.</p>
<p>Note that in methods and getters / setters, <code>this</code> works just like in normal
function properties.</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">Demo</span><span class="err">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="n">static</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="n">static</span><span class="w"> </span><span class="n">d</span><span class="p">()</span><span class="err">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="w">  </span><span class="err">}</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Getters</span><span class="p">,</span><span class="w"> </span><span class="k">set</span><span class="n">ters</span><span class="p">,</span><span class="w"> </span><span class="n">private</span><span class="w"> </span><span class="n">modifiers</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">possible</span><span class="p">.</span>
<span class="err">}</span>

<span class="n">const</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">;</span>

<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">demo</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">demo</span><span class="p">.</span><span class="n">b</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Both</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`demo`</span><span class="p">.</span>
<span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">Demo</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">Demo</span><span class="p">.</span><span class="n">d</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">Both</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n n-Quoted">`Demo`</span><span class="p">.</span>
</pre></div>

<hr>
<p>1: <code>(o.f)()</code> is equivalent to <code>o.f()</code>; <code>(f)()</code> is equivalent to <code>f()</code>. This is
explained in this 2ality article (archived). Particularly see how a
<em>ParenthesizedExpression</em> is evaluated.</p>
<p>2: It must be a <em>MemberExpression</em> , must not be a property, must have a
[[ReferencedName]] of exactly <strong>"eval"</strong> , and must be the %eval% intrinsic
object.</p>
<p>3: Whenever the specification says <em>“Let</em> ref <em>be the result of evaluating</em>
X.”, then <em>X</em> is some expression that you need to find the evaluation steps
for. For example, evaluating a <em>MemberExpression</em> or <em>CallExpression</em> is the
result of one of these algorithms. Some of them result in a Reference Record.</p>
<p>4: There are also several other native and host methods that allow providing a
<em>this</em> value, notably <code>Array.prototype.map</code>, <code>Array.prototype.forEach</code>, etc.
that accept a <em>thisArg</em> as their second argument. Anyone can make their own
methods to alter <code>this</code> like <code>(func, thisArg) =&gt; func.bind(thisArg)</code>, <code>(func,
thisArg) =&gt; func.call(thisArg)</code>, etc. As always, MDN offers great
documentation.</p>
<hr>
<h3>Just for fun, test your understanding with some examples</h3>
<p>For each code snippet, answer the question: <em>“What is the value of<code>this</code> at
the marked line? Why?”</em>.</p>
<p><em>To reveal the answers, click the gray boxes.</em></p>
<ol>
<li>if(true){
      console.log(this); // What is <code>this</code> here?
    }</li>
</ol>
<blockquote>
<p><code>globalThis</code>. The marked line is evaluated in the initial global execution
context.</p>
</blockquote>
<ol>
<li>
<p>const obj = {};</p>
<p>function myFun(){
  return { // What is <code>this</code> here?
    "is obj": this === obj,
    "is globalThis": this === globalThis
  };
}</p>
<p>obj.method = myFun;</p>
<p>console.log(obj.method());</p>
</li>
</ol>
<blockquote>
<p><code>obj</code>. When calling a function as a property of an object, it is called with
the <em>this</em> binding set to the <em>base</em> of the reference <code>obj.method</code>, i.e.
<code>obj</code>.</p>
</blockquote>
<ol>
<li>
<p>const obj = {
        myMethod: function(){
          return { // What is <code>this</code> here?
            "is obj": this === obj,
            "is globalThis": this === globalThis
          };
        }
      },
      myFun = obj.myMethod;</p>
<p>console.log(myFun());</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. Since the function value <code>myFun</code> / <code>obj.myMethod</code> is not
called off of an object, as a property, the <em>this</em> binding will be
<code>globalThis</code>. This is different from Python, in which accessing a method
(<code>obj.myMethod</code>) creates a bound method object.</p>
</blockquote>
<ol>
<li>
<p>const obj = {
        myFun: () =&gt; ({ // What is <code>this</code> here?
          "is obj": this === obj,
          "is globalThis": this === globalThis
        })
      };</p>
<p>console.log(obj.myFun());</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. Arrow functions don’t create their own <em>this</em> binding. The
lexical scope is the same as the initial global scope, so <code>this</code> is
<code>globalThis</code>.</p>
</blockquote>
<ol>
<li>
<p>function myFun(){
      console.log(this); // What is <code>this</code> here?
    }</p>
<p>const obj = {
    myMethod: function(){
      eval("myFun()");
    }
  };</p>
<p>obj.myMethod();</p>
</li>
</ol>
<blockquote>
<p><code>globalThis</code>. When evaluating the direct eval call, <code>this</code> is <code>obj</code>.
However, in the eval code, <code>myFun</code> is not called off of an object, so the
<em>this</em> binding is set to the global object.</p>
</blockquote>
<ol>
<li>
<p>function myFun() {
      // What is <code>this</code> here?
      return {
        "is obj": this === obj,
        "is globalThis": this === globalThis
      };
    }</p>
<p>const obj = {};</p>
<p>console.log(myFun.call(obj));</p>
</li>
</ol>
<blockquote>
<p><code>obj</code>. The line <code>myFun.call(obj);</code> is invoking the special built-in function
<code>Function.prototype.call</code>, which accepts <code>thisArg</code> as the first argument.</p>
</blockquote>
<ol>
<li>
<p>class MyCls{
      arrow = () =&gt; ({ // What is <code>this</code> here?
        "is MyCls": this === MyCls,
        "is globalThis": this === globalThis,
        "is instance": this instanceof MyCls
      });
    }</p>
<p>console.log(new MyCls().arrow());</p>
</li>
</ol>
<blockquote>
<p>It’s the instance of <code>MyCls</code>. Arrow functions don’t change the <em>this</em>
binding, so it comes from lexical scope. Therefore, this is <em>exactly the
same</em> as with the class fields mentioned above, like <code>a = this;</code>. Try
changing it to <code>static arrow</code>. Do you get the result you expect?</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p><code>this</code>与其他语言相比，关键字在 JavaScript 中的行为不同。在面向对象的语言中，<code>this</code>关键字指的是类的当前实例。在 JavaScript
中， 的值<code>this</code>由函数 ( ) 的调用上下文 <em><code>context.function()</code></em> 和调用位置决定。</p>
<p><strong>1. 在全局上下文中使用时</strong></p>
<p>当您<code>this</code>在全局上下文中使用时，它会绑定到全局对象（<code>window</code>在浏览器中）</p>
<div class="code"><pre class="code literal-block"><span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="w">  </span><span class="c1">//[object Window]</span>
</pre></div>

<p>当您<code>this</code>在全局上下文中定义的函数内部使用时，<code>this</code>仍然绑定到全局对象，因为该函数实际上是全局上下文的方法。</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="nf">f1</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">f1</span><span class="p">());</span><span class="w">  </span><span class="o">//</span><span class="p">[</span><span class="n">object</span><span class="w"> </span><span class="n">Window</span><span class="p">]</span>
</pre></div>

<p>以上<code>f1</code>是全局对象的方法。因此我们也可以在对象上调用它，<code>window</code>如下所示：</p>
<div class="code"><pre class="code literal-block"><span class="k">function</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="p">[</span><span class="n">object</span><span class="w"> </span><span class="n">Window</span><span class="p">]</span>
</pre></div>

<p><strong>2.在对象方法内部使用时</strong></p>
<p><code>this</code>当您在对象方法中使用关键字时，<code>this</code>将绑定到“立即”封闭对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">f</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w">  </span><span class="c1">//[object Object]:obj</span>
</pre></div>

<p>上面我把立即这个词用双引号引起来了。它的意思是，如果将对象嵌套在另一个对象中，则<code>this</code>绑定到直接父对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj1"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">nestedobj</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nl">name</span><span class="p">:</span><span class="s">"nestedobj"</span><span class="p">,</span>
<span class="w">        </span><span class="nl">f</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w">            </span>
<span class="p">}</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">nestedobj</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Object]:nestedobj</span>
</pre></div>

<p>即使你将函数作为方法显式地添加到对象中，它仍然遵循上述规则，即<code>this</code>仍然指向直接父对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="s">"obj1"</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">function</span><span class="w"> </span><span class="n">returnName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">obj1</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">returnName</span><span class="p">;</span><span class="w"> </span><span class="c1">//add method to object</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">f</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Object]:obj1</span>
</pre></div>

<p><strong>3.调用context-less函数时</strong></p>
<p>当您使用<code>this</code>在没有任何上下文（即不在任何对象上）的情况下调用的内部函数时，它会绑定到全局对象（<code>window</code>在浏览器中）（即使函数是在对象内部定义的）。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"global"</span><span class="p">;</span>

<span class="n">var</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">    </span><span class="nl">context</span><span class="p">:</span><span class="w"> </span><span class="s">"object"</span><span class="p">,</span>
<span class="w">    </span><span class="nl">method</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">                  </span>
<span class="w">        </span><span class="n">function</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">var</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"function"</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">context</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="c1">//invoked without context</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">method</span><span class="p">());</span><span class="w"> </span><span class="c1">//[object Window]:global</span>
</pre></div>

<p><strong>用函数尝试一切</strong></p>
<p>我们也可以用函数尝试以上几点。但是，存在一些差异。</p>
<ul>
<li>上面我们使用对象字面量表示法向对象添加了成员​​。我们可以使用 向函数添加成员<code>this</code>。指定它们。</li>
<li>对象字面量符号创建了一个我们可以立即使用的对象实例。对于函数，我们可能需要首先使用<code>new</code>运算符创建它的实例。</li>
<li>同样在对象字面量方法中，我们可以使用点运算符显式地将成员添加到已定义的对象中。这只会添加到特定实例。但是，我已将变量添加到函数原型中，以便它反映在函数的所有实例中。</li>
</ul>
<p>下面我尝试了我们对 Object 及以上所做的所有事情<code>this</code>，但是首先创建函数而不是直接编写对象。</p>
<div class="code"><pre class="code literal-block"><span class="cm">/********************************************************************* </span>
<span class="cm">  1. When you add variable to the function using this keyword, it </span>
<span class="cm">     gets added to the function prototype, thus allowing all function </span>
<span class="cm">     instances to have their own copy of the variables added.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">function</span><span class="w"> </span><span class="nf">functionDef</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"ObjDefinition"</span><span class="p">;</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">getName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span><span class="w">                </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">functionDef</span><span class="p">();</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//[object Object]:ObjDefinition</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   2. Members explicitly added to the function protorype also behave </span>
<span class="cm">      as above: all function instances have their own copy of the </span>
<span class="cm">      variable added.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">getVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">"v"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="p">;</span><span class="w"> </span><span class="c1">//see how this.version refers to the</span>
<span class="w">                             </span><span class="c1">//version variable added through </span>
<span class="w">                             </span><span class="c1">//prototype</span>
<span class="p">}</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   3. Illustrating that the function variables added by both above </span>
<span class="cm">      ways have their own copies across function instances</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">incrementVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">var</span><span class="w"> </span><span class="n">obj2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">functionDef</span><span class="p">();</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="n">obj2</span><span class="p">.</span><span class="n">incrementVersion</span><span class="p">();</span><span class="w">      </span><span class="c1">//incrementing version in obj2</span>
<span class="w">                              </span><span class="c1">//does not affect obj1 version</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v2</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">getVersion</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//v1</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   4. `this` keyword refers to the immediate parent object. If you </span>
<span class="cm">       nest the object through function prototype, then `this` inside </span>
<span class="cm">       object refers to the nested object not the function instance</span>
<span class="cm">*********************************************************************/</span>
<span class="n">functionDef</span><span class="p">.</span><span class="n">prototype</span><span class="p">.</span><span class="n">nestedObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="err">'</span><span class="n">nestedObj</span><span class="err">'</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                    </span><span class="nl">getName1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">                                        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">                                    </span><span class="p">}</span><span class="w">                            </span>
<span class="w">                                  </span><span class="p">};</span>

<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj2</span><span class="p">.</span><span class="n">nestedObj</span><span class="p">.</span><span class="n">getName1</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="w"> </span><span class="c1">//[object Object]:nestedObj</span>

<span class="cm">/********************************************************************* </span>
<span class="cm">   5. If the method is on an object's prototype chain, `this` refers </span>
<span class="cm">      to the object the method was called on, as if the method was on </span>
<span class="cm">      the object.</span>
<span class="cm">*********************************************************************/</span>
<span class="n">var</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fun</span><span class="o">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<span class="n">var</span><span class="w"> </span><span class="n">obj3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Object</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">ProtoObj</span><span class="p">);</span><span class="w"> </span><span class="c1">//creating an object setting ProtoObj</span>
<span class="w">                                    </span><span class="c1">//as its prototype</span>
<span class="n">obj3</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="p">;</span><span class="w">                       </span><span class="c1">//adding instance member to obj3</span>
<span class="n">document</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj3</span><span class="p">.</span><span class="n">fun</span><span class="p">()</span><span class="o">+</span><span class="s">"&lt;br /&gt;"</span><span class="p">);</span><span class="c1">//999</span>
<span class="w">                                    </span><span class="c1">//calling obj3.fun() makes </span>
<span class="w">                                    </span><span class="c1">//ProtoObj.fun() to access obj3.a as </span>
<span class="w">                                    </span><span class="c1">//if fun() is defined on obj3</span>
</pre></div>

<p><strong>4.在构造函数内部使用时</strong> 。</p>
<p>当函数用作构造函数时（即使用<code>new</code>关键字调用时），<code>this</code>函数体内指向正在构造的新对象。</p>
<div class="code"><pre class="code literal-block"><span class="n">var</span><span class="w"> </span><span class="n">myname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"global context"</span><span class="p">;</span>
<span class="k">function</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">()</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">myname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"simple function"</span><span class="p">;</span>
<span class="err">}</span>

<span class="n">var</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">();</span><span class="w"> </span><span class="o">//</span><span class="n">adds</span><span class="w"> </span><span class="n">myname</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">obj1</span>
<span class="o">//</span><span class="mf">1.</span><span class="w"> </span><span class="n n-Quoted">`new`</span><span class="w"> </span><span class="n">causes</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">SimpleFun</span><span class="p">()</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">point</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span>
<span class="o">//</span><span class="w">   </span><span class="n">object</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">constructed</span><span class="w"> </span><span class="n">thus</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="k">any</span><span class="w"> </span><span class="k">member</span>
<span class="o">//</span><span class="w">   </span><span class="n">created</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">SimipleFun</span><span class="p">()</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">membername</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span>
<span class="o">//</span><span class="w">   </span><span class="n">object</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">constructed</span>
<span class="o">//</span><span class="mf">2.</span><span class="w"> </span><span class="k">And</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n n-Quoted">`new`</span><span class="w"> </span><span class="n">makes</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">newly</span><span class="w"> </span>
<span class="o">//</span><span class="w">   </span><span class="n">constructed</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">specified</span>

<span class="n">document</span><span class="p">.</span><span class="k">write</span><span class="p">(</span><span class="n">obj1</span><span class="p">.</span><span class="n">myname</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="k">simple</span><span class="w"> </span><span class="k">function</span>
</pre></div>

<p><strong>5. 在原型链上定义的函数内部使用时</strong></p>
<p>如果该方法在对象的原型链上，<code>this</code>则在该方法内部引用调用该方法的对象，就好像该方法是在该对象上定义的一样。</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fun</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="o">//</span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">create</span><span class="p">()</span><span class="w"> </span><span class="n">creates</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">ProtoObj</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">its</span>
<span class="o">//</span><span class="n">prototype</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">assigns</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">obj3</span><span class="p">,</span><span class="w"> </span><span class="n">thus</span><span class="w"> </span><span class="n">making</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span>
<span class="o">//</span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">prototype</span><span class="w"> </span><span class="n">chain</span>

<span class="k">var</span><span class="w"> </span><span class="n">obj3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb nb-Type">Object</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ProtoObj</span><span class="p">);</span>
<span class="n">obj3</span><span class="o">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="p">;</span>
<span class="n">document</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj3</span><span class="o">.</span><span class="n">fun</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="mi">999</span>

<span class="o">//</span><span class="n">Notice</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">obj3</span><span class="s1">'s prototype but </span>
<span class="o">//</span><span class="err">`</span><span class="n">this</span><span class="o">.</span><span class="n">a</span><span class="err">`</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="n">fun</span><span class="p">()</span><span class="w"> </span><span class="n">retrieves</span><span class="w"> </span><span class="n">obj3</span><span class="o">.</span><span class="n">a</span>
</pre></div>

<p><strong>6. call()、apply() 和 bind() 函数内部</strong></p>
<ul>
<li>所有这些方法都定义在<code>Function.prototype</code>.</li>
<li>这些方法允许编写一次函数并在不同的上下文中调用它。换句话说，它们允许指定<code>this</code>在执行函数时将使用的值。它们还会在调用原始函数时采用任何参数传递给原始函数。</li>
<li>
<strong><code>fun.apply(obj1 [, argsArray])</code></strong> 设置为inside<code>obj1</code>的值并调用传递的元素作为其参数。<code>this``fun()``fun()``argsArray</code>
</li>
<li>
<strong><code>fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])</code></strong> - 设置为内部<code>obj1</code>的值并调用作为其参数传递。<code>this``fun()``fun()``arg1, arg2, arg3, ...</code>
</li>
<li>
<strong><code>fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])</code></strong><code>fun</code>- 返回对具有<code>this</code>内部 fun 绑定<code>obj1</code>和参数<code>fun</code>绑定到指定参数的函数的引用<code>arg1, arg2, arg3,...</code>。</li>
<li>
<p><code>apply</code>到现在，<code>call</code>和之间的区别<code>bind</code>一定已经很明显了。<code>apply</code>允许将参数指定为类似数组的对象，即具有数字<code>length</code>属性和相应的非负整数属性的对象。而<code>call</code>允许直接指定函数的参数。和<code>apply</code>都<code>call</code>在指定的上下文中使用指定的参数立即调用函数。另一方面，简单地返回绑定到指定值和参数的<code>bind</code>函数。<code>this</code>我们可以通过将它分配给一个变量来捕获对该返回函数的引用，然后我们可以随时调用它。</p>
<p>function add(inc1, inc2)
{
    return this.a + inc1 + inc2;
}</p>
<p>var o = { a : 4 };
document.write(add.call(o, 5, 6)+"<br>"); //15
      //above add.call(o,5,6) sets <code>this</code> inside
      //add() to <code>o</code> and calls add() resulting:
      // this.a + inc1 + inc2 = 
      // <code>o.a</code> i.e. 4 + 5 + 6 = 15
document.write(add.apply(o, [5, 6]) + "<br>"); //15
      // <code>o.a</code> i.e. 4 + 5 + 6 = 15</p>
<p>var g = add.bind(o, 5, 6);       //g: <code>o.a</code> i.e. 4 + 5 + 6
document.write(g()+"<br>");    //15</p>
<p>var h = add.bind(o, 5);          //h: <code>o.a</code> i.e. 4 + 5 + ?
document.write(h(6) + "<br>"); //15
      // 4 + 5 + 6 = 15
document.write(h() + "<br>");  //NaN
      //no parameter is passed to h()
      //thus inc2 inside add() is <code>undefined</code>
      //4 + 5 + undefined = NaN</p>
</li>
</ul>
<p><strong>7.<code>this</code>内部事件处理程序</strong></p>
<ul>
<li>When you assign function directly to event handlers of an element, use of <code>this</code> directly inside event handling function refers to the corresponding element. Such direct function assignment can be done using <code>addeventListener</code> method or through the traditional event registration methods like <code>onclick</code>.</li>
<li>Similarly, when you use <code>this</code> directly inside the event property (like <code>&lt;button onclick="...this..." &gt;</code>) of the element, it refers to the element.</li>
<li>However use of <code>this</code> indirectly through the other function called inside the event handling function or event property resolves to the global object <code>window</code>.</li>
<li>The same above behavior is achieved when we attach the function to the event handler using Microsoft's Event Registration model method <code>attachEvent</code>. Instead of assigning the function to the event handler (and the thus making the function method of the element), it calls the function on the event (effectively calling it in global context).</li>
</ul>
<p><em>I recommend to better try this in JSFiddle.</em></p>
<div class="code"><pre class="code literal-block"><span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span><span class="w"> </span>
<span class="w">    </span><span class="k">function</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">()</span><span class="w"> </span><span class="err">{</span>
<span class="w">       </span><span class="n">alert</span><span class="p">(</span><span class="n">this</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" : "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">tagName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">" : "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="err">}</span><span class="w"> </span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button1"</span><span class="p">).</span><span class="n">addEventListener</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">,</span><span class="w"> </span><span class="no">false</span><span class="p">);</span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button2"</span><span class="p">).</span><span class="n">onclick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">;</span>
<span class="w">    </span><span class="n">document</span><span class="p">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s2">"button5"</span><span class="p">).</span><span class="n">attachEvent</span><span class="p">(</span><span class="s1">'onclick'</span><span class="p">,</span><span class="w"> </span><span class="n">clickedMe</span><span class="p">);</span><span class="w">   </span>
<span class="o">&lt;/</span><span class="n">script</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="k">Using</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="s2">"directly"</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="k">handler</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button1"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"assigned"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">addEventListner</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button2"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"assigned"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button3"</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"alert(this+ ' : ' + this.tagName + ' : ' + this.id);"</span><span class="o">&gt;</span><span class="n">used</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">click</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="k">Using</span><span class="w"> </span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="s2">"indirectly"</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="k">handler</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"alert((function(){return this + ' : ' + this.tagName + ' : ' + this.id;})());"</span><span class="o">&gt;</span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">indirectly</span><span class="p">,</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>

<span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button4"</span><span class="w"> </span><span class="n">onclick</span><span class="o">=</span><span class="s2">"clickedMe()"</span><span class="o">&gt;</span><span class="n n-Quoted">`this`</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">indirectly</span><span class="p">,</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="n">property</span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">br</span><span class="w"> </span><span class="o">/&gt;</span>

<span class="n">IE</span><span class="w"> </span><span class="k">only</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">button</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="s2">"button5"</span><span class="o">&gt;</span><span class="n">click</span><span class="p">()</span><span class="w"> </span><span class="s2">"attached"</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">attachEvent</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;/</span><span class="n">button</span><span class="o">&gt;</span>
</pre></div>

<p><strong>8.<code>this</code> in ES6 arrow function</strong></p>
<p>In an arrow function, <code>this</code> will behave like common variables: it will be
inherited from its lexical scope. The function's <code>this</code>, where the arrow
function is defined, will be the arrow function's <code>this</code>.</p>
<p>So, that's the same behavior as:</p>
<div class="code"><pre class="code literal-block">(function(){}).bind(this)
</pre></div>

<p>See the following code:</p>
<div class="code"><pre class="code literal-block"><span class="k">const</span><span class="w"> </span><span class="n">globalArrowFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">globalArrowFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="k">const</span><span class="w"> </span><span class="n">contextObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">method1</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">},</span>
<span class="w">  </span><span class="n">method2</span><span class="p">:</span><span class="w"> </span><span class="n">function</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">this</span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextObject</span><span class="o">.</span><span class="n">method1</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="k">const</span><span class="w"> </span><span class="n">contextLessFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contextObject</span><span class="o">.</span><span class="n">method1</span><span class="p">;</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextLessFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">window</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">contextObject</span><span class="o">.</span><span class="n">method2</span><span class="p">()())</span><span class="w"> </span><span class="o">//</span><span class="n">contextObject</span>

<span class="k">const</span><span class="w"> </span><span class="n">innerArrowFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">contextObject</span><span class="o">.</span><span class="n">method2</span><span class="p">();</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">innerArrowFunction</span><span class="p">());</span><span class="w"> </span><span class="o">//</span><span class="n">contextObject</span>
</pre></div>

<p><br><br><a href="posts/how-does-the-this-keyword-work-and-when-should-it-be-used/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/ru-he-zai-bu-chuang-jian-xin-mi-yao-de-qing-kuang-xia-shan-chu-ssh-mi-yao-de-mi-ma/" class="u-url">如何在不创建新密钥的情况下删除 SSH 密钥的密码？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/ru-he-zai-bu-chuang-jian-xin-mi-yao-de-qing-kuang-xia-shan-chu-ssh-mi-yao-de-mi-ma/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:06:22+08:00" itemprop="datePublished" title="2023-02-17 02:06">2023-02-17 02:06</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我在笔记本电脑上创建新的 SSH 密钥时设置了密码。但是，正如我现在意识到的那样，当您尝试在一小时内通过 SSH 多次提交（Git和SVN
）到远程位置时，这会非常痛苦。</p>
<p>我能想到的一种方法是，删除我的 SSH 密钥并创建新的。有没有办法删除密码，同时仍然保留相同的密钥？</p>
<p><br><br></p>
<h2>解答</h2>
<p>简短回答：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>ssh-keygen<span class="w"> </span>-p
</pre></div>

<p>然后这将提示您输入密钥文件位置、旧密码和新密码（可以留空以没有密码）。</p>
<hr>
<p>如果您想在没有提示的情况下在一行上完成所有操作，请执行以下操作：</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>ssh-keygen<span class="w"> </span>-p<span class="w"> </span><span class="o">[</span>-P<span class="w"> </span>old_passphrase<span class="o">]</span><span class="w"> </span><span class="o">[</span>-N<span class="w"> </span>new_passphrase<span class="o">]</span><span class="w"> </span><span class="o">[</span>-f<span class="w"> </span>keyfile<span class="o">]</span>
</pre></div>

<p><strong>重要提示：</strong>
请注意，在执行命令时，它们通常会以<code>~/.bash_history</code>纯文本形式记录在您的文件（或类似文件）中，包括提供的所有参数（即本例中的密码）。因此，建议您使用第一个选项，除非您有特殊原因不这样做。</p>
<p>请注意，您仍然可以<code>-f keyfile</code>在不指定<code>-P</code>nor
的情况下使用<code>-N</code>，并且密钥文件默认为<code>~/.ssh/id_rsa</code>，因此在许多情况下，甚至不需要它。</p>
<p>您可能需要考虑使用 ssh-agent，它可以暂时缓存密码。最新版本的 gpg-agent 也支持 ssh-agent 使用的协议。</p>
<p><br></p>
<h3>更多建议</h3>
<p><code>$ ssh-keygen -p</code>为我工作</p>
<p>打开 git bash。粘贴：<code>$ ssh-keygen -p</code></p>
<p>按回车进入默认位置。</p>
<p>输入旧密码</p>
<p>输入新密码 - 空白</p>
<p>确认新密码 - 空白</p>
<p>BOOM 为 git push 输入密码的痛苦消失了。</p>
<p>谢谢！</p>
<p><br><br><a href="posts/how-do-i-remove-the-passphrase-for-the-ssh-key-without-having-to-create-a-new-key/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/tong-bu-jian-cha-node-js-zhong-shi-fou-cun-zai-wen-jian-mu-lu/" class="u-url">同步检查 Node.js 中是否存在文件/目录</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/tong-bu-jian-cha-node-js-zhong-shi-fou-cun-zai-wen-jian-mu-lu/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T02:05:57+08:00" itemprop="datePublished" title="2023-02-17 02:05">2023-02-17 02:05</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>如何使用 <strong>node.js</strong> 同步检查文件或目录是否存在？</p>
<p><br><br></p>
<h2>解答</h2>
<p>这个问题的答案多年来一直在变化。 <em>当前的</em> 答案在顶部，然后是多年来按时间顺序排列的各种答案：</p>
<h3>当前答案</h3>
<p>您可以使用<code>fs.existsSync()</code>：</p>
<div class="code"><pre class="code literal-block"><span class="n">const</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span><span class="s2">"fs"</span><span class="p">);</span> <span class="o">//</span> <span class="n">Or</span> <span class="err">`</span><span class="kn">import</span> <span class="nn">fs</span> <span class="kn">from</span> <span class="s2">"fs"</span><span class="p">;</span><span class="err">`</span> <span class="k">with</span> <span class="n">ESM</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">existsSync</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Do</span> <span class="n">something</span>
<span class="p">}</span>
</pre></div>

<p>它被弃用了好几年，但现在不再是了。从文档：</p>
<blockquote>
<p>请注意，<code>fs.exists()</code>已弃用，但<code>fs.existsSync()</code>不是。（回调参数<code>fs.exists()</code>接受与其他Node.js回调不一致的参数。<code>fs.existsSync()</code>不使用回调。）</p>
</blockquote>
<p>您已经明确要求进行 <em>同步</em> 检查，但是如果您可以改用 <em>异步</em> 检查（通常最好与 I/O
一起使用），<code>fs.promises.access</code>则在您使用<code>async</code>函数时使用，或者<code>fs.access</code>（因为<code>exists</code>不推荐使用）如果不是：</p>
<p>在一个<code>async</code>函数中：</p>
<div class="code"><pre class="code literal-block">try {
    await fs.promises.access("somefile");
    // The check succeeded
} catch (error) {
    // The check failed
}
</pre></div>

<p>或者回调：</p>
<div class="code"><pre class="code literal-block"><span class="nv">fs</span>.<span class="nv">access</span><span class="ss">(</span><span class="s2">"somefile"</span>,<span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>{
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="o">!</span><span class="nv">error</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nv">The</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="nv">succeeded</span>
<span class="w">    </span>}<span class="w"> </span><span class="k">else</span><span class="w"> </span>{
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nv">The</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="nv">failed</span>
<span class="w">    </span>}
}<span class="ss">)</span><span class="c1">;</span>
</pre></div>

<hr>
<h3>历史答案</h3>
<p>以下是按时间顺序排列的历史答案：</p>
<ul>
<li>
<p><strong>2010 年的原始答案</strong> <br>
（<code>stat</code>/<code>statSync</code>或<code>lstat</code>/ <code>lstatSync</code>）</p>
</li>
<li>
<p><strong>2012 年 9 月更新</strong> <br>
( <code>exists</code>/ <code>existsSync</code>)</p>
</li>
<li>
<p><strong>2015 年 2 月更新</strong> <br>
（注意到即将弃用<code>exists</code>/ <code>existsSync</code>，所以我们可能会回到<code>stat</code>/<code>statSync</code>或<code>lstat</code>/
<code>lstatSync</code>）</p>
</li>
<li>
<p><strong>2015 年 12 月更新</strong> <br>
（还有<code>fs.access(path, fs.F_OK, function(){})</code>/ <code>fs.accessSync(path,
fs.F_OK)</code>，但请注意，如果文件/目录不存在，则为错误；如果您需要在不打开的情况下检查是否存在，<code>fs.stat</code>建议使用文档）<code>fs.access</code></p>
</li>
<li>
<p><strong>2016 年 12 月更新</strong> <br><code>fs.exists()</code>仍被弃用，但<code>fs.existsSync()</code>不再被弃用。所以你现在可以放心地使用它了。</p>
</li>
</ul>
<h4>2010年的原始答案：</h4>
<p>您可以使用<code>statSync</code>or
<code>lstatSync</code>（文档链接），它会为您提供一个<code>fs.Stats</code>对象。<code>Sync</code>通常，如果函数的同步版本可用，它将与末尾的异步版本同名。<code>statSync</code>的同步版本也是如此<code>stat</code>；是等<code>lstatSync</code>的同步版本。<code>lstat</code></p>
<p><code>lstatSync</code>告诉你某物是否存在，如果存在，它是文件还是目录（或在某些文件系统中，符号链接、块设备、字符设备等），例如，如果你需要知道它是否存在并且是一个目录：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="n">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Query</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">entry</span>
<span class="w">    </span><span class="n">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="o">.</span><span class="n">lstatSync</span><span class="p">(</span><span class="s1">'/the/path'</span><span class="p">);</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Is</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">directory</span><span class="err">?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">isDirectory</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>...同样，如果它是一个文件，则有<code>isFile</code>；如果它是块设备，则有<code>isBlockDevice</code>, 等等。注意<code>try/catch</code>;
如果条目根本不存在，它会抛出错误。</p>
<p><del>如果您不关心条目 <em>是</em>
什么，只想知道它是否存在，您可以使用<code>path.existsSync</code>（或使用最新的<code>fs.existsSync</code>），如user618408 所述：</del></p>
<p>~~</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="k">var</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require</span><span class="p">(</span><span class="s1">'path'</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">existsSync</span><span class="p">(</span><span class="s2">"/the/path"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">fs</span><span class="o">.</span><span class="n">existsSync</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">...</span>
<span class="p">}</span>
</pre></div>

<p>~~</p>
<p><del>它不需要 a<code>try/catch</code>但不会向您提供有关该事物是什么的信息，只是它就在那里。</del> <code>path.existsSync</code>很久以前就被弃用了。</p>
<hr>
<p>旁注：您已经明确询问如何 <em>同步</em> 检查，所以我使用了<code>xyzSync</code>上述功能的版本。但是只要有可能，对于 I/O，最好避免同步调用。从 CPU
的角度来看，调用 I/O 子系统会花费大量时间。<code>lstat</code>请注意调用而不是调用是多么容易<code>lstatSync</code>：</p>
<div class="code"><pre class="code literal-block"><span class="c1">// Is it a directory?</span>
<span class="n">lstat</span><span class="p">(</span><span class="s">'/the/path'</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">stats</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span>!<span class="n">err</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">stats</span><span class="p">.</span><span class="n">isDirectory</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Yes it is</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>但是如果你需要同步版本，它就在那里。</p>
<h4>2012 年 9 月更新</h4>
<p>几年前的以下答案现在有点过时了。当前的方法是使用<code>fs.existsSync</code>同步检查文件/目录是否存在（或者当然<code>fs.exists</code>是异步检查），而不是<code>path</code>下面的版本。</p>
<p>例子：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">existsSync</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span>
<span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="n">Or</span>

<span class="n">fs</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">exists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>

<h4>2015 年 2 月更新</h4>
<p>现在是 2015 年，Node 文档现在说<code>fs.existsSync</code>（和<code>fs.exists</code>）“将被弃用”。（因为 Node
的人认为在打开之前检查某物是否存在是愚蠢的，事实确实如此；但这并不是检查某物是否存在的唯一原因！）</p>
<p>所以我们可能会回到各种<code>stat</code>方法……当然，直到/除非这种情况再次发生变化。</p>
<h4>2015 年 12 月更新</h4>
<p>不知道它在那里多久了，但也有<code>fs.access(path, fs.F_OK, ...)</code>/<code>fs.accessSync(path,
fs.F_OK)</code>。至少从 2016 年 10 月开始，<code>fs.stat</code>文档建议使用<code>fs.access</code>它来进行存在性检查（
<em>“建议检查文件是否存在，而无需事后对其进行操作<code>fs.access()</code>。”</em>）。但请注意，访问不可用被认为是一个 <em>错误</em>
，所以如果您希望文件可以访问，这可能是最好的：</p>
<div class="code"><pre class="code literal-block"><span class="k">var</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>

<span class="n">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fs</span><span class="o">.</span><span class="n">accessSync</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">.</span><span class="n">F_OK</span><span class="p">);</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span>
<span class="p">}</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">isn</span><span class="s1">'t accessible</span>
<span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="n">Or</span>

<span class="n">fs</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="o">.</span><span class="n">F_OK</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">something</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">isn</span><span class="s1">'t accessible</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>

<h4>2016 年 12 月更新</h4>
<p>您可以使用<code>fs.existsSync()</code>：</p>
<div class="code"><pre class="code literal-block"><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">fs</span>.<span class="nv">existsSync</span><span class="ss">(</span><span class="nv">path</span><span class="ss">))</span><span class="w"> </span>{
<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">Do</span><span class="w"> </span><span class="nv">something</span>
}
</pre></div>

<p>它被弃用了好几年，但现在不再是了。从文档：</p>
<blockquote>
<p>Note that <code>fs.exists()</code> is deprecated, but <code>fs.existsSync()</code> is not. (The
callback parameter to <code>fs.exists()</code> accepts parameters that are inconsistent
with other Node.js callbacks. <code>fs.existsSync()</code> does not use a callback.)</p>
</blockquote>
<p><br></p>
<h3>更多建议</h3>
<p>查看源代码，有一个同步版本<code>path.exists</code>- <code>path.existsSync</code>。看起来它在文档中被遗漏了。</p>
<h4>更新：</h4>
<p><code>path.exists``path.existsSync</code>现在已 <strong>弃用</strong> 。 <del>请使用<code>fs.exists</code>和<code>fs.existsSync</code></del>。</p>
<h4>2016 年更新：</h4>
<p><code>fs.exists</code> <del>并且<code>fs.existsSync</code>也</del> <strong>被弃用了</strong> 。请改用fs.stat()或fs.access()。</p>
<h4>2019 年更新：</h4>
<p>使用<code>fs.existsSync</code>。它没有被弃用。https://nodejs.org/api/fs.html#fs_fs_existssync_path</p>
<p><br><br><a href="posts/check-synchronously-if-file-directory-exists-in-node-js/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-249.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-247.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
