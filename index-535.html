<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is a snapshot site for StackOverflow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>StackOverflow Snapshot (old posts, page 535) | StackOverflow Snapshot</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://ohstackoverflow.netlify.app/index-535.html">
<link rel="prev" href="index-536.html" type="text/html">
<link rel="next" href="index-534.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ohstackoverflow.netlify.app/">

                <span id="blog-title">StackOverflow Snapshot</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right">
<div style="display:table;min-height:5rem;min-width:27rem;">
					<div class="input-group" style="display: table-cell;vertical-align: middle;">
						<input id="words" type="text" class="form-control" style="max-width:22rem;" onkeydown="if(event.keyCode==13){btn.click()}"><span class="input-group-btn" style="float:left">
							<button id="btn" class="btn btn-default" type="button" data-toggle="modal" data-target="#myModal">
								<span class="glyphicon glyphicon-search">
							</span></button>
						</span>
					</div>
<!-- /input-group -->
				</div>

				
                
                
                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><!-- 模态框（Modal） --><div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×
				</button>
				<h4 class="modal-title" id="myModalLabel">
					查找结果
				</h4>
			</div>
			<div class="modal-body">
				<div id="search-count" style="min-height:4rem;">
				查找中，请稍后...
				</div>
				<div id="search-result">
				</div>

				
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">
					关闭
				</button>
			</div>
		</div>
<!-- /.modal-content -->
	</div>
<!-- /.modal-dialog -->
</div>
<!-- /.modal -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/wei-shi-yao-yong-yu-ce-shi-collatz-cai-xiang-de-c-dai-ma-bi-shou-xie-hui-bian-yun-xing-de-geng-kuai/" class="u-url">为什么用于测试 Collatz 猜想的 C++ 代码比手写汇编运行得更快？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/wei-shi-yao-yong-yu-ce-shi-collatz-cai-xiang-de-c-dai-ma-bi-shou-xie-hui-bian-yun-xing-de-geng-kuai/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:28:25+08:00" itemprop="datePublished" title="2023-02-17 09:28">2023-02-17 09:28</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我用汇编和 C++为Project Euler Q14编写了这两个解决方案。他们采用相同的蛮力方法来测试Collat​​z 猜想。装配解决方案装配有：</p>
<div class="code"><pre class="code literal-block">nasm -felf64 p14.asm &amp;&amp; gcc p14.o -o p14
</pre></div>

<p>C++ 编译为：</p>
<div class="code"><pre class="code literal-block">g++ p14.cpp -o p14
</pre></div>

<p>大会，<code>p14.asm</code>：</p>
<div class="code"><pre class="code literal-block"><span class="nt">section</span><span class="w"> </span><span class="p">.</span><span class="nc">data</span>
<span class="w">    </span><span class="nt">fmt</span><span class="w"> </span><span class="nt">db</span><span class="w"> </span><span class="s2">"%d"</span><span class="o">,</span><span class="w"> </span><span class="nt">10</span><span class="o">,</span><span class="w"> </span><span class="nt">0</span>

<span class="nt">global</span><span class="w"> </span><span class="nt">main</span>
<span class="nt">extern</span><span class="w"> </span><span class="nt">printf</span>

<span class="nt">section</span><span class="w"> </span><span class="p">.</span><span class="nc">text</span>

<span class="nt">main</span><span class="o">:</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rcx</span><span class="o">,</span><span class="w"> </span><span class="nt">1000000</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">rdi</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">max</span><span class="w"> </span><span class="nt">i</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rsi</span><span class="o">,</span><span class="w"> </span><span class="nt">rsi</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">i</span>

<span class="nt">l1</span><span class="o">:</span>
<span class="w">    </span><span class="nt">dec</span><span class="w"> </span><span class="nt">rcx</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">r10</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">count</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">rcx</span>

<span class="nt">l2</span><span class="o">:</span>
<span class="w">    </span><span class="nt">test</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span>
<span class="w">    </span><span class="nt">jpe</span><span class="w"> </span><span class="nt">even</span>

<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rbx</span><span class="o">,</span><span class="w"> </span><span class="nt">3</span>
<span class="w">    </span><span class="nt">mul</span><span class="w"> </span><span class="nt">rbx</span>
<span class="w">    </span><span class="nt">inc</span><span class="w"> </span><span class="nt">rax</span>
<span class="w">    </span><span class="nt">jmp</span><span class="w"> </span><span class="nt">c1</span>

<span class="nt">even</span><span class="o">:</span>
<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rbx</span><span class="o">,</span><span class="w"> </span><span class="nt">2</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rdx</span><span class="o">,</span><span class="w"> </span><span class="nt">rdx</span>
<span class="w">    </span><span class="nt">div</span><span class="w"> </span><span class="nt">rbx</span>

<span class="nt">c1</span><span class="o">:</span>
<span class="w">    </span><span class="nt">inc</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span>
<span class="w">    </span><span class="nt">jne</span><span class="w"> </span><span class="nt">l2</span>

<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmovl</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">r10</span>
<span class="w">    </span><span class="nt">cmovl</span><span class="w"> </span><span class="nt">rsi</span><span class="o">,</span><span class="w"> </span><span class="nt">rcx</span>

<span class="w">    </span><span class="nt">cmp</span><span class="w"> </span><span class="nt">rcx</span><span class="o">,</span><span class="w"> </span><span class="nt">2</span>
<span class="w">    </span><span class="nt">jne</span><span class="w"> </span><span class="nt">l1</span>

<span class="w">    </span><span class="nt">mov</span><span class="w"> </span><span class="nt">rdi</span><span class="o">,</span><span class="w"> </span><span class="nt">fmt</span>
<span class="w">    </span><span class="nt">xor</span><span class="w"> </span><span class="nt">rax</span><span class="o">,</span><span class="w"> </span><span class="nt">rax</span>
<span class="w">    </span><span class="nt">call</span><span class="w"> </span><span class="nt">printf</span>
<span class="w">    </span><span class="nt">ret</span>
</pre></div>

<p>C++, <code>p14.cpp</code>:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">sequence</span><span class="p">(</span><span class="kr">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">int</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">maxi</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kr">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999999</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sequence</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nf">max</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nf">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">            </span><span class="n">maxi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maxi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>我知道编译器优化可以提高速度和一切，但我没有看到很多方法可以进一步优化我的汇编解决方案（以编程方式，而不是数学方式）。</p>
<p>C++ 代码每隔一项使用模数，每隔一项使用除法，而汇编代码仅每隔一项使用一次除法。</p>
<p>但是程序集比 C++ 解决方案平均多花 1 秒。为什么是这样？我问主要是出于好奇。</p>
<h4>执行次数</h4>
<p>我的系统：1.4 GHz Intel Celeron 2955U（Haswell 微架构）上的 64 位 Linux。</p>
<ul>
<li>
<code>g++</code>（未优化）：平均 1272 毫秒。</li>
<li>
<code>g++ -O3</code>：平均 578 毫秒。</li>
<li>
<code>asm (div)</code>（原始）：平均 2650 毫秒。</li>
<li>
<code>asm (shr)</code>：平均 679 毫秒。</li>
<li>@johnfound asm（用 NASM 组装）：平均 501 毫秒。</li>
<li>@hidefromkgb asm：平均 200 毫秒。</li>
<li>@hidefromkgb asm，由@Peter Cordes 优化：平均 145 毫秒。</li>
<li>@Veedrac C++：平均 81 毫秒<code>-O3</code>，平均 305 毫秒<code>-O0</code>。</li>
</ul>
<p><br><br></p>
<h2>解答</h2>
<p>如果您认为 64 位 DIV 指令是除以二的好方法，那么难怪编译器的 asm
输出打败了您的手写代码，即使有（快速编译，没有额外的优化，并在之后存储/重新加载到内存<code>-O0</code>/在每个 C 语句之前，以便调试器可以修改变量）。</p>
<p>请参阅Agner Fog 的优化汇编指南以了解如何编写高效的汇编。他还有针对特定 CPU 的特定详细信息的指令表和微架构指南。另见x86标记 wiki
以获得更多性能链接。</p>
<p>另请参阅有关使用手写 asm 击败编译器的更普遍的问题：内联汇编语言是否比本机 C++ 代码慢？. TL:DR：是的，如果你做错了（比如这个问题）。</p>
<p>通常您可以让编译器完成它的工作，尤其是当您 <strong>尝试编写可以高效编译的 C++</strong> 时。另请参阅汇编语言是否比编译语言更快？.
其中一个答案链接到这些简洁的幻灯片，展示了各种 C 编译器如何使用很酷的技巧优化一些非常简单的函数。 <strong>Matt Godbolt 的 CppCon2017
演讲“ 我的编译器最近为我做了什么？Unbolting the Compiler's Lid ”与此类似。</strong></p>
<hr>
<div class="code"><pre class="code literal-block"><span class="n">even</span><span class="o">:</span>
<span class="w">    </span><span class="n">mov</span><span class="w"> </span><span class="n">rbx</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="n">xor</span><span class="w"> </span><span class="n">rdx</span><span class="o">,</span><span class="w"> </span><span class="n">rdx</span>
<span class="w">    </span><span class="n">div</span><span class="w"> </span><span class="n">rbx</span>
</pre></div>

<p>在 Intel Haswell 上， <strong><code>div r64</code></strong> 是 36 微指令，延迟 <strong>为 32-96 个周期</strong> ，吞吐量为每 21-74
个周期一个。（加上 2 微指令来设置 RBX 和零 RDX，但乱序执行可以提前运行它们）。像 DIV
这样的高微指令是微编码的，这也会导致前端瓶颈。在这种情况下，延迟是最相关的因素，因为它是循环携带的依赖链的一部分。</p>
<p><strong><code>shr rax, 1</code> 执行相同的无符号除法：它是 1 uop，具有 1c 延迟</strong>，并且每个时钟周期可以运行 2。</p>
<p>相比之下，32 位除法更快，但与移位相比仍然很糟糕。<code>idiv r32</code>在 Haswell 上是 9 微指令、22-29c 延迟和每 8-11c
吞吐量一个。</p>
<hr>
<p><strong>从查看 gcc 的<code>-O0</code>asm 输出（Godbolt
编译器资源管理器）可以看出，它仅使用移位指令</strong>。clang<code>-O0</code>确实像您想象的那样天真地编译，甚至两次使用 64 位
IDIV。（在优化时，如果源代码使用相同的操作数进行除法和取模，编译器会使用 IDIV 的两个输出，如果它们完全使用 IDIV）</p>
<p>GCC 没有完全天真的模式；它总是通过 GIMPLE 进行转换，这意味着无法禁用某些“优化”。这包括识别除以常数并使用移位（2 的幂）或定点乘法逆（非 2
的幂）来避免 IDIV（参见<code>div_by_13</code>上面的 godbolt 链接）。</p>
<p><code>gcc -Os</code>（优化大小） <em>确实</em> 将 IDIV 用于非 2 的幂除法，不幸的是，即使在乘法逆码仅稍大但速度更快的情况下也是如此。</p>
<hr>
<h2>帮助编译器</h2>
<p>（这种情况的总结：使用<code>uint64_t n</code>）</p>
<p>首先，只对优化后的编译器输出感兴趣。( <code>-O3</code>).<br><strong><code>-O0</code> 速度基本上没有意义。</strong></p>
<p>查看您的 asm 输出（在 Godbolt 上，或查看How to remove "noise" from GCC/clang assembly
output?）。当编译器没有首先生成最佳代码时： <strong>以引导编译器生成更好代码的方式编写 C/C++ 源代码通常是最好的方法</strong> 。你必须知道
asm，知道什么是有效的，但你间接地应用了这些知识。编译器也是一个很好的想法来源：有时 clang 会做一些很酷的事情，你可以手持 gcc
来做同样的事情：请参阅这个答案以及我在下面@Veedrac 的代码中对非展开循环所做的操作。）</p>
<p>这种方法是可移植的，并且在 20 年后，某些未来的编译器可以将其编译为在未来硬件（x86 或非 x86）上有效的任何东西，可能使用新的 ISA
扩展或自动矢量化。15 年前手写的 x86-64 asm 通常不会针对 Skylake 进行优化调整。例如compare&amp;branch macro-
fusion当时还不存在。 <strong>对于一种微体系结构的手工制作的 asm，现在最佳的可能对于其他当前和未来的 CPU 而言并不是最佳的。</strong>
@johnfound 的回答的评论讨论了 AMD Bulldozer 和 Intel Haswell
之间的主要区别，这对这段代码有很大的影响。但理论上，<code>g++ -O3 -march=bdver3</code>并<code>g++ -O3
-march=skylake</code>会做正确的事。（或者<code>-march=native</code>。）或者<code>-mtune=...</code>只是调整，而不使用其他 CPU
可能不支持的指令。</p>
<p>我的感觉是，将编译器引导到对您关心的当前 CPU 有益的 asm
对于未来的编译器来说应该不是问题。他们有望比当前的编译器更擅长寻找转换代码的方法，并且可以找到适用于未来 CPU 的方法。无论如何，未来的 x86
可能不会在当前 x86 上的任何优点上变得糟糕，并且未来的编译器将避免任何特定于 asm 的陷阱，同时实现诸如来自 C
源的数据移动之类的东西，如果它没有看到更好的东西。</p>
<p>手写的 asm 是优化器的黑盒，因此当内联使输入成为编译时常量时，常量传播不起作用。其他优化也会受到影响。在使用 asm
之前阅读https://gcc.gnu.org/wiki/DontUseInlineAsm。（并避免 MSVC 风格的内联
asm：输入/输出必须通过内存，这会增加开销。）</p>
<p><strong>在这种情况下</strong> ：您<code>n</code>有一个带符号的类型，gcc 使用 SAR/SHR/ADD 序列给出正确的舍入。（对于负输入，IDIV
和算术移位“舍入”不同，请参阅SAR insn set ref 手册条目）。（IDK 如果 gcc
尝试但未能证明<code>n</code>不能为负，或者什么。签名溢出是未定义的行为，所以它应该能够。）</p>
<p>你应该使用<code>uint64_t n</code>，所以它可以只是 SHR。因此它可以移植到<code>long</code>只有 32 位的系统（例如 x86-64 Windows）。</p>
<hr>
<p>顺便说一句， <strong>gcc 的 <em>优化</em> asm 输出看起来相当不错（使用<code>unsigned long
n</code>）</strong>：它内联到的内部循环<code>main()</code>执行此操作：</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="c1"># from gcc5.4 -O3  plus my comments</span>

<span class="w"> </span><span class="c1"># edx= count=1</span>
<span class="w"> </span><span class="c1"># rax= uint64_t n</span>

<span class="nl">.L9:</span><span class="w">                   </span><span class="c1"># do{</span>
<span class="w">    </span><span class="nf">lea</span><span class="w">    </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rax</span><span class="err">+</span><span class="mi">1</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">2</span><span class="p">]</span><span class="w">   </span><span class="c1"># rcx = 3*n + 1</span>
<span class="w">    </span><span class="nf">mov</span><span class="w">    </span><span class="no">rdi</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span>
<span class="w">    </span><span class="nf">shr</span><span class="w">    </span><span class="no">rdi</span><span class="w">         </span><span class="c1"># rdi = n&gt;&gt;1;</span>
<span class="w">    </span><span class="nf">test</span><span class="w">   </span><span class="no">al</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">       </span><span class="c1"># set flags based on n%2 (aka n&amp;1)</span>
<span class="w">    </span><span class="nf">mov</span><span class="w">    </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rcx</span>
<span class="w">    </span><span class="nf">cmove</span><span class="w">  </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w">    </span><span class="c1"># n= (n%2) ? 3*n+1 : n/2;</span>
<span class="w">    </span><span class="nf">add</span><span class="w">    </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">      </span><span class="c1"># ++count;</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">    </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">jne</span><span class="w">   </span><span class="no">.L9</span><span class="w">          </span><span class="c1">#}while(n!=1)</span>

<span class="w">  </span><span class="nf">cmp</span><span class="err">/</span><span class="no">branch</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">update</span><span class="w"> </span><span class="no">max</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">maxi</span><span class="p">,</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">do</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">next</span><span class="w"> </span><span class="no">n</span>
</pre></div>

<p>内循环是无分支的，循环承载依赖链的关键路径为：</p>
<ul>
<li>3 分量 LEA（3 个周期）</li>
<li>cmov（在 Haswell 上 2 个周期，在 Broadwell 或更高版本上 1c）。</li>
</ul>
<p><strong>总计：每次迭代 5 个周期，延迟瓶颈</strong> 。乱序执行处理与此并行的所有其他事情（理论上：我没有用性能计数器测试它是否真的以 5c/iter 运行）。</p>
<p>（由 TEST 产生）的 FLAGS 输入<code>cmov</code>比 RAX 输入（由 LEA-&gt;MOV）产生更快，所以它不在关键路径上。</p>
<p>同样，产生 CMOV 的 RDI 输入的 MOV-&gt;SHR 不在关键路径上，因为它也比 LEA 快。IvyBridge 及更高版本上的 MOV
具有零延迟（在寄存器重命名时处理）。（它仍然需要一个 uop 和管道中的一个插槽，所以它不是免费的，只是零延迟）。LEA dep 链中的额外 MOV 是其他
CPU 瓶颈的一部分。</p>
<p>cmp/jne 也不是关键路径的一部分：它不是循环携带的，因为控制依赖性是通过分支预测 + 推测执行处理的，这与关键路径上的数据依赖性不同。</p>
<hr>
<h2>击败编译器</h2>
<p>GCC 在这里做得很好。<code>inc edx</code>它可以通过使用instead of<code>add edx, 1</code>来节省一个代码字节，因为没有人关心 P4
及其对部分标志修改指令的错误依赖性。</p>
<p>它还可以保存所有 MOV 指令，并且 TEST: SHR 设置 CF= 移出的位，因此我们可以使用<code>cmovc</code>而不是<code>test</code>/ <code>cmovz</code>。</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="c1">### Hand-optimized version of what gcc does</span>
<span class="nl">.L9:</span><span class="w">                       </span><span class="c1">#do{</span>
<span class="w">    </span><span class="nf">lea</span><span class="w">     </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rax</span><span class="err">+</span><span class="mi">1</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1"># rcx = 3*n + 1</span>
<span class="w">    </span><span class="nf">shr</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">         </span><span class="c1"># n&gt;&gt;=1;    CF = n&amp;1 = n%2</span>
<span class="w">    </span><span class="nf">cmovc</span><span class="w">   </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rcx</span><span class="w">       </span><span class="c1"># n= (n&amp;1) ? 3*n+1 : n/2;</span>
<span class="w">    </span><span class="nf">inc</span><span class="w">     </span><span class="no">edx</span><span class="w">            </span><span class="c1"># ++count;</span>
<span class="w">    </span><span class="nf">cmp</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nf">jne</span><span class="w">     </span><span class="no">.L9</span><span class="w">            </span><span class="c1">#}while(n!=1)</span>
</pre></div>

<p>请参阅@johnfound 的另一个巧妙技巧的答案：通过在 SHR 的标志结果上分支并将其用于 CMOV 来删除 CMP：仅当 n 为 1（或
0）时才为零。（有趣的事实：在 Nehalem 或更早版本上使用 count != 1 的 SHR 如果您读取标志 results
会导致停顿。这就是他们使它成为单 uop 的方式。不过 shift-by-1 特殊编码很好。）</p>
<p>避免 MOV 对 Haswell 上的延迟根本没有帮助（x86 的 MOV 真的可以“免费”吗？为什么我根本不能重现这个？）。它确实对 Intel pre-
IvB 和 AMD Bulldozer 系列等 CPU <em>有很大</em> 帮助，其中 MOV 不是零延迟（以及更新了微代码的 Ice Lake）。编译器浪费的
MOV 指令确实会影响关键路径。BD 的复杂 LEA 和 CMOV 都具有较低的延迟（分别为 2c 和
1c），因此它占延迟的很大一部分。此外，吞吐量瓶颈成为一个问题，因为它只有两个整数 ALU 管道。请参阅@johnfound 的回答，其中他有来自 AMD
CPU 的计时结果。</p>
<p>即使在 Haswell 上，这个版本也可以通过避免一些偶然的延迟来提供一点帮助，在这种情况下，非关键的 uop 从关键路径上的 uop
窃取执行端口，将执行延迟 1 个周期。（这称为资源冲突）。它还保存了一个寄存器，这可能有助于<code>n</code>在交错循环中并行执行多个值（见下文）。</p>
<p><strong><em>*LEA 的延迟取决于英特尔 SnB 系列 CPU 上的 </em>*寻址模式。</strong> 3c 用于 3
个组件（<code>[base+idx+const]</code>，需要两个单独的添加），但只有 1c 具有 2 个或更少的组件（一个添加）。一些 CPU（如
Core2）甚至可以在单个周期内执行 3 分量 LEA，但 SnB 系列不会。更糟糕的是，英特尔 SnB 系列将延迟标准化，因此没有 2c uops，否则
3 分量 LEA 将像 Bulldozer 一样只有 2c。（3 分量 LEA 在 AMD 上也较慢，只是没有那么多）。</p>
<p>所以<code>lea rcx, [rax + rax*2]</code>/<code>inc rcx</code>只有 2c 延迟，比<code>lea rcx, [rax + rax*2 + 1]</code>，在像
Haswell 这样的 Intel SnB 系列 CPU 上更快。在 BD 上收支平衡，在 Core2 上更糟。它确实需要额外的 uop，这通常不值得节省
1c 延迟，但延迟是这里的主要瓶颈，Haswell 有足够宽的管道来处理额外的 uop 吞吐量。</p>
<p><strong>gcc、icc 和 clang（在 godbolt 上）都没有使用 SHR 的 CF 输出，总是使用 AND 或 TEST</strong> 。愚蠢的编译器。:P
它们是复杂机器的重要组成部分，但聪明的人通常可以在小规模问题上击败它们。（当然，考虑的时间要长几千到几百万倍！编译器不会使用详尽的算法来搜索每一种可能的做事方式，因为在优化大量内联代码时这会花费太长时间，这就是他们做得最好。他们也不在目标微体系结构中对管道进行建模，至少与IACA或其他静态分析工具的细节不同；他们只是使用一些启发式方法。）</p>
<hr>
<p><strong>简单的循环展开无济于事</strong> ；这个循环瓶颈是循环携带的依赖链的延迟，而不是循环开销/吞吐量。这意味着它可以很好地处理超线程（或任何其他类型的
SMT），因为 CPU 有很多时间来交错来自两个线程的指令。这意味着并行化
中的循环<code>main</code>，但这很好，因为每个线程都可以检查一个<code>n</code>值范围并生成一对整数作为结果。</p>
<p><strong>在单个线程中手动交错也可能是可行的</strong> 。也许并行计算一对数字的序列，因为每个数字只需要几个寄存器，并且它们都可以更新相同的<code>max</code>/
<code>maxi</code>。这创造了更多的指令级并行性。</p>
<p>诀窍在于决定是等到所有值都<code>n</code>达到<code>1</code>后再获取另一对起始值<code>n</code>，还是在不触及另一个序列的寄存器的情况下，只为达到结束条件的一个值突破并获取一个新的起始点。可能最好让每个链都处理有用的数据，否则你必须有条件地增加它的计数器。</p>
<hr>
<p><code>n</code>您甚至可以使用 SSE 打包比较的东西来执行此操作，以有条件地增加尚未到达的矢量元素的计数器<code>1</code>。然后为了隐藏 SIMD
条件增量实现的甚至更长的延迟，您需要将更多的<code>n</code>值向量悬而未决。也许只值 256b 向量 (4x <code>uint64_t</code>)。</p>
<p>我认为检测<code>1</code>“粘性”的最佳策略是屏蔽为增加计数器而添加的全一向量。所以在你看到<code>1</code>一个元素中的 a 之后，增量向量将有一个零，并且 +=0
是一个空操作。</p>
<h4>未经测试的手动矢量化想法</h4>
<div class="code"><pre class="code literal-block"><span class="c1"># starting with YMM0 = [ n_d, n_c, n_b, n_a ]  (64-bit elements)</span>
<span class="c1"># ymm4 = _mm256_set1_epi64x(1):  increment vector</span>
<span class="c1"># ymm5 = all-zeros:  count vector</span>

<span class="o">.</span><span class="n">inner_loop</span><span class="p">:</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">xmm0</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">xmm0</span>
<span class="w">    </span><span class="n">vpaddq</span><span class="w">    </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">set1_epi64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">     </span><span class="c1"># ymm1= 3*n + 1.  Maybe could do this more efficiently?</span>

<span class="w">    </span><span class="n">vpsllq</span><span class="w">    </span><span class="n">ymm3</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="mi">63</span><span class="w">                </span><span class="c1"># shift bit 1 to the sign bit</span>

<span class="w">    </span><span class="n">vpsrlq</span><span class="w">    </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">                 </span><span class="c1"># n /= 2</span>

<span class="w">    </span><span class="c1"># FP blend between integer insns may cost extra bypass latency, but integer blends don't have 1 bit controlling a whole qword.</span>
<span class="w">    </span><span class="n">vpblendvpd</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm3</span><span class="w">       </span><span class="c1"># variable blend controlled by the sign bit of each 64-bit element.  I might have the source operands backwards, I always have to look this up.</span>

<span class="w">    </span><span class="c1"># ymm0 = updated n  in each element.</span>

<span class="w">    </span><span class="n">vpcmpeqq</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">set1_epi64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">vpandn</span><span class="w">   </span><span class="n">ymm4</span><span class="p">,</span><span class="w"> </span><span class="n">ymm1</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span><span class="w">         </span><span class="c1"># zero out elements of ymm4 where the compare was true</span>

<span class="w">    </span><span class="n">vpaddq</span><span class="w">   </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span><span class="w">         </span><span class="c1"># count++ in elements where n has never been == 1</span>

<span class="w">    </span><span class="n">vptest</span><span class="w">   </span><span class="n">ymm4</span><span class="p">,</span><span class="w"> </span><span class="n">ymm4</span>
<span class="w">    </span><span class="n">jnz</span><span class="w">  </span><span class="o">.</span><span class="n">inner_loop</span>
<span class="w">    </span><span class="c1"># Fall through when all the n values have reached 1 at some point, and our increment vector is all-zero</span>

<span class="w">    </span><span class="n">vextracti128</span><span class="w"> </span><span class="n">ymm0</span><span class="p">,</span><span class="w"> </span><span class="n">ymm5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">vpmaxq</span><span class="w"> </span><span class="o">....</span><span class="w"> </span><span class="n">crap</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">doesn</span><span class="s1">'t exist</span>
<span class="w">    </span><span class="c1"># Actually just delay doing a horizontal max until the very very end.  But you need some way to record max and maxi.</span>
</pre></div>

<p>您可以而且应该使用内在函数而不是手写的 asm 来实现它。</p>
<hr>
<h3>算法/实现改进：</h3>
<p>除了用更高效的 asm 实现相同的逻辑之外，寻找简化逻辑或避免冗余工作的方法。例如 memoize 以检测序列的常见结尾。或者甚至更好，一次查看 8
个尾随位（gnasher 的回答）</p>
<p>@EOF points out that <code>tzcnt</code> (or <code>bsf</code>) could be used to do multiple <code>n/=2</code>
iterations in one step. That's probably better than SIMD vectorizing; no SSE
or AVX instruction can do that. It's still compatible with doing multiple
scalar <code>n</code>s in parallel in different integer registers, though.</p>
<p>So the loop might look like this:</p>
<div class="code"><pre class="code literal-block"><span class="nt">goto</span><span class="w"> </span><span class="nt">loop_entry</span><span class="o">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nt">C</span><span class="o">++</span><span class="w"> </span><span class="nt">structured</span><span class="w"> </span><span class="nt">like</span><span class="w"> </span><span class="nt">the</span><span class="w"> </span><span class="nt">asm</span><span class="o">,</span><span class="w"> </span><span class="nt">for</span><span class="w"> </span><span class="nt">illustration</span><span class="w"> </span><span class="nt">only</span>
<span class="nt">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="err">n</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">n*3</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">loop_entry</span><span class="p">:</span>
<span class="w">   </span><span class="n">shift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">_tzcnt_u64</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">   </span><span class="err">n</span><span class="w"> </span><span class="err">&gt;&gt;=</span><span class="w"> </span><span class="err">shift</span><span class="p">;</span>
<span class="w">   </span><span class="err">count</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">shift</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="nt">while</span><span class="o">(</span><span class="nt">n</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nt">1</span><span class="o">);</span>
</pre></div>

<p>This may do significantly fewer iterations, but variable-count shifts are slow
on Intel SnB-family CPUs without BMI2. 3 uops, 2c latency. (They have an input
dependency on the FLAGS because count=0 means the flags are unmodified. They
handle this as a data dependency, and take multiple uops because a uop can
only have 2 inputs (pre-HSW/BDW anyway)). This is the kind that people
complaining about x86's crazy-CISC design are referring to. It makes x86 CPUs
slower than they would be if the ISA was designed from scratch today, even in
a mostly-similar way. (i.e. this is part of the "x86 tax" that costs speed /
power.) SHRX/SHLX/SARX (BMI2) are a big win (1 uop / 1c latency).</p>
<p>It also puts tzcnt (3c on Haswell and later) on the critical path, so it
significantly lengthens the total latency of the loop-carried dependency
chain. It does remove any need for a CMOV, or for preparing a register holding
<code>n&gt;&gt;1</code>, though. <strong>@Veedrac's answer overcomes all this by deferring the
tzcnt/shift for multiple iterations, which is highly effective (see below).</strong></p>
<p>We can safely use BSF or TZCNT interchangeably, because <code>n</code> can never be zero
at that point. TZCNT's machine-code decodes as BSF on CPUs that don't support
BMI1. (Meaningless prefixes are ignored, so REP BSF runs as BSF).</p>
<p>TZCNT performs much better than BSF on AMD CPUs that support it, so it can be
a good idea to use <code>REP BSF</code>, even if you don't care about setting ZF if the
input is zero rather than the output. Some compilers do this when you use
<code>__builtin_ctzll</code> even with <code>-mno-bmi</code>.</p>
<p>They perform the same on Intel CPUs, so just save the byte if that's all that
matters. TZCNT on Intel (pre-Skylake) still has a false-dependency on the
supposedly write-only output operand, just like BSF, to support the
undocumented behaviour that BSF with input = 0 leaves its destination
unmodified. So you need to work around that unless optimizing only for
Skylake, so there's nothing to gain from the extra REP byte. (Intel often goes
above and beyond what the x86 ISA manual requires, to avoid breaking widely-
used code that depends on something it shouldn't, or that is retroactively
disallowed. e.g. Windows 9x's assumes no speculative prefetching of TLB
entries, which was safe when the code was written, before Intel updated the
TLB management rules.)</p>
<p>Anyway, LZCNT/TZCNT on Haswell have the same false dep as POPCNT: see this
Q&amp;A. This is why in gcc's asm output for @Veedrac's code, you see it breaking
the dep chain with xor-zeroing on the register it's about to use as TZCNT's
destination when it doesn't use dst=src. Since TZCNT/LZCNT/POPCNT never leave
their destination undefined or unmodified, this false dependency on the output
on Intel CPUs is a performance bug / limitation. Presumably it's worth some
transistors / power to have them behave like other uops that go to the same
execution unit. The only perf upside is interaction with another uarch
limitation: they can micro-fuse a memory operand with an indexed addressing
mode on Haswell, but on Skylake where Intel removed the false dep for
LZCNT/TZCNT they "un-laminate" indexed addressing modes while POPCNT can still
micro-fuse any addr mode.</p>
<hr>
<h2>Improvements to ideas / code from other answers:</h2>
<p><strong>@hidefromkgb's answer</strong> has a nice observation that you're guaranteed to be
able to do one right shift after a 3n+1. You can compute this more even more
efficiently than just leaving out the checks between steps. The asm
implementation in that answer is broken, though (it depends on OF, which is
undefined after SHRD with a count &gt; 1), and slow: <code>ROR rdi,2</code> is faster than
<code>SHRD rdi,rdi,2</code>, and using two CMOV instructions on the critical path is
slower than an extra TEST that can run in parallel.</p>
<p>I put tidied / improved C (which guides the compiler to produce better asm),
and tested+working faster asm (in comments below the C) up on Godbolt: see the
link in @hidefromkgb's answer. (This answer hit the 30k char limit from the
large Godbolt URLs, but shortlinks can rot and were too long for goo.gl
anyway.)</p>
<p>Also improved the output-printing to convert to a string and make one
<code>write()</code> instead of writing one char at a time. This minimizes impact on
timing the whole program with <code>perf stat ./collatz</code> (to record performance
counters), and I de-obfuscated some of the non-critical asm.</p>
<hr>
<p><strong>@Veedrac's code</strong></p>
<p>I got a minor speedup from right-shifting as much as we <em>know</em> needs doing,
and checking to continue the loop. From 7.5s for limit=1e8 down to 7.275s, on
Core2Duo (Merom), with an unroll factor of 16.</p>
<p>code + comments on Godbolt. Don't use this version with clang; it does
something silly with the defer-loop. Using a tmp counter <code>k</code> and then adding
it to <code>count</code> later changes what clang does, but that <em>slightly</em> hurts gcc.</p>
<p>See discussion in comments: Veedrac's code is <em>excellent</em> on CPUs with BMI1
(i.e. not Celeron/Pentium)</p>
<p><br></p>
<h3>更多建议</h3>
<p>声称 C++
编译器可以生成比称职的汇编语言程序员更优化的代码是一个非常严重的错误。尤其是在这种情况下。人类总是可以使代码比编译器更好，这种特殊情况很好地说明了这一说法。</p>
<p>您看到的时间差异是因为问题中的汇编代码在内部循环中远非最佳。</p>
<p>（以下代码是 32 位的，但可以轻松转换为 64 位）</p>
<p>例如，序列函数可以优化为只有 5 条指令：</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="p">.</span><span class="nc">seq</span><span class="o">:</span>
<span class="w">        </span><span class="nt">inc</span><span class="w">     </span><span class="nt">esi</span><span class="w">                 </span><span class="o">;</span><span class="w"> </span><span class="nt">counter</span>
<span class="w">        </span><span class="nt">lea</span><span class="w">     </span><span class="nt">edx</span><span class="o">,</span><span class="w"> </span><span class="cp">[</span><span class="mi">3</span><span class="o">*</span><span class="nx">eax</span><span class="o">+</span><span class="mi">1</span><span class="cp">]</span><span class="w">      </span><span class="o">;</span><span class="w"> </span><span class="nt">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">3</span><span class="o">*</span><span class="nt">n</span><span class="o">+</span><span class="nt">1</span>
<span class="w">        </span><span class="nt">shr</span><span class="w">     </span><span class="nt">eax</span><span class="o">,</span><span class="w"> </span><span class="nt">1</span><span class="w">              </span><span class="o">;</span><span class="w"> </span><span class="nt">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">n</span><span class="o">/</span><span class="nt">2</span>
<span class="w">        </span><span class="nt">cmovc</span><span class="w">   </span><span class="nt">eax</span><span class="o">,</span><span class="w"> </span><span class="nt">edx</span><span class="w">            </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">CF</span><span class="w"> </span><span class="nt">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">edx</span>
<span class="w">        </span><span class="nt">jnz</span><span class="w">     </span><span class="p">.</span><span class="nc">seq</span><span class="w">                </span><span class="o">;</span><span class="w"> </span><span class="nt">jmp</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">n</span><span class="o">&lt;&gt;</span><span class="nt">1</span>
</pre></div>

<p>整个代码看起来像：</p>
<div class="code"><pre class="code literal-block"><span class="k">include</span><span class="w"> </span><span class="ss">"%lib%/freshlib.inc"</span>
<span class="nv">@BinaryType</span><span class="w"> </span><span class="n">console</span><span class="p">,</span><span class="w"> </span><span class="n">compact</span>
<span class="n">options</span><span class="p">.</span><span class="n">DebugMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="k">include</span><span class="w"> </span><span class="ss">"%lib%/freshlib.asm"</span>

<span class="k">start</span><span class="err">:</span>
<span class="w">        </span><span class="n">InitializeAll</span>
<span class="w">        </span><span class="n">mov</span><span class="w"> </span><span class="n">ecx</span><span class="p">,</span><span class="w"> </span><span class="mi">999999</span>
<span class="w">        </span><span class="n">xor</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nf">max</span>
<span class="w">        </span><span class="n">xor</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="n">ebx</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="n">i</span>

<span class="w">    </span><span class="p">.</span><span class="nl">main_loop</span><span class="p">:</span>

<span class="w">        </span><span class="n">xor</span><span class="w">     </span><span class="n">esi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">mov</span><span class="w">     </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span>

<span class="w">    </span><span class="p">.</span><span class="nl">seq</span><span class="p">:</span>
<span class="w">        </span><span class="n">inc</span><span class="w">     </span><span class="n">esi</span><span class="w">                 </span><span class="p">;</span><span class="w"> </span><span class="n">counter</span>
<span class="w">        </span><span class="n">lea</span><span class="w">     </span><span class="n">edx</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">3*eax+1</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">edx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
<span class="w">        </span><span class="n">shr</span><span class="w">     </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span>
<span class="w">        </span><span class="n">cmovc</span><span class="w">   </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="n">edx</span><span class="w">            </span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">CF</span><span class="w"> </span><span class="n">eax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edx</span>
<span class="w">        </span><span class="n">jnz</span><span class="w">     </span><span class="p">.</span><span class="n">seq</span><span class="w">                </span><span class="p">;</span><span class="w"> </span><span class="n">jmp</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;&gt;</span><span class="mi">1</span>

<span class="w">        </span><span class="n">cmp</span><span class="w">     </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">cmovb</span><span class="w">   </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="n">esi</span>
<span class="w">        </span><span class="n">cmovb</span><span class="w">   </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="n">ecx</span>

<span class="w">        </span><span class="k">dec</span><span class="w">     </span><span class="n">ecx</span>
<span class="w">        </span><span class="n">jnz</span><span class="w">     </span><span class="p">.</span><span class="n">main_loop</span>

<span class="w">        </span><span class="n">OutputValue</span><span class="w"> </span><span class="ss">"Max sequence: "</span><span class="p">,</span><span class="w"> </span><span class="n">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">        </span><span class="n">OutputValue</span><span class="w"> </span><span class="ss">"Max index: "</span><span class="p">,</span><span class="w"> </span><span class="n">ebx</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>

<span class="w">        </span><span class="n">FinalizeAll</span>
<span class="w">        </span><span class="n">stdcall</span><span class="w"> </span><span class="n">TerminateAll</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
</pre></div>

<p>为了编译此代码，需要FreshLib 。</p>
<p>在我的测试中，（1 GHz AMD A4-1200 处理器），上面的代码比问题中的 C++ 代码快大约四倍（编译时：430<code>-O0</code>毫秒对 1900
毫秒），并且快两倍多（430 ms 与 830 ms）当 C++ 代码使用<code>-O3</code>.</p>
<p>两个程序的输出是相同的：max sequence = 525 on i = 837799。</p>
<p><br><br><a href="posts/why-does-c-code-for-testing-the-collatz-conjecture-run-faster-than-hand-written-assembly/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/yong-yu-die-dai-java-zhong-de-mei-ju-de-for-xun-huan/" class="u-url">用于迭代 Java 中的枚举的 for 循环</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/yong-yu-die-dai-java-zhong-de-mei-ju-de-for-xun-huan/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:27:56+08:00" itemprop="datePublished" title="2023-02-17 09:27">2023-02-17 09:27</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>我<code>enum</code>在 Java 中有一个基本方向和中间方向：</p>
<div class="code"><pre class="code literal-block"><span class="n">public</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">Direction</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">NORTH</span><span class="p">,</span>
<span class="w">   </span><span class="n">NORTHEAST</span><span class="p">,</span>
<span class="w">   </span><span class="n">EAST</span><span class="p">,</span>
<span class="w">   </span><span class="n">SOUTHEAST</span><span class="p">,</span>
<span class="w">   </span><span class="n">SOUTH</span><span class="p">,</span>
<span class="w">   </span><span class="n">SOUTHWEST</span><span class="p">,</span>
<span class="w">   </span><span class="n">WEST</span><span class="p">,</span>
<span class="w">   </span><span class="n">NORTHWEST</span>
<span class="p">}</span>
</pre></div>

<p>我如何编写一个<code>for</code>循环遍历每个<code>enum</code>值的循环？</p>
<p><br><br></p>
<h2>解答</h2>
<h2><code>.values()</code></h2>
<p><code>values()</code>您可以在枚举上调用该方法。</p>
<div class="code"><pre class="code literal-block"><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">Direction</span><span class="w"> </span><span class="nv">dir</span><span class="w"> </span>:<span class="w"> </span><span class="nv">Direction</span>.<span class="nv">values</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">what</span><span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">want</span>
}
</pre></div>

<p>此<code>values()</code>方法由编译器隐式声明。所以它没有在<code>Enum</code>文档中列出。</p>
<p><br></p>
<h3>更多建议</h3>
<p>枚举类型的所有常量都可以通过调用<code>public static T[] values()</code>该类型的隐式方法获得：</p>
<div class="code"><pre class="code literal-block"><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ss">(</span><span class="nv">Direction</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span>:<span class="w"> </span><span class="nv">Direction</span>.<span class="nv">values</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">     </span><span class="nv">System</span>.<span class="nv">out</span>.<span class="nv">println</span><span class="ss">(</span><span class="nv">d</span><span class="ss">)</span><span class="c1">;</span>
<span class="w"> </span>}
</pre></div>

<p><br><br><a href="posts/a-for-loop-to-iterate-over-an-enum-in-java/">查看原文</a></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/react-native-he-react-you-shi-yao-qu-bie/" class="u-url">React Native 和 React 有什么区别？</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                <a href="authors/arya/">Arya</a>
            </span></p>
            <p class="dateline">
            <a href="posts/react-native-he-react-you-shi-yao-qu-bie/" rel="bookmark">
            <time class="published dt-published" datetime="2023-02-17T09:27:31+08:00" itemprop="datePublished" title="2023-02-17 09:27">2023-02-17 09:27</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p><strong>这个问题的答案是 社区的努力</strong>。编辑现有答案以改进这篇文章。它目前不接受新的答案或互动。</p>
<p>出于好奇，我开始学习 <em>React</em> ，想知道 React 和 React Native 之间的区别——尽管无法使用 Google
找到满意的答案。React 和 React Native 似乎具有相同的格式。他们有完全不同的语法吗？</p>
<p><br><br></p>
<h2>解答</h2>
<p>ReactJS是一个 JavaScript 库，支持前端 Web 和在服务器上运行，用于构建用户界面和 Web 应用程序。它遵循可重用组件的概念。</p>
<p>React Native是一个移动框架，它利用主机上可用的 JavaScript 引擎，允许您在 JavaScript 中为不同平台（iOS、Android
和 Windows Mobile）构建移动应用程序，允许您使用 ReactJS 构建可重用的组件并进行通信使用本机组件进一步说明</p>
<p>两者都遵循 JavaScript 的 JSX 语法扩展。哪个编译为<code>React.createElement</code>引擎盖下的调用。深入 JSX</p>
<p>两者都是由 Facebook 开源的。</p>
<p><br></p>
<h3>更多建议</h3>
<p>这是 <strong>React</strong> 项目。</p>
<p>在 Facebook，他们发明了 <strong>React</strong> ，因此 JavaScript 可以使用虚拟 DOM 模型更快地操作网站 DOM。</p>
<p>与React 虚拟 dom 模型相比，DOM 完全刷新速度较慢，后者仅刷新页面的一部分（阅读：部分刷新）。</p>
<p>正如您从该视频中了解到的那样，Facebook 并没有发明 React，因为他们立即意识到局部刷新会比传统刷新更快。最初，他们需要一种方法来减少
Facebook 应用程序的重新构建时间，幸运的是，这使部分 DOM 刷新得以实现。</p>
<p><strong>React native</strong> 只是 React 的结果。它是一个使用 JavaScript 构建本机应用程序的平台。</p>
<p><strong>在使用React native</strong> 之前，您需要了解适用于 Android 的 Java 或 Kotlin 以及适用于 iPhone 和 iPad 的
Swift 或 Objective-C 才能创建原生应用程序。</p>
<p>使用 React Native，可以在 JavaScript
中模仿本机应用程序的行为，最后，您将获得特定于平台的代码作为输出。如果您需要进一步优化您的应用程序，您甚至可以将 <strong>本机代码与 JavaScript
混合使用。</strong></p>
<p>正如 Olivia Bishop 在视频中所说，85% 的 <strong>React native</strong>
代码库可以在平台之间共享。这些将是应用程序通常使用的组件和通用逻辑。</p>
<p>15% 的代码是特定于平台的。特定于平台的 JavaScript 赋予了平台风味（并使体验有所不同）。</p>
<p>很酷的是这个特定于平台的代码——已经写好了，所以你只需要使用它。</p>
<p><br><br><a href="posts/what-is-the-difference-between-react-native-and-react/">查看原文</a></p>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-536.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-534.html" rel="next">Older posts</a>
            </li>
        </ul></nav>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2023         Go to StackOverflow Chinese Site  <a href="http://stackoverflow.ink">StackOverflow-ZH</a>  
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script><script src="assets/js/search.js"></script>
</body>
</html>
